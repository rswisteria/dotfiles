This is emacs-ja.info, produced by makeinfo version 6.1 from emacs.texi.

This is the ‘GNU Emacs Manual’, updated for Emacs version 24.5.

   Copyright © 2015–2016 Ayanokoji Takesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).            拡張可能なセルフドキュメント形式のテキストエディター。
END-INFO-DIR-ENTRY


File: emacs-ja.info,  Node: CUA Bindings,  Prev: Rectangles,  Up: Killing

12.6 CUAバインド
================

コマンド‘M-x cua-mode’は、多くのアプリケーションで使われている、
CUA(Common User Access)互換のキーバンドをセットアップします。

   CUAモードが有効な場合、‘C-x’、‘C-c’、‘C-v’、‘C-z’などのキーは、カット
(kill)、コピー、ペースト(yank)、アンドウのコマンドを呼び出します。
‘C-x’と‘C-c’によるカットとコピーは、リージョンがアクティブなときだけ処理
されます。リージョンが非アクティブのときはプレフィクスキーとして動作する
ので、‘C-x C-c’のような標準のEmacsコマンドは正常に機能します。変数
‘mark-even-if-inactive’は‘C-x’と‘C-c’に影響を及ぼさないことに注意してく
ださい(*note Using Region::を参照してください)。

   マークがアクティブのときに‘C-x C-f’のようなEmacsコマンドを入力するに
は、‘Shift’を押しながらプレフィクスキーを押す(例 ‘S-C-x C-f’)か、プレフ
ィクスキーを素早く2回タイプ(例 ‘C-x C-x C-f’)します。

   CUAモードがEmacs標準のキーバインドをオーバーライドするのを無効にしつ
つ、以下で説明するそれ以外のCUAモードの機能は使う場合は、変数
‘cua-enable-cua-keys’に‘nil’をセットしてください。

   CUA モードはデフォルトでDelete-Selectionモード(*note Mouse
Commands::を参照してください)を有効にするので、アクティブなリージョンが
あるときテキストをタイプすると、そのテキストで置き換えられます。CUAモー
ドでこれを無効にするには、変数‘cua-delete-selection’を‘nil’にセットして
ください。

   CUAモードは矩形領域を明白にハイライトする、強化された矩形領域サポート
を提供します。‘C-<RET>’を使うことにより矩形領域の選択が開始され、移動コ
マンドを使って拡張したり、‘C-x’と‘C-c’で切り取りとコピーができます。
<RET>により、矩形領域の四隅に時計方向へカーソルを移動させるので、任意の
方向に簡単に領域を拡張できます。タイプされた通常のテキストは、矩形領域の
各行の左か右(カーソルのある側)に挿入されます。

   この矩形領域サポートは、‘cua-rectangle-mark-mode’コマンドを呼び出すこ
とにより、CUAモードを有効にせずに使うこともできます。しかし標準の
‘rectangle-mark-mode’も参照してください。*Note Rectangles::を参照してく
ださい。

   CUAモードでは、テキストや矩形領域を簡単にレジスターに保存したり、取り
出すことができます。これは1桁の数引数をkill、copy、yankコマンドに指定し
ます。たとえば‘C-1 C-c’はリージョンをレジスター‘1’にコピーし、‘C-2 C-v’は
レジスター‘2’の内容をyankします。

   CUAモードは、バッファー間での簡単にテキストを移動したりコピーするため
のグローバルマーク機能も提供します。‘C-S-<SPC>’を使って、グローバルマー
クのオンとオフが切り替えられます。グローバルマークがオンのときは、killま
たはコピーされたすべてのテキストは自動的にグローバルマークの位置に挿入さ
れ、タイプしたテキストも現在のカーソル位置ではなくグローバルマークに挿入
されます。

   たとえば複数のバッファーから単語をコピーして単語リストを作るには、単
語リストを作るバッファーにグローバルマークをセットします。次にリストにし
たい単語をマーク(‘S-M-f’など)してから、‘C-c’か‘M-w’でリストにコピーしま
す。そして<RET>でリストにコピーされた単語の後ろに改行を挿入すればよいの
です。


File: emacs-ja.info,  Node: Registers,  Next: Display,  Prev: Killing,  Up: Top

13 レジスター
*************

Emacsの“レジスター(registers)”は、テキストや矩形領域、位置、その他、後で
使うものを保存するための小部屋です。一度テキストや矩形領域をレジスターに
保存すれば、それをバッファーに何度もコピーできます。一度場所をレジスター
に保存すれば、何度でもその場所にジャンプして戻ることができます。

   各レジスターは1文字からなる名前があり、ここではRと表記することにしま
す。Rには、英字(‘a’など)または数字(‘1’など)を使用できます。大文字小文字
は区別されるので、レジスター‘a’とレジスター‘A’は同じではありません。

   レジスターには位置、テキスト、矩形領域、数字、ウィンドウの設定、ファ
イル名が保存できますが、一度に保存できるのは1つです。レジスターに何か保
存すると、他の何かをそのレジスターに保存するまで残ります。レジスターRに
何が含まれているのか見るには。‘M-x view-register’を使います:

‘M-x view-register <RET> R’
     レジスターRに何が含まれるかの説明を表示します。

   レジスター名の入力を求めるコマンドはすべて、既存のレジスターを一覧す
る“プレビュー(preview)”ウィンドウを遅延表示します。遅延の長さは
‘register-preview-delay’でカスタマイズできます。遅延を無効にするには、
‘nil’をセットしてください。この場合、‘C-h’か<F1>で、明示的にプレビューウ
ィンドウを要求できます。

   “ブックマーク(Bookmarks)”はファイルと位置を記録するので、ファイルを再
び見るときは記録された位置から閲覧できます。ブックマークも本質的にレジス
ター同じなので、このチャプターに記載します。

* Menu:

* Position Registers::       位置をレジスターに保存する。
* Text Registers::           テキストをレジスターに保存する。
* Rectangle Registers::      矩形領域をレジスターに保存する。
* Configuration Registers::  ウィンドウの設定をレジスターに保存する。
* Number Registers::         レジスターの中の数字。
* File Registers::           レジスターの中のファイル名。
* Keyboard Macro Registers::  レジスターの中のキーボードマクロ。
* Bookmarks::                レジスターと似ているが永続性があるブックマーク。


File: emacs-ja.info,  Node: Position Registers,  Next: Text Registers,  Up: Registers

13.1 レジスターに位置を保存する
===============================

‘C-x r <SPC> R’
     現在のバッファーのポイント位置をレジスターRに記録します
     (‘point-to-register’)。
‘C-x r j R’
     レジスターRに記録されたバッファーの位置にジャンプします
     (‘jump-to-register’)。

   ‘C-x r <SPC>’ (‘point-to-register’)と、それに続けて文字‘R’をタイプす
ると、ポイント位置と現在のバッファーの両方をレジスターRも保存します。レ
ジスターは他の何かが保存されるまでこの情報を保持します。

   コマンド‘C-x r j R’は、Rに記録されたバッファーに切り替えて、記録され
た位置にポイントを移動します。レジスターの内容は変わらないので、保存した
位置に何度でもジャンプできます。

   ‘C-x r j’を使って保存した位置に移動するとき、保存されたバッファが
killされていた場合、‘C-x r j’は同じファイルをvisitしてバッファーを生成し
ようと試みます。もちろんこれはファイルをvisitしたバッファーだけの動作で
す。


File: emacs-ja.info,  Node: Text Registers,  Next: Rectangle Registers,  Prev: Position Registers,  Up: Registers

13.2 レジスターにテキストを保存する
===================================

同じテキストのコピーを何回も挿入したいとき、killリングからyankするのは不
便です。なぜなら何かkillするたびに、そのエントリーはリングの下の方へ移動
してしまうからです。代替として、テキストをレジスターに保存して、後で取り
出す方法があります。

‘C-x r s R’
     リージョンをレジスターRにコピーします(‘copy-to-register’)。
‘C-x r i R’
     レジスターRからテキストを挿入します(‘insert-register’)。
‘M-x append-to-register <RET> R’
     リージョンをレジスターRのテキストに追加します。

     レジスターRの内容がテキストの場合、そのレジスターに追加するのに‘C-x
     r +’ (‘increment-register’)も使用できます。レジスターRに数値が含ま
     れている場合、コマンド‘C-x r +’は違う動作をすることに注意してくださ
     い。*note Number Registers::を参照してください。

‘M-x prepend-to-register <RET> R’
     リージョンをレジスターRの先頭に追加します。

   ‘C-x r s R’は、リージョンのテキストのコピーを、Rという名前のレジスタ
ーに保存します。マークが非アクティブのとき、Emacsはまず最後にセットされ
たマークをアクティブにします。マークはこのコマンドの最後に非アクティブに
なります。*note Mark::を参照してください。同じコマンドにプレフィクス引数
を指定した‘C-u C-x r s R’は、テキストのコピーをレジスターRに保存してから
、バッファーのテキストを削除します。これはリージョンのテキストを、レジス
ターに“移動”したと考えることができます。

   ‘M-x append-to-register <RET> R’は、リージョンのテキストのコピーを、
Rという名前のレジスターにすでに保存されているテキストに追加します。プレ
フィクス引数を指定した場合、レジスターに追加した後にリージョンを削除しま
す。コマンド‘prepend-to-register’も同様ですが、これはリージョンのテキス
トをレジスターのテキストの_最後_ではなく_先頭_に追加します。

   ‘append-to-register’と‘prepend-to-register’を使ってテキストを集める場
合、セパレーターを使って個々に集めたテキストを分割したい場合があります。
そのようなときは‘register-separator’を構成して、セパレーター文字列をその
レジスターに保存します。たとえばテキストを収集する過程で、個々のテキスト
を2つの改行で分けたい場合、以下の設定を使うことができます。

     (setq register-separator ?+)
     (set-register register-separator "\n\n")

   ‘C-x r i R’は、レジスターRのテキストをバッファーに挿入します。通常は
ポイントをテキストの前に置き、非アクティブのマークをテキストの後ろにセッ
トします。数引数を指定したときは、ポイントをテキストの後ろ、マークをテキ
ストの前にセットします。


File: emacs-ja.info,  Node: Rectangle Registers,  Next: Configuration Registers,  Prev: Text Registers,  Up: Registers

13.3 レジスターに矩形領域を保存する
===================================

レジスターには線形のテキストだけでなく、矩形領域も保存できます。バッファ
ーで矩形領域を指定する方法は、*note Rectangles::を参照してください。

‘C-x r r R’
     矩形リージョンをレジスターRにコピーします
     (‘copy-rectangle-to-register’)。数引数を指定するとコピー後に矩形リ
     ージョンを削除します。
‘C-x r i R’
     レジスターRに矩形リージョンが保存されている場合、それを挿入します
     (‘insert-register’)。

   前に*note Text Registers::でも説明した‘C-x r i R’
(‘insert-register’)コマンドは、レジスターに矩形領域が保存されているとき
はテキストではなく矩形領域を挿入します。


File: emacs-ja.info,  Node: Configuration Registers,  Next: Number Registers,  Prev: Rectangle Registers,  Up: Registers

13.4 レジスターにウィンドウ設定を保存する
=========================================

選択されたフレームのウィンドウの設定や、すべてのフレームのすべてのウィン
ドウの設定もレジスターに保存して、後で設定を復元することができます。ウィ
ンドウの設定については、*note Windows::を参照してください。

‘C-x r w R’
     選択されたフレームのウィンドウの設定を、レジスターRに保存します
     (‘window-configuration-to-register’)。
‘C-x r f R’
     すべてのフレームおよびフレームに含まれるすべてのウィンドウの状態を
     、レジスターRに保存します(‘frameset-to-register’)。

   ‘C-x r j R’を使うと、ウィンドウまたはフレームの設定を復元できます。こ
れはカーソル位置を復元するコマンドと同じです。フレームの設定を復元すると
き、設定に含まれていないフレームは非表示になります。もしこれらのフレーム
を削除したいときは、かわりに‘C-u C-x r j R’を使います。


File: emacs-ja.info,  Node: Number Registers,  Next: File Registers,  Prev: Configuration Registers,  Up: Registers

13.5 レジスターに数字を保存する
===============================

数字をレジスターに保存して、その数字(10進)をバッファーに挿入したり、増加
させるコマンドがあります。これらのコマンドはキーボードマクロで使うと便利
です(*note Keyboard Macros::を参照してください)。

‘C-u NUMBER C-x r n R’
     NUMBERをレジスターRに保存します(‘number-to-register’)。
‘C-u NUMBER C-x r + R’
     Rに数字が保存しているときは、レジスターの数字をNUMBERだけ増加させま
     す。コマンド‘C-x r +’ (‘increment-register’)は、Rにテキストが保存さ
     れているときは異なる動作をすることに注意してください。*note Text
     Registers::を参照してください。
‘C-x r i R’
     レジスターRの数字をバッファーに挿入します。

   ‘C-x r i’は、他のレジスターの内容をバッファーに挿入するコマンドと同じ
です。‘C-x r +’に数字の引数を与えない場合、レジスターの値は1増加します。
‘C-x r n’に数字の引数を与えない場合、レジスターには0が保存されます。


File: emacs-ja.info,  Node: File Registers,  Next: Keyboard Macro Registers,  Prev: Number Registers,  Up: Registers

13.6 レジスターにファイル名を保存する
=====================================

特定の名前のファイルを頻繁にvisitする場合、その名前をレジスターにセット
しておけば、より便利にファイルをvisitすることができます。以下はNAMEとい
うファイルをレジスターRにセットするLispコードです:

     (set-register R '(file . NAME))

たとえば

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

はレジスター‘z’にファイル名をセットします。

   レジスターRに名前がセットされているファイルをvisitするには、‘C-x r j
R’とタイプします。これはある位置にジャンプしたり、フレームの設定を復元す
るのと同じコマンドです。


File: emacs-ja.info,  Node: Keyboard Macro Registers,  Next: Bookmarks,  Prev: File Registers,  Up: Registers

13.7 キーボードマクロのレジスター
=================================

あるキーボードマクロ(*note Keyboard Macros::を参照してください)を頻繁に
実行する必要がある場合、それをレジスターにセットしたり保存することができ
ればより便利でしょう(*note Save Keyboard Macro::を参照してください)。
‘C-x C-k x R’ (‘kmacro-to-register’)は、最後のキーボードマクロをレジスタ
ーRに保存します。

   レジスターRのキーボードマクロを実行するには、‘C-x r j R’とタイプしま
す(これはある位置にジャンプしたりフレームを復元するのと同じコマンドです
)。


File: emacs-ja.info,  Node: Bookmarks,  Prev: Keyboard Macro Registers,  Up: Registers

13.8 ブックマーク
=================

“ブックマーク(Bookmarks)”とは、ジャンプしたい位置を記録するレジスターの
ようなものです。レジスターとの違いは、長い名前をもつことができ、次の
Emacsセッションに自動的に引き継がれることです。ブックマークの典型的な使
い方は、さまざまなファイルの“どこを読んでいたか”を記録することです。

‘C-x r m <RET>’
     visitしているファイルのポイント位置に、ブックマークをセットします。

‘C-x r m BOOKMARK <RET>’
     ポイント位置に、BOOKMARKという名前のブックマークをセットします
     (‘bookmark-set’)。

‘C-x r b BOOKMARK <RET>’
     BOOKMARKという名前のブックマークにジャンプします(‘bookmark-jump’)。

‘C-x r l’
     すべてのブックマークを一覧します(‘list-bookmarks’)。

‘M-x bookmark-save’
     現在のすべてのブックマークの値を、デフォルトのブックマークファイル
     に保存します。

   ブックマークの典型的な使い方は、各ファイルごとに現在の位置を保存する
ことです。そのためブックマークをセットするコマンド‘C-x r m’は、ブックマ
ーク名のデフォルトとしてファイル名を使います。ブックマークが指すファイル
をもとにブックマークの名前を付ければ、‘C-x r b’で任意のファイルを再び
visitして、同時にブックマーク位置に移動するという操作を楽に行えます。

   すべてのブックマークのリストを別のバッファーに表示するには、‘C-x r l’
(‘list-bookmarks’)とタイプします。そのバッファーに切り替えて、ブックマー
クの定義の編集やブックマークに注釈をつけることができます。ブックマークバ
ッファーで‘C-h m’とタイプすれば、特別な編集コマンドに関する情報を見るこ
とができます。

   Emacsを終了するとき、もしブックマークの値を変更していたら、Emacsはブ
ックマークを保存します。‘M-x bookmark-save’コマンドで、いつでもブックマ
ークを保存できます。ブックマークは‘~/.emacs.d/bookmarks’というファイルに
保存されます(古いバージョンのEmacsとの互換性を保つため、もし
‘~/.emacs.bmk’というファイルがあればそのファイルに保存します)。ブックマ
ークコマンドは、デフォルトのブックマークファイルを自動的にロードします。
この保存とロードにより、ブックマークの内容を次のEmacsセッションに引き継
ぐことができるのです。

   ‘bookmark-save-flag’に1をセットすると、ブックマークをセットするコマン
ドはブックマークの保存も行ないます。こうすることにより、Emacsがクラッシ
ュしてもブックマークを失わずにすみます。この変数の値が数字の場合、それは
ブックマークを何回変更したら保存するという意味です。この変数に‘nil’をセ
ットすると、Emacsは明示的に‘M-x bookmark-save’を使ったときだけブックマー
クを保存します。

   変数‘bookmark-default-file’には、ブックマークを保存するデフォルトのフ
ァイルを指定します。

   ブックマークの位置は、周囲のコンテキストとともに保存されるので、ファ
イルが少し変更されていても、‘bookmark-jump’は正確な位置を見つけることが
できます。変数‘bookmark-search-size’は、ブックマーク位置のコンテキストの
前後何文字を記録するかを指定します。

   以下はブックマークを処理する追加のコマンドです:

‘M-x bookmark-load <RET> FILENAME <RET>’
     ブックマークのリストを含む、FILENAMEという名前のファイルをロードし
     ます。このコマンドは‘bookmark-write’と同様に、デフォルトのブックマ
     ークファイルに加えて、他のファイルのブックマークを使うことができま
     す。

‘M-x bookmark-write <RET> FILENAME <RET>’
     現在のすべてのブックマークをファイルFILENAMEに保存します。

‘M-x bookmark-delete <RET> BOOKMARK <RET>’
     BOOKMARKという名前のブックマークを削除します。

‘M-x bookmark-insert-location <RET> BOOKMARK <RET>’
     ブックマークBOOKMARKが指すファイル名をバッファーに挿入します。

‘M-x bookmark-insert <RET> BOOKMARK <RET>’
     ブックマークBOOKMARKが指すファイルの_内容_をバッファーに挿入します
     。


File: emacs-ja.info,  Node: Display,  Next: Search,  Prev: Registers,  Up: Top

14 ディスプレーの制御
*********************

ウィンドウに入りきらない大きなバッファーでは、Emacsはその一部しか表示で
きません。このチャプターでは、見たい部分のテキストを指定するコマンドや変
数と、どのようにしてテキストが表示されるかを説明します。

* Menu:

* Scrolling::                ウィンドウのテキストを上下に移動させるコマンド。
* Recentering::              カレント行を中央にするスクロールコマンド。
* Auto Scrolling::           必要なときテキストをスクロールして再表示する。
* Horizontal Scrolling::     ウィンドウの左右にテキストを移動させる。
* Narrowing::                表示を制限してバッファーの一部を編集する。
* View Mode::                読み取り専用バッファーの表示。
* Follow Mode::              Followモードで2つのウィンドウを1つとしてスクロールさせる。
* Faces::                    フェイスを使って表示スタイルを変更する方法。
* Colors::                   フェイスのカラーを指定する。
* Standard Faces::           主要な既定のフェイス。
* Text Scale::               バッファーのテキストサイズの拡大と縮小。
* Font Lock::                フェイスを使って文法をハイライトするマイナーモード。
* Highlight Interactively::  Emacsにハイライトするテキストを指示する。
* Fringes::                  ウィンドウフリンジの有効と無効。
* Displaying Boundaries::    バッファーの先頭と最後を表示する。
* Useless Whitespace::       行末の不要な空白文字の表示。
* Selective Display::        インデントの大きな行を隠す。
* Optional Mode Line::       モードラインの表示機能のオプション。
* Text Display::             テキスト文字が通常表示される方法。
* Cursor Display::           カーソル表示の機能。
* Line Truncation::          複数のスクリーン行で継続表示させずにスクリーン幅に行を切り詰める。
* Visual Line Mode::         単語の折り返しとスクリーン行にもとづく編集。
* Display Custom::           ディスプレーをカスタマイズする変数の情報。


File: emacs-ja.info,  Node: Scrolling,  Next: Recentering,  Up: Display

14.1 スクロール
===============

ウィンドウがバッファーのすべてのテキストを表示するには小さい場合、その一
部だけが表示されます。“スクロール”コマンドは、バッファーで表示される部分
を変更します。

   “前方(forward)”または“上(up)”へのスクロールは、ウィンドウに表示される
部分を先に進めます。これはウィンドウに表示されるバッファーのテキストを、
上に移動させるのと同じです。“後方(backward)”または“下(down)”へのスクロー
ルは、ウィンドウに表示される部分を前に戻します。これはウィンドウに表示さ
れるバッファーのテキストを下に移動させます。

   Emacsでの“up”と“down”は、ウィンドウでテキストが移動する方向に基づいて
おり、テキストにたいしてウィンドウが移動する方向では_ありません_。この用
語は現在の“scrolling up”や“scrolling down”が広まる前に、Emacsで採用され
ました。そのため<PageDown>は、Emacs的には“上(up)”にスクロールするという
、奇妙な結果となりました。

   ウィンドウに表示されているバッファー部分には、常にポイントが含まれて
います。もしウィンドウの下端か上端を越えてポイントを移動させると、ポイン
トを画面に表示させるために自動的にスクロールが発生します(*note Auto
Scrolling::を参照してください)。以下のコマンドで明示的にスクロールができ
ます:

‘C-v’
‘<next>’
‘<PageDown>’
     ウィンドウのほぼ全画面分、前方にスクロールします
     (‘scroll-up-command’)。
‘M-v’
‘<prior>’
‘<PageUp>’
     後方にスクロールします(‘scroll-down-command’)。

   ‘C-v’ (‘scroll-up-command’)は、ウィンドウ全体の高さに近い量、前方にス
クロールします。これにより下端の2行が上端になるようスクロールして、それ
に続く表示されていなかった行を表示します。ポイントが上端より上になってし
まう場合、ウィンドウの新たな上端の行に移動します。The <next>(または
<PageDown>)は、‘C-v’と同じです。

   ‘M-v’ (‘scroll-down-command’)は、同様の方法で後方にスクロールします。
<prior>(または<PageUp>)は、‘M-v’と同じです。

   スクロールコマンドでオーバーラップして表示される行数は、変数
‘next-screen-context-lines’で制御され、デフォルトは2です。数引数Nを与え
たときは、N行スクロールします。Emacsはポイントを変更しないよう試みるので
、テキストとポイントは一緒に上または下に動きます。‘C-v’に負の引数を与え
ると、‘M-v’のように反対方向へスクロールします。

   デフォルトでは、ウィンドウがバッファーの先頭または最後に到達していて
、これ以上スクロールできない場合、これらのコマンドは(beep音をならしたり
画面をフラッシュして)エラーをシグナルします。変数
‘scroll-error-top-bottom’を‘t’に変更すると、コマンドは可能な限り、つまり
バッファーの先頭の文字または最後の文字にポイントを移動します。ポイントが
すでにそこにあるときは、エラーをシグナルします。

   スクロールしたとき、ポイントが同じスクリーン位置に留まることを好むユ
ーザーもいます。そうすれば同じスクリーンにスクロールして戻ったとき、ポイ
ントが元の位置にあると便利だからです。この動作は変数
‘scroll-preserve-screen-position’を通じて利用可能です。変数の値が‘t’のと
き、スクロールコマンドによりポイントがウィンドウの外にでるような場合、
Emacsはポイントを先頭行または最終行に移動させるのではなく、同じスクリー
ン位置にポイントを調整して、カーソルを維持します。その他の非‘nil’値の場
合、Emacsはスクロールコマンドによりポイントがウィンドウに残っている場合
にも、この方法でポイントを調整します。この変数はこのセクションで説明する
すべてのスクロールコマンド、同様にマウスホイールによるスクロール(*note
Mouse Commands::を参照してください)に影響を与えます。一般的にいうと、こ
の変数は‘scroll-command’プロパティが非‘nil’のコマンドに影響を及ぼします
。*note (elisp)Property Lists::を参照してください。

   コマンド‘M-x scroll-up’および‘M-x scroll-down’は、
‘scroll-up-command’および‘scroll-down-command’と同様に動作しますが、
‘scroll-error-top-bottom’を考慮しません。これらのコマンドは、Emacs 24以
前ではスクロールアップおよびスクロールダウンのためのデフォルトでした。コ
マンド‘M-x scroll-up-line’および‘M-x scroll-down-line’は、現在のウィンド
ウを1行スクロールさせます。もしこれらのコマンドを使う場合は、それにキー
バインドを割り当てたくなるでしょう(*note Init Rebinding::を参照してくだ
さい)。


File: emacs-ja.info,  Node: Recentering,  Next: Auto Scrolling,  Prev: Scrolling,  Up: Display

14.2 センタリング
=================

‘C-l’
     選択されているウィンドウで、現在行が中央になるようスクロールします
     。連続して呼び出すと、次は現在行が上端になり、その次は現在行が下端
     に、という順番で循環します。画面の再描画が行われる可能性があります
     (‘recenter-top-bottom’)。

‘M-x recenter’
     選択されているウィンドウで、現在行が中央になるようにスクロールしま
     す。画面の再描画が行われる可能性があります。

‘C-M-l’
     有用な情報が表示されるよう、発見的な手法でスクロールします
     (‘reposition-window’)。

   ‘C-l’ (‘recenter-top-bottom’)コマンドは、選択されたウィンドウにたいし
て“センタリング(recenters)”をします。これにより現在のスクリーン行がウィ
ンドウの中央、または中央に一番近い行になります。

   (‘C-l C-l’)のように‘C-l’を2回タイプすると、ポイントのある行が上端にな
るようにスクロールします。‘C-l’を3回タイプするとポイントのある行が下端に
なるようにスクロールします。連続して‘C-l’をタイプすることにより、上記の
3つの位置を循環してスクロールできます。

   リスト変数‘recenter-positions’をカスタマイズすることにより、循環する
順序を変更できます。リスト要素にはシンボル‘top’、‘middle’、‘bottom’また
は数値を指定します。数値に整数を指定すると、現在行が指定したスクリーン行
になるようスクロールします。数値に0.0から1.0の浮動小数点数は、ウィンドウ
の上端から現在行までを割合で指定します。デフォルトは‘(middle top
bottom)’で、これは上述した循環順序です。さらに変数‘scroll-margin’を、0以
外の値Nに変更すると、‘C-l’は常にウィンドウの上端または下端からスクリーン
行で、N行を残してスクロールします(*note Auto Scrolling::を参照してくださ
い)。

   ‘C-l’にプレフィクス引数を指定することもできます。‘C-u C-l’のようにプ
レフィクス引数だけを指定すると、単にポイントのある行を中央にします。正の
引数Nは、ポイントのある行がウィンドウの上端からN行目になるようにスクロー
ルします。0を指定すると、ポイントのある行が上端になるようにスクロールし
ます。負の引数-Nは、ポイントのある行がウィンドウの下端からN行目になるよ
うにスクロールします。引数を与えたときは、‘C-l’は画面をクリアーせず、異
なるスクリーン位置への循環もしません。

   変数‘recenter-redisplay’が非‘nil’値の場合、‘C-l’はスクリーンのクリア
ーと再描画を行います。特別な値‘tty’(デフォルト)は、これをテキスト端末上
のフレームだけに限定します。再描画はスクリーンが何らかの理由により文字化
けしてしまったときなどに便利です(*note Screen Garbled::を参照してくださ
い)。

   より原始的なコマンド‘M-x recenter’は、‘recenter-top-bottom’と同じよう
に振る舞いますが、スクリーン位置を循環しません。

   ‘C-M-l’ (‘reposition-window’)は、有用な情報がスクリーンに表示されるよ
うに、現在のウィンドウを発見的な手法によりスクロールします。たとえば
Lispファイルの場合、このコマンドは可能な限り現在のdefun全体がスクリーン
上に表示されるよう試みます。


File: emacs-ja.info,  Node: Auto Scrolling,  Next: Horizontal Scrolling,  Prev: Recentering,  Up: Display

14.3 自動スクロール
===================

ポイントが表示されているテキスト部分から外に移動すると、Emacsは“自動スク
ロール(automatic scrolling)”の処理を行います。通常自動スクロールは、ウィ
ンドウの垂直方向の中央にポイントをセンタリングしますが、この振る舞いを変
えるいくつかの方法があります。

   ‘scroll-conservatively’に小さい数字Nをセットすると、ポイントが少し
(N行以下)スクリーンの外に出たら、Emacsはポイントがスクリーンに表示される
のに充分なだけスクロールします。これでもしポイントの表示に失敗した場合、
Emacsはそのウィンドウの中央にポイント行が表示されるのに充分なだけのスク
ロールをします。‘scroll-conservatively’に大きな数字(100より大)も数字をセ
ットすると、どれだけポイントを移動させようと、自動スクロールはポイント行
を中央にセンタリングしなくなります。Emacsはポイントが表示されるように常
にテキストをスクロールします。ウィンドウの上端または下端かはスクロールの
方向に依存します。デフォルトでは‘scroll-conservatively’は 0で、これは常
にポイント行がウィンドウの中央にセンタリングされることを意味します。

   自動スクロールを制御する他の方法は、変数‘scroll-step’をカスタマイズす
ることです。この変数の値はポイントがスクリーンから外れたとき、何行を自動
スクロールさせるかを決定します。その行数スクロールしてもポイントが表示さ
れない場合、かわりにポイント行が中央にきます。デフォルト値は0で、スクロ
ール後は常にポイント行が中央にきます。

   自動コントロールを制御する3番目の方法は、変数
‘scroll-up-aggressively’と‘scroll-down-aggressively’をカスタマイズするこ
とで、これは直接スクロール後のポイントの垂直位置を指定します。
‘scroll-up-aggressively’の値には、‘nil’(デフォルト)、または0から1までの
浮動小数点数Fを指定します。ポイントがウィンドウの下端を越えたとき(たとえ
ば前方にスクロールしたとき)、Emacsはウィンドウの高さとウィンドウの下端か
らポイント行までの割合が、Fになるようスクロールします。つまりFを大きくす
るとより積極的(aggressive)、つまり新しいテキストがより多く表示されること
を意味します。デフォルト値‘nil’は0.5と同じです。

   同様に‘scroll-down-aggressively’は、ポイントがウィンドウの上端を越え
たとき(たとえば後方にスクロールしたとき)の振る舞いを設定します。値にはス
クロール後のウィンドウの上端からポイント行までのマージンを指定します。つ
まり‘scroll-up-aggressively’を大きくすると、より積極的になります。

   変数‘scroll-conservatively’、‘scroll-step’、および
‘scroll-up-aggressively’と‘scroll-down-aggressively’は、互いに矛盾する方
法で自動スクロールを制御します。したがって自動スクロールをカスタマイズす
る場合は、2つ以上の手法を選ぶべきではありません。もし2つ以上の変数をカス
タマイズする場合は、‘scroll-conservatively’、次に‘scroll-step’、そして最
後に‘scroll-up-aggressively’と‘scroll-down-aggressively’という優先順でカ
スタマイズしてください。

   変数‘scroll-margin’は(たとえscroll-up-aggressivelyや
scroll-down-aggressivelyに、上端または下端からのマージンがウィンドウにた
いして占める割合より大きくなるようなFを指定していても)、ポイントがウィン
ドウの上端または下端にどれだけ近づけるかを制限します。変数の値にはスクリ
ーン行の行数です。もしポイントがウィンドウの上端または下端から指定した行
数の位置にくると、Emacsは自動的にスクロールします。デフォルトでは
‘scroll-margin’は0です。


File: emacs-ja.info,  Node: Horizontal Scrolling,  Next: Narrowing,  Prev: Auto Scrolling,  Up: Display

14.4 水平スクロール
===================

“水平スクロール(Horizontal scrolling)”は、ウィンドウの行を右方向に移動さ
せます。そのため左端の近くのテキストは表示されなくなります。ウィンドウの
テキストが水平スクロールされると、テキスト行は折り返されるのではなく、切
り詰め(truncated)られます。ウィンドウが切り詰められた行を表示していると
き、ポイントがスクリーンの左端か右端を越えて移動すると、Emacsは自動的に
水平スクロールを行います。自動的な水平スクロールを無効にするには、変数
‘auto-hscroll-mode’に‘nil’をセットしてください。また自動的な水平スクロー
ルがオフになっている場合、ポイントがスクリーンの端を越えると、それを知ら
せるためにカーソルが表示されなくなることに注意してください(テキスト端末
の場合カーソルは端に残されます)。

   変数‘hscroll-margin’は、自動的なスクロールが起こる前に、ポイントがウ
ィンドウの左端または右端に、どれだけ近づけるかを制御します。変数の値は列
数で指定します。たとえば変数の値が5のときは、端から5列目にポイントが移動
すると、水平スクロールが発生します。

   変数‘hscroll-step’はmポイントが端に近づきすぎたときに、何列スクロール
するかを決定します。デフォルト値の0は、ポイントがウィンドウの中央になる
ようにスクロールされることを意味します。正の整数はスクロールされる列数を
指定します。浮動小数点数は、スクロールされる量を、ウィンドウの幅にたいす
る割合で指定します。

   以下のコマンドで明示的に水平スクロールすることもできます:

‘C-x <’
     現在のウィンドウのテキストを左にスクロールします(‘scroll-left’)。
‘C-x >’
     右にスクロールします(‘scroll-right’)。

   ‘C-x <’ (‘scroll-left’)は選択された、ウィンドウをウィンドウ幅から2列
少ない列数、左にスクロール(いいかえればウィンドウのテキストは左に移動)し
ます。数引数Nを指定すると、N列スクロールします。

   テキストが左にスクロールされて、ポイントがウィンドウの左端を越えると
、ポイントが表示されているテキストに戻るまで、カーソルはフリーズします。
これは‘auto-hscroll-mode’の設定とは独立しています(これはテキストを左にス
クロールするときのウィンドウの右端での振る舞いだけに影響します)。

   ‘C-x >’ (‘scroll-right’)は、同様に右にスクロールします。ウィンドウが
通常の表示(行の先頭がウィンドウの左端に表示されている状態)のときは、それ
以上スクロールできないので何も起こりません。これは‘C-x >’の引数を正確に
計算する必要がないことを意味します。充分に大きな引数を与えれば、通常の表
示が復元されます。

   これらのコマンドでウィンドウを水平方向にスクロールすると、自動水平ス
クロールの下限値がセットされます。自動スクロールはウィンドウのスクロール
を続けますが、前に‘scroll-left’にセットされた値を越えて右にスクロールで
きなくなります。


File: emacs-ja.info,  Node: Narrowing,  Next: View Mode,  Prev: Horizontal Scrolling,  Up: Display

14.5 ナローイング
=================

“ナローイング(Narrowing)”とはバッファーのある範囲にフォーカスを置き、他
の部分を一時的にアクセス不能にすることを意味します。扱うことのできる範囲
のことを、“アクセス可能範囲(accessible portion)”と呼びます。ナローイング
を取り消すと。バッファー全体に再びアクセスできるようになります。これを
“ワイドニング(widening)”と呼びます。バッファーにたいして、ナローイングに
より境界を設けることを、バッファーの“制限(restriction)”と呼びます。

   ナローイングにより、他の部分に気を取られずに、1つのサブルーチンやパラ
グラフに集中することが容易になります。ナローイングは、置換コマンドやキー
ボードマクロの繰り返しにより操作される範囲を制限するためにも使われます。

‘C-x n n’
     ポイントとマークの間にナローイングします(‘narrow-to-region’)。
‘C-x n w’
     バッファー全体をワイドニングして、再びアクセス可能にします
     (‘widen’)。
‘C-x n p’
     現在のページにナローイングします(‘narrow-to-page’)。
‘C-x n d’
     現在のdefunにナローイングします(‘narrow-to-defun’)。

   バッファーをナローイングしているときは、表示されている範囲がすべてで
す。残りの部分を見ることはできず、移動もできず(移動コマンドによりアクセ
ス可能範囲の外に移動することはできません)、変更もできません。しかし残り
の部分がなくなったわけではないので、ファイルを保存するとアクセス不能範囲
のテキストもすべて保存されます。ナローイングが有効なときは、モードライン
に‘Narrow’という単語が表示されます。

   主要なナローイングコマンドは、‘C-x n n’ (‘narrow-to-region’)です。こ
れは現在のバッファーを制限するので、現在のリージョンだけがアクセス可能に
なり、リージョンの前後のすべてのテキストはアクセス不能になります。ポイン
トとマークは変化しません。

   かわりに‘C-x n p’ (‘narrow-to-page’)を使うと、現在のページにナローイ
ングされます。ページの定義については、*note Pages::を参照してください。
‘C-x n d’ (‘narrow-to-defun’)は、ポイントを含むdefunにナローイングします
(*note Defuns::を参照してください)。

   ナローイングを取り消す方法は、‘C-x n w’ (‘widen’)です。これにより再び
バッファーのテキストすべてにアクセス可能になります。

   バッファーのどの範囲にナローイングされているかは、‘C-x =’コマンドを使
って情報を得ることができます。*note Position Info::を参照してください。

   ナローイングは、それを理解していないユーザーを容易に混乱させるので、
通常‘narrow-to-region’コマンドは無効になっています。このコマンドを使おう
とすると、Emacsは確認を求め、有効にするオプションを提供します。このコマ
ンドを有効にすると、それ以降は確認を求められなくなります。*note
Disabling::を参照してください。


File: emacs-ja.info,  Node: View Mode,  Next: Follow Mode,  Prev: Narrowing,  Up: Display

14.6 Viewモード
===============

Viewモードは、バッファーをスクリーン上でスキャンするためのマイナーモード
です。このモードは、バッファーを変更せずにスクロールする、便利なコマンド
を提供します。Emacsのカーソル移動コマンドとは別に、<SPC>で前方にスクロー
ル、‘S-<SPC>’または<DEL>で後方にスクロール、‘s’でインクリメンタルサーチ
ができます。

   ‘q’ (‘View-quit’)とタイプするとViewモードが無効になり、Viewモードが有
効になる前のパッファーの位置に戻ります。‘e’ (‘View-exit’)とタイプすると
Viewモードが無効になり、現在のバッファーと位置は維持されます。

   ‘M-x view-buffer’は、既存のEmacsバッファー名を入力として求め、そのバ
ッファーに切り替えてViewモードを有効にします。‘M-x view-file’はファイル
名を入力として求め、そのファイルをvisitしてViewモードを有効にします。


File: emacs-ja.info,  Node: Follow Mode,  Next: Faces,  Prev: View Mode,  Up: Display

14.7 Followモード
=================

“Followモード”は、同じバッファーを表示する2つのウィンドウを、1つの“仮想
ウィンドウ”としてスクロールするマイナーモードです。Followモードを使うに
は、ウィンドウが1つだけのフレームを選択して、それを‘C-x 3’を使って縦に並
べて2分割してから、‘M-x follow-mode’とタイプします。それ以降はバッファー
をどちらのウィンドウでも編集でき、どちらかのウィンドウをスクロールすると
、他方のウィンドウも追従してスクロールします。

   Followモードでは、一方のウィンドウで表示されている部分の外にポイント
を移動して、もう一方のウィンドウで表示されている部分にポイントを移動させ
ると、そのウィンドウが選択されます。つまり2つのウィンドウを1つの大きなウ
ィンドウとして扱えるのです。

   Followモードをオフにするには、もう一度‘M-x follow-mode’とタイプしてく
ださい。


File: emacs-ja.info,  Node: Faces,  Next: Colors,  Prev: Follow Mode,  Up: Display

14.8 テキストのフェイス
=======================

Emacsは“フェイス(faces)”と呼ばれる仕組みを通じて、テキストをいくつかの異
なるスタイルで表示できます。フェイスにはfont(フォント)、height(高さ)、
weight(太さ)、slant(傾き)、foreground(前景)およびbackground(背景)、
underline(アンダーライン)、overline(オーバーライン)などの様々な“フェイス
属性(face attributes)”を指定できます。ほとんどのメジャーモードはFont
Lockモードを通じて、テキストに自動的にフェイスを割り当てます。これらのフ
ェイスを割り当てる方法については、*note Font Lock::を参照してください。

   現在定義されているフェイスと、それがどのような外観なのかを見るには、
‘M-x list-faces-display’とタイプします。プレフィクス引数を指定すると、こ
のコマンドは正規表現の入力を求め、その正規表現にマッチするフェイスだけを
表示します(*note Regexps::を参照してください)。

   あるフェイスが、フレームが異なると違って見えるのことがあり得ます。た
とえばいくつかのテキスト端末ではすべてのフェース属性、特に特にfont、
height、widthはサポートされておらず、指定できるcolorも限られているものが
あります。加えて、ほとんどのEmacsフェースは視認性をよくするために、フレ
ームのバックグラウンドが明るい(light)か暗い(dark)かで属性が異なります。
デフォルトでは、Emacsはフレームの現在のバックグラウンドカラーに基づいて
、表示するフェイスの属性を自動的に選択します。しかし変数
‘frame-background-mode’に非‘nil’値を与えると、これをオーバーライドできま
す。値‘dark’ではすべてのフレームの背景色が暗い色であるかのように処理し、
値‘light’ではすべてのフレームの背景色が明るい色であるかのように処理させ
ることができます。

   フェイスの属性を変えてフェイスをカスタマイズして、将来のEmacsセッショ
ン用にカスタマイズ結果を保存することができます。詳細については、*note
Face Customization::を参照してください。

   ‘default’フェイスはテキストを表示するデフォルトのフェイスで、そのすべ
ての属性は指定されています。バックグラウンドカラーは、フレームのバックグ
ラウンドカラーとしても使用されます。*note Colors::を参照してください。

   他の特別なフェイスとしては、‘cursor’フェイスがあります。グラフィカル
なディスプレーでは、このフェイスのバックグラウンドカラーは、テキストカー
ソルを描画するのに使用されます。このフェイスで効果があるのはこの属性だけ
です。カーソルの下のテキストのフォアグラウンドカラーには、そのテキストの
バックグラウンドカラーが使われます。テキスト端末でのテキストカーソルの外
観は、‘cursor’フェイスではなく端末により決定されます。

   特定のフェイスの属性を指定するのにXのリソースを使うこともできます。
*note Resources::を参照してください。

   Emacsは可変幅フォント(variable-width fonts)を表示できますが、いくつか
のコマンド、特にインデントを行うコマンドは、可変幅の文字幅の表示をうまく
処理できません。そのため、ほとんどのフェイスにたいして可変幅フォントを使
わないこと、特にそれがFont Lockモードに割り当てられている場合は、使わな
いことを推奨します。


File: emacs-ja.info,  Node: Colors,  Next: Standard Faces,  Prev: Faces,  Up: Display

14.9 フェイスのカラー
=====================

フェイスには、さまざまなフォアグラウンドカラーとバックグラウンドカラーを
もたせることができます。フェイスにカラーを指定するとき、たとえばフェイス
をカスタマイズ(*note Face Customization::を参照してください)するときは、
“カラーネーム(color name)”か、“RGBトリプレット(RGB triplet)”で指定するこ
とができます。

   カラーネームとは、‘dark orange’や‘medium sea green’のような、事前に定
義された名前です。カラーネームの一覧を見るには、‘M-x
list-colors-display’とタイプします。表示されるカラーの順番を制御するには
、‘list-colors-sort’をカスタマイズします。このコマンドをグラフィカルなデ
ィスプレーで実行すると、Emacsで既知のカラーネームのすべてが表示されます
(これらは標準のX11のカラーネームで、Xの‘rgb.txt’で定義されています)。コ
マンドをテキスト端末で実行すると、端末で安全に表示することができる一部の
カラーだけが表示されます。フェイスには、さまざまなフォアグラウンドカラー
とバックグラウンドカラーを持たせることができます。しかしEmacsは、テキス
ト端末でもX11のカラーネームを理解できます。もしフェイスにX11のカラーネー
ムが指定されている場合、最も近い端末の色で表示されます。

   RGBトリプレットは、‘#RRGGBB’という形式の文字列で指定します。R、G、Bの
各コンポーネントは、そのそのコンポーネントに関連する色の強度を、1桁から
4桁(通常は2桁)の16進数で指定します。各コンポーネントは同じ桁数でなければ
なりません。16進数のAからFは、大文字小文字を区別しません。

   ‘M-x list-colors-display’は、カラーネームと、それに相当するRGBトリプ
レットを表示します。たとえば‘medium sea green’は‘#3CB371’と同じです。

   ‘M-x set-face-foreground’と‘M-x set-face-background’で、フェイスのフ
ォアグラウンドとバックグラウンドのカラーを変更できます。これらのコマンド
は、ミニバッファーでフェイス名とカラーの入力を求め(補完機能あり)、指定し
たカラーをフェイスにセットします。フェイスのカラーは全フレームに影響しま
すが、カスタマイズバッファーやXリソースを使うのとは異なり、将来のEmacsセ
ッションには引き継がれません。フレームパラメーターを使って、特定のフレー
ムのフォアグラウンドとバックグラウンドのカラーをセットすることもできます
。*note Frame Parameters::を参照してください。


File: emacs-ja.info,  Node: Standard Faces,  Next: Text Scale,  Prev: Colors,  Up: Display

14.10 標準フェイス
==================

以下はテキストの外見を指定する標準フェイスです。これらのフェイスの効果が
欲しい場合は、特定のテキストに適用することができます。

‘default’
     このフェイスは特定のフェイスをもたない普通のテキストに使われます。
     フェイスのバックグラウンドカラーは、フレームのバックグラウンドカラ
     ーとして使用されます。
‘bold’
     このフェイスは、デフォルトフォントのbold(太字)バージョンです。
‘italic’
     このフェイスはデフォルトフォントのitalic(斜体)バージョンです。
‘bold-italic’
     このフェイスはデフォルトフォントのbold italic(太字斜体)バージョンで
     す。
‘underline’
     このフェイスはunderline(下線)のテキストです。
‘fixed-pitch’
     このフェイスはfixed-width font(固定幅フォント)の使用を強制します。
     もし望むなら、このフェイスから他の固定幅フォントにカスタマイズする
     のは妥当ですが、可変幅フォントにするべきではありません。
‘variable-pitch’
     このフェイスはvariable-width font(可変幅フォント)の使用を強制します
     。
‘shadow’
     このフェースはまわりのテキストに比べて、そのテキストを目立たなくし
     ます。通常これはデフォルトの黒または白のフォアグラウンドカラーでは
     なく、グレーが使われます。

   以下は特別な目的のために、一時的にテキストの一部をハイライトするのに
使われるフェイスの、不完全なリストです(他にも多くのモードが、そのモード
の目的のために、独自のフェイスを定義しています)。

‘highlight’
     このフェイスはさまざまなコンテキスト、たとえばハイパーリンク上をマ
     ウスカーソルが通過したときなどに、テキストをハイライトするのに使わ
     れます。
‘isearch’
     このフェイスは、現在のIsearch(インクリメンタル検索)のマッチをハイラ
     イトするのに使われます(*note Incremental Search::を参照してください
     )。
‘query-replace’
     このフェイスは、現在の問い合わせ置換(Query Replace)のマッチをハイラ
     イトするのに使われます(*note Replace::を参照してください)。
‘lazy-highlight’
     このフェイスは、Isearchおよび問い合わせ置換で、“カレントのマッチ(現
     在カーソルがあるマッチ)以外のマッチ(lazy matches)”をハイライトする
     のに使われます。
‘region’
     このフェイスは、アクティブなリージョンを表示するのに使われます
     (*note Mark::を参照してください)。EmacsをGTKサポートつきでビルドし
     た場合、カラーは現在のGTKのテーマから提供されます。
‘secondary-selection’
     このフェイスは、Xのセカンダリー選択(secondary X selection)を表示す
     るのに使われます(*note Secondary Selection::を参照してください)。
‘trailing-whitespace’
     このフェイスは、‘show-trailing-whitespace’は非‘nil’のとき、行末の余
     分なスペースやタブをハイライトするためのものです(*note Useless
     Whitespace::を参照してください)。
‘escape-glyph’
     このフェイスは、制御文字やエスケープシーケンスを表示するためのもの
     です(*note Text Display::を参照してください)。
‘nobreak-space’
     このフェイスは、“no-break”スペース文字を表示するためのものです
     (*note Text Display::を参照してください)。

   以下のフェイスは、Emacsフレームの一部の外見を制御します:

‘mode-line’
     このフェイスは、現在選択されているウィンドウのモードラインと、ツー
     ルキットメニューが使われていないときのメニューバーに使われます。デ
     フォルトでは、グラフィカルなウィンドウでは“raised”効果をだすため影
     つきで描画され、非ウィンドウの端末ではデフォルトのフェイスを反転し
     て描画されます。
‘mode-line-inactive’
     ‘mode-line’と似ていますが、選択されていないウィンドウのモードライン
     に使われます(‘mode-line-in-non-selected-windows’が非‘nil’のとき)。
     このフェイスは‘mode-line’を継承するので、フェイスを変更するとすべて
     のウィンドウのモードラインが影響を受けます。
‘mode-line-highlight’
     ‘highlight’と似ていますが、モードライン上でマウスセンシティブ(マウ
     スに感応する)なテキスト範囲に使われます。通常このようなテキスト範囲
     は上にマウスポインターがくると、ツールチップ(*note Tooltips::を参照
     してください)をポップアップします。
‘mode-line-buffer-id’
     このフェイスは、モードライン上でバッファーを識別する部分に使われま
     す。
‘header-line’
     ‘mode-line’と似ていますが、ウィンドウのヘッダーラインのためのもので
     す。モードラインがウィンドウの一番下に表示されるように、ヘッダーラ
     インはウィンドウの一番上に表示されます。ほとんどのウィンドウはヘッ
     ダーラインを持ちません。Infoモードのような特別なモードだけがヘッダ
     ーラインを持ちます。
‘vertical-border’
     このフェイスは、テキスト端末上でウィンドウを縦に分割するとき使われ
     ます。
‘minibuffer-prompt’
     このフェイスは、ミニバッファーで入力を求めるプロンプトのテキストに
     使われます。デフォルトでは、Emacsは自動的にプロンプトのテキストの、
     テキストプロパティのリスト‘minibuffer-prompt-properties’に、このフ
     ェイスを追加します(この変数はミニバッファーに入ったときに効果をあら
     わします)。
‘fringe’
     グラフィカルなウィンドウでの、左右のフリンジのためのフェイスです(フ
     リンジはEmacsフレームで、テキストエリアとウィンドウの左右の境界線の
     間にある、狭い領域です)。*note Fringes::を参照してください。
‘cursor’
     このフェイスの‘:background’属性は、テキストカーソルのカラーを指定し
     ます。*note Cursor Display::を参照してください。
‘tooltip’
     このフェイスは、ツールチップのテキストに使われます。デフォルトでは
     、EmacsがGTKサポートつきでビルドされた場合、ツールチップはGTKを通じ
     て描画されるので、このフェイスは効果がありません。*note Tooltips::を
     参照してください。
‘mouse’
     このファイスは、マウスポインターのカラーを決定します。

   以下のフェイスは、Emacsフレームの一部の外見を制御するときと同様ですが
、テキスト端末またはEmacsをXサポートつき(ただしツールキットサポートなし
)でビルドしたときだけ使われます(それ以外の場合、フレームの対応する各要素
は広義なシステム設定により決定されます)。

‘scroll-bar’
     このフェイスは、スクロールバーの外見を決定します。*note Scroll
     Bars::を参照してください。
‘tool-bar’
     このフェイスは、ツールバーのアイコンのカラーを決定します。*note
     Tool Bars::を参照してください。
‘menu’
     このフェイスはEmacsメニューのカラーとフォントを決定します。*note
     Menu Bars::を参照してください。
‘tty-menu-enabled-face’
     このフェイスは、テキスト端末で利用可能なメニューアイテムを表示する
     のに使われます。
‘tty-menu-disabled-face’
     このフェイスは、テキスト端末で利用不可なメニューアイテムを表示する
     のに使われます。
‘tty-menu-selected-face’
     このフェイスは、テキスト端末でマウスをクリックするか、<RET>を押せば
     選択できるメニューアイテムを表示するのに使われます。


File: emacs-ja.info,  Node: Text Scale,  Next: Font Lock,  Prev: Standard Faces,  Up: Display

14.11 テキストのスケール
========================

現在のバッファーのデフォルトフェイスを大きくするには、‘C-x C-+’または
‘C-x C-=’をタイプします。小さくするには、‘C-x C--’をタイプします。デフォ
ルトのフェースの大きさ(グローバル)に復元するには、‘C-x C-0’とタイプしま
す。これらのキーは、すべて同じコマンド‘text-scale-adjust’にバインドされ
ており、このコマンドは最後のキーを判断して動作を決定します。

   これらのコマンドの最後のキーは、‘C-x’を前置せずに繰り返すことができま
す。たとえば‘C-x C-= C-= C-=’は、フェイスの大きさを3段階に大きくします。
各ステップで大きくなる倍率は1.2です。この倍率を変更するには、変数
‘text-scale-mode-step’をカスタマイズします。‘text-scale-adjust’コマンド
に数引数0を指定すると、‘C-x C-0’とタイプしたのと同様に、デフォルトの大き
さに復元します。

   コマンド‘text-scale-increase’および‘text-scale-decrease’は、‘C-x
C-+’および‘C-x C--’と同様、デフォルトフェイスを大きくまたは小さくします
。キーをバインドする場合、これらのコマンドは、‘text-scale-adjust’より便
利でしょう。

   コマンド‘text-scale-set’は、数引数で現在のバッファーのデフォルトフェ
イスの大きさを、絶対倍率で指定します。

   上記のコマンドは、現在のフォント倍率が1以外のときは、自動的にマイナー
モード‘text-scale-mode’を有効にし、そうでない場合は無効にします。


File: emacs-ja.info,  Node: Font Lock,  Next: Highlight Interactively,  Prev: Text Scale,  Up: Display

14.12 Font Lockモード
=====================

Font Lockモードはマイナーモードで、常に特定のバッファーにローカルで、バ
ッファーのテキストにフェイスを割り当てます(または“フォント表示化
(fontifies)します”)。各バッファーのメジャーモードは、Font Lockモードにど
のテキストをフォント表示可するか指示します。たとえばプログラム言語のモー
ドは、コメントや文字列、関数名のような、構文に関連する構成をフォント表示
化します。

   Font Lockモードはデフォルトで有効です。現在のバッファーでこれを切り替
えるには、‘M-x font-lock-mode’とタイプします。正の数引数は無条件にFont
Lockモードを有効にし、負または0の数引数を指定すると無効になります。

   ‘M-x global-font-lock-mode’とタイプすると、すべてのバッファーでFont
Lockモードを切り替えます。このセッティングを将来のEmacsセッションに引き
継ぐには、変数‘global-font-lock-mode’をカスタマイズ(*note Easy
Customization::を参照してください)するか、以下の行をinitファイルに追加し
ます。

     (global-font-lock-mode 0)

Global Font Lockモードを無効にしていたとしても、モードフック(mode
hooks)に関数を追加することにより、特定のメジャーモードでFont Lockモード
を有効にできます。たとえばCファイルの編集でFont Lockモードを有効にするに
は、以下のように記述します:

     (add-hook 'c-mode-hook 'font-lock-mode)

   Font Lockモードは、‘font-lock-string-face’、
‘font-lock-comment-face’のような、いくつかの特別な名前のフェイスを使って
処理を行います。これらすべてを簡単に探す方法には、‘M-x customize-group
<RET> font-lock-faces <RET>’を使います。それからカスタマイズバッファーで
それらのフェイスの外見をカスタマイズできます。*note Face
Customization::を参照してください。

   変数‘font-lock-maximum-decoration’をカスタマイズして、Font Lockモード
で適用されるフォント表示化のレベルを変更できます。値には数字を指定します
(1は最小限のフォント表示化で、3という高いレベルのモードもあります)。
‘t’は“可能な限り高く”という意味です(デフォルト)。特定のモードに異なる数
字を指定することもできます。たとえばC/C++モードにはレベル1を指定して、他
のモードにはデフォルトのレベルを適用するには、以下の値を使います:

     '((c-mode . 1) (c++-mode . 1)))

   コメントと文字列のフォント表示化(または“構文的”なフォント表示化)は、
バッファーのテキストの構文構造の解析に依存します。速度向上のため、Lispモ
ードを含めたいくつかのモードでは、特別な慣習に依存しています。たとえば一
番左の列の開きカッコ(open-parenthesis)または開き大カッコ(open-brace)は常
にdefunの開始であり、すなわち常に文字列またはコメントの外部にあるとみな
す、というように解析します。したがって文字列やコメントの中で、一番左の列
に開きカッコや開き大カッコを記述するのは避けるべきです。詳細については、
*note Left Margin Paren::を参照してください。

   常にバッファーローカルな変数
‘font-lock-beginning-of-syntax-function’は、Font Lockモードがコメント、
もしくは文字列の外であることが保証される位置を探す方法を指定します。それ
が最左列がカッコであるという慣習をもつモードでは、変数のデフォルト値は
‘beginning-of-defun’で、Font Lockモードがその慣習にしたがうよう指定しま
す。この変数に‘nil’をセットすると、Font Lockモードはもはや慣習には依存し
なくなります。これでまちがった結果を避けられますが、その代償はとして、変
更したテキストをフォント表示化するに、バッファのテキストをバッファの先頭
から再走査しなければならない場合もあります。これはスクロールに相当な速度
低下を招きかねず、大きなバッファーの最後に近い位置では、それが特に顕著に
なります。

   Font Lockは、ほとんどのモードで既存のパターンをハイライトしますが、追
加のパターンをフォント表示化したいときもあるでしょう。特定のモードでハイ
ライトするパターンを追加するには、関数‘font-lock-add-keywords’を使うこと
ができます。たとえばCコメント中の‘FIXME:’という単語をハイライトするには
、以下を使います:

     (add-hook 'c-mode-hook
               (lambda ()
                (font-lock-add-keywords nil
                 '(("\\<\\(FIXME\\):" 1
                    font-lock-warning-face t)))))

font-lockのハイライトパターンからキーワードを削除するには、関数
‘font-lock-remove-keywords’を使います。*note (elisp)Search-based
Fontification::を参照してください。

   大きなバッファーのフォント表示化には、長い時間を要することもあります
。ファイルをvisitしたとき大きな遅延を避けるには、Emacsが最初はバッファー
の表示された部分だけをフォント表示化するようにします。バッファーをスクロ
ールすると、新たに表示される部分がフォント表示化されます。このタイプの
Font Lockは、“Just-In-Time”(または“JIT”) Lockと呼ばれます。カスタマイズ
グループ‘jit-lock’の値をカスタマイズすることにより、アイドル状態のときに
フォント表示可を行うことも含めて、JIT Lockがどのように振る舞うか制御でき
ます。*note Specific Customization::を参照してください。


File: emacs-ja.info,  Node: Highlight Interactively,  Next: Fringes,  Prev: Font Lock,  Up: Display

14.13 インタラクティブなハイライト
==================================

Highlight Changesモードは、最近変更されたバッファー部分のテキストに、異
なるフェイスを与えることにより“ハイライト”するマイナーモードです。
Highlight Changesモードを有効または無効にするには、‘M-x
highlight-changes-mode’を使います。

   Hi Lockモードは、指定した正規表現にマッチするテキストをハイライトする
、マイナーモードです。たとえば、プログラムのソースファイルで、特定の変数
へのすべての参照をハイライトしたり、何らかのプログラムの大量の出力の一部
をハイライトしたり、記事中の特定の名前をハイライトするために使用できます
。Hi Lockモードを有効または無効にするには、コマンド‘M-x hi-lock-mode’を
使います。すべてのバッファーでHi Lockモードを有効にするには、‘M-x
global-hi-lock-mode’を使うか、‘.emacs’ファイルに‘(global-hi-lock-mode
1)’と記述してください。

   Hi LockモードはFont Lockモード(*note Font Lock::を参照してください)と
同じように動作しますが、ハイライトするパターンを明示的に正規表現で指定し
ます。これらは以下のコマンドで制御できます:

‘M-s h r REGEXP <RET> FACE <RET>’
‘C-x w h REGEXP <RET> FACE <RET>’
     REGEXPにマッチするテキストを、フェイスFACEを使ってハイライトします
     (‘highlight-regexp’)。ハイライトはバッファーがロードされている限り
     残ります。たとえば単語“whim”をデフォルトのフェイス(黄色いバックグラ
     ウンドカラー)でハイライトするには、‘M-s h r whim <RET> <RET>’とタイ
     プします。ハイライトには任意のフェイスを使うことができますが、Hi
     Lockモードはモード自身でいくつかのフェイスを提供しており、それらは
     デフォルト値のリストに事前ロードされています。フェイスの入力プロン
     プトで‘M-n’と‘M-p’を使うことにより、それらを巡回することができます
     。

     オプション‘hi-lock-auto-select-face’に非‘nil’値をセットすることによ
     り、このコマンド(およびその他のフェイスを読みとるHi Lockコマンド)は
     、入力を求めることなく、デフォルト値のリストから次のフェイスを自動
     的に選択します。

     このコマンドを複数回使用して、さまざまな正規表現を指定し、それぞれ
     を異なる方法でハイライトできます。

‘M-s h u REGEXP <RET>’
‘C-x w r REGEXP <RET>’
     REGEXPのハイライトを解除します(‘unhighlight-regexp’)。

     メニューから呼び出した場合、ハイライト解除する正規表現をリストから
     選択します。キーボードから呼び出した場合は、ミニバッファーを使いま
     す。一番最近追加された正規表現を表示し、‘M-n’を使って次に古い正規表
     現、‘M-p’で次に新しい正規表現を表示できます(手入力もでき、その場合
     は補完機能つきです)。ハイライト解除したい正規表現がミニバッファーに
     表示されたら、‘<RET>’を押してミニバッファーを抜けだし、ハイライトを
     解除できます。

‘M-s h l REGEXP <RET> FACE <RET>’
‘C-x w l REGEXP <RET> FACE <RET>’
     REGEXPとのマッチを含む行全体を、フェイスFACEを使ってハイライトしま
     す(‘highlight-lines-matching-regexp’)。

‘M-s h p PHRASE <RET> FACE <RET>’
‘C-x w p PHRASE <RET> FACE <RET>’
     PHRASEにマッチするフレーズを、フェイスFACEでハイライトします
     (‘highlight-phrase’)。PHRASEには正規表現を指定できますが、スペース
     は空白文字にマッチする正規表現に置き換えられます。また、先頭に小文
     字を使用することにより、大文字小文字を区別しなくなります。

‘M-s h .’
‘C-x w .’
     ポイントの近くで見つかったシンボルを、次に利用可能なフェイスでハイ
     ライトします(‘highlight-symbol-at-point’)。

‘M-s h w’
‘C-x w b’
     現在ハイライトを行っている正規表現/フェイスのペアを、バッファーのポ
     イント位置に挿入します。挿入はプログラムを変更してしまわないように
     、コメント文字列でコメント化されます(このキーバインドは
     ‘hi-lock-write-interactive-patterns’コマンドを実行します)。

     これらのパターンは、コメントからも逆抽出されます。それは、コメント
     に記述されたテキストが適正で、‘M-x hi-lock-find-patterns’を呼び出し
     た、あるいはHi Lockモードが有効なときファイルをvisit(これは
     ‘hi-lock-find-patterns’を実行します)したときです。

‘M-s h f’
‘C-x w i’
     正規表現/フェイスのペアを、現在のバッファーのコメントから抽出します
     (‘hi-lock-find-patterns’)。これらのコマンドを使えば、
     ‘highlight-regexp’でパターンを対話的に入力、
     ‘hi-lock-write-interactive-patterns’でそれをファイルに保存、それら
     を編集(あるマッチのフェイスを別のフェイスにしたり)、そして最後にこ
     のコマンド(‘hi-lock-find-patterns’)で編集済みのパターンを、Hi Lockの
     ハイライトに適用することができます。

     変数‘hi-lock-file-patterns-policy’はファイルをvisitしたとき、Hi
     Lockモードがパターンを探して、それを自動的に抽出するべきかを制御し
     ます。値には‘nil’(ハイライトしない)、‘ask’(ユーザーに尋ねる)、また
     は関数を指定します。関数の場合、‘hi-lock-find-patterns’はパターンを
     引数としてその関数を呼び出します。関数が非‘nil’を返した場合、パター
     ンを使用します。デフォルトは‘ask’です。直接
     ‘hi-lock-find-patterns’を呼び出した場合、この変数の値に関係なく、常
     にパターンはハイライトされることに注意してください。

     現在のメジャーモードのシンボルが、リスト‘hi-lock-exclude-modes’のメ
     ンバーの場合、‘hi-lock-find-patterns’は何もしません。


File: emacs-ja.info,  Node: Fringes,  Next: Displaying Boundaries,  Prev: Highlight Interactively,  Up: Display

14.14 ウィンドウのフリンジ
==========================

グラフィカルなディスプレーでは、通常Emacsの各ウィンドウの左右の端に、狭
い“フリンジ(fringes: 縁、へり)”があります。フリンジは、ウィンドウのテキ
ストに関する情報を提供するシンボルの表示に使用されます。‘M-x
fringe-mode’とタイプしてフリンジを無効にしたり、幅を変更できます。このコ
マンドは全フレームのフリンジに影響します。選択されたフレームのフリンジだ
けを変更するには、‘M-x set-fringe-style’を使います。変数‘fringe-mode’を
カスタマイズして、フリンジへの変更を永続化できます。

   フリンジのもっとも一般的な使われかたは、継続行の表示です(*note
Continuation Lines::を参照してください)。テキストの1行が複数のスクリーン
行に分割されるとき、最初の行を除いた各行の左フリンジには曲矢印が表示され
、その行の先頭が“実際の行頭ではない”ことを示します。そして、最後の行を除
いた各行の右フリンジにも曲矢印が表示され、その行の最後が“実際の行末では
ない”ことを示します。行の方向が右から左(*note Bidirectional Editing::を
参照してください)の場合、フリンジの曲矢印の意味は逆になります。

   行が切り詰められているときは水平方向の直矢印を表示して、“この行には水
平スクロールしなければ見ることのできないテキストがある”ことを示します。
矢印の上でマウスをクリックすれば、矢印の指す方向に水平スクロールします。

   フリンジはバッファーの境界(*note Displaying Boundaries::を参照してく
ださい)や、デバッグ(*note Debuggers::を参照してください)しているプログラ
ムが実行中であることを示すためにも使われます。

   現在の行がウィンドウの幅と正確に一致して、ポイントがその行の行末にあ
る場合、フリンジにはカーソルが描画されます。これを無効にするには、変数
‘overflow-newline-into-fringe’を‘nil’に変更します。これによりEmacsはウィ
ンドウ幅と同じ長さの行にたいしても、継続または切り詰めを行います。


File: emacs-ja.info,  Node: Displaying Boundaries,  Next: Useless Whitespace,  Prev: Fringes,  Up: Display

14.15 バウンダリーの表示
========================

グラフィカルなディスプレーでは、Emacsはバッファーのバウンダリー
(boundary: 境界)を、フリンジに表示することもできます。この機能を有効にす
ると、最初の行と最後の行ではフリンジに、かぎカッコが表示されます。上矢印
または下矢印の場合、それはウィンドウをその方向に、もっとスクロールできる
ことを示します。

   バッファーローカルな変数‘indicate-buffer-boundaries’は、バッファーの
バウンダリーととウィンドウのスクロールが、フリンジでどのように表示される
かを制御します。値が‘left’(または‘right’)の場合、かぎカッコと矢印のビッ
トマップは、左フリンジ(または右フリンジ)に表示されます。

   値がalist(association list: 連想リスト)の場合、各要素の‘(INDICATOR .
POSITION)’で、標識(indicator)の位置(position)を指定します。INDICATORには
‘top’、‘bottom’、‘up’、‘down’、または‘t’(指定されていない標識のデフォル
ト位置)を指定します。POSITIONには‘left’、‘right’、または‘nil’(標識を表示
しない)を指定します。

   たとえば‘((top . left) (t . right))’は、最上行の左フリンジにかぎカッ
コを表示し、右フリンジには最下行のかぎカッコとスクロール矢印を表示します
。左フリンジにかぎカッコだけを表示させる場合は、‘((top . left) (bottom .
left))’を使います。


File: emacs-ja.info,  Node: Useless Whitespace,  Next: Selective Display,  Prev: Displaying Boundaries,  Up: Display

14.16 不要なスペース
====================

意識せずに不必要なスペースを行末に残してしまったり、バッファーの最後に空
行を残してしまうことはよくあります。ほとんどの場合、そのような“行末の空
白文字(trailing whitespace)”は何の影響も及ぼしませんが、厄介物になる場合
もあります。

   バッファーローカルな変数‘show-trailing-whitespace’を‘t’にセットするこ
とにより、行末の空白文字を可視化できます。これによりEmacsはフェイス
‘trailing-whitespace’で、行末の空白文字を表示します。

   この機能は行末に空白文字を含む行の、行末にポイントがあるときは適用さ
れません。厳密にいえば、これも“行末の空白文字”なのですが、それを特別に表
示してしまうと、新しいテキストをタイプするとき面倒です。このような特別な
ケースでは、ポイントの位置に表示されるカーソルより、空白文字があることが
自明だからです。

   ‘M-x delete-trailing-whitespace’とタイプすると、すべての行末の空白文
字を削除します。このコマンドは、バッファー内の各行の行末にあるすべての余
分なスペースと、バッファーの最後にある空行を削除します。バッファー内の空
行を削除しない場合は、変数‘delete-trailing-lines’を‘nil’に変更してくださ
い。リージョンがアクティブのときは、リージョン内の各行の行末の余分なスペ
ースを削除します。

   グラフィカルなディスプレーでは、Emacsはウィンドウの最後の使われていな
い行の左フリンジに小さなイメージを表示して、それを示すことができます。こ
のイメージはバッファーのテキストが何も含まれていないスクリーン行に表示さ
れるので、バッファーの最後にある空行は、このイメージが表示されないことで
見分けることができます。この機能を有効にするにはバッファーローカルな変数
‘indicate-empty-lines’に非‘nil’値をセットします。すべての新しいバッファ
ーでこの機能を有効または無効にするには、この変数のデフォルト値をセットし
ます(例 ‘(setq-default indicate-empty-lines t)’)

   Whitespaceモードはバッファーローカルなマイナーモードで、バッファー内
にある多くの種類の空白文字を“視覚化”します。これは空白文字を特別なフェイ
スで描画するか、特別なグリフで表示することにより行われます。このモードを
切り替えるには、‘M-x whitespace-mode’とタイプします。視覚化される空白文
字の種類は、リスト変数‘whitespace-style’により決定されます。以下はリスト
に指定できる要素の一部です(完全なリストは変数のドキュメントを参照してく
ださい)。

‘face’
     特別なフェイスを使った視覚化をすべて有効にします。この要素には特別
     な意味があります。もしこれがリストに含まれていない場合、
     ‘space-mark’、‘tab-mark’、‘newline-mark’を除く他の視覚化は効果がな
     くなります。

‘trailing’
     行末の空白文字をハイライトします。

‘tabs’
     タブ文字をハイライトします。

‘spaces’
     スペースおよびnon-breaking space文字をハイライトします。

‘lines’
     80列以上の行をハイライトします。列の上限を変更するには、変数
     ‘whitespace-line-column’をカスタマイズします。

‘newline’
     改行をハイライトします。

‘empty’
     空行をハイライトします。

‘space-mark’
     スペースとnon-breaking文字を特別なグリフで描画します。

‘tab-mark’
     タブ文字を特別なグリフで描画します。

‘newline-mark’
     改行文字を特別なグリフで描画します。


File: emacs-ja.info,  Node: Selective Display,  Next: Optional Mode Line,  Prev: Useless Whitespace,  Up: Display

14.17 選択的な表示
==================

Emacsには、与えられたレベルより多くインデントされた行を隠す機能がありま
す。これをプログラムの概要を理解するのに使うことができます。

   現在のバッファーの行を隠すには、数引数Nを指定して‘C-x $’
(‘set-selective-display’)をタイプします。すると少なくともN列のインデント
をもつ行は、スクリーンに表示されなくなります。隠された行の存在を示すのは
、表示されている行末に表示された3つのドット(‘...’)だけで、これは1行以上
の行が後に隠されていることを意味します。

   コマンド‘C-n’および‘C-p’は、隠された行が存在しないかのように、隠され
た行をスキップして移動します。

   隠された行は依然としてバッファーに存在し、ほとんどの編集コマンドはそ
れらを見ることができるので、隠されな行にポイントを移動することもありえま
す。これが起こるとカーソルは前の行の最後、つまり3つのドットの後ろに表示
されます。ポイントが表示されている行の行末、つまり改行の前にある場合、カ
ーソルは3つのドットの前に表示されます。

   隠された行のすべてを再び表示するには、引数を指定せずに‘C-x $’とタイプ
してください。

   変数‘selective-display-ellipses’に‘nil’をセットすると、隠された行があ
ることを示す3つのドットは表示されなくなり、隠された行があることを示す視
覚的な表示はなくなります。変数がセットされると、それは自動的にローカルに
なります。

   バッファーのテキストの一部を隠す他の方法については、*note Outline
Mode::を参照してください。


File: emacs-ja.info,  Node: Optional Mode Line,  Next: Text Display,  Prev: Selective Display,  Up: Display

14.18 モードラインのオプション
==============================

バッファーのパーセント表示POSは、ウィンドウの上端がバッファーのどの場所
にあるかを100分率で示します。‘M-x size-indication-mode’とタイプしてSize
Indicationモードをオンにすることにより、バッファーのサイズを追加で表示で
きます。サイズは以下のようにパーセント表示のすぐ後に表示されます:

     POS of SIZE

SIZEは、バッファーの文字数を人間が理解しやすい形式(‘k’は10^3、‘M’は
10^6、‘G’は10^9などの短縮形が使用されます)で表示します。

   Line Numberモードが有効なとき、ポイント位置の現在の行番号はモードライ
ンに表示されます。‘M-x line-number-mode’コマンドを使って、Line Numberモ
ードのオンとオフを切り替えることができます(通常はオンです)。行番号はそれ
が何であるかを示す文字‘L’とともに、バッファーのパーセント表示POSの後ろに
表示されます。

   同様に、‘M-x column-number-mode’でColumn numberモードをオンにすること
により、現在の列番号を表示できます。列番号は文字‘C’で示されます。しかし
両方のモードが有効になっているときは、行番号と列番号は‘L’や‘C’ではなく、
‘(561,2)’のようにカッコつきで表示されます。マイナーモードとこれらのコマ
ンドの使い方については、*note Minor Modes::を参照してください。

   ナローイング(*note Narrowing::を参照してください)によりバッファーを制
限している場合、アクセスできる部分にもとづいた行番号が表示されます。その
ため、これは‘goto-line’の引数として使用するには適しません(ファイル全体に
たいする行番号を見るには、‘what-line’コマンドを使います)。

   バッファーが非常に大きい場合(‘line-number-display-limit’の値より大)、
速度が遅くなるのでEmacsは行番号を計算しません。そのためモードラインに行
番号は表示されません。この制限を取り除くには、
‘line-number-display-limit’に‘nil’をセットします。

   バッファーの行が長いときも、行番号の計算が遅くなります。この理由によ
り、Emacsはポイントの近くの行の幅の平均文字数が、
‘line-number-display-limit-width’より大きいときは、行番号を表示しません
。デフォルト値は200文字です。

   Emacsはオプションで、時刻とシステムロードを、すべてのモードラインで表
示できます。この機能を有効にするには、‘M-x display-time’とタイプするか、
オプション‘display-time-mode’をカスタマイズします。モードラインに追加さ
れる情報は以下のような形式です:

     HH:MMpm L.LL

ここでHHとMMは時間と分で、後ろに‘am’と‘pm’がつきます。L.LLは、過去数分間
における、システム全体で実行中または実行準備ができている(例: 利用可能な
プロセッサー待ち)プロセスの平均数です(オペレーティングシステムがサポート
しないフィールドは表示されません)。時刻を24時間表示にしたいときは、変数
‘display-time-24hr-format’に‘t’をセットしてください。

   もし未読メールがある場合、ロードレベルの後ろに‘Mail’という単語が表示
されます。グラフィカルなディスプレーでは、‘display-time-use-mail-icon’を
カスタマイズすることにより、‘Mail’のかわりにアイコンを使うことができます
。これによりモードラインのスペースが多少節約できます。
‘display-time-mail-face’をカスタマイズして、メールの表示を目立たせること
ができます。‘display-time-mail-file’を使ってチェックするメールファイルを
指定したり、‘display-time-mail-directory’で受信メールのディレクトリーを
指定できます(ディレクトリー内の空でない普通のファイルは、“新しい受信メー
ル”と判断されます)。

   Emacsをラップトップコンピューターで実行している場合、コマンド
‘display-battery-mode’を使うか、変数‘display-battery-mode’をカスタマイズ
することにより、モードラインにバッテリー充電状況を表示できます。変数
‘battery-mode-line-format’は、バッテリーの充電状況の表示方法を決定します
。モードラインに表示されるメッセージの正確さはオペレーティングシステムに
依存しており、通常はバッテリーの充電トータルにたいする現在のバッテリー充
電率が表示されます。

   グラフィカルなディスプレーでは、モードラインは立体的に描画されます。
この効果が気に入らない場合は、‘mode-line’フェイスをカスタマイズして、
‘box’属性に‘nil’をセットすることにより無効にできます。*note Face
Customization::を参照してください。

   デフォルトでは、選択されていないウィンドウのモードラインは、
‘mode-line-inactive’と呼ばれる、別のフェイスで表示されます。選択されたウ
ィンドウのモードラインだけが、‘mode-line’フェイスで表示されます。これに
より、どのウィンドウが選択されているかがわかりやすくなります。モードライ
ンがないミニバッファーが選択されているときは、ミニバッファーをアクティブ
にしたウィンドウのモードラインが、‘mode-line’で表示されます。結果として
通常のミニバッファーの使用では、モードラインは変化しません。

   変数‘mode-line-in-non-selected-windows’を‘nil’にセットすることにより
、‘mode-line-inactive’の使用を無効にできます。これによりすべてのモードラ
インが、‘mode-line’フェイスで表示されます。

   モードラインに表示される改行フォーマットは、変数‘eol-mnemonic-unix’、
‘eol-mnemonic-dos’、‘eol-mnemonic-mac’、および‘eol-mnemonic-undecided’を
セットすることにより、カスタマイズできます。


File: emacs-ja.info,  Node: Text Display,  Next: Cursor Display,  Prev: Optional Mode Line,  Up: Display

14.19 テキストが表示される方法
==============================

ほとんどの文字は、“印字文字(printing characters)”です。これらの文字がバ
ッファーに存在すると、スクリーンにそのまま表示されます。印字文字には
ASCIIの数字、文字、区切り文字、同様に多くの非ASCII文字が含まれます。

   ASCII文字セットには、印字されない“制御文字(control characters)”が含ま
れます。その中でも特別に表示されるものが2つあります。1つ目は改行文字
(Unicodeのコードポイント‘U+000A’)で、新しい行を開始するのに表示されます
。2つ目はタブ文字(‘U+0009’)で、次のタブストップ(通常は8文字ごと)までをス
ペースで表示します。タブを何文字のスペースで表示するかは、バッファーロー
カルな変数‘tab-width’で制御され、1から1000の整数で指定しなければなりませ
ん。バッファーのタブ文字がどのように表示されるかは、コマンドとしての
<TAB>の定義には関係ないことに注意してください。

   他のASCII制御文字としては、‘U+0020’(8進の40、10進の32)より下のコード
があり、それらはカレット(‘^’)と、その後ろに非制御文字バージョンの文字を
続けて、‘escape-glyph’フェイスで表示されます。たとえば文字
‘control-A’(‘U+0001’)は、‘^A’と表示されます。

   コード‘U+0080’(8進の200)から‘U+009F’(8進の237)までのrawバイトは、
‘escape-glyph’フェイスにより、“8進エスケープシーケンス(octal escape
sequences)”で表示されます。たとえば文字コード‘U+0098’(8進の230)は、
‘\230’と表示されます。バッファーローカルな変数‘ctl-arrow’を‘nil’に変更す
ると、ASCII制御文字も、カレットエスケープシーケンスではなく、8進エスケー
プシーケンスで表示されます。

   非ASCII文字の中には、ASCIIのスペースやハイフン(マイナス記号)と同じ外
観を持つものがあります。そのような文字は、意識せずにバッファーに入力され
たとき(たとえばyankなどで)、問題となることがあります。たとえばソースコー
ドコンパイラーは通常、非ASCIIのスペースを、空白文字として扱いません。こ
の問題に対処するため、Emacsはそのような文字を特別な方法
(‘U+00A0’(no-break space)は‘nobreak-space’フェイス、‘U+00AD’(soft
hyphen)、‘U+2010’(hyphen)、‘U+2011’ (non-breaking hyphen)は
‘escape-glyph’フェイス)で表示します。これを無効にするには、変数
‘nobreak-char-display’を‘nil’に変更します。この変数に非‘nil’かつ非‘t’の
値を与えると、Emacsはハイライトされたバックスラッシュの後に、スペースま
たはハイフンを表示します。

   特定の文字コードの表示のカスタマイズは、ディスプレーテーブル(display
table)によって行われます。*note Display Tables: (elisp)Display Tables.を
参照してください。

   グラフィカルなディスプレーでは、Emacsが利用可能なフォントにグリフがな
い文字がいくつかあります。これらの“グリフがない文字(glyphless
characters)”は、通常16進文字を含むボックスで表示されます。テキスト端末で
は、端末エンコーディング(*note Terminal Coding::を参照してください)で表
示できない文字は、通常クエスチョン記号で表示されます。表示方法は、変数
‘glyphless-char-display-control’で制御できます。詳細は、*note Glyphless
Character Display: (elisp)Glyphless Chars.を参照してください。


File: emacs-ja.info,  Node: Cursor Display,  Next: Line Truncation,  Prev: Text Display,  Up: Display

14.20 カーソルの表示
====================

テキスト端末では、カーソルの外見は端末により制御され、大部分はEmacsの制
御が及びません。いくつかの端末は、“普通の”固定的なカーソルと、“目立つ”点
滅カーソルの2種類を提供します。デフォルトではEmacsは目立つカーソルを使い
、Emacsを開始または再開したときは、そのカーソルに切り替えます。変数
‘visible-cursor’が‘nil’の場合、Emacsを開始または再開したとき、普通のカー
ソルを使います。

   グラフィカルなディスプレーでは、より多くのテキストカーソルのプロパテ
ィを変更できます。カラーを変えるには、フェイス‘cursor’の、属性
‘:background’を変更します(このフェイスの他の属性には、何を指定しても効果
はありません。カーソルの下にあるテキストはフレームのバックグラウンドカラ
ーを使って描画されます)。外見を変更するには、バッファーローカルな変数
‘cursor-type’をカスタマイズします。有効な値は、‘box’(デフォルト)、
‘hollow’(中抜きのボックス)、‘bar’(垂直のバー)、‘(bar . N)’(幅がNピクセル
の垂直バー), ‘hbar’(水平バー)、‘(hbar . N)’(高さがNピクセルの水平バー)、
または‘nil’(カーソルなし)です。

   デフォルトでは、カーソルは10回点滅する間にEmacsに何も入力がないと、点
滅をストップします。そして何らかの入力イベントがあると、また0からカウン
トを再開します。変数‘blink-cursor-blinks’をカスタマイズして、これを制御
できます。変数の値には、何の入力もないとき点滅をストップする点滅回数を指
定します。変数に0または負の値をセットすると、カーソルはずっと点滅したま
まになります。カーソルの点滅を無効にするには、変数‘blink-cursor-mode’を
‘nil’に変更するか(*note Easy Customization::を参照してください)、initフ
ァイルに以下の行を追加します:

       (blink-cursor-mode 0)

リスト変数‘blink-cursor-alist’をカスタマイズして、カーソルが"点滅をスト
ップしたとき"、どのように見えるかを変更できます。リストの各要素は、
‘(ON-TYPE . OFF-TYPE)’という形式を指定します。ON-TYPEには、点滅している
ときのカーソルを指定します(ON-TYPEには、上で説明したカーソルタイプを指定
します)。そしてOFF-TYPEには、点滅していないときのカーソルを指定します。

   タブ文字のように“特別に幅が広い”文字もあります。そのような文字上にカ
ーソルがあるとき、通常はデフォルトの文字幅で描画されます。カーソルを文字
幅に伸ばすには、変数‘x-stretch-cursor’を非‘nil’値に変更してください。

   選択されていないウィンドウのカーソルは、通常点滅していない中抜きのボ
ックスで表示されます(カーソルにバーを使っている場合、より細いバーで表示
されます)。選択されていないウィンドウでカーソルを非表示にするには、変数
‘cursor-in-non-selected-windows’を‘nil’に変更してください。

   カーソルをよりはっきりと表示させるために、HL Lineモードを使用できます
。このモードでは、ポイントを含む行がハイライトされます。現在のバッファー
で有効または無効にするには、‘M-x hl-line-mode’を使います。このモードをグ
ローバルに有効または無効にするには、‘M-x global-hl-line-mode’を使用して
ください。


File: emacs-ja.info,  Node: Line Truncation,  Next: Visual Line Mode,  Prev: Cursor Display,  Up: Display

14.21 行の切り詰め
==================

Emacsは行を継続(*note Continuation Lines::を参照してください)するかわり
に、長い行を“切り詰めて”表示できます。これは、スクリーンやウィンドウの幅
より長い行は、全体が表示されないことを意味します。グラフィカルなディスプ
レーでは、行が切り詰められている場合、フリンジに小さな直矢印が表示されま
す。テキスト端末では、左端または右端の列に‘$’が表示されます。

   水平スクロールは、自動的に行の切り詰めを引き起こします(*note
Horizontal Scrolling::を参照してください)。特定のバッファーにたいして行
の切り詰めを明示的に有効にするには、コマンド‘M-x toggle-truncate-lines’を
使います。これは変数‘truncate-lines’をローカルに変更することで機能します
。値が非‘nil’のときは、長い行は切り詰められ、‘nil’のときは複数のスクリー
ン行に分けられます。変数‘truncate-lines’をセットすると、現在のバッファー
にローカルに適用されます。値を変更するまでは、デフォルト値(‘nil’)が使わ
れます。

   ウィンドウを分割して狭くなりすぎたとき、Emacsは自動的に行の切り詰めを
有効にします。これを制御する変数‘truncate-partial-width-windows’について
は、*note Split Window::を参照してください。


File: emacs-ja.info,  Node: Visual Line Mode,  Next: Display Custom,  Prev: Line Truncation,  Up: Display

14.22 Visual Lineモード
=======================

このモードでは、通常の行継続の代わりに、“単語での折り返し”が使われます。
通常の行継続のように、長い論理行は2行以上のスクリーン行に分割されます。
しかしEmacsはウィンドウの右端の近くの、単語の境界で折り返すよう試みます
。これは単語の途中で折り返さないことにより、可読性を高めるためです。

   単語での折り返しは、オプションのマイナーモードである、Visual Lineモー
ドで有効になります。現在のバッファーでVisual Lineモードの有効と無効を切
り替えるには、‘M-x visual-line-mode’とタイプします。メニューバーから
Visual Lineモードを有効にすることもできます(Optionsメニューから、サブメ
ニュー‘Line Wrapping in this Buffer’の、メニューアイテム‘Word Wrap
(Visual Line Mode)’を選択します)。Visual Lineモードが有効なときは、モー
ドラインのモード表示に‘wrap’という文字が表示されます。コマンド‘M-x
global-visual-line-mode’は、全バッファーのVisual Lineモードを切り替えま
す。

   Visual Lineモードでは、いくつかのコマンドは論理行ではなくスクリーン行
に作用します。‘C-a’ (‘beginning-of-visual-line’)はスクリーン行の先頭に移
動し、‘C-e’ (‘end-of-visual-line’)はスクリーン行の最後に移動、‘C-k’
(‘kill-visual-line’)はテキストをスクリーン行の最後までkillします。

   論理行単位で移動するには、コマンド‘M-x next-logical-line’または‘M-x
previous-logical-line’を使います。これらのコマンドはVisual Lineモードが
有効であるかにかかわらず、次または前の論理行に移動します。これらのコマン
ドを頻繁に使う場合は、キーを割り当てると便利でしょう。*note Init
Rebinding::を参照してください。

   デフォルトでは、単語の折り返し表示はフリンジに表示されません。Visual
Lineモードは、長い論理行を含むファイルを編集するときに使われる場合があり
、折り返し行すべてにフリンジの表示をすると見にくくなるためです。これを変
更するには、変数‘visual-line-fringe-indicators’をカスタマイズしてくださ
い。


File: emacs-ja.info,  Node: Display Custom,  Prev: Visual Line Mode,  Up: Display

14.23 ディスプレーのカスタマイズ
================================

このセクションでは、Emacsスクリーンの外観を制御するさまざまな変数を説明
します。初心者はスキップして構いません。

   変数‘visible-bell’が非‘nil’の場合、Emacsは通常ベルサウンドを鳴らす場
面で、スクリーン全体を点滅するよう試みます。端末がスクリーンを点滅させる
方法を持たないとき、この変数は効果がありません。

   変数‘echo-keystrokes’は、複数文字キーのエコー表示を制御します。値には
エコーが開始されるまでの秒数を指定します。0の場合、エコーされません。何
かエコーされるべきものがあるときは、この変数の値が効果をもちます。*note
Echo Area::を参照してください。

   グラフィカルなディスプレーでは、Emacsはビジーのときにマウスポインター
を砂時計で表示します。この機能を無効にするには、変数
‘display-hourglass’に‘nil’をセットします。変数‘hourglass-delay’は砂時計
が表示されるまでの“busy time”を、秒数で指定します。デフォルトは1です。

   マウスポインターがEmacsのフレーム内にある場合、文字をタイプしてテキス
トを挿入するまでの間、テキストを隠さないよう、Emacsはマウスポインターを
非表示にします(正確に言うとマウスポインターの非表示は、“自己挿入的な
(self-inserting)”文字をタイプしたときです。*note Inserting Text::を参照
してください)。マウスポインターを動かすと、再び表示されます。この機能を
無効にするには、変数‘make-pointer-invisible’に‘nil’をセットしてください
。

   グラフィカルなディスプレーでは、変数‘underline-minimum-offset’は、ア
ンダーラインされたテキストの、アンダーラインから文字の基底線までの最小距
離を、ピクセルで決定します。デフォルトでは値は1です。この変数を増加させ
ると、特定のフォントにおいて、アンダーラインされたテキストの可読性が向上
します(しかしEmacsは、カレント行にはアンダーラインを描画しません)。変数
‘x-underline-at-descent-line’は、テキストにアンダーラインを引く方法を決
定します。デフォルトは‘nil’で、これはフォントの基底線と同じレベルに描画
されることを意味します。非‘nil’に変更すると、Emacsはフォントが同じ大きさ
になるよう、アンダーラインを少し下に描画します。

   変数‘overline-margin’は、テキストの上のオーバーラインの垂直位置を、オ
ーバーライン自身の高さも含めて、ピクセルで指定します。デフォルトは2です
。

   テキスト端末には、bold(太字)かつ反転されたテキストが読みにくいものが
あります。関数‘tty-suppress-bold-inverse-default-colors’に、引数非
‘nil’を与えて呼び出すと、このような場合のbold-faceの効果を抑制します。


File: emacs-ja.info,  Node: Search,  Next: Fixit,  Prev: Display,  Up: Top

15 検索と置換
*************

他のエディターと同様、Emacsには文字列を検索(search)するコマンドがありま
す。Emacsには、文字列を違う文字列で置き換える(replace)コマンドもあります
。また、同じことを行いますが、固定文字列ではなくパターンを検索するコマン
ドもあります。

   tagsテーブルの制御下にある複数ファイルにたいして検索したり(*note Tags
Search::を参照してください)、Diredの‘A’コマンドを通じて検索したり(*note
Operating on Files::を参照してください)、‘grep’コマンドを使った検索
(*note Grep Searching::を参照してください)も可能です。

* Menu:

* Incremental Search::       文字列をタイプすることにより始まる検索。
* Nonincremental Search::    文字列全体を指定してから検索する。
* Word Search::              単語の並びを検索する。
* Symbol Search::            ソースコードのシンボルを検索する。
* Regexp Search::            正規表現にマッチする検索。
* Regexps::                  正規表現の構文について。
* Regexp Backslash::         ‘\’で開始される正規表現の構築。
* Regexp Example::           複雑な正規表現の解説。
* Search Case::              検索で大文字小文字を無視または区別するには。
* Replace::                  一部またはすべてのマッチを検索または置換する。
* Other Repeating Search::   いくつかの正規表現にマッチするすべてを処理する。


File: emacs-ja.info,  Node: Incremental Search,  Next: Nonincremental Search,  Up: Search

15.1 インクリメンタル検索
=========================

Emacsにおける重要な検索コマンドは、“インクリメンタル検索(isearch:
incremental search)”です。これは検索する文字列の最初の文字をタイプすると
、すぐに検索が開始されます。検索文字列をタイプしていくにつれて、Emacsは
その文字列(それまでに入力した文字列)がどこにあるかを表示します。望む場所
を特定するのに充分な文字列をタイプしたところで、検索をストップできます。
次に何をするかによって、明示的な<RET>により検索を終えたり、続けることが
できます。

‘C-s’
     前方にインクリメンタル検索します(‘isearch-forward’)。
‘C-r’
     後方にインクリメンタル検索します(‘isearch-backward’)。

* Menu:

* Basic Isearch::            基本的なインクリメンタル検索コマンド。
* Repeat Isearch::           同じ文字列を再度検索する。
* Error in Isearch::         文字列が見つからなかったとき。
* Special Isearch::          インクリメンタル検索での特別な入力。
* Isearch Yank::             検索文字列にテキストを取り込んだり、検索文字列を編集するコマンド。
* Not Exiting Isearch::      プレフィクス引数とスクロールコマンド。
* Isearch Minibuffer::       ミニバッファーヒストリーのインクリメンタル検索。


File: emacs-ja.info,  Node: Basic Isearch,  Next: Repeat Isearch,  Up: Incremental Search

15.1.1 インクリメンタル検索の基本
---------------------------------

‘C-s’
     インクリメンタル検索を開始します(‘isearch-forward’)。
‘C-r’
     逆向きのインクリメンタル検索を開始します(‘isearch-backward’)。

   ‘C-s’ (‘isearch-forward’)は、前方へのインクリメンタル検索を開始します
。これはキーボードから文字を読み取り、タイプした文字が最初に出現するバッ
ファーの位置に、ポイントを移動します。

   たとえば‘C-s’とタイプした後に‘F’をタイプすると、検索を開始したバッフ
ァーのポイント位置より前方にある、最初の‘F’にカーソルを移動します。つぎ
に‘O’をタイプすると、前方にある最初の‘FO’にカーソルが移動します。この場
合、‘FO’の‘F’は、前に見つかった‘F’と同じ位置である必要はありません。もう
一度‘O’をタイプすると、カーソルは最初の‘FOO’に移動します。

   各ステップでEmacsは“カレントマッチ(current match: 現在のマッチ)”(検索
文字列にマッチしたバッファーのテキスト)を、‘isearch’フェイスでハイライト
します(*note Faces::を参照してください)。その時点での検索文字列はエコー
エリアにも表示されます。

   検索文字列を間違ってタイプしたときは、<DEL>をタイプします。<DEL>をタ
イプするごとに、検索文字列の最後の文字が取り消されます。

   検索により到達した位置に満足したら、<RET>をタイプします。これは検索を
ストップして、検索により移動した位置にカーソルを残します。検索とは関係な
いコマンドも、検索をストップして、そのコマンドが実行されます。つまり
‘C-a’は検索を中止して、行の先頭に移動します。<RET>で検索を終える必要があ
るのは、次のコマンドが印字文字をタイプするコマンドのときだけです。
<DEL>、<RET>および他のいくつかの文字(‘C-q’、‘C-w’、‘C-r’、‘C-s’、‘C-y’、
‘M-y’、‘M-r’、‘M-c’、‘M-e’、および以下で説明する文字)は、検索で特別な意
味を持っています。

   特別な例外として、検索文字列が空のときに<RET>を入力すると、非インクリ
メンタル検索を開始します(*note Nonincremental Search::を参照してください
)。

   インクリメンタル検索を終了するとき、ポイントの元の位置をマークをアク
ティブにせず(ただしマークがすでにアクティブではなかったときだけ)に、マー
クリングに追加します。これにより、‘C-u C-<SPC>’を使って、検索を開始する
前の位置に戻ることができます。*note Mark Ring::を参照してください。これ
はマークがすでにアクティブでないときだけ行なわれます。

   後方に検索するには、‘C-s’で検索を開始するかわりに、‘C-r’
(‘isearch-backward’)を使います。前方検索が検索を開始した位置より前方にあ
る最初のマッチを探すように、後方検索は検索を開始した位置より後方にある最
後のマッチを探します。


File: emacs-ja.info,  Node: Repeat Isearch,  Next: Error in Isearch,  Prev: Basic Isearch,  Up: Incremental Search

15.1.2 インクリメンタル検索の繰り返し
-------------------------------------

前方に‘FOO’を検索してマッチしたが、それは探しているマッチではなく、探し
ているのはバッファーのもっと前方に出現する‘FOO’だとしましょう。ここでも
う1度‘C-s’をタイプすることにより、検索文字列が次に出現する場所に移動しま
す。これは何回でも繰り返すことができます。もしタイプしすぎたときは、
‘C-s’を<DEL>で取り消すことができます。同様に後方へのインクリメンタル検索
では、‘C-r’により後方検索が繰り返されます。

   インクリメンタル検索中に手を止めて眺めてみると、検索文字列にたいする
カレントマッチ以外に、スクリーンに表示されている他のマッチもハイライトさ
れていることがわかります。これは検索するために、何回‘C-s’または‘C-r’を繰
り返せばよいのか予測しやすくするためです。その他のマッチは、カスタマイズ
可能なフェイス‘lazy-highlight’ (*note Faces::を参照してください)を使って
、現在のマッチとは異なってハイライトされます。この機能を無効にするには、
‘isearch-lazy-highlight’に‘nil’をセットしてください。

   検索を終了した後、同じ文字列を再度検索するには、‘C-s C-s’とタイプしま
す。最初の‘C-s’はインクリメンタル検索を呼び出し、2回目の‘C-s’は“再検索
”を意味します。同様に、‘C-r C-r’は最後に検索した文字列を後方に検索します
。最後に検索された文字列の決定では、文字列が‘C-s’で検索されたのか、
‘C-r’で検索されたのかは問題ではありません。

   前方に検索していて、検索している対象が検索開始点より後方にあるのに気
付いたときは、検索文字列を変更すること無く、‘C-r’で後方検索に切り替える
ことができます。同様に後方検索で‘C-s’をタイプすると、前方検索に切り替わ
ります。

   検索が失敗したとき、バッファーの先頭から検索を再開するには、もう一度
‘C-s’をタイプします。逆向きの繰り返し検索が失敗したときは、‘C-r’でバッフ
ァーの最後から検索を再開します。これは“wrapping around(巻き直し)”と呼ば
れ、これが発生すると、‘Wrapped’という単語が検索プロンプトに表示されます
。検索を続けて元の検索開始ポイントを通過すると、‘Overwrapped’に変化しま
す。これはすでに見たマッチを再訪していることを意味します。

   以前に検索した文字列を再利用するには、“サーチリング(search ring)”を使
います。コマンド‘M-p’または‘M-n’で、リングを移動して再使用したい文字列を
取り出します。これらのコマンドは、選択されたリング要素の文字列をミニバッ
ファーに残すので、それを編集することができます。

   ミニバッファーの現在の検索文字列を、サーチリングのアイテムで置き換え
ずに編集するときは、‘M-e’をタイプします。<RET>、‘C-s’、‘C-r’をタイプすれ
ば編集を終了して、それを検索できます。


File: emacs-ja.info,  Node: Error in Isearch,  Next: Special Isearch,  Prev: Repeat Isearch,  Up: Incremental Search

15.1.3 インクリメンタル検索でのエラー
-------------------------------------

文字列が見つからなかった場合、エコーエリアに‘Failing I-Search’と表示され
て、文字列とできるかぎりマッチした位置に、カーソルが移動します。つまり
‘FOOT’を検索して‘FOOT’がない場合、カーソルは‘FOOL’という文字列の‘FOO’の
後ろに移動します。エコーエリアではマッチに失敗した検索文字列の一部が、フ
ェイス‘isearch-fail’を使ってハイライトされます。

   その時に行うことができる、いくつかの選択肢があります。もし文字列が間
違っている場合は、文字列を訂正するため<DEL>でテキストを削除できます。も
し見つかった位置が望む位置なら、<RET>をタイプしてその位置に留まることが
できます。または‘C-g’をタイプして、検索文字列から検索できなかった文字
(‘FOOT’の中の‘T’)を取り除き、検索された部分の文字列(‘FOOT’の中の‘FOO’)を
残します。その位置でもう1回‘C-g’をタイプすると、検索全体を取り消し、ポイ
ントは検索を開始した位置に戻ります。

   終了コマンドの‘C-g’は、検索において特別な処理を行います。このコマンド
の動作は、検索の状況に依存します。もし指定した文字列の検索が成功して、さ
らに検索文字の入力を待っているとき、‘C-g’は検索全体を取り消して、カーソ
ルを検索を開始したときの位置に移動します。検索文字列に検索に失敗した文字
が含まれているときに、‘C-g’がタイプされたときは、検索文字列から検索に失
敗した文字が取り除かれます。後に残るのは検索に成功した文字列で、さらに検
索文字の入力を待っているので、先のケースと同様、2回目の‘C-g’で検索全体が
取り消されます。


File: emacs-ja.info,  Node: Special Isearch,  Next: Isearch Yank,  Prev: Error in Isearch,  Up: Incremental Search

15.1.4 インクリメンタル検索の特別な入力
---------------------------------------

インクリメンタル検索のときタイプする文字列の中には、特別な効果をもつもの
があります。

   デフォルトでは、インクリメンタル検索は“緩いスペースマッチング(lax
space matching)”を行います。これはスペースおよび一連のスペースは、テキス
ト中の1つまたはそれ以上のスペースにマッチします。したがって‘foo bar’は
‘foo bar’、‘foo  bar’、‘foo   bar’、...にマッチします(‘foobar’にはマッチ
しません)。正確にいうと、Emacsは検索文字列中の一連のスペースを、変数
‘search-whitespace-regexp’で指定された正規表現にマッチさせます。たとえば
スペースを一連の改行とスペースにマッチさせるには、変数に
‘"[[:space:]\n]+"’をセットします。

   緩いスペースマッチングを切り替えるには、‘M-s <SPC>’
(‘isearch-toggle-lax-whitespace’)をタイプします。この機能全体を無効にす
るには、‘search-whitespace-regexp’を‘nil’に変更します。これにより検索文
字列中のスペースは、正確に1つのスペースにマッチします。

   検索文字列に小文字しか含まれていないとき、検索は大文字小文字を区別し
ません。検索文字列に大文字が含まれているとき、検索は大文字小文字を区別し
ます。検索文字列から大文字を削除すると、この効果はなくなります。*note
Search Case::を参照してください。

   非表示のテキストを検索するかしないかは、‘M-s i’
(‘isearch-toggle-invisible’)とタイプして切り替えることができます。*note
Outline Search::を参照してください。

   改行文字を検索するには‘C-j’とタイプします。

   非ASCII文字を検索するには、以下の方法の1つを使います:

   • ‘C-q’に続けて、非グラフィック文字か8進数字をタイプします。これは
     ‘C-q’を使ってバッファーに文字を挿入するのと同様に、検索文字列にタイ
     プする文字を追加します(*note Inserting Text::を参照してください)。
     たとえばインクリメンタル検索で‘C-q C-s’をタイプすると、検索文字列に
     文字‘control-S’が追加されます。

   • ‘C-x 8 <RET>’に続けて、Unicode名かコードポイントをタイプします。こ
     れは通常の‘insert-char’コマンドと同様に、検索文字列に指定した文字を
     追加します(*note Inserting Text::を参照してください)。

   • 入力メソッド(IM: input method)を使います(*note Input Methods::を参
     照してください)。検索を開始したとき、カレントバッファーで入力メソッ
     ドが有効の場合、検索文字列にもそれを使うことができます。検索文字列
     をタイプするとき、‘C-\’ (‘isearch-toggle-input-method’)で、入力メソ
     ッドを切り替えることができます。非デフォルトの入力メソッドに切り替
     えるには、‘C-^’ (‘isearch-toggle-specified-input-method’)を使います
     。これは入力メソッドの名前を尋ねます。インクリメンタル検索で入力メ
     ソッドがアクティブのとき、検索プロンプトには以下のようなニーモニッ
     クが含まれます。

          I-search [IM]:

     IMはアクティブな入力メソッドのニーモニックです。インクリメンタル検
     索で入力メソッドを有効にすると、カレントバッファーでも入力メソッド
     が有効のまま残ります。

   インクリメンタル検索で‘M-%’をタイプすると、‘query-replace’または
‘query-replace-regexp’が呼び出され(検索モードに依存します)、現在の検索文
字が置換対象になります。負のプレフィクス引数は、後方への置換を意味します
。*note Query Replace::を参照してください。

   インクリメンタル検索で‘M-<TAB>’をタイプすると、‘isearch-complete’が呼
び出され、サーチリングを補完リストとして使って、検索文字列の補完を試みま
す。*note Completion::を参照してください。多くのオペレーティングシステム
では、キーシーケンス‘M-<TAB>’はウィンドウマネージャーに捕えられます。そ
の場合、これを使うには‘isearch-complete’を、他のキーシーケンスに再バイン
ドする必要があります(*note Rebinding::を参照してください)。

   インクリメンタル検索がアクティブのとき、‘C-h C-h’とタイプすると、特別
なキーバインドのリストを含む、対話的なヘルプにアクセスできます。これらの
キーバインドは、キーマップ‘isearch-mode-map’の一部です(*note Keymaps::を
参照してください)。


File: emacs-ja.info,  Node: Isearch Yank,  Next: Not Exiting Isearch,  Prev: Special Isearch,  Up: Incremental Search

15.1.5 インクリメンタル検索でのyank
-----------------------------------

インクリメンタル検索での‘C-y’ (‘isearch-yank-kill’)は、カレントkillを検
索文字列に追加します。‘C-y’の後に‘M-y’ (‘isearch-yank-pop’)が呼び出され
ると、追加するテキストを、もっと前にkillされたものに置き換えます。これは
通常の‘M-y’ (‘yank-pop’)コマンドと似ています(*note Yanking::を参照してく
ださい)。‘Mouse-2’はカレントのX選択を追加します(*note Primary
Selection::を参照してください)。

   ‘C-w’ (‘isearch-yank-word-or-char’)は、検索された文字列のポイントの次
の文字または単語を、検索文字列に追加します。これはポイント位置にあるテキ
ストを検索する、簡単な方法です(コピーする対象を文字または単語のどちらに
するかの決定は、発見的に行われます)。

   同様に‘M-s C-e’ (‘isearch-yank-line’)は、検索文字列にカレント行の残り
の部分を追加します。ポイントが既に行末にある場合、次の行が追加されます。
プレフィクス引数Nを指定すると、次のN行を追加します。

   もし大文字小文字を区別せずに検索している場合、‘C-w’と‘M-s C-e’はテキ
ストを小文字に変換してからコピーするので、それ以降も検索は大文字小文字を
区別せずに行われます。

   ‘C-M-w’ (‘isearch-del-char’)は検索文字列の最後の文字を削除し、‘C-M-y’
(‘isearch-yank-char’)は検索されたポイントの後ろの文字を追加します。ポイ
ントの後ろの文字を追加する他の方法は、‘M-e’(*note Repeat Isearch::を参照
してください)でミニバッファーに移動してから、検索文字列の最後で‘C-f’をタ
イプします。


File: emacs-ja.info,  Node: Not Exiting Isearch,  Next: Isearch Minibuffer,  Prev: Isearch Yank,  Up: Incremental Search

15.1.6 インクリメンタル検索を終了させない
-----------------------------------------

このサブセクションでは、2つのカテゴリーに属するコマンドを説明します。こ
れらのコマンドはインクリメンタル検索の一部ではありませんが、現在のインク
リメンタル検索を終了させずにタイプできます。

プレフィクス引数
     インクリメンタル検索でプレフィクス引数を入力すると、デフォルトでは
     その引数は次の検索アクションに適用されるか、検索を終了させるコマン
     ドに渡されます。

     以前のバージョンのEmacsでは、プレフィクス引数の入力は常に検索を終了
     させていました。この振る舞いに戻すには、変数
     ‘isearch-allow-prefix’に‘nil’をセットしてください。

     ‘isearch-allow-scroll’が非‘nil’のとき(以下を参照)、プレフィクス引数
     は上で説明したようなデフォルト動作をします。

スクロールコマンド
     通常スクロールコマンドは、インクリメンタル検索を終了させます。変数
     ‘isearch-allow-scroll’を非‘nil’値に変更すると、スクロールバーや
     ‘C-v’、‘M-v’、‘C-l’のようなスクロールコマンド(*note Scrolling::を参
     照してください)が利用可能になります。これは、これらのコマンドをバウ
     ンドされたキーシーケンスで呼び出したときだけ適用されます。つまり
     ‘M-x’は依然として検索を終了させます。これらのコマンドには、通常の方
     法でプレフィクス引数を与えることができます。この機能ではカレントマ
     ッチが表示されない位置にスクロールすることはできません。

     ‘isearch-allow-scroll’の機能は、正確にはスクロールではないが、テキ
     ストが表示されるスクリーン位置に影響する、‘C-x 2’
     (‘split-window-below’)や‘C-x ^’ (‘enlarge-window’)のような、コマン
     ドにも効果を及ぼします。これはコマンド名の‘isearch-scroll’プロパテ
     ィが非‘nil’のコマンドに適用されます。そのため、どのコマンドが影響を
     受けるかは、それらのプロパティを変更して制御できます。

     たとえば将来のEmacsセッションも含めて、インクリメンタル検索中に‘C-h
     l’を使えれば便利だと思ったら、まず‘C-h c’で何のコマンドが実行される
     か調べて(*note Key Help::を参照してください)、それが
     ‘view-lossage’だとわかります。その後はinitファイルに以下を追加しま
     す(*note Init File::を参照してください)。

          (put 'view-lossage 'isearch-scroll t)

     この機能はポイント、バッファー内容、マッチデータ、カレントバッファ
     ーや選択されているウィンドウ・フレームを変更しない任意のコマンドに
     適用できます。そして、そのコマンド自体がインクリメンタル検索を行っ
     てはなりません。


File: emacs-ja.info,  Node: Isearch Minibuffer,  Prev: Not Exiting Isearch,  Up: Incremental Search

15.1.7 ミニバッファーの検索
---------------------------

ミニバッファーがアクティブのときインクリメンタル検索を開始すると、
Emacsはミニバッファーの内容を検索します。通常のバッファーにたいする検索
とは異なり、エコーエリアはミニバッファーの表示に使われているので、検索文
字列はエコーエリアには表示されません。

   ミニバッファーでのインクリメンタル検索が失敗すると、ミニバッファーヒ
ストリーを検索します。*note Minibuffer History::を参照してください。ミニ
バッファーとミニバッファーのヒストリーは、一番古いヒストリー要素が最初で
、カレントのミニバッファーが最後にある、一連の“ページ”として視覚化するこ
とができます。前方検索の‘C-s’は前方、つまり新しいページを検索し、後方検
索の‘C-r’は後方、つまり古いページを検索します。普通のバッファーの検索と
同様、検索が失敗すると、最後から最初のページ、またはその逆に巻き直して検
索します。

   カレントマッチがヒストリーの要素にあった場合、ヒストリーの要素はミニ
バッファーに取り出されます。インクリメンタル検索を正常に終了(たとえば
<RET>をタイプ)すれば、それはミニバッファーに残ります。検索を取り消すのは
‘C-g’で、これによりミニバッファーの内容は検索を開始したときのものに復元
されます。


File: emacs-ja.info,  Node: Nonincremental Search,  Next: Word Search,  Prev: Incremental Search,  Up: Search

15.2 非インクリメンタル検索
===========================

Emacsには、従来式の非インクリメンタル検索もあります。これは検索を開始す
る前に、検索文字列全体を入力する必要があります。

‘C-s <RET> STRING <RET>’
     STRINGを検索します。
‘C-r <RET> STRING <RET>’
     後方にSTRINGを検索します。

   非インクリメンタル検索を開始するには、最初に‘C-s <RET>’をタイプします
。これにより、検索文字列を読みとるために、ミニバッファーに移動します。検
索文字列の入力を終了して検索を開始するには、<RET>をタイプします。文字列
が見つからなかったとき、検索コマンドはエラーをシグナルします。

   ‘C-s <RET>’とタイプすると、‘C-s’は通常どおりインクリメンタル検索を呼
び出します。しかし、このコマンドは指定した文字列が空のとき、非インクリメ
ンタル検索を行うコマンド‘search-forward’を呼び出すよう、プログラムされて
います(そのような用途以外に空の引数は無意味です)。‘C-r <RET>’も同様に、
コマンド‘search-backward’を呼び出します。


File: emacs-ja.info,  Node: Word Search,  Next: Symbol Search,  Prev: Nonincremental Search,  Up: Search

15.3 単語検索
=============

“単語検索(word search)”は、単語の並びを、その間にある区切り文字の種類と
は無関係に検索します。たとえば検索文字列に、1つのスペースで区切られた2つ
の単語を入力すると、2つの単語を区切るのが、1つまたはそれ以上のスペース、
改行文字、およびそれ以外の区切り文字の場合にもマッチします。これはテキス
ト文書を検索するとき特に有用です。なぜなら検索する単語が改行で区切られて
いるのか、スペースで区切られているのか考慮しなくてもよいからです。

‘M-s w’
     インクリメンタル検索がアクティブのとき、単語検索モードに切り替えま
     す(‘isearch-toggle-word’)。非アクティブのときは、前方へのインクリメ
     ンタルな単語検索を開始します(‘isearch-forward-word’)。
‘M-s w <RET> WORDS <RET>’
     非インクリメンタルな単語検索を使って、WORDSを前方検索します。
‘M-s w C-r <RET> WORDS <RET>’
     非インクリメンタルな単語検索を使って、WORDSを後方検索します。

   前方へのインクリメンタルな単語検索を開始するには、‘M-s w’とタイプしま
す。インクリメンタル検索が非アクティブの場合、これはコマンド
‘isearch-forward-word’を実行します。インクリメンタル検索がすでにアクティ
ブの場合(前方か後方かにかかわらず)、‘M-s w’は検索の方向と現在の検索文字
列は変更せずに、単語検索に切り替えます。単語検索をオフに切り替えるには、
再度‘M-s w’をタイプしてください。

   非インクリメンタルな単語検索を開始する場合、前方検索は‘M-s w <RET>’、
後方検索は‘M-s w C-r <RET>’をタイプします。これらはコマンド
‘word-search-forward’、または‘word-search-backward’を実行します。

   インクリメンタルな単語検索と、非インクリメンタルな単語検索では、マッ
チを見つける方法に若干の違いがあります。非インクリメンタルな単語検索では
、検索文字列の各単語は、単語全体に厳密に一致しなければなりません。インク
リメンタルな単語検索では、マッチの規則は緩くなります。検索文字列をタイプ
するとき、最初と最後の単語は、単語全体にマッチする必要はありません。これ
はタイプする度にマッチを処理するためです。これは(カーソルがある)カレント
マッチ以外のマッチ(lazy matches)には適用されません。それらは単語全体がマ
ッチしなければハイライトされません。


File: emacs-ja.info,  Node: Symbol Search,  Next: Regexp Search,  Prev: Word Search,  Up: Search

15.4 シンボル検索
=================

“シンボル検索(symbol search)”は、通常の検索と似ていますが、検索の境界が
シンボルの境界にマッチしていなければなりません。“シンボル”の意味は、メジ
ャーモードのコンテキストに依存しており、Emacs LispモードでのLispシンボル
のように、通常はソースコードのトークンを参照します。たとえばLispシンボル
‘forward-word’をインクリメンタルなシンボル検索すると、これは
‘isearch-forward-word’にはマッチしません。そのため、この機能は主にソース
コードの検索に有用です。

‘M-s _’
     インクリメンタル検索がアクティブのとき、シンボル検索モードに切り替
     えます(‘isearch-toggle-symbol’)。非アクティブのときは、前方へのイン
     クリメンタルなシンボル検索を開始します(‘isearch-forward-symbol’)。
‘M-s .’
     ポイントの近くにあるシンボルを、検索文字列の初期値に追加して、前方
     へのインクリメンタルなシンボル検索を開始します。
‘M-s _ <RET> SYMBOL <RET>’
     SYMBOLにたいして、前方への非インクリメンタルな検索をします。
‘M-s _ C-r <RET> SYMBOL <RET>’
     SYMBOLにたいして、後方への非インクリメンタルな検索をします。

   前方へのインクリメンタルなシンボル検索を開始するには、‘M-s _’(ポイン
トの近くにシンボルがあるときは‘M-s .’)をタイプします。インクリメンタル検
索が非アクティブのときは、コマンド‘isearch-forward-symbol’が実行されます
。すでにインクリメンタル検索がアクティブのとき、‘M-s _’は検索方向と現在
の検索文字列を維持した状態で、シンボル検索に切り替えます(もう一度‘M-s
_’をタイプすると、シンボル検索を無効にできます)。インクリメンタルなシン
ボル検索では、検索文字列の先頭がシンボルの先頭にマッチする必要があります
。

   非インクリメンタルなシンボル検索は、前方への検索は‘M-s _ <RET>’、後方
への検索は‘M-s _ C-r <RET>’をタイプします。非インクリメンタル検索では、
文字列の先頭と最後が、シンボルの先頭と最後にマッチする必要があります。


File: emacs-ja.info,  Node: Regexp Search,  Next: Regexps,  Prev: Symbol Search,  Up: Search

15.5 正規表現検索
=================

“正規表現”(regular expression: “regexp”と略します)とは、文字列にマッチさ
せるための代替の文字列クラスを示すパターンです。Emacsはregexpにマッチす
る検索を、インクリメンタル、非インクリメンタルの両方で提供します。正規表
現の構文は、次のセクションで説明します。

‘C-M-s’
     インクリメンタルなregexp検索を開始します
     (‘isearch-forward-regexp’)。
‘C-M-r’
     逆方向のインクリメンタルなregexp検索を開始します
     (‘isearch-backward-regexp’)。

   regexpにたいするインクリメンタル検索は、‘C-M-s’
(‘isearch-forward-regexp’をタイプするか、プレフィクス引数(引数の値は何で
もよい)を指定して、‘C-s’を呼び出します。前方へのインクリメンタル検索中は
、‘M-r’をタイプします。このコマンドは‘C-s’と同様に、検索文字列をインクリ
メンタルに読みとりますが、検索文字列に正確に一致するバッファーのテキスト
を検索するのではなく、検索文字列をregexpとして扱います。検索文字列にテキ
ストを追加する度に、regexpは長くなり、新しいregexpを検索します。後方への
regexp検索には、‘C-M-r’(‘isearch-backward-regexp’)またはプレフィクス引数
を指定した‘C-r’を使います。後方へのインクリメンタル検索中は‘M-r’を使いま
す。

   通常のインクリメンタル検索の特別なキーシーケンスは、インクリメンタル
なregexp検索でも同じようなことを行います。たとえば検索開始直後に‘C-s’を
タイプすると、最後に行ったインクリメンタル検索で使ったregexpで、前方検索
を行います。インクリメンタルなregexpと非regexp検索は、独立したデフォルト
を持ちます。これらは別のサーチリングも持っており、これには‘M-p’と‘M-n’で
アクセスできます。

   通常のインクリメンタル検索とは異なり、インクリメンタルregexp検索は、
デフォルトでは緩いスペースマッチング(lax space matching)を使いません。こ
の機能を切り替えるには、‘M-s <SPC>’ (‘isearch-toggle-lax-whitespace’)を
使います。そうするとインクリメンタルregexp検索での<SPC>は、1つ以上の空白
文字の並びにマッチするようになります。変数‘search-whitespace-regexp’は、
緩いスペースマッチングにたいするregexpを指定します。*note Special
Isearch::を参照してください。

   インクリメンタルregexp検索では、検索文字列の追加によりカーソルが前に
戻され、最初から検索しなおされることがありえます。たとえば検索文字列
‘foo’に‘\|bar’を追加すると、カーソルは‘foo’から、それより前にある最初の
‘bar’に戻ります。*note Regexps::を参照してください。

   前方および後方へのregexp検索は、対照的ではありません。なぜならEmacsで
のregexpに対するマッチは常に前方へ処理され、regexpの先頭から開始されるか
らです。したがって前方へのregexp検索は前方にスキャンし、可能性のある開始
位置から前方へとマッチを試みます。後方へのregexp検索は後方へスキャンし、
可能性のある開始位置から前方へとマッチを試みます。これらの検索手法はミラ
ーイメージではありません。

   regexpにたいする非インクリメンタルな検索は、コマンド
‘re-search-forward’および‘re-search-backward’で行われます。これらのコマ
ンドは‘M-x’から呼び出すか、インクリメンタルregexp検索からの‘C-M-s
<RET>’および‘C-M-r <RET>’で呼び出します。

   プレフィクス引数を指定したインクリメンタルregexp検索は、
‘isearch-forward’や‘isearch-backward’のような、通常の文字列を検索します
。*note Incremental Search::を参照してください。


File: emacs-ja.info,  Node: Regexps,  Next: Regexp Backslash,  Prev: Regexp Search,  Up: Search

15.6 正規表現の構文
===================

このマニュアルでは、ユーザーが通常使う正規表現の機能を説明します。主に
Lispプログラムで使用される追加の機能については、*note (elisp)Regular
Expressions::を参照してください。

   正規表現は、いくつかの特殊文字と、それ以外の“普通”の文字からなる構文
を持ちます。通常の文字はそれと同じ文字にマッチし、それ以外の文字にはマッ
チしません。特殊文字は、‘$^.*+?[\’です。文字‘]’は、文字候補を終了させる
場合は特殊文字です(以下参照)。文字‘-’は、文字候補の中では特殊文字です。
正規表現の中に現れるその他の文字は、前に‘\’がついてない限り普通の文字で
す(Lispプログラム内で正規表現を使う場合、‘\’は2つ記述しなければなりませ
ん。このセクションの最後にある例を参照してください)。

   たとえば‘f’は特殊文字ではなく普通の文字なので、正規表現中の‘f’は文字
列‘f’にマッチし、他の文字列にはマッチしません(文字列‘ff’にはマッチ_しま
せん_)。同様に正規表現中の‘o’は、‘o’だけにマッチします(大文字小文字を区
別しない場合、これらのregexpは‘F’や‘O’にもマッチしますが、これを例外とし
てではなく、“同じ文字列”を一般化したものと考えます)。

   2つの正規表現AとBを結合できます。結合した結果は、Aが先頭の適当な部分
に一致して、Bが残りの部分に一致する正規表現となります。たとえば‘f’と
‘o’という正規表現を結合すると、正規表現‘fo’となり、これは文字列‘fo’だけ
にマッチします。ここまでは普通です。普通でないことを行うには、特殊文字を
使う必要があります。以下にリストを示します。

‘.’ (ピリオド)
     これは改行文字以外の任意の1文字にマッチする特殊文字です。たとえば正
     規表現‘a.b’は、最初が‘a’で最後が‘b’の3文字の文字列にマッチします。

‘*’
     単独では使用されません。これは接尾演算子で、前の正規表現の任意の回
     数、可能な限り多くの回数を含めた繰り返しを意味します。したがって
     ‘o*’は任意の個数の‘o’にマッチし、‘o’がない場合(0個の場合)も含めてマ
     ッチします。

     ‘*’は常に可能な限り_小さな_、前置表現に適用されます。したがって
     ‘fo*’は‘fo’の繰り返しではなく‘o’の繰り返しです。この正規表現は‘f’、
     ‘fo’、‘foo’、...にマッチします。

     マッチングにより構成される‘*’は、見つけられるだけの反復回数へと、直
     ちに処理されます。その後でパターンの残りの部分の処理を続けます。こ
     れが失敗すると、バックトラッキングが発生します。‘*’の反復回数をいく
     つか捨てて、パターンの残りの部分がマッチするように構成を変更します
     。たとえば文字列‘caaar’にたいして‘ca*ar’をマッチさせる場合、まず最
     初に‘a*’を、3つすべての‘a’にマッチさせます。しかしパターンの残りの
     部分は‘ar’ですが、マッチさせるために残っているのは‘r’だけなので、こ
     のマッチは失敗します。かわりに‘a*’を2つの‘a*’だけにマッチさせます。
     この選択により、regexpの残りの部分のマッチが成功します。

‘+’
     これは‘*’と同様に接尾演算子ですが、前置表現に最低1回マッチしなけれ
     ばならない点が異なります。したがって‘ca+r’は‘car’、‘caaaar’にマッチ
     しますが、‘cr’にはマッチしません。一方‘ca*r’は、これら3つすべての文
     字列にマッチします。

‘?’
     これは‘*’と同様に接尾演算子ですが、前置表現が1回出現するか、出現し
     ないかいずれかという点が異なります。したがって‘ca?r’は、‘car’または
     ‘cr’のいずれかになります。

‘*?’, ‘+?’, ‘??’
     これらは上述した演算子の、非“貪欲(greedy)”なタイプの演算子です。通
     常の演算子‘*’、‘+’、‘?’は、regexpがマッチする、できる限り長いマッチ
     を行います。しかしこれらの演算子に‘?’を後置すると、できる限り短いマ
     ッチを行います。

     したがって‘ab*’と‘ab*?’は、両方とも文字列‘a’と文字列‘abbbb’にマッチ
     しますが、文字列‘abbb’にマッチさせたとき、‘ab*’は文字列全体(有効な
     最長マッチ)にマッチしますが、‘ab*?’は‘a’(有効な最短マッチ)だけにマ
     ッチします。

     非貪欲な演算子は、与えられた開始位置から開始される、できるだけ短い
     文字列にマッチします。前方検索では、利用できる一番最初の開始位置は
     、常にカーソルの位置となります。したがって末尾が改行のテキスト
     ‘abbab’にたいして‘a.*?$’を検索すると、文字列全体にマッチします。こ
     れはマッチが最初の‘a’から開始されので、マッチさせることが_できる_の
     です。

‘\{N\}’
     これはN回の繰り返しを指定する接尾演算子です。つまり前置される正規表
     現に、正確にN回連続でマッチしなければなりません。たとえば‘x\{4\}’は
     、文字列‘xxxx’だけにマッチします。

‘\{N,M\}’
     これはN回からM回の繰り返しを指定する接尾演算子です。つまり前置され
     る正規表現が、最低N回、最大M回マッチしなければなりません。Mが省略さ
     れたときは、マッチ回数の上限はありませんが、前置される正規表現は少
     なくともN回マッチしなければなりません。
     ‘\{0,1\}’は、‘?’と同じです。
     ‘\{0,\}’は、‘*’と同じです.
     ‘\{1,\}’は、‘+’と同じです。

‘[ ... ]’
     これは‘[’で始まり‘]’で終わる、“文字集合(character set)”です。

     もっとも簡単なケースでは、2つのカッコの間に指定された文字が、マッチ
     できる文字集合となります。したがって‘[ad]’は1つの‘a’か1つの‘d’にマ
     ッチし、‘[ad]*’は‘a’と‘d’からなる任意の文字列にマッチします(空の文
     字列を含む)。結果として‘c[ad]*r’は、‘cr’、‘car’、‘cdr’、‘caddaar’、
     ...にマッチします。

     文字集合には、開始文字と終了文字の間に‘-’を記述することにより、文字
     の範囲を含めることもできます。したがって‘[a-z]’は、ASCII小文字とな
     ります。文字の範囲と特定の文字の指定を混ぜることもできます。
     ‘[a-z$%.]’は任意のASCII小文字と‘$’、‘%’、‘.’にマッチします。

     いくつかの特別な“文字クラス(character classes)”を、文字集合に含める
     こともできます。文字の候補を含む文字クラスを‘[:’と‘:]’で囲んで指定
     します。たとえば‘[[:alnum:]]’は、任意のアルファベットと数字にマッチ
     します。文字クラスのリストは、*note (elisp)Char Classes::を参照して
     ください。

     文字集合に‘]’を含めるには、それを最初に記述しなければなりません。た
     とえば‘[]a]’は、‘]’または‘a’にマッチします。文字集合に‘-’を含めるに
     は、‘-’を、文字集合の最初または最後に記述するか、文字範囲の外に記述
     します。したがって‘[]-]’は、‘]’と‘-’の両方にマッチします。

     文字集合に‘^’を含めるには、集合の最初以外に記述します(最初に記述し
     た場合、補集合を指定したことになります。以下を参照してください)。

     大文字小文字を区別しない検索で文字の範囲を使う場合、範囲の先頭と最
     後を、大文字だけ、または小文字だけで記述するか、先頭と最後をアルフ
     ァベット以外で記述するべきです。‘A-z’のような大文字小文字を混成した
     範囲指定は不正な定義で、Emacsの将来のバージョンで変更されるかもしれ
     ません。

‘[^ ... ]’
     ‘[^’は“文字の補集合complemented character set”を開始します。つまり
     指定された文字以外がマッチします。したがって‘[^a-z0-9A-Z]’は、
     ASCII文字と数字_以外_にマッチします。

     ‘^’は文字集合で最初以外で使用された場合、特別な意味をもちません。
     ‘^’に続く文字は、先頭にあるものとして扱われます(いいかえると‘-’と
     ‘]’は、ここでは特別な意味をもちません)。

     もしマッチしない文字として改行が記述されていなければ、文字の補集合
     を改行にマッチさせることができます。これは‘grep’のようなプログラム
     における、regexpにたいする処理とは対照的です。

‘^’
     これは空文字列、ただしテキストの行頭だけにマッチする特殊文字です。
     それ以外ではマッチに失敗します。したがって‘^foo’は行の先頭にある
     ‘foo’にマッチします。

     歴史的な互換性により、この意味での‘^’の使用は、正規表現の先頭か、
     ‘\(’または‘\|’の後に記述された場合に限ります。

‘$’
     ‘^’と似ていますが、行末だけにマッチします。したがって‘x+$’は、行末
     にある1つ以上の‘x’にマッチします。

     歴史的な互換性により、この意味での‘$’の使用は、正規表現の最後か、
     ‘\)’または‘\|’の後に記述された場合に限ります。

‘\’
     これには2つの機能があります。まず特殊文字(‘\’を含む)をクォートする
     ことと、追加の特別な構成を導入することです。

     ‘\’は特殊文字をクォートするので、正規表現中の‘\$’は‘$’だけにマッチ
     し、‘\[’は‘[’だけにマッチします。

     ‘\’で始まる特別な構成については、以下のセクションを参照してください
     。

   注意: 歴史的な互換性から、特殊文字はそれが特殊な意味をもたないような
コンテキストで使用された場合は、通常の文字として扱われます。たとえば
‘*foo’は、‘*’が特殊文字として動作するための前置された表現がないので、普
通の文字として扱われます。このような振る舞いに依存することは、よい習慣で
はありません。特殊文字を記述する場合、それがどこに記述されようとクォート
するべきです。

   文字集合の候補中では‘\’は特別ではなく、‘-’と‘]’のもつ特別な意味を除去
することはありません。したがって、これらの文字が特別な意味をもたないよう
な場所にあるときは、これらの文字をクォートすべきではありません。これでは
明確ではないかもしれません。これらの特殊文字が特別な意味を_もつ_場所にあ
るとき、バックスラッシュを前置することによりクォートされるのです。たとえ
ば‘[^\]’(Lispの文字記法では‘"[^\\]"’)は、バックスラッシュ以外の任意の一
文字にマッチします。


File: emacs-ja.info,  Node: Regexp Backslash,  Next: Regexp Example,  Prev: Regexps,  Up: Search

15.7 正規表現でのバックスラッシュ
=================================

多くの場合、任意の文字を伴う‘\’はその文字だけに一致します。しかしいくつ
か例外があって、‘\’で始まる2文字のシーケンスが、特別な意味を持つ場合があ
ります。シーケンス内の2文字目にくる文字は、単独で使った場合には普通の文
字として扱われるものです。以下は‘\’の構成の表です。

‘\|’
     選択肢を指定します。2つの正規表現AとBの間に‘\|’を記述すると、それは
     AまたはBのいずれかにマッチする表現を形成します。これはまずAとのマッ
     チを試み、失敗した場合にBとのマッチを試みます。

     したがって‘foo\|bar’は、‘foo’または‘bar’のいずれかにマッチし、それ
     以外の文字列にはマッチしません。

     ‘\|’は、周囲の一番大きな表現に適用されます。‘\|’のグループ化の能力
     に制限をかけることができるのは、周囲の‘\( ... \)’によるグループ化だ
     けです。

     複数の‘\|’使用を処理するための、完全なバックトラッキング能力が存在
     します。

‘\( ... \)’
     3つの目的のためのグループ化構成です:

       1. 他の操作に使うために、一連の選択肢‘\|’を括ります。したがって
          ‘\(foo\|bar\)x’は、‘foox’または‘barx’のいずれかにマッチします
          。

       2. 接尾演算子‘*’、‘+’、‘?’を適用できるように、複雑な正規表現を括
          ります。したがって‘ba\(na\)*’は、‘bananana’のように、(0個以上
          の)文字列‘na’にマッチします。

       3. あとで参照できるように、マッチした部分文字列を記録します。

     この最後の使い方は、カッコでグループ化することが重要なのではありま
     せん。これは‘\( ... \)’構成の、2番目の意味とは異なる機能です。実際
     には、これら2つの機能が衝突することは、通常はありません。もし衝突す
     るようなら、“内気(shy)”なグループ化を使うことができます。

‘\(?: ... \)’
     マッチした部分文字列を記録しない、“内気(shy)”なグループ化を指定しま
     す。マッチした部分文字列は、‘\D’により後方参照できません。この機能
     は正規表現を機械的にまとめるときに役立ちます。これにより後方参照す
     るためのグループにたいする番号づけに影響することなく、文法的な目的
     によるグループ化を行うことができます。

‘\D’
     D番目に‘\( ... \)’構成にマッチしたテキストと同じテキストにマッチし
     ます。これは“後方参照(back reference)”と呼ばれます。

     最後の‘\( ... \)’構成の後で、マッチ処理はこの構成にマッチしたテキス
     トの最初と最後を記録します。そして正規表現の後の部分で‘\’の後に数字
     Dを使うことにより、D番目の‘\( ... \)’構成にマッチしたテキストと同じ
     テキストにマッチさせることができます。

     正規表現に記述された最初の9つの‘\( ... \)’にマッチしたテキストは、
     正規表現で開きカッコが出現した順に、1から9までの数字が割り当てられ
     ます。そのため‘\1’から‘\9’を使うことにより、‘\( ... \)’構成にマッチ
     した、対応するテキストを参照することができます。

     たとえば‘\(.*\)\1’は改行を含まない、前半と後半が同一の文字列にマッ
     チします。‘\(.*\)’は、そのテキストが何であろうと前半にマッチします
     が、‘\1’は前半と正確に同じテキストにマッチしなければなりません。

     もし特定の‘\( ... \)’構成が１回以上マッチする場合(これは‘*’が後置さ
     れているとき簡単に発生します)、最後のマッチだけが記録されます。

‘\`’
     空の文字列にマッチしますが、文字列またはバッファー(またはアクセスで
     きる部分)の先頭に限定されます。

‘\'’
     空の文字列にマッチしますが、文字列またはバッファー(またはアクセスで
     きる部分)の最後に限定されます。

‘\=’
     空の文字列にマッチしますが、ポイント位置に限定されます。

‘\b’
     空の文字列にマッチしますが単語の先頭または最後に限定されます。した
     がって‘\bfoo\b’は、区切られた単語‘foo’にマッチします。
     ‘\bballs?\b’は、別々の単語‘ball’または‘balls’にマッチします。

     ‘\b’は、そこにどんなテキストが出現しようと、バッファーの先頭または
     最後にもマッチします。

‘\B’
     空の文字列にマッチしますが、単語の最初と最後_以外_にマッチします。

‘\<’
     空の文字列にマッチしますが、単語の先頭に限定されます。‘\<’は単語の
     構成文字が続く場合に限り、バッファーの先頭にマッチします。

‘\>’
     空の文字列にマッチしますが、単語の最後に限定されます。‘\<’は内容が
     単語の構成文字で終わる場合に限りバッファーの最後にマッチします。

‘\w’
     任意の単語構成文字にマッチします。どの文字が該当するかは、構文テー
     ブル(syntax table)により決定されます。*note Syntax Tables:
     (elisp)Syntax Tables.を参照してください。

‘\W’
     単語構成文字以外の任意の文字にマッチします。

‘\_<’
     空の文字列にマッチしますが、シンボルの先頭に限られます。シンボルは
     １文字以上のシンボル構成文字からなります。シンボル構成文字は、‘w’と
     ‘_’の構文をもつ文字です。‘\_<’はシンボル構成文字が続く場合に限り、
     バッファーの先頭にもマッチします。

‘\_>’
     空の文字列にマッチしますが、シンボルの最後に限定されます。‘\_>’は内
     容がシンボル構成文字で終わる場合に限り、バッファーの最後にマッチし
     ます。

‘\sC’
     構文がCである、任意の文字にマッチします。ここでCとは、特定の構文ク
     ラスを表す文字です。したがって‘w’は単語構成文字、‘-’または‘ ’は空白
     文字、‘.’は通常の区切り文字、などとなります。*note Syntax Tables:
     (elisp)Syntax Tables.を参照してください。

‘\SC’
     構文がC以外の、任意の文字にマッチします。

‘\cC’
     カテゴリーCに属する、任意の文字にマッチします。たとえば‘\cc’は中国
     文字、‘\cg’はギリシャ文字にマッチします。既知のカテゴリーについての
     説明は、‘M-x describe-categories <RET>’をタイプしてください。

‘\CC’
     カテゴリーCに_属さない_、任意の文字にマッチします。

   単語と構文に関係する構成は構文テーブルのセッティングにより制御されま
す。*Note Syntax Tables: (elisp)Syntax Tables.


File: emacs-ja.info,  Node: Regexp Example,  Next: Search Case,  Prev: Regexp Backslash,  Up: Search

15.8 正規表現の例
=================

以下にregexpの例を示します。これはEmacsがセンテンスの最後(末尾の空白は含
まない)を認識するために、デフォルトで使用するregexp(たとえば変数
‘sentence-end-base’)と似ています。

     [.?!][]\"')}]*

これには2つの連続する部分があります。1つは‘.’、‘?’、‘!’にマッチする文字
です。もう1つは閉じカッコ、クォート、カッコの0回以上の繰り返しです。


File: emacs-ja.info,  Node: Search Case,  Next: Replace,  Prev: Regexp Example,  Up: Search

15.9 検索と大文字小文字
=======================

Emacsでの検索では、テキストを小文字で指定した場合、通常は検索するテキス
トの大文字小文字は区別されません。したがって‘foo’を検索すると、‘Foo’や
‘foo’もマッチします。regexp、特に文字集合でも同様に振る舞います。つまり
‘[ab]’は、‘a’、‘A’、‘b’、‘B’もマッチします。

   インクリメンタル検索する文字列のどこかに大文字があると、検索は大文字
小文字を区別するようになります。したがって‘Foo’を検索すると、‘foo’や
‘FOO’は検索されません。これは正規表現検索でも文字列検索と同様に適用され
ます。検索文字列から大文字を削除すると、効果はなくなります。

   変数‘case-fold-search’に‘nil’をセットすると、すべての文字は大文字小文
字を含めて、完全にマッチしなければなりません。これはバッファーごとの変数
で、変数の変更はデフォルト値を変えない限り、通常はカレントバッファーだけ
が影響を受けます。*note Locals::を参照してください。これは置換コマンド
(*note Replace::を参照してください)や、ミニバッファーのヒストリー検索
(*note Minibuffer History::を参照してください)を処理する、非インクリメン
タル検索にも適用されます。

   インクリメンタル検索で‘M-c’をタイプすると、検索が大文字小文字を区別す
るかが、切り替わります。この効果は、現在の検索を超えて次の検索には引き継
がれませんが、現在の検索にたいして大文字を追加・削除したときの効果をオー
バーライドします.

   特定のコマンドや操作にたいする検索やマッチングにおいて、大文字小文字
の区別を制御する変数がいくつかあります。たとえば
‘tags-case-fold-search’は、‘find-tag’での大文字小文字の区別を制御します
。これらの変数を探すには、‘M-x apropos-variable <RET> case-fold-search
<RET>’とタイプしてください。


File: emacs-ja.info,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

15.10 置換コマンド
==================

Emacsは検索と置換を行うコマンドをいくつか提供します。単純な‘M-x
replace-string’コマンドに加えて、出現するパターンごとに置換するかを問い
合わせる‘M-%’ (‘query-replace’)も提供します。

   通常、置換コマンドはポイント位置から、バッファーの最後までのテキスト
にたいして、処理を行います。リージョンがアクティブのときは、リージョンに
たいして処理を行います(*note Mark::を参照してください)。基本的な置換コマ
ンドは1つの“検索文字列”(またはregexp)を、1つの“置換文字列”で置き換えます
。コマンド‘expand-region-abbrevs’を使用して、複数の置換を並行して処理す
ることが可能です(*note Expanding Abbrevs::を参照してください)。

   インクリメンタル検索とは異なり、置換コマンドはデフォルトでは緩いスペ
ースマッチング(lax space matching)を行いません(*note Special Isearch::を
参照してください)。置換で緩いスペースマッチングを有効にするには、変数
‘replace-lax-whitespace’を‘t’に変更してください(これはEmacsが置換文字列
ではなく、置換するテキストを検索する方法だけに影響を与えます)。

* Menu:

* Unconditional Replace::    文字列にマッチするすべて置換する。
* Regexp Replace::           regexpにマッチするすべてを置換する。
* Replacement and Case::     置換が大文字小文字を維持する方法。
* Query Replace::            問い合わせの使い方。


File: emacs-ja.info,  Node: Unconditional Replace,  Next: Regexp Replace,  Up: Replace

15.10.1 無条件の置換
--------------------

‘M-x replace-string <RET> STRING <RET> NEWSTRING <RET>’
     すべてのSTRINGをNEWSTRINGで置換します。

   ポイントの後にある‘foo’のすべてのインスタンスを‘bar’に置換するには、
コマンド‘M-x replace-string’に2つの引数‘foo’と‘bar’を指定します。置換は
ポイントの後だけで発生するので、バッファー全体を置換したい場合は、最初に
バッファーの先頭に移動しなければなりません。バッファーの最後までのすべて
が置換されます。置換をバッファーの一部に制限したいときは、そのリージョン
部分をアクティブにします。リージョンがアクティブのときは、置換はそのリー
ジョンに制限されます(*note Mark::を参照してください)。

   ‘replace-string’が終了したとき、ポイントは最後に置換された位置に留ま
ります。以前のポイント位置(‘replace-string’コマンドを実行した場所)はマー
クリングに追加されるので(マークは非アクティブ)、‘C-u C-<SPC>’で戻ること
ができます。*note Mark Ring::を参照してください。

   プレフィクス引数を指定すると、置換対象は単語単位に制限されます。

   置換コマンドでの大文字小文字の区別については、*note Replacement and
Case::を参照してください。


File: emacs-ja.info,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

15.10.2 正規表現の置換
----------------------

‘M-x replace-string’コマンドは、正確にマッチする単一の文字列を置換します
。コマンド‘M-x replace-regexp’は指定したパターンにマッチするすべてを置換
します。

‘M-x replace-regexp <RET> REGEXP <RET> NEWSTRING <RET>’
     REGEXPにマッチするすべてをNEWSTRINGで置換します。

   ‘replace-regexp’では、NEWSTRINGが定数である必要はありません。REGEXPに
マッチした全体、または部分を参照することができます。NEWSTRINGでの‘\&’は
、置換されるマッチ全体を表します。NEWSTRINGでの‘\D’(Dは数字)は、REGEXP内
でカッコでグループ化されたものの、D番目にマッチします(これは“後方参照
(back reference)と呼ばれます”)。‘\#’は、このコマンドですでに置換された件
数を10進数で参照します。最初の置換では‘\#’は‘0’で、2番目の置換では‘1’、
...のようになります。たとえば、

     M-x replace-regexp <RET> c[ad]+r <RET> \&-safe <RET>

これは‘cadr’を‘cadr-safe’に、‘cddr’を‘cddr-safe’に置き換えます。

     M-x replace-regexp <RET> \(c[ad]+r\)-safe <RET> \1 <RET>

これは逆向きの置換をします。置換するテキストに‘\’を含めるときは、‘\\’と
入力しなければなりません。

   置換する文字列の一部を毎回手入力したいときは、置換文字列で‘\?’を使用
します。すると置換ごとにミニバッファーで置換文字列を編集できます(ポイン
ト位置は‘\?’を記述した場所です。)

   このサブセクションの残りの部分は、Lispの知識が必要となる特別な処理を
念頭に書かれています。大半の読者はスキップしても構いません。

   置換文字列の一部を計算するために、Lisp式を使うことができます。これを
行うには、置換文字列の中で、‘\,’に続けてLisp式を記述します。各置換におい
て式の値が計算され、それをクォートされていない文字列に変換します(もし文
字列の場合は、その文字列の内容が使われることを意味します)。そしてそれを
置換文字列内で、式が記述された場所に使用します。もし式がシンボルのときは
、シンボル名と、置換文字列中のシンボル名の後にあるの間に1つスペースは、
両方シンボルの値に置換されます。

   このような式の中では、いくつかの特別なシーケンスを使うことができます
。式の中での‘\&’や‘\N’は、通常のようにマッチした文字列全体と、部分マッチ
した文字列を参照します。Nには複数桁の数字を記述でき、N番目の正規表現がマ
ッチしなかったとき、‘\N’は‘nil’になります。‘\#&’と‘\#N’を使って、それら
のマッチを数字で参照することもできます(これはマッチまたは部分マッチが数
字書式の場合に有効です)。ここでの‘\#’も、すでに置換された数を意味します
。

   ‘x’と‘y’の入れ替えは、以下の方法で行うことができます:

     M-x replace-regexp <RET> \(x\)\|y <RET>
     \,(if \1 "y" "x") <RET>

   ‘\,’により置換する文字列を計算するには、‘format’関数が便利なときがあ
ります(*note (elisp)Formatting Strings::を参照してください)。たとえば
73列目から80列目(もしそこに何もなければ)に、‘ABC00042’のような連番を振り
たいときは、以下を使うことができます。

     M-x replace-regexp <RET> ^.\{0,72\}$ <RET>
     \,(format "%-72sABC%05d" \& \#) <RET>


File: emacs-ja.info,  Node: Replacement and Case,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

15.10.3 置換コマンドと大文字小文字
----------------------------------

置換コマンドの最初の引数がすべて小文字の場合、置換のための検索において大
文字小文字の違いを無視します。これは‘case-fold-search’が非‘nil’の場合で
す。‘case-fold-search’を‘nil’にセットすると、すべての検索において常に大
文字小文字の違いが有効になります。

   さらにNEWSTRINGのすべて、または一部が小文字の場合、置換コマンドは大文
字小文字が出現するパターンを維持しようと試みます。したがって以下のコマン
ド、

     M-x replace-string <RET> foo <RET> bar <RET>

は小文字の‘foo’を小文字の‘bar’で置換し、すべて大文字の‘FOO’を‘BAR’、そし
て最初が大文字の‘Foo’を‘Bar’に置換します。(これら3つの候補、すなわち小文
字、すべて大文字、先頭が大文字は、‘replace-string’が認識できる唯一のパタ
ーンです)。

   置換文字列に大文字が使われている場合、テキストが挿入されるときは、常
に大文字のままとなります。大文字が最初の引数で使用されている場合、大文字
小文字の変換なしで、2番目の引数に与えられたとおりに置換されます。同様に
‘case-replace’と‘case-fold-search’の両方が‘nil’にセットされている場合、
大文字小文字の変換なしで置換されます。


File: emacs-ja.info,  Node: Query Replace,  Prev: Replacement and Case,  Up: Replace

15.10.4 問い合わせつき置換
--------------------------

‘M-% STRING <RET> NEWSTRING <RET>’
     任意のSTRINGをNEWSTRINGで置換します。
‘C-M-% REGEXP <RET> NEWSTRING <RET>’
     REGEXPにたいする任意のマッチをNEWSTRINGで置換します。

   ‘foo’を‘bar’に置換するとき、すべてではなく、そのうちのいくつかだけを
置換したいときは、‘M-%’ (‘query-replace’)を使います。このコマンドは
‘foo’を1つずつ検索して、それを置換するかを毎回尋ねます。この問い合わせを
別とすれば、‘query-replace’は‘replace-string’と同様に機能します(*note
Unconditional Replace::を参照してください)。通常のように、
‘case-replace’が非‘nil’のときは、大文字小文字を区別します(*note
Replacement and Case::を参照してください)。数引数を指定すると、単語区切
り文字で区切られた単語だけを考慮します。負のプレフィクス引数は後方に置換
します。

   ‘C-M-%’ (‘query-replace-regexp’)は、regexpの検索と置換を行います。こ
れは‘query-replace’のように問い合わせを行う以外は、‘replace-regexp’と同
様に機能します。

   これらのコマンドは、カレントのマッチを、フェイス‘query-replace’を使っ
てハイライトします。他のマッチのハイライトにはインクリメンタル検索と同様
に、フェイス‘lazy-highlight’が使われます(*note Incremental Search::を参
照してください)。デフォルトでは‘query-replace-regexp’は、カレントマッチ
を置換する展開後の文字列を、ミニバッファーに表示します。特別なシーケンス
‘\&’および‘\N’を展開せずに維持するには、
‘query-replace-show-replacement’変数をカスタマイズしてください。

   以下は文字列またはregexpにたいするマッチが表示されているときにタイプ
できる文字です:

‘<SPC>’
     マッチをNEWSTRINGで置き換えます。

‘<DEL>’
     カレントマッチを置換せずに次のマッチへスキップします。

‘, (カンマ)’
     カレントマッチを置換して、結果を表示します。そして次に何をするかを
     文字入力するよう促します。置換がすでに行われているので、この状況で
     は<DEL>と<SPC>は等価で、どちらも次のマッチへ移動します。

     ここで‘C-r’(以下を参照)をタイプして、置換されたテキストを編集できま
     す。‘C-x u’をタイプして、置換を取り消すこともできます。これは
     ‘query-replace’を終了させるので、さらに置換を行う場合は、‘C-x <ESC>
     <ESC> <RET>’で置換を再開しなければなりません(*note Repetition::を参
     照してください)。

‘<RET>’
     これ以上の置換を行わずに終了します。

‘. (ピリオド)’
     カレントマッチを置換してから、これ以上の検索を行わずに終了します。

‘!’
     これ以上の問い合わせをせずに、残りのマッチをすべて置換します。

‘Y (大文字)’
     複数バッファーの置換で、残りのバッファーの、残りのマッチをすべて置
     換します(これは選択したファイルにたいして問い合わせつきの置換を行う
     、Diredの<Q>コマンドと似ています)。これはすべての一連の問い合わせに
     たいして、これ以上のユーザーとの対話なしに"yes"を答えます。

‘N (大文字)’
     複数バッファーの置換で、カレントバッファーの残りのマッチを置換せず
     に、次のバッファーへスキップします。これはカレントバッファーのマッ
     チにたいする問い合わせに"no"を答えて、次のバッファーへと処理を続け
     ます。

‘^’
     前のマッチの位置に戻ります。これは間違えて変更したときや、再検証し
     たい場合に使います。

‘C-r’
     再帰編集レベル(recursive editing level)に入ります。これはマッチを
     NEWSTRINGで置換するだけでなく、編集したい場合に使用します。編集を終
     えたら‘C-M-c’で再帰編集レベルを抜けて、次のマッチを処理します。
     *note Recursive Edit::を参照してください。

‘C-w’
     マッチを削除してから、‘C-r’と同様に再帰編集レベルに入ります。これは
     STRINGを削除してから、テキストを挿入することにより置換を行う場合に
     使用します。編集を終えたら‘C-M-c’で再帰編集レベルを抜けて、次のマッ
     チを処理します。

‘e’
     置換文字列をミニバッファーで編集します。<RET>でミニバッファーを抜け
     ると、カレントマッチをミニバッファーの内容で置換します。この新しい
     置換文字列は、残りのマッチにたいしても適用されます。

‘C-l’
     スクリーンを再描画します。その後でカレントマッチにたいして何を行う
     か、別の文字をタイプして指定しなければなりません。

‘C-h’
     上述したオプションの要約を表示します。その後でカレントマッチにたい
     して何を行うか、別の文字をタイプして指定しなければなりません。

   上述した文字以外は、上述の文字リストのエイリアスです。たとえば‘y’、
‘n’、‘q’は、<SPC>、<DEL>、<RET>と等価です。

   これらのエイリアス文字以外の文字は、‘query-replace’を終了してから、キ
ーシーケンスの残りの部分を読みとります。したがって‘C-k’とタイプすると、
‘query-replace’を終了してから、行末までをkillします。

   一度終了した‘query-replace’を再開するには、‘C-x <ESC> <ESC>’を使いま
す。‘query-replace’は引数の読み取りにミニバッファーを使っているので、こ
のキーシーケンスで再開させることができます。*note C-x ESC ESC:
Repetition.を参照してください。

   オプション‘search-invisible’は、‘query-replace’が非表示のテキストを扱
う方法を決定します。*note Outline Search::を参照してください。

   選択されたファイルにたいして問い合わせつきの置換を行う、Diredの‘Q’コ
マンドについては、*note Operating on Files::を参照してください。regexpに
マッチするファイル名にたいして、ファイル名の変更、ファイルのコピー、ファ
イルのリンクを行うDiredのコマンドについては、*note Transforming File
Names::を参照してください。


File: emacs-ja.info,  Node: Other Repeating Search,  Prev: Replace,  Up: Search

15.11 その他の検索およびループコマンド
======================================

ここでは正規表現にたいするマッチを検索する、その他のコマンドを説明します
。これらのコマンドは、パターンに大文字が含まれていないカ、
‘case-fold-search’が非‘nil’のときは、マッチングで大文字小文字を区別しま
せん。‘occur’とその変種をのぞき、これらはすべて、ポイント位置からバッフ
ァーの最後まで、リージョンがアクティブなときはリージョンにたいして処理を
行います。

‘M-x multi-isearch-buffers’
     １つ以上のバッファー名の入力を求め(<RET>で終了)、それらのバッファー
     にたいして複数バッファーのインクリメンタル検索を開始します(あるバッ
     ファーでの検索に失敗すると、次の‘C-s’により、指定された次のバッファ
     ーへと検索を試みます)。プレフィクス引数を指定すると、regexpの入力を
     求め、regexpにマッチするバッファーにたいして、複数バッファーでのイ
     ンクリメンタル検索を開始します。

‘M-x multi-isearch-buffers-regexp’
     このコマンドは‘multi-isearch-buffers’と同様ですが、インクリメンタル
     なregexp検索を行います。

‘M-x occur’
     regexpの入力を求め、それへのマッチを含むバッファー内の各行を一覧表
     示します。検索をバッファーの一部に制限するには、その部分にナローイ
     ングします(*note Narrowing::を参照してください)。数引数Nを指定する
     と、そのコンテキストでマッチした各行の、前後N行を表示します。

     ‘*Occur*’バッファーでは、エントリーをクリックするか、ポイントをそこ
     に移動して<RET>をタイプすることにより、検索されたバッファーの対応す
     る位置をvisitします。‘o’と‘C-o’はマッチを他のウィンドウに表示します
     (‘C-o’はそのウィンドウを選択しません)。かわりに‘C-x `’
     (‘next-error’)コマンドを使うことにより、マッチした場所を1つ1つ
     visitできます(*note Compilation Mode::を参照してください)。

     ‘*Occur*’バッファーで‘e’をタイプすることにより、Occur Editモードに
     切り替えます。このモードではエントリーにたいする編集結果が、元のバ
     ッファーのテキストに適用されます。‘C-c C-c’とタイプすることにより、
     Occurモードに戻ります。

     コマンド‘M-x list-matching-lines’は、‘M-x occur’の別名です。

‘M-s o’
     最後にインクリメンタル検索で使った文字列を検索文字列として、
     ‘occur’を実行します。インクリメンタル検索がアクティブのときは‘M-s
     o’を実行して、カレントのサーチリングを使うこともできます。

‘M-x multi-occur’
     このコマンドは‘occur’と同じですが、複数のバッファーを検索する点が異
     なります。このコマンドは、1つずつバッファー名の入力を求めます。

‘M-x multi-occur-in-matching-buffers’
     このコマンドは‘multi-occur’と似ていますが、visitしているファイル名
     にマッチする正規表現を指定することにより、検索するバッファーを指定
     する点が異なります。プレフィクス引数を指定すると、正規表現にマッチ
     するバッファー名となります。

‘M-x how-many’
     regexpの入力を求め、バッファーのポイント位置以降に、何個のマッチが
     あるか表示します。リージョンがアクティブのときは、リージョンにたい
     して操作を行います。

‘M-x flush-lines’
     regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチが
     含まれている行を削除します。カレント行のポイント以降にマッチする文
     字列が含まれているときは、カレント行を削除します。リージョンがアク
     ティブのときは、リージョンにたいして操作を行います。行の一部ににリ
     ージョンが含まれていて、さらにマッチの全体がリージョンに含まれてい
     るとき、その行は削除されます。

     マッチが行をまたいでいる場合、‘flush-lines’はそれらの行すべてを削除
     します。このコマンドは行を削除してから、次のマッチを検索します。し
     たがって、1行にマッチ全体と、次の行にまたがるマッチが両方含まれると
     き、次の行にまたがるマッチは無視されます。

‘M-x keep-lines’
     regexpの入力を求め、ポイント以降にあるテキストにたいして、マッチを
     _含まない_行を削除します。ポイントが行の先頭でない場合、このコマン
     ドは常にカレント行を維持します。リージョンがアクティブのときは、リ
     ージョンにたいして操作を行います。このコマンドは一部がリージョンに
     含まれるだけの行は削除しません(行を終端する改行は、その行の一部と判
     断します)。

     マッチが行をまたぐ場合、このコマンドはそれらすべての行を維持します
     。


File: emacs-ja.info,  Node: Fixit,  Next: Keyboard Macros,  Prev: Search,  Up: Top

16 タイプミスを訂正するコマンド
*******************************

このチャプターでは、編集中に間違いに気付いたときに便利なコマンドを説明し
ます。これらのコマンドの中でもっとも基本的なのは、undoコマンド‘C-/’です
(これは‘C-x u’と‘C-_’にもバインドされています)。これは1つのコマンドやコ
マンドの一部(‘query-replace’の場合など)、または連続するいくつかの文字の
挿入を取り消します。連続して‘C-/’を繰り返すと、前へ前へと変更を取り消し
、undo情報が利用できる限界までさかのぼって、変更を取り消します。

   ここで説明するコマンドとは別に、<DEL> (‘delete-backward-char’)のよう
な削除コマンドでもテキストを消去できます。これらのコマンドは、このマニュ
アルの前のチャプターで説明しています。*note Erasing::を参照してください
。

* Menu:

* Undo::                     Undoコマンド。
* Transpose::                2つの文字、単語、行、リスト、...の入れ替え。
* Fixing Case::              最後に入力した文字の大文字小文字を訂正する。
* Spelling::                 単語またはファイル全体へのスペルチェッカーの適用。


File: emacs-ja.info,  Node: Undo,  Next: Transpose,  Up: Fixit

16.1 Undo(取り消し)
===================

“undo(取り消し)”コマンドは、バッファーのテキストにたいする最後の変更を無
効にします。バッファーはそれぞれ変更を個別に記録しており、undoコマンドは
常にカレントバッファーに適用されます。バッファーのレコードにより、バッフ
ァーにたいするすべての変更をundoできます。通常、個々の変種コマンドは、
undoレコードに個別のエントリーを作成しますが、‘query-replace’のようない
くつかのコマンドは、undo操作に柔軟性をもたせるために、コマンドによる変更
を複数のエントリーに分割します。連続した文字の挿入コマンドは、undo操作の
冗長性をなくすために、通常1つのundoレコードにまとめられます。

‘C-/’
‘C-x u’
‘C-_’
     カレントバッファーのundoレコードの、1エントリーでundoします
     (‘undo’)。

   undoを開始するには、‘C-/’(またはエイリアスの‘C-_’か‘C-x u’)をタイプし
ます(1)。これは一番最近のバッファーにたいする変更を取り消して、バッファ
ーが変更される前の位置にポイントを戻します。連続して‘C-/’(またはそれのエ
イリアス)を繰り返すと、現在のバッファーにたいする変更を、前へ前へとさか
のぼって取り消します。すでに記録されている変更がすべて取り消されていると
き、undoコマンドはエラーをシグナルします。

   undo以外のコマンドは、undoコマンドの順序性を損ないます。undo以外のコ
マンドを開始した時点から、undoしてきた一連のundoコマンド全体が、1つの変
更としてundoレコードとして記録されます。したがってundoした変更を再適用す
るには、undoの順序性を損なわないような‘C-f’のようなコマンドをタイプして
から、‘C-/’でundoコマンドをundoします。

   以前のundoコマンドを再実行せずにundoを再開したいときは、かわりに‘M-x
undo-only’を使います。これは‘undo’と同様ですが、すでにundoした変更を再実
行しません。

   バッファーをうっかり変更してしまったのに気付いたら、モードラインのア
スタリスクが表示されなくなるまで‘C-/’を繰り返しタイプするのが、もっとも
簡単な復旧方法です。undoコマンドによりモードラインのアスタリスクが消えた
とき、それはバッファーの内容がファイルを最後に読み込んだとき、または保存
したときと同じ内容だということを意味します。バッファーを意図して変更した
か覚えていないときは、‘C-/’を1回タイプします。最後の変更がundoされたのを
確認して、それが意図した変更なのか確かめます。もしそれが意図しない変更だ
ったならundoしたままにします。意図した変更だった場合、上で説明した方法で
変更を再実行します。

   アクティブなリージョンがあるとき、‘undo’は“選択的なundo(selective
undo)”を行います。これはバッファー全体ではなく、リージョンにたいして一番
最近の変更をundoします。しかしTransient Markモードがオフのとき(*note
Disabled Transient Mark::を参照してください)、‘C-/’は、リージョンではな
く、常にバッファー全体を操作します。この場合‘undo’コマンドにプレフィクス
引数を指定（‘C-u C-/’)することにより、選択的なundoができます。同じリージ
ョンにたいしてさらに変更をundoしたいときは、‘undo’コマンドを繰り返します
(プレフィクス引数は必要ありません)。

   undoレコードを作らない、特別なバッファーがいくつかあります。それは名
前がスペースで始まるバッファーです。これらのバッファーはEmacsにより内部
的に使用されており、通常ユーザーが閲覧したり編集しないテキストを保持しま
す。

   バッファーにたいするundo情報が大きくなりすぎたとき、Emacsは一番古いレ
コードを、時々(“ガベージコレクション(garbage collection)の間”)廃棄します
。変数‘undo-limit’、‘undo-strong-limit’、‘undo-outer-limit’をセットする
ことにより、どれだけのundo情報を保持するか指定することができます。これら
の値はバイト数で指定します。

   変数‘undo-limit’は、ソフトリミットをセットします。Emacsはこのサイズに
達するまでのコマンドのundoデータを保持します。制限を超えることもあり得ま
すが、これを超える古いデータは保持しません。デフォルト値は80000です。変
数‘undo-strong-limit’は、厳密なリミット(stricter limit)をセットします。
この制限を超えるような以前のコマンド(一番最近のコマンドではない)は記憶さ
れません。‘undo-strong-limit’のデフォルト値は120000です。

   これらの変数の値にかかわらず、一番最近の変更はundo情報が
‘undo-outer-limit’(通常は12,000,000)より大きくならない限り、廃棄されるこ
とはありません。もしこれを超えるような場合、Emacsはundoデータを廃棄して
、それにたいする警告を発します。これは一番最近のコマンドをundoできない唯
一の状況です。これが発生した場合、将来同じことが起こらないように
‘undo-outer-limit’の値を増やすことができます。しかしコマンドがそのような
大きなundoデータを作るとは考えられない場合、それは多分バグなので、それを
報告すべきです。*note Reporting Bugs: Bugs.を参照してください。

   ---------- Footnotes ----------

   (1) ‘C-/’以外に、‘undo’コマンドは‘C-x u’にもバインドされています。な
ぜならこれは初心者が記憶するのが簡単だからです。‘u’は“undo”に由来してい
ます。このコマンドは‘C-_’にもバインドされています。なぜならいくつかのテ
キスト端末では、‘C-/’とタイプすることにより、‘C-_’が入力されるからです。


File: emacs-ja.info,  Node: Transpose,  Next: Fixing Case,  Prev: Undo,  Up: Fixit

16.2 テキストの入れ替え
=======================

‘C-t’
     2つの文字を入れ替えます(‘transpose-chars’)。
‘M-t’
     2つの単語を入れ替えます(‘transpose-words’)。
‘C-M-t’
     バランスのとれた2つの式を入れ替えます(‘transpose-sexps’)。
‘C-x C-t’
     2つの行を入れ替えます(‘transpose-lines’)。

   2つの文字を入れ違いに入力してしまう間違いはよくありますが、それらが隣
接しているときは‘C-t’(‘transpose-chars’)コマンドで訂正できます。通常
‘C-t’はポイントの左右にある文字を入れ替えます。行末でこのコマンドを使う
場合、最後の文字と改行を入れ替えるのはおそらく無意味なので、‘C-t’は行末
の2文字を入れ替えます。このような入れ違いミスにすぐ気付いたときは、
‘C-t’だけで訂正できます。すぐに間違いに気付かなかった場合、‘C-t’をタイプ
する前に、入れ替えて入力してしまった文字の間にカーソルを移動しなければな
りません。単語の最後の文字とスペースを入れ替えて入力してしまった場合、そ
こに戻るには単語移動コマンドが良い方法です。それ以外では、逆向きの検索
(‘C-r’)が最善な方法の場合があります。*note Search::を参照してください。

   ‘M-t’は、ポイントの前にある単語と、後にある単語を入れ替えます
(‘transpose-words’)。このコマンドはポイントより後方、またはポイントがあ
る単語を前方に移動して、ポイントをその後に移動します。文字の間にある区切
り文字は移動しません。たとえば‘FOO, BAR’は、‘BAR FOO,’ではなく、
‘BAR, FOO’に入れ替わります。

   ‘C-M-t’ (‘transpose-sexps’)も似ていますが、これは2つの式(*note
Expressions::を参照してください)を入れ替えます。そして‘C-x C-t’
(‘transpose-lines’)は、行を入れ替えます。これらは‘M-t’と同様に動作します
が、入れ替えを行うテキスト単位が異なります。

   入れ替えコマンドに数引数を指定すると、反復回数になります。これは入れ
替えコマンドに、ポイントより前(またはポイントがある)の移動させる文字(ま
たは単語、式、行)を、何文字(または単語、式、行)後に移動させるか指示しま
す。たとえば‘C-u 3 C-t’は、ポイントの前にある文字を3文字後ろに移動します
。つまり‘f★oobar’は‘oobf★ar’に変更されます。これは‘C-t’を3回繰り返したの
と同じです‘C-u - 4 M-t’はポイントの前にある単語を、後方に単語4つ分移動し
ます。‘C-u - C-M-t’は、引数を指定しない‘C-M-t’の効果を取り消します。

   数引数0には特別な意味が割り当てられています(繰り返し回数としては、0に
意味がありません)。これはポイントの後ろで終わる文字(または単語、式、行
)を、マーク位置で終わる文字(または単語、式、行)と入れ替えます。


File: emacs-ja.info,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

16.3 大文字小文字の変換
=======================

‘M-- M-l’
     最後に入力した単語を小文字に変換します。‘Meta--’はメタとマイナスで
     あることに注意して下さい。
‘M-- M-u’
     最後に入力した単語をすべて大文字に変換します。
‘M-- M-c’
     最後に入力した単語の先頭を大文字、それ以外を小文字に変換します。

   単語の大文字小文字を間違えてタイプするのは、とても一般的な間違えです
。そのため、単語の大文字小文字の変換コマンド‘M-l’、‘M-u’、‘M-c’に負の数
引数を指定すると、カーソルを移動しないという特性があります。最後に入力し
た単語のタイプミスに気付いたら、単に大文字小文字を変換して、タイプを続け
ることができます。*note Case::を参照してください。


File: emacs-ja.info,  Node: Spelling,  Prev: Fixing Case,  Up: Fixit

16.4 スペルのチェックと訂正
===========================

このセクションでは、1つの単語、またはバッファーの一部のスペルをチェック
するコマンドを説明します。これらのコマンドはAspell、Ispell、Hunspellのよ
うなスペルチェッカープログラムがインストールされている場合だけ機能します
。これらのプログラムはEmacsの一部ではありませんが、GNU/Linuxまたは他のフ
リーなオペレーティングシステムには、通常1つはインストールされています。
*note Aspell: (aspell)Top.を参照してください。

‘M-$’
     ポイントがある単語スペルの、チェックと訂正をします(‘ispell-word’)。
     リージョンがアクティブのときは、リージョンに含まれるすべての単語に
     たいして行います。
‘M-x ispell’
     バッファーにある単語スペルの、チェックと訂正をします。リージョンが
     アクティブのときは、リージョンに含まれるすべての単語にたいして行い
     ます。
‘M-x ispell-buffer’
     バッファーにある単語スペルの、チェックと訂正をします。
‘M-x ispell-region’
     リージョンにある単語スペルの、チェックと訂正をします。
‘M-x ispell-message’
     メールメッセージのドラフト(引用部分を除く)にたいして、単語スペルの
     チェックと訂正をします。
‘M-x ispell-change-dictionary <RET> DICT <RET>’
     Aspell/Ispell/Hunspellのプロセスを再起動して、DICTを辞書として使用
     させます。
‘M-x ispell-kill-ispell’
     Aspell/Ispell/Hunspellのサブプロセスをkillします。
‘M-<TAB>’
‘<ESC> <TAB>’
     ポイントの前にある単語を、スペル辞書をもとに補完します
     (‘ispell-complete-word’)。
‘M-x flyspell-mode’
     スペルミスした単語をハイライトする、Flyspellモードを有効にします。
‘M-x flyspell-prog-mode’
     コメントと文字列にたいして、Flyspellモードを有効にします。

   ポイントの前または周囲にある単語スペルをチェックしたり訂正するには、
‘M-$’ (‘ispell-word’)をタイプします。リージョンがアクティブのときは、リ
ージョン内のすべての単語スペルをチェックします。*note Mark::を参照してく
ださい(Transient Markモードがオフのとき、‘M-$’はリージョンを無視して、常
にポイントの前または周囲の単語にたいして動作します。*note Disabled
Transient Mark::を参照してください)。

   同様に、コマンド‘M-x ispell’はリージョンがアクティブのときはリージョ
ン、それ以外のときはバッファー全体にたいして、スペルチェックを行います。
コマンド‘M-x ispell-buffer’および‘M-x ispell-region’は、スペルチェックを
バッファー全体にたいして行うのか、リージョンにたいして行うかを明示します
。このコマンドはバッファー全体をチェックしますが、インデントされているテ
キストと、以前のメッセージの引用と思われるテキストはチェックしません。
*note Sending Mail::を参照してください。

   これらのコマンドは、正しくないと思われる単語に出会うと、それをどうす
るかを尋ねます。通常は番号が振られた“近い単語(near-misses)”(正しくないと
思われる単語に似た単語)のリストを表示します。これにたいして1文字をタイプ
して応答しなければなりません。以下は有効な応答文字です。

‘数字’
     今回だけは近い単語の一覧で単語を置き換えます。近い単語には番号が振
     られており、選択するにはその番号をタイプします。

‘<SPC>’
     その単語を間違いと判断することは変更しませんが、その単語をここでは
     変更せずスキップします。

‘r NEW <RET>’
     今回は単語をNEWで置き換えます(置換文字列にスペルエラーがないか再ス
     キャンされます)。

‘R NEW <RET>’
     単語をNEWで置き換え、‘query-replace’を実行します。これによりバッフ
     ァーの他の箇所の間違えを置換できます(置換にスペルエラーがないか再ス
     キャンされます)。

‘a’
     正しくないと思われる単語を正しいものとして受け入れますが、それは今
     回の編集セッションに限られます。

‘A’
     正しくないと思われる単語を正しいものとして受け入れますが、それは今
     回の編集セッションとそのバッファーに限られます。

‘i’
     この単語をプライベートな辞書ファイルに挿入するので、今後(将来のセッ
     ションを含めて)Aspell/Ispell/Hunspellはその単語を正しく認識します。

‘m’
     ‘i’と同様ですが、辞書の補完情報も指定できます。

‘u’
     この単語の小文字バージョンを、プライベートな辞書ファイルに挿入しま
     す。

‘l WORD <RET>’
     WORDにマッチする単語を辞書から探します。これらの単語は“近い単語”の
     新しいリストになるので、置換で数字をタイプして選択できるようになり
     ます。WORDにはワイルドカードとして‘*’を使うことができます。

‘C-g’
‘X’
     対話的なスペルチェックを終了します(ポイントはチェックされた単語の位
     置に残されます)。‘C-u M-$’でチェックを再開できます。

‘x’
     対話的なスペルチェックを終了します(ポイントはチェックを開始したとき
     の位置に戻ります)。

‘q’
     対話的なスペルチェックを終了して、スペルチェッカーのサブプロセスを
     killします。

‘?’
     オプションの一覧を表示します。

   Textモードおよびそれに関連するモードでは、‘M-<TAB>’
(‘ispell-complete-word’)で、スペル訂正にもとづくバッファー内補完を行いま
す。単語の最初の部分を入力してから‘M-<TAB>’をタイプすると、補完一覧が表
示されます(ウィンドウマネージャーが‘M-<TAB>’を横取りしてしまう場合は、
‘<ESC> <TAB>’または‘C-M-i’をタイプします)。補完対象には番号か文字が振ら
れているので、その番号か文字をタイプして選択します。

   1度プロセスが開始されれば、Aspell/Ispell/Hunspellのサブプロセスは待機
状態で実行を続けるので、一連のスペルチェックコマンドは素早く完了します。
プロセスを終了させたいときは‘M-x ispell-kill-ispell’を使います。スペルの
訂正を行うとき以外プロセスがCPU時間を使うことはないので、これは通常必要
ありません。

   Ispell/Aspell/Hunspellは、スペルを2つの辞書から探します。それは標準辞
書と個人用辞書です。標準辞書は変数‘ispell-local-dictionary’で指定されま
す。これが‘nil’のときは、変数‘ispell-dictionary’で指定されます。両方が
‘nil’のとき、スペルプログラムは既定の辞書を使います。コマンド‘M-x
ispell-change-dictionary’は、バッファーにたいする標準辞書をセットしてか
らサブプロセスを再起動することにより、これにより異なる標準辞書を使うこと
ができます。個人用の辞書は、変数‘ispell-personal-dictionary’で指定します
。これが‘nil’のとき、スペルプログラムは個人辞書を既定の場所から探します
。

   単語の補完には別の辞書が使われます。変数‘ispell-complete-word-dict’は
、この辞書のファイル名を指定します。補完辞書はメインの辞書として使うこと
ができず、追加の情報ももたないので、別のものでなければなりません。補完辞
書のないスペルチェック辞書をもつ言語もいくつかあります。

   Flyspellモードは、タイプした単語のスペルを自動的にチェックするマイナ
ーモードです。認識できない単語を見つけると、その単語をハイライトします。
‘M-x flyspell-mode’とタイプすると、カレントバッファーのFlyspellモードを
切り替えます。すべてのTextバッファーでFlyspellモードを有効にするには、
‘text-mode-hook’に、‘flyspell-mode’を追加します。*note Hooks::を参照して
ください。

   Flyspellモードでスペルミスした単語がハイライトされているときは、それ
を‘Mouse-2’でクリックすることにより、利用可能な訂正とアクションのメニュ
ーを表示できます。手入力により、自分の好きな方法で単語を訂正することもで
きます。

   Flyspell Progモードは通常のFlyspellモードと同じように機能しますが、コ
メントと文字列に含まれた単語だけをチェックします。この機能はプログラムを
編集する場合に便利です。‘M-x flyspell-prog-mode’をタイプして、現在のバッ
ファーにたいするこのモードの有効と無効を切り替えます。すべてのプログラミ
ングに関連したモードでこのモードを有効にするには、‘prog-mode-hook’に
‘flyspell-prog-mode’を追加します(*note Hooks::を参照してください)。


File: emacs-ja.info,  Node: Keyboard Macros,  Next: Files,  Prev: Fixit,  Up: Top

17 キーボードマクロ
*******************

このチャプターでは一連の編集コマンドを記録して、後で簡単に繰り返す方法を
説明します。

   “キーボードマクロ(keyboard macro)”とは、Emacsのユーザーにより定義され
る、一連のキー入力からなるコマンドです。たとえば‘C-n M-d C-d’を40回繰り
返しタイプしていることに気付いたとしましょう。‘C-n M-d C-d’を行うキーボ
ードマクロを定義して、それを39回以上繰り返すことにより、作業スピードをあ
げることができます。

   キーボードマクロは、コマンドを実行・記録することにより定義します。違
う言い方をすると、キーボードマクロの定義では、初回はマクロの定義が実行さ
れるということです。この方法により、頭だけで考えるのではなく、コマンドの
影響を目で見ることができます。コマンド列の入力を終了して定義を終了すると
きは、キーボードマクロが定義されるとともに、入力したコマンド列の影響とし
てマクロが1回実行されたことになります。その後はマクロを呼び出すことによ
り、コマンド列全体を実行することができます。

   キーボードマクロは、LispではなくEmacsコマンド言語(Emacs command
language)で記述されている点が、通常のEmacsコマンドと異なります。しかし
Emacsコマンド言語は、高度なことや一般的なことを記述するプログラム言語と
して、充分にパワフルとはいえません。そのような事項には、Lispを使わなけれ
ばなりません。

* Menu:

* Basic Keyboard Macro::     キーボードマクロの定義と実行。
* Keyboard Macro Ring::      以前のキーボードマクロが保存される場所。
* Keyboard Macro Counter::   マクロに増加する番号を挿入する。
* Keyboard Macro Query::     毎回違うことを行うマクロの作成。
* Save Keyboard Macro::      キーボードマクロの命名とファイルへの保存。
* Edit Keyboard Macro::      キーボードマクロを編集するには。
* Keyboard Macro Step-Edit::  キーボードマクロのインタラクティブな実行と編集。


File: emacs-ja.info,  Node: Basic Keyboard Macro,  Next: Keyboard Macro Ring,  Up: Keyboard Macros

17.1 基本的な使い方
===================

‘<F3>’
     キーボードマクロの定義を開始します
     (‘kmacro-start-macro-or-insert-counter’)。
‘<F4>’
     キーボードマクロを定義しているときは定義を終了します。それ以外の場
     合は一番最近のキーボードマクロを実行します
     (‘kmacro-end-or-call-macro’)。
‘C-u <F3>’
     最後のキーボードマクロを再実行してから、キーをマクロ定義に追加しま
     す。
‘C-u C-u <F3>’
     最後のキーボードマクロを再実行せずに、キーをマクロ定義に追加します
     。
‘C-x C-k r’
     リージョンの中の各行の行頭にたいして、最後のキーボードマクロを実行
     します(‘apply-macro-to-region-lines’)。

   キーボードマクロの定義を開始するには、<F3>をタイプします。それからは
キーを入力して実行を続けますが、それは同時にマクロ定義の一部になります。
その間は、モードラインに‘Def’が表示されて、マクロの定義中であることを示
します。終了するときは<F4> (‘kmacro-end-or-call-macro’)をタイプして、定
義を終了します。たとえば、

     <F3> M-f foo <F4>

これは1単語前方に移動してから、‘foo’を挿入するマクロを定義します。<F3>と
<F4>は、マクロの一部とはならないことに注意してください。

   マクロを定義した後は、<F4>でそれを呼び出すことができます。上記の例で
は、それは‘M-f foo’ againをタイプしたのと同じ効果をもちます(<F4>コマンド
の2つの役割に注意してください。これはマクロを定義しているときはマクロの
定義を終了し、そうでないときは最後のマクロを呼び出します)。<F4>に数引数
‘n’を与えることもできます。これはマクロを‘n’回呼び出すことを意味します。
引数に0を与えると、エラーになるか、‘C-g’(MS-DOSでは‘C-<BREAK>’)をタイプ
するまで、マクロを永久に繰り返します。

   上記の例は、キーボードマクロを使った便利なトリックをデモンストレイト
する例です。テキストの一定間隔の位置にたいして繰り返し操作を行いたいとき
は、マクロの一部に移動コマンドを含めます。この例ではマクロの繰り返しによ
り、連続する単語の後ろに文字列‘foo’を挿入していきます。

   キーボードマクロの定義を終了した後でも、‘C-u <F3>’をタイプすることに
より、マクロの定義にキーストロークを追加できます。これは<F3>に続けてマク
ロの定義を再タイプするのと同じです。結果として、そのマクロの以前の定義が
再実行されることになります。変数‘kmacro-execute-before-append’を‘nil’に
変更すると、既存のマクロにキーストロークが追加されるまでは実行されません
(デフォルトは‘t’)。最後に実行したキーボードマクロを再実行することなく、
定義の最後にキーストロークを追加するには、‘C-u C-u <F3>’をタイプしてくだ
さい。

   コマンドがミニバッファーから引数を読みとる場合、ミニバッファーにたい
する入力は、コマンドと一緒にマクロの一部となります。したがってマクロを再
生すると、そのコマンドの引数は入力されたのと同じになります。たとえば、

     <F3> C-a C-k C-x b foo <RET> C-y C-x b <RET> <F4>

これはカレント行をkillして、バッファー‘foo’にそれをyankした後、元のバッ
ファーに戻ります。

   ほとんどのキーボードコマンドは、キーボードマクロの定義で普通に機能し
ますが、いくつか例外があります。‘C-g’ (‘keyboard-quit’)をタイプすると、
キーボードマクロの定義が終了します。‘C-M-c’ (‘exit-recursive-edit’)は信
頼できません。これはマクロの中で再帰編集(recursive edit)を開始したときは
期待通りに再帰編集から抜け出しますが、キーボードマクロの呼び出し前に開始
された再帰編集を抜け出すには、キーボードマクロからも抜け出す必要がありま
す。同様に、マウスイベントもキーボードマクロで使用できますが。信頼はでき
ません。マクロによりマウスイベントが再生されるときは、マクロを定義したと
きのマウス位置が使用されます。この効果は予測が困難です。

   コマンド‘C-x C-k r’ (‘apply-macro-to-region-lines’)は、リージョン内の
各行のにたいして、最後に定義されたキーボードマクロを繰り返します。これは
1行ずつポイントをリージョン内の行頭に移動してからマクロを実行します。

   上記で説明した<F3>と<F4>に加えて、Emacsはキーボードマクロを定義したり
実行するための、古いキーバインドもサポートします。<F3>と同様ににマクロ定
義を開始するには、‘C-x (’ (‘kmacro-start-macro’)とタイプします。プレフィ
クス引数を指定すると、最後のキーボードマクロの定義に追加します。マクロ定
義を終了するには‘C-x )’ (‘kmacro-end-macro’)とタイプします。一番最近のマ
クロを実行するには、‘C-x e’ (‘kmacro-end-and-call-macro’)とタイプします
。マクロ定義中に‘C-x e’を入力すると、マクロ定義を終了してからすぐに実行
されます。‘C-x e’をタイプした後すぐに<e>をタイプすることにより、そのマク
ロを１回以上繰り返すことができます。<F4>と同様、‘C-x e’には繰り返し回数
を引数指定できます。

   ‘C-x )’に、繰り返し回数を引数として与えることができます。これはマクロ
を定義した後、すぐにマクロが繰り返されることを意味します。マクロの定義は
、定義することによりマクロが実行されるので、最初の1回として数えられます
。したがって‘C-u 4 C-x )’は、マクロを3回すぐに追加実行します。


File: emacs-ja.info,  Node: Keyboard Macro Ring,  Next: Keyboard Macro Counter,  Prev: Basic Keyboard Macro,  Up: Keyboard Macros

17.2 キーボードマクロリング
===========================

すべての定義されたキーボードマクロは、“キーボードマクロリング(keyboard
macro ring)”に記録されます。キーボードマクロリングはすべてのバッファーで
共有され、1つだけしかありません。

‘C-x C-k C-k’
     リングの先頭にあるキーボードマクロを実行します
     (‘kmacro-end-or-call-macro-repeat’)。
‘C-x C-k C-n’
     キーボードマクロリングを、次のマクロ(古く定義されたもの)にローテー
     トします(‘kmacro-cycle-ring-next’)。
‘C-x C-k C-p’
     キーボードマクロリングを前のマクロ(新しく定義されたもの)にローテー
     トします(‘kmacro-cycle-ring-previous’)。

   キーボードマクロリングを操作するすべてのコマンドは、同じ‘C-x C-k’を使
います。これらのコマンドでは、すぐ後にコマンドを実行して繰り返す場合には
、互いに‘C-x C-k’プレフィクスを必要としません。たとえば、

     C-x C-k C-p C-p C-k C-k C-k C-n C-n C-k C-p C-k C-d

これは、キーボードマクロリングを“2つ前”のマクロが先頭にくるようにローテ
ートして、3回実行します。次にキーボードマクロリングをローテートして、元
は先頭だったマクロを先頭に戻して１回実行します。次にキーボードマクロリン
グを“1つ前”のマクロが先頭にくるようにローテートして、それを実行します。
そして最後にそれを削除しています。

   コマンド‘C-x C-k C-k’ (‘kmacro-end-or-call-macro-repeat’)は、マクロリ
ングの先頭にあるキーボードマクロを実行します。もう一度すぐに‘C-k’をタイ
プすると、マクロを繰り返すことができます。すぐに‘C-n’か‘C-p’をタイプすれ
ば、マクロリングをローテートすることができます。

   キーボードマクロを定義しているとき、‘C-x C-k C-k’は<F4>と同様に振る舞
いますが、すぐ後にタイプされた場合は異なります。このセクションで説明する
ほとんどのキーバインドは、‘C-x C-k’プレフィクスが必要ない場合があります
。たとえば、すぐに‘C-k’をタイプした場合は、マクロを再実行します。

   コマンド‘C-x C-k C-n’ (‘kmacro-cycle-ring-next’)および‘C-x C-k C-p’
(‘kmacro-cycle-ring-previous’)は、マクロリングをローテートして、次または
前のキーボードマクロをリングの先頭に移動させます。新しく先頭となったマク
ロの定義は、エコーエリアに表示されます。お望みのマクロが先頭にくるまで、
すぐに‘C-n’または‘C-p’を繰り返しタイプすれば、マクロリングのローテートを
続けることができます。新しくマクロリングの先頭にきたマクロを実行するには
、単に‘C-k’をタイプします。

   Emacsはマクロリングの先頭を、“最後に定義されたキーボードマクロ”として
扱います。たとえば、そのマクロは<F4>で実行でき、‘C-x C-k n’で名前をつけ
ることができます。

   キーボードマクロリングに格納できるマクロの最大数は、カスタマイズ可能
な変数‘kmacro-ring-max’により決定されます。


File: emacs-ja.info,  Node: Keyboard Macro Counter,  Next: Keyboard Macro Query,  Prev: Keyboard Macro Ring,  Up: Keyboard Macros

17.3 キーボードマクロカウンター
===============================

キーボードマクロには、それぞれカウンターが割り当てられています。これはマ
クロの定義を開始したとき0に初期化されます。カウンターの数値をバッファー
に挿入することもできます。カウンターの数値は、マクロが呼び出された回数に
もとづきます。バッファーにカウンターの値が挿入される度に、カウンターは増
加します。

‘<F3>’
     キーボードマクロの定義では、キーボードマクロカウンターの値をバッフ
     ァーに挿入します(‘kmacro-start-macro-or-insert-counter’)。
‘C-x C-k C-i’
     キーボードマクロカウンターの値をバッファーに挿入します
     (‘kmacro-insert-counter’)。
‘C-x C-k C-c’
     キーボードマクロカウンターをセットします(‘kmacro-set-counter’)。
‘C-x C-k C-a’
     プレフィクス引数をキーボードマクロカウンターに加えます
     (‘kmacro-add-counter’)。
‘C-x C-k C-f’
     挿入するキーボードマクロカウンターの書式を指定します
     (‘kmacro-set-format’)。

   キーボードマクロを定義しているとき、コマンド<F3>
(‘kmacro-start-macro-or-insert-counter’)は、キーボードマクロカウンターの
現在の値をバッファーに挿入して、カウンターを1増加させます(マクロを定義し
ていないとき、<F3>はマクロの定義を開始します。*note Basic Keyboard
Macro::を参照してください)。異なる増分の指定には、数引数を使うことができ
ます。単にプレフィクス‘C-u’を指定すると、それは0増加させるのと同じです。
つまり現在のカウンターの値を挿入しますが、カウンターの値は変化しません。

   例として数字が振られたリストを構築するために、キーボードマクロカウン
ターを使う方法を見てみましょう。以下のキーシーケンスを考えてください:

     <F3> C-a <F3> . <SPC> <F4>

マクロ定義の一部として、現在の行の先頭に文字列‘0. ’が挿入されます。バッ
ファーの他の箇所で<F4>でマクロを呼び出すと、その行の先頭に文字列‘1. ’が
挿入されます。その後に呼び出すと‘2. ’、‘3. ’、...が挿入されます。

   コマンド‘C-x C-k C-i’ (‘kmacro-insert-counter’)は、<F3>と同様のことを
行いますが、これはキーボードマクロの定義外でも使用できます。キーボードマ
クロが定義中でなく実行もされていない場合、これはキーボードマクロリングの
先頭にあるマクロのカウンター値を挿入および増加します。

   コマンド‘C-x C-k C-c’ (‘kmacro-set-counter’)は現在のマクロカウンター
を、数引数の値にセットします。マクロ内で使用した場合、マクロ実行ごとに処
理します。プレフィクス引数に単に‘C-u’を指定した場合、マクロの現在の繰り
返し実行おいて、カウンターが最初にもっていた値に、カウンターをリセットし
ます(この繰り返しにおける増加を取り消します)。

   コマンド‘C-x C-k C-a’ (‘kmacro-add-counter’)は、プレフィクス引数を現
在のマクロカウンターに加えます。単に‘C-u’を引数に指定すると、任意のキー
ボードマクロにより最後に挿入された値に、カウンターをリセットします(通常
これを使うときは、最後の挿入は同じマクロによる同じカウンターです)。

   コマンド‘C-x C-k C-f’ (‘kmacro-set-format’)は、マクロカウンターを挿入
するときに使われる書式の入力を求めます。デフォルトの書式は‘%d’で、これは
パディングなしの10進数字が挿入されることを意味します。ミニバッファーに何
も入力せずにexitすることにより、このデフォルト書式にリセットできます。
‘format’関数(この関数はさらに1つの整数の引数をとります)が受け入れる書式
文字列を指定できます(*note (elisp)Formatting Strings::を参照してください
)。ミニバッファーに書式文字列を入力するときは、書式文字列をダブルクォー
テーションで括らないでください。

   キーボードマクロの定義および実行がされていないときにこのコマンドを使
うと、新しい書式はそれ以降のマクロ定義すべてに影響を及ぼします。既存のマ
クロは、それが定義されたときの書式を使いつづけます。キーボードマクロ定義
中に書式をセットすると、そのマクロが定義されている箇所に影響を及ぼします
が、それ以降のマクロには影響を与えません。マクロの実行においては、そのマ
クロ定義の時点の書式が使われます。マクロの実行中にマクロ書式を変更すると
、これは定義中における書式の変更と同様、それ以降のマクロに影響を与えませ
ん。

   ‘C-x C-k C-f’によりセットされた書式は、レジスターに格納された数字の挿
入には影響しません。

   マクロの繰り返しにおいてレジスターを増加してカウンターとして使う場合
、これはキーボードマクロカウンターと同じことです。*note Number
Registers::を参照してください。大抵の用途では、キーボードマクロカウンタ
ーを使う方が単純です。


File: emacs-ja.info,  Node: Keyboard Macro Query,  Next: Save Keyboard Macro,  Prev: Keyboard Macro Counter,  Up: Keyboard Macros

17.4 変化のあるマクロの実行
===========================

キーボードマクロで、‘query-replace’のように変更を行うか応答を求める効果
を作ることができます。

‘C-x q’
     マクロ実行中にこの箇所に到達すると確認を求めます
     (‘kbd-macro-query’)。

   マクロ定義中に問い合わせを行いたい箇所で‘C-x q’をタイプします。マクロ
定義中は‘C-x q’は何も行いませんが、後でマクロを実行すると‘C-x q’は実行を
続けるか対話的に確認を求めます。

   以下は‘C-x q’にたいする有効な応答です:

<SPC> (または‘y’)
     キーボードマクロの実行を続けます。

<DEL> (または‘n’)
     マクロのこの繰り返しでの残りの部分をスキップして、次の繰り返しを開
     始します。

<RET> (または‘q’)
     マクロのこの繰り返しでの残りの部分をスキップして、これ以上の繰り返
     しを取り消します。

‘C-r’
     マクロの一部ではない編集を行うことができる、再帰編集レベル
     (recursive editing level)に入ります。‘C-M-c’を使って再帰編集を抜け
     ると、キーボードマクロを続行するか再び確認を求められます。ここで
     <SPC>をタイプすると、マクロ定義の残りの部分が実行されます。マクロの
     残りの部分が期待したように動作するためにポイントとテキストを残すの
     は、ユーザーの責任です。

   ‘C-x q’に数引数を指定した‘C-u C-x q’は、完全に異なる関数を実行します
。これはマクロ定義中およびマクロ実行中の両方で、キーボード入力を読みとる
再帰編集に入ります。定義中のときは、再帰編集の中で行った編集はマクロの一
部とはなりません。マクロ実行中は、再帰編集により各繰り返しにおいて特別な
編集を行う機会が与えられます。*note Recursive Edit::を参照してください。


File: emacs-ja.info,  Node: Save Keyboard Macro,  Next: Edit Keyboard Macro,  Prev: Keyboard Macro Query,  Up: Keyboard Macros

17.5 キーボードマクロの命名と保存
=================================

‘C-x C-k n’
     一番最近定義したキーボードマクロに、名前(持続期間はEmacsセッション
     中)を与えます(‘kmacro-name-last-macro’)。
‘C-x C-k b’
     一番最近定義したキーボードマクロを、キーにバインド(持続期間は
     Emacsセッション中)します(‘kmacro-bind-to-key’)。
‘M-x insert-kbd-macro’
     キーボードマクロの定義を、Lispコードとしてバッファーに挿入します。

   キーボードマクロを後で使うために保存するには、‘C-x C-k n’
(‘kmacro-name-last-macro’)を使って、それに名前を与えることができます。こ
れはミニバッファーを使って名前を引数として読み取り、最後のキーボードマク
ロの現在の定義を実行するための、名前を定義します(後でこのマクロの定義を
追加した場合、その名前のマクロ定義は変更されません)。マクロ名はLispシン
ボルで、‘M-x’で呼び出せ、‘global-set-key’でキーにバインドできる有効な名
前をつけます。キーボードマクロ以外に定義されている名前を指定すると、エラ
ーメッセージが表示され何も変更はされません。

   ‘C-x C-k b’ (‘kmacro-bind-to-key’)の後に、バインドしたいキーシーケン
スを続けることにより、最後のキーボードマクロ(の現在の定義)をキーにバイン
ドすることもできます。グローバルキーマップ(global keymap)の任意のキーシ
ーケンスにバインドできますが、大部分のキーシーケンスはすでに他のバインド
をもっているので、キーシーケンスの選択は慎重に行う必要があります。任意の
キーマップで既存のバインドをもつキーシーケンスにバインドしようとすると、
既存のバインドを置き換える前に確認を求めます。

   既存のバインドの上書きに起因する問題を避けるには、キーシーケンス‘C-x
C-k 0’から‘C-x C-k 9’と、‘C-x C-k A’から‘C-x C-k Z’を使います。これらの
キーシーケンスは、キーボードマクロのバインド用に予約されています。これら
のキーシーケンスにバインドするには、キーシーケンス全体ではなく数字か文字
だけをタイプすればバインドできます。たとえば、

     C-x C-k b 4

これは最後のキーボードマクロをキーシーケンス‘C-x C-k 4’にバインドします
。

   1度マクロにコマンド名をつければ、その定義をファイルに保存できます。そ
れは他の編集セッションでも使用できます。最初に定義を保存したいファイルを
visitします。次に以下のコマンドを使います:

     M-x insert-kbd-macro <RET> MACRONAME <RET>

これは後で実行するとき、今と同じ定義のマクロとなるLispコードをバッファー
に挿入します(これを行うためにLispコードを理解する必要はありません。なぜ
ならあなたのかわりに‘insert-kbd-macro’がLispコードを記述するからです)。
それからファイルを保存します。後でそのファイルを‘load-file’ (*note Lisp
Libraries::を参照してください)でロードできます。initファイル‘~/.emacs’
(*note Init File::を参照してください)に保存すれば、そのマクロはEmacsを実
行する度に定義されます。

   ‘insert-kbd-macro’に数引数を与えると、(もしあれば)MACRONAMEにバインド
したキーを記録するためのLispコードが追加されるので、ファイルをロードした
とき同じキーにマクロが割り当てられます。


File: emacs-ja.info,  Node: Edit Keyboard Macro,  Next: Keyboard Macro Step-Edit,  Prev: Save Keyboard Macro,  Up: Keyboard Macros

17.6 キーボードマクロの編集
===========================

‘C-x C-k C-e’
     最後に定義されたキーボードマクロを編集します(‘kmacro-edit-macro’)。
‘C-x C-k e NAME <RET>’
     以前に定義されたキーボードマクロNAMEを編集します
     (‘edit-kbd-macro’)。
‘C-x C-k l’
     過去300回分のキーストロークを、キーボードマクロとして編集します
     (‘kmacro-edit-lossage’)。

   ‘C-x C-k C-e’または‘C-x C-k <RET>’ (‘kmacro-edit-macro’)をとタイプし
て、最後のキーボードマクロを編集できます。これはマクロ定義をバッファーに
整形出力して、それを編集するために特化したモードに入ります。そのバッファ
ーで‘C-h m’をタイプすると、マクロを編集する方法の詳細が表示されます。編
集を終了するには‘C-c C-c’をタイプしてください。

   名前をつけたキーボードマクロ、またはキーにバインドしたマクロは、‘C-x
C-k e’ (‘edit-kbd-macro’)とタイプして編集できます。このコマンドに続けて
そのマクロを呼び出すときのキー入力(‘C-x e’、‘M-x NAME’、またはその他のキ
ーシーケンス)を入力します。

   ‘C-x C-k l’ (‘kmacro-edit-lossage’)とタイプして、最近300回のキースト
ロークをマクロとして編集できます。


File: emacs-ja.info,  Node: Keyboard Macro Step-Edit,  Prev: Edit Keyboard Macro,  Up: Keyboard Macros

17.7 キーボードマクロのステップ編集
===================================

‘C-x C-k <SPC>’ (‘kmacro-step-edit-macro’)とタイプして、最後のキーボード
マクロをインタラクティブに1コマンドずつ再生および編集できます。マクロを
‘q’または‘C-g’で終了しなければ、編集されたマクロでマクロリングの最後のマ
クロを置き換えます。

   このマクロ編集機能は、最初(または次)に実行されるコマンドと、それにた
いする操作を尋ねるプロンプトをミニバッファーに表示します。‘?’を入力すれ
ば、オプションの要約を表示できます。以下のオプションが利用可能です:

   • <SPC>および‘y’は、現在のコマンドを実行して、キーボードマクロの次の
     コマンドに進みます。
   • ‘n’、‘d’、および<DEL>は、現在のコマンドをスキップして削除します。
   • ‘f’は、キーボードマクロの実行において現在のコマンドをスキップします
     が、マクロから削除はしません。
   • <TAB>は、現在のコマンドと、現在のコマンドのすぐ後に続く同じようなコ
     マンドを実行します。たとえば連続する文字の挿入
     (‘self-insert-command’に相当)には、<TAB>が使われます。
   • ‘c’は、(これ以上の編集は行わずに)キーボードマクロの最後まで実行を続
     けます。実行が正常に終了した場合、編集されたマクロで元のキーボード
     マクロを置き換えます。
   • ‘C-k’は、キーボードマクロの残りの部分をスキップおよび削除して、ステ
     ップ編集を終了し、編集されたマクロで元のキーボードマクロを置き換え
     ます。
   • ‘q’および‘C-g’は、キーボードマクロのステップ編集を取り消して、キー
     ボードマクロにたいして行った編集を破棄します。
   • ‘i KEY... C-j’は、一連のキーシーケンス(最後の‘C-j’は含まれません)を
     読み取って実行し、キーボードマクロの現在のコマンドの前に挿入します
     (現在のコマンドはスキップしません)。
   • ‘I KEY...’は、1つのキーシーケンスを読み取って実行し、キーボードマク
     ロの現在のコマンドの前に挿入します(現在のコマンドはスキップしません
     )。
   • ‘r KEY... C-j’は、一連のキーシーケンス(最後の‘C-j’は含まれません)を
     読み取って実行し、現在のコマンドをそれで置き換えます(実行は挿入され
     たキーシーケンスの次に移ります)。
   • ‘R KEY...’は、1つのキーシーケンスを読み取って実行し、キーボードマク
     ロの現在のコマンドを、そのキーシーケンスで置き換えます(実行は挿入さ
     れたキーシーケンスの次に移ります)。
   • ‘a KEY... C-j’は、現在のコマンドを実行してから、一連のキーシーケン
     ス(最後の‘C-j’は含まれません)を読み取って実行してから、それをキーボ
     ードマクロの現在のコマンドの後ろに挿入します(実行は現在のコマンドと
     、その後ろに挿入されたキーシーケンスの次に移ります)。
   • ‘A KEY... C-j’は、キーボードマクロの残りのコマンドを実行してから、
     一連のキーシーケンス(最後の‘C-j’は含まれません)を読み取って実行し、
     それらをキーボードマクロの最後に追加します。それからステップ編集を
     終了し、編集されたマクロで元の元のキーボードマクロを置き換えます。


File: emacs-ja.info,  Node: Files,  Next: Buffers,  Prev: Keyboard Macros,  Up: Top

18 ファイルの処理
*****************

オペレーティングシステムは“ファイル”にデータを永続化するので、Emacsで編
集するテキストの大部分はファイルから読み込んで、最終的にファイルに格納し
ます。

   ファイルを編集するには、Emacsにファイルを読み込み、ファイルのテキスト
を含むバッファーを準備するよう、指示しなければなりません。これを、ファイ
ルの“visit(訪問)”と呼びます。編集コマンドは直接バッファーのテキスト、つ
まりEmacs内部のコピーに適用されます。変更がファイルに反映されるのは、バ
ッファーをファイルに“保存(save)”したときだけです。

   ファイルのvisitや保存に加え、Emacsはファイルの削除、コピー、名前の変
更、ファイルへの追加、ファイルの複数バージョンの保持、ディレクトリーの操
作を行うことができます。

* Menu:

* File Names::               ファイル名引数をタイプ、編集する方法。
* Visiting::                 ファイルをvisitしてEmacsが編集する準備をする。
* Saving::                   保存して変更を永続化する。
* Reverting::                保存されていないすべての変更を取り消して前の状態に戻す。
* Autorevert:: 非ファイルバッファーの自動リバートについて。
* Auto Save::                定期的な自動保存によりデータを失うことから守る。
* File Aliases::             1つのファイルにたいする複数の名前を処理する。
* Directories::              ファイルディレクトリーの削除、作成、一覧。
* Comparing Files::          2つのファイルの異なる部分を探す。
* Diff Mode::                ファイルの異なる部分を編集するモード。
* Misc File Ops::            ファイルにたいして行うその他のコマンド。
* Compressed Files::         圧縮されたファイルへのアクセス。
* File Archives::            tar、zip、jar、...などのアーカイブファイルにたいする操作。
* Remote Files::             他のマシンにあるファイルへのアクセス。
* Quoted File Names::        ファイル名に含まれる特別な文字のクォート。
* File Name Cache::          補完のための、よく使うファイルの一覧。
* File Conveniences::        ファイルを探すための便利な機能。
* Filesets::                 複数ファイルの処理。


File: emacs-ja.info,  Node: File Names,  Next: Visiting,  Up: Files

18.1 ファイルの名前
===================

ファイルを操作するEmacsコマンドの多くは、ミニバッファー(*note Minibuffer
File::を)を使って、ファイル名の指定を求めます。

   ミニバッファーでは、通常の補完およびヒストリーコマンドを使うことがで
きます(*note Minibuffer::を参照してください)。ファイル名の補完では、ファ
イル名の拡張子が変数‘completion-ignored-extensions’に含まれているファイ
ルは無視されます(*note Completion Options::を参照してください)。またほと
んどのコマンドは、ファイルの読み込みにおいて、“確認をともなう寛大な補完
(permissive completion with confirmation)”を使います。この補完では、存在
しないファイル名が許されますが、存在しないファイル名の入力を完了するため
に<RET>をタイプすると、Emacsは‘[Confirm]’を表示し、この確認に同意するた
めに2番目の<RET>をタイプしなければなりません。詳細については、*note
Completion Exit::を参照してください。

   それぞれのバッファーは、バッファーローカルな変数‘default-directory’に
、“デフォルトのディレクトリー”を格納しています。ミニバッファーを使ってフ
ァイル名を読み取るとき、通常Emacsはミニバッファーの初期内容として、デフ
ォルトディレクトリーを挿入します。変数‘insert-default-directory’を
‘nil’に変更することにより、この挿入を抑制できます。常にEmacsは任意の相対
パスで指定されたファイル名を、デフォルトディレクトリーにたいする相対パス
とみなします。たとえばディレクトリーを指定しないファイル名は、デフォルト
ディレクトリーのファイルを指定します。

   ファイルをvisitするとき、Emacsはvisitしているバッファーの
‘default-directory’に、そのファイルのディレクトリーをセットします。‘C-x
b’のようなコマンドを通じて、ファイルをvisitしていないバッファーを新たに
作成すると、通常そのバッファーのデフォルトディレクトリーは、現在のバッフ
ァーのデフォルトディレクトリーをコピーします。現在のバッファーの
‘default-directory’の値を見るために、‘M-x pwd’コマンドを使用できます。
‘M-x cd’コマンドはディレクトリー名の入力を求め、バッファーの
‘default-directory’もそのディレクトリーをセットします(これを行うことによ
りバッファーのファイル名は変更されません)。

   例として、ファイル‘/u/rms/gnu/gnu.tasks’をvisitしているとします。この
ときデフォルトディレクトリーは‘/u/rms/gnu/’にセットされます。ファイル名
を読み取るコマンドを呼び出して、ミニバッファーでディレクトリー名を省略し
て単に‘foo’と入力すると、これはファイル‘/u/rms/gnu/foo’を指定したことに
なります。‘../.login’と入力すると‘/u/rms/.login’、‘new/foo’と入力すると
‘/u/rms/gnu/new/foo’を指定したことになります。

   ミニバッファーにファイル名をタイプするとき、2つのショートカットを使う
ことができます。2つのスラッシュは、“2番目のスラッシュの前にあるすべてを
無視する”と解釈されます。そして‘~/’は、ユーザーのホームディレクトリーと
解釈されます。*note Minibuffer File::を参照してください。

   文字‘$’は、ファイル名を置き換える環境変数の代用として使われます。環境
変数の名前は、‘$’の後ろのすべての英数字から構成されます。‘$’の後ろの、大
カッコ(braces)に囲まれた変数名も使用できます。たとえばシェルコマンド
‘export FOO=rms/hacks’は、名前が‘FOO’の環境変数をセットするために使われ
ます。すると‘/u/$FOO/test.c’と‘/u/${FOO}/test.c’はどちらも、
‘/u/rms/hacks/test.c’の省略形となります。環境変数が定義されていないとき
は、何の置き換えも発生せず、文字‘$’はそれ自身を意味します。環境変数は、
それがEmacsの開始前に適用されたときだけ、Emacsに影響を与えることに注意し
てください。

   ‘$’により環境変数が展開されるようなとき、名前に‘$’を含むファイルにア
クセスする場合は、‘$$’とタイプします。1つの‘$’が環境変数を展開するのと同
時に、2つのペアは1つの‘$’に変換されます。かわりにファイル名を‘/:’でクォ
ートすることもできます(*note Quoted File Names::を参照してください)。名
前が文字‘~’で始まるファイル名も、‘/:’でクォートするべきです。

   ファイル名に非ASCII文字を含めることができます。*note File Name
Coding::を参照してください。


File: emacs-ja.info,  Node: Visiting,  Next: Saving,  Prev: File Names,  Up: Files

18.2 ファイルのvisit(訪問)
==========================

‘C-x C-f’
     ファイルをvisitします(‘find-file’)。
‘C-x C-r’
     変更を許さない閲覧用として、ファイルをvisitします
     (‘find-file-read-only’)。
‘C-x C-v’
     最後にvisitしたファイルとは異なるファイルを、かわりにvisitします
     (‘find-alternate-file’)。
‘C-x 4 f’
     別のウィンドウでファイルをvisitします(‘find-file-other-window’)。選
     択されたウィンドウに表示されているものは変更しません。
‘C-x 5 f’
     新しいフレームでファイルをvisitします(‘find-file-other-frame’)。選
     択されたフレームに表示されているものは変更しません。
‘M-x find-file-literally’
     内容を変換せずにファイルをvisitします。

   ファイルを“Visiting(訪問)”するとは、そのファイル内容をEmacsのバッファ
ーに読み込むことを意味するので、それを編集することができます。Emacsは
visitするファイルごとに、新しいバッファーを作成します。

   ファイルをvisitするには、‘C-x C-f’ (‘find-file’)とタイプして、visitし
たいファイルの名前をミニバッファーで入力します。ミニバッファーでは、
‘C-g’をタイプして、コマンドを中止することができます。ミニバッファーでの
ファイル名の入力についての詳細は、*note File Names::を参照してください。

   ファイルは存在するが、システムが読み込みを許さない場合、エコーエリア
にエラーメッセージが表示されます。それ以外の場合、スクリーンに新しいテキ
ストが表示され、モードラインバッファー名が表示されることで、‘C-x C-f’が
成功したことを知ることができます。通常Emacsは、ファイル名からディレクト
リー名を省いて、バッファー名を作ります。たとえば‘/usr/rms/emacs.tex’とい
う名前のファイルは、バッファー名‘emacs.tex’となります。その名前のバッフ
ァーがすでにある場合、Emacsは一意な名前を作ります。通常の方法はディレク
トリー名にもとづく接尾辞の追加です(たとえば‘<rms>’、‘<tmp>’など)が、違う
方法を選択することもできます。*note Uniquify::を参照してください。

   新しいファイルを作成するには、同じコマンド‘C-x C-f’を使ってvisitする
だけです。Emacsはエコーエリアに‘(New file)’と表示しますが、他の点では既
存の空のファイルをvisitしたのと同じく振る舞います。

   ファイルをvisitした後で編集コマンドにより行われた変更は、Emacsのバッ
ファーに反映されます。バッファーを“保存(save)”するまでは、visitしている
ファイルに影響はありません。バッファーが保存されていない変更を含むとき、
そのバッファーが“変更されている(modified)”といいます。これはバッファーを
保存しなければ、その変更が失われることを意味します。モードラインの左余白
の近くに2つのアスタリスクが表示され、バッファーが変更されていることを示
します。

   すでにEmacsがvisitしているファイルをvisitした場合、‘C-x C-f’は他のコ
ピーを作らず既存のバッファーに切り替えます。切り替えを行う前に、最後に
visitまたは保存した後にファイルが変更されているか確認します。もしファイ
ルが変更されているとき、Emacsはそれの再読み込みを提案します。

   ‘large-file-warning-threshold’ (デフォルトは10000000で、これは約
10MB)より大きなファイルのvisitを試みると、Emacsは最初に確認を求めます。
‘y’を応えることにより、ファイルのvisitを続けます。しかしEmacsは、Emacsバ
ッファーの最大サイズ(Emacsが割り当てられるメモリー量の制限と、Emacsが扱
える整数により制限されます)を超えるバッファーは、visitできないことに注意
してください。この場合、Emacsは最大バッファーサイズを超えた旨を知らせる
エラーメッセージを表示します。

   ファイル名にシェル形式のワイルドカード文字が含まれている場合、Emacsは
それにマッチするすべてのファイルをvisitします。(大文字小文字を区別しない
ファイルシステムでは、Emacsは大文字小文字に関係なくワイルドカードをマッ
チします)。ワイルドカードには‘?’、‘*’および‘[...]’シーケンスが含まれます
。ミニバッファーでワイルドカード‘?’をファイル名に入力するには、‘C-q ?’と
タイプする必要があります。ワイルドカード文字を実際に名前に含むファイルを
visitする方法についての情報は、*note Quoted File Names::を参照してくださ
い。‘find-file-wildcards’をカスタマイズして、ワイルドカード機能を無効に
することができます。

   無意識に間違ったファイル名をタイプして違うファイルをvisitした場合、
‘C-x C-v’ (‘find-alternate-file’)で実際に望むファイルをvisitできます。
‘C-x C-v’は‘C-x C-f’と似ていますが、これは現在のバッファーをkillします
(変更されている場合は最初に保存するか確認を求めます)。‘C-x C-v’がvisitす
るファイルの名前を読み取るときは、ミニバッファーにデフォルトのファイル名
全体を挿入して、ポイントをディレクトリー名の後に置きます。これは名前を少
し間違えた場合などに便利です。

   実際はディレクトリーであるファイルを“visit”したとき、EmacsはEmacsのデ
ィレクトリーブラウザーのDiredを呼び出します。*note Dired::を参照してくだ
さい。この振る舞いは、変数‘find-file-run-dired’を‘nil’にセットすることに
より無効にできます。この場合、ディレクトリーをvisitするとエラーになりま
す。

   実際には他のファイルの集まりであるような“アーカイブファイル(file
archives)”の場合、アーカイブされたメンバーを操作できる、Diredに似た環境
を呼び出す特別なモードでvisitします。これらの機能については、*note File
Archives::を参照してください。

   オペレーティングシステムが変更を許していない、または読み取り専用にし
ているファイルをvisitした場合、Emacsもバッファーを読み取り専用にするので
、保存すると問題を起こすような変更を防ぐことができます。‘C-x C-q’
(‘read-only-mode’)で、バッファーを書き込み可能にできます。*note Misc
Buffer::を参照してください。

   予期せぬ入力による変更を防ぐために、読み込み専用でファイルをvisitした
い場合は、‘C-x C-f’のかわりにコマンド‘C-x C-r’ (‘find-file-read-only’)で
visitします。

   ‘C-x 4 f’ (‘find-file-other-window’)は‘C-x C-f’と同様ですが、指定した
ファイルを含むバッファーは、別のウィンドウで選択されます。‘C-x 4 f’の前
に選択されていたウィンドウは、すでに表示していたのと同じバッファーの表示
を続けます。1つのウィンドウしか表示されていないときにこのコマンドを使う
と、これはウィンドウを2つに分割し、1つのウィンドウには前に表示されていた
のと同じバッファー、別の1つには新しい要求されたファイルを表示します。
*note Windows::を参照してください。

   ‘C-x 5 f’ (‘find-file-other-frame’)も同様ですが、新しいフレームををオ
ープンするか、指定したファイルをすでに表示している既存のフレームを選択し
ます。*note Frames::を参照してください。

   グラフィカルなディスプレーでは、ファイルをvisitする追加の方法が２つあ
ります。1つ目は、Emacsが適したGUIツールキットによりビルドされているとき
、マウスによるコマンドの呼び出し(メニューバーやツールバーのクリックによ
る)は、ミニバッファーでファイル名の入力を求める代わりに、そのツールキッ
ト標準の“ファイル選択(File Selection)”ダイアログを表示します。
GNU/LinuxおよびUnixプラットフォームでは、GTK、LessTif、Motifツールキット
とともに構築されていると、Emacsはこれを行います。MS-WindowsとMacでは、
GUIバージョンのデフォルトにより行われます。これをカスタマイズする情報に
ついては、*note Dialog Boxes::を参照してください。

   2つ目は、Emacsはの“ドラッグアンドドロップ(drag and drop)”サポートで、
通常のEmacsウィンドウにファイルをドロップすることにより、そのウィンドウ
でファイルをvisitします。例外としてDiredバッファーを表示しているウィンド
ウにファイルをドロップすると、表示されているディレクトリーにファイルを移
動またはコピーします。詳細については*note Drag and Drop::と*note Misc
Dired Features::を参照してください。

   テキスト端末、およびGUIツールキットなしでビルドされているグラフィカル
なディスプレーでは、メニューバーの“File”メニューから、“Visit New File”ア
イテムを選択することにより、ファイルをvisitできます。

   文字エンコーディングと使用されている改行規則を検知するために、Emacsは
自動的に内容をスキャンします。そして、それらをEmacsの内部エンコーディン
グとバッファーの改行規則に変換します。バッファーを保存するとき、Emacsは
逆の変換を行い、元のエンコーディングと改行規則でファイルをディスクに書き
込みます。*note Coding Systems::を参照してください。

   ファイルにたいして特別なエンコーディングや変換を行わずに、非ASCII文字
のシーケンスとして編集したいときは、‘M-x find-file-literally’コマンドを
使います。これは‘C-x C-f’と同様ですが、フォーマット変換(*note Format
Conversion: (elisp)Format Conversion.を参照してください)、文字コード変換
(*note Coding Systems::を参照してください)、自動解凍(*note Compressed
Files::を参照してください)を行わず、‘require-final-newline’による最後の
改行も追加しません(*note Customize Save::を参照してください)。同じファイ
ルをすでに通常(非リテラル)の方法でvisitしている場合、このコマンドはそれ
をリテラル(そのままの文字の列)としてvisitするかを尋ねます。

   2つの特別なフック変数により、ファイルをvisitする操作を変更して拡張す
ることができます。存在しないファイルをvisitすることにより、
‘find-file-not-found-functions’の関数が実行されます。この変数は関数のリ
ストを保有し、それらはどれか1つが非‘nil’を返すまで、(引数を指定せずに
)1つずつ呼び出されます。これはノーマルフックではないため、その事実を示す
ために名前の最後が‘-hook’ではなく、‘-functions’で終わっています。

   ファイルが存在するしないにかかわらず、ファイルをvisitするのに成功する
と、引数なしで関数‘find-file-hook’を呼び出します。この変数はノーマルフッ
クです。ファイルが存在しない場合、最初に
‘find-file-not-found-functions’を実行します。*note Hooks::を参照してくだ
さい。

   ファイルを編集するために自動的にメジャーモードを指定し(*note Choosing
Modes::を参照してください)、そのファイルのために特別なローカル変数を定義
する方法がいくつかあります(*note File Variables::を参照してください)。


File: emacs-ja.info,  Node: Saving,  Next: Reverting,  Prev: Visiting,  Up: Files

18.3 ファイルの保存
===================

Emacsでのバッファーの“保存(Saving)”は、バッファーの内容を、そのバッファ
ーによりvisitされているファイルに書き戻すことを意味します。

* Menu:

* Save Commands::            ファイルを保存するコマンド。
* Backup::                   Emacsがファイルの古いバージョンを保存する方法。
* Customize Save::           ファイルの保存のカスタマイズ。
* Interlocking::             Emacsが2人のユーザーによる1つのファイルへの同時編集から保護する方法。
* Shadowing: File Shadowing.  ファイルを自動的に"shadows"コピーする。
* Time Stamps::              Emacsによる保存されたファイルのタイムスタンプの更新。


File: emacs-ja.info,  Node: Save Commands,  Next: Backup,  Up: Saving

18.3.1 ファイルを保存するコマンド
---------------------------------

ファイルの保存と書き込みに関するコマンドが、いくつかあります。

‘C-x C-s’
     現在のバッファーを、そのファイルに保存します(‘save-buffer’)。
‘C-x s’
     任意、またはすべてのバッファーを、それらのファイルに保存します
     (‘save-some-buffers’)。
‘M-~’
     現在のバッファーが変更されたことを忘れます(‘not-modified’)。プレフ
     ィクス引数(‘C-u’)を指定すると、現在のバッファーを変更済みとマークし
     ます。
‘C-x C-w’
     現在のバッファーを、指定したファイル名で保存します(‘write-file’)。
‘M-x set-visited-file-name’
     現在のバッファーが保存される場所で、ファイル名を変更します。

   ファイルを保存して変更を永続化させたいときは、‘C-x C-s’
(‘save-buffer’)とタイプします。保存が完了すると、‘C-x C-s’は以下のような
メッセージを表示します:

     Wrote /u/rms/gnu/gnu.tasks

現在のバッファーが変更されていない(新規作成されたとき、または最後に変更
されたときから変更していない)場合、保存しても意味がないので実際の保存は
行われません。かわりに‘C-x C-s’は、エコーエリアに以下のようなメッセージ
を表示します:

     (No changes need to be saved)

   ‘C-u C-x C-s’のようにプレフィクス引数を指定すると、Emacsはそのバッフ
ァーを次回の保存が行われるときバックアップするようマークします。*note
Backup::を参照してください。

   コマンド‘C-x s’ (‘save-some-buffers’)は、任意、またはすべての変更され
たバッファーの保存を提案します。これはバッファーごとに何を行うか尋ねます
。使用できる応答は、‘query-replace’と同様です。

‘y’
     このバッファーを保存し、残りのバッファーについて尋ねます。
‘n’
     このバッファーは保存せずに、残りのバッファーについて尋ねます。
‘!’
     このバッファーを保存し、残りのバッファーを尋ねることなくすべて保存
     します。
‘<RET>’
     これ以上の保存をせずに、‘save-some-buffers’を終了します。
‘.’
     このバッファーを保存したら、他のバッファーをどうするか尋ねることな
     く、‘save-some-buffers’を終了します。
‘C-r’
     現在尋ねられているバッファーを閲覧します。Viewモードから抜けると、
     再び‘save-some-buffers’はどうするか尋ねます。
‘d’
     そのバッファーに対応するファイルとDiffをとり、どのような変更を保存
     するのか確認できます。これはコマンド‘diff-buffer-with-file’ (*note
     Comparing Files::を参照してください)を呼び出します。
‘C-h’
     これらのオプションについての、ヘルプメッセージを表示します。

   Emacsを終了するキーシーケンス‘C-x C-c’は、‘save-some-buffers’を呼び出
すので、同じ質問をします。

   バッファーを変更したが変更を保存したくないとき、保存されるのを防ぐた
めにできることがいくつかあります(それ以外の‘C-x s’または‘C-x C-c’で間違
って保存してしまうのはあなたの責任です)。まずできることは、‘M-~’
(‘not-modified’)とタイプすることで、これはバッファーが変更されているとい
うマークをクリアーします。これを行うと、保存コマンドに、バッファーが保存
を必要しないと信じこませることができます(‘~’は数学のシンボルで、‘not(否
定)’として使われることがあります。したがって‘M-~’はメタと‘not’になります
。)。かわりにファイルからテキストを読み込むことにより、ファイルをvisitま
たは保存された後に行った、すべての変更を取り消すことができます。これは
“リバート(reverting: 復元)”と呼ばれます。*note Reverting::を参照してくだ
さい(undoコマンド‘C-x u’を繰り返すことにより、変更がすべての変更を取り消
すこともできますが、リバートの方が簡単です)。

   ‘M-x set-visited-file-name’は、現在のバッファーがvisitしているファイ
ルの名前を変更します。このコマンドはミニバッファーを使って、新しいファイ
ル名を読み取ります。その後に、そのバッファーがそのファイル名のファイルを
visitしているとマークし、バッファー名も合わせて変更します。
‘set-visited-file-name’は、新しくvisitするファイルへの保存はしません。こ
れは後で保存するときのために、Emacs内のレコードを変更するだけです。これ
はバッファーを“変更されている(modified)”とマークするので、そのバッファー
での_将来_の‘C-x C-s’で、保存が行われます。

   バッファーにたいして、違うファイルをvisitしているとマークしてすぐに保
存したい場合は、‘C-x C-w’ (‘write-file’)を使います。このコマンドは、
‘set-visited-file-name’の後すぐに‘C-x C-s’をするのと同じですが、‘C-x
C-w’はファイルが存在するとき確認を求める点が異なります。ファイルを
visitしていないバッファーでの‘C-x C-s’は、‘C-x C-w’と同じ効果をもちます
。したがってファイル名を読み取り、バッファーがそのファイルをvisitしてい
るとマークした後、バッファー内容をそのファイルに保存します。ファイルを
visitしていないバッファーのデフォルトファイル名は、バッファー名と、バッ
ファーのデフォルトディレクトリーから合成されます(*note File Names::を参
照してください)。

   新しいファイル名が何らかのメジャーモードに関連する場合、大抵は‘C-x
C-w’によりそのメジャーモードへの切り替えが行われます。コマンド
‘set-visited-file-name’もこれを行います。*note Choosing Modes::を参照し
てください。

   Emacsがファイルを保存する際、ディスクの最新バージョンのファイル日付を
確認して、それがEmacsが最後に読み込み、または書き込みしたときと異なる場
合、Emacsはその事実をユーザーに知らせます。なぜならそれはおそらく同時編
集による問題を示しており、それをすぐにユーザーに知らせる必要があるからで
す。*note Simultaneous Editing: Interlocking.を参照してください。


File: emacs-ja.info,  Node: Backup,  Next: Customize Save,  Prev: Save Commands,  Up: Saving

18.3.2 バックアップファイル
---------------------------

ほとんどのオペレーティングシステムでは、ファイルを書き換えるとファイルに
入っていたそれまでの記録は、自動的に破棄されます。したがって、Emacsでフ
ァイルを保存すると、ファイルの古い内容は捨てられます。しかし実際に保存す
る前に、Emacsが慎重に古い内容を“バックアップ(backup)”ファイルと呼ばれる
別のファイルにコピーすれば、古い内容は失われません。

   Emacsは最初にバッファーからファイルに保存されたときだけ、バックアップ
ファイルを作成します。その後ファイルを何回保存しようと、バックアップは変
更されません。しかしバッファーをkillしてから、そのファイルを再びvisitす
ると、新しいバックアップファイルが作成されます。

   ほとんどのファイルにたいして、変数‘make-backup-files’はバックアップフ
ァイルを作るかを決定します。ほとんどのオペレーティングシステムでは、デフ
ォルト値は‘t’なので、Emacsはバックアップファイルを書き込みます。

   バージョンコントロールシステム(version control system: *note Version
Control::を参照してください)で管理されているファイルにたいして、バックア
ップファイルを作るかは、変数‘vc-make-backup-files’により決定されます。バ
ージョンコントロールシステムに以前のバージョンがある場合、バックアップフ
ァイルを作るのは不必要なので、デフォルト値は‘nil’です。 *Note General VC
Options::を参照してください。

   選択できるオプションは、Emacsにファイルごとに1つのバックアップを作ら
せる方法と、編集するファイルごとに番号がついた、一連のファイルを作る方法
があります。*note Backup Names::を参照してください。

   変数‘backup-enable-predicate’のデフォルト値は、一時的なファイルのため
に使われるディレクトリー(変数‘temporary-file-directory’または
‘small-temporary-file-directory’で指定されます)のファイルは、バックアッ
プしないような値になっています。

   前に保存されたバッファーにたいしても、バッファーから他のバックアップ
ファイルを作るよう、Emacsに明示的に指示することができます。バッファーを
‘C-u C-x C-s’で保存すると、この保存したバージョンが、次にバックアップす
るときのバックアップになります。‘C-u C-u C-x C-s’はバッファーを保存しま
すが、最初に元のファイル内容を新しいバックアップファイルとします。‘C-u
C-u C-u C-x C-s’は両方を行います。まず前の内容でバックアップを作成し、次
回に保存したときは、今回保存したものをバックアップにします。

* Menu:

* Names: Backup Names.       バックアップファイルの命名方法。
* Deletion: Backup Deletion.  Emacsによる余分な番号つきバックアップの削除。
* Copying: Backup Copying.   コピーとリネームによるバックアップの作成。


File: emacs-ja.info,  Node: Backup Names,  Next: Backup Deletion,  Up: Backup

18.3.2.1 単一または番号つきバックアップ
.......................................

Emacsのバックアップファイル作成では、バックアップの名前は通常、編集され
るファイル名の後ろに‘~’をつけて作成されます。したがって‘eval.c’のバック
アップファイルは、‘eval.c~’になります。

   アクセスコントロールによりEmacsが通常の名前でバックアップファイルを書
き込めない場合、‘~/.emacs.d/%backup%~’というバックアップファイルに書き込
みます。この1つのファイルしか存在しないので、一番最近作られたバックアッ
プだけが利用可能です。

   Emacsは“番号つきバックアップファイル(numbered backup files)”を作るこ
ともできます。番号つきバックアップファイルの名前は、元のファイル名の後ろ
に‘.~’と番号と‘~’をつけたものです。したがって‘eval.c’のバックアップファ
イルは、‘eval.c.~1~’、‘eval.c.~2~’、...、‘eval.c.~259~’、...となります。

   変数‘version-control’は、単一のバックアップファイルを作るか、複数の番
号つきバックアップファイルを作るかを決定します。有効な値は以下のとおりで
す:

‘nil’
     すでに番号つきバックアップのあるファイルにたいしては、番号つきバッ
     クアップを作ります。それ以外は単独のバックアップをつくります。これ
     がデフォルトです。
‘t’
     番号つきバックアップを作ります。
‘never’
     番号つきバックアップをつくらず、常に単一のバックアップを作ります。

この変数をセットする通常の方法は、initファイルやcustomizationバッファー
を通じて、グローバルにセットする方法です。しかし特定のバッファーにローカ
ルに‘version-control’をセットして、そのバッファーのバックアップ作成を制
御することができます(*note Locals::を参照してください)。特定のファイルを
visitするとき、常にEmacsに‘version-control’をローカルにセットさせること
ができます(*note File Variables::を参照してください)。Rmailモードのよう
ないくつかのモードは、この変数をセットします。

   さまざまなGNUユーティリティーにたいして、何をすべきか指示する環境変数
‘VERSION_CONTROL’をセットすると、Emacsも開始時にこの環境変数にしたがって
、Lisp変数‘version-control’をセットします。環境変数の値が‘t’または
‘numbered’のときは、‘version-control’は‘t’になります。値が‘nil’または
‘existing’のときは、‘version-control’は‘nil’になります。もし‘never’また
は‘simple’のときは、‘version-control’は‘never’になります。

   変数‘backup-directory-alist’をカスタマイズして、指定したパターンにマ
ッチする特定のファイルにたいして、指定したディレクトリーにバックアップを
作成させることができます。この変数は単独、または複数の番号つきバックアッ
プの両方に適用されます。典型的な使い方は、要素‘("." . DIR)’を追加するこ
とにより、すべてのバックアップを絶対パスDIRに作る方法です。異なるディレ
クトリーにある同じ名前のファイルによる、バックアップファイルの名前の衝突
を避けるため、Emacsはバックアップファイルの名前を変更します。‘("." .
".~")’を追加すると、これは元のファイルがあるディレクトリーに、非表示の
‘.~’というディレクトリーを作って、そこにバックアップを作成します。
Emacsはバックアップを作るため、必要ならディレクトリーを作成します。

   変数‘make-backup-file-name-function’に適切なLisp関数をセットすること
により、Emacsがバックアップファイル名を作る通常の方法をオーバーライドで
きます。


File: emacs-ja.info,  Node: Backup Deletion,  Next: Backup Copying,  Prev: Backup Names,  Up: Backup

18.3.2.2 バックアップの自動削除
...............................

ディスク容量の過度な消費を防ぐため、Emacsは自動的に番号つきバックアップ
を削除することができます。一般的にEmacsは一番古いバックアップと、一番新
しいバックアップをいくつか保持し、その間にあるバックアップを削除します。
これは新しいバックアップが作られる度に行なわれます。

   2つの変数‘kept-old-versions’および‘kept-new-versions’が、この削除を制
御します。これらの変数の値は順に、削除せずに残す一番古い番号(小さい番号
)のバックアップと、一番新しい番号(大きい番号)で、新しいバックアップが作
られる度に評価されます。中間のバックアップ(一番古いものと一番新しいもの
を除いたもの)は、余分なバージョンで、これらのバックアップは削除されます
。これらの変数の値は余分なバージョンを削除するとき、つまり新しいバックア
ップが作られた直後に使われます。新しく作られたバックアップは、
‘kept-new-versions’のカウントに含まれます。デフォルトでは、両方の変数の
値は2です。

   ‘delete-old-versions’が‘t’のとき、Emacsは何も尋ねずに余分なバックアッ
プファイルを削除します。‘nil’(デフォルト)のとき、Emacsは余分なバージョン
のバックアップを削除するか尋ねます。他の値の場合、Emacsはバックアップの
自動削除をしません。

   Diredの‘.’(ピリオド)コマンドでも、古いバージョンを削除できます。*note
Dired Deletion::を参照してください。


File: emacs-ja.info,  Node: Backup Copying,  Prev: Backup Deletion,  Up: Backup

18.3.2.3 コピー vs. リネーム
............................

バックアップファイルは、古いファイルをコピーまたはリネームすることで作る
ことができます。コピーとリネームは、古いファイルが複数の名前をもつ場合
(ハードリンクされている場合)に、異なる効果をもちます。古いファイルがバッ
クアップファイルにリネームされた場合、ハードリンクされた別の名前で参照さ
れるファイルは、バックアップファイルとなります。かわりに古いファイルをコ
ピーすると、ハードリンクされた別の名前で参照されるファイルは、編集中のフ
ァイルのままで、それらの名前でアクセスする内容は新しい内容となります。

   バックアップファイルを作る方法は、編集中のファイルの所有者とグループ
にも影響します。コピーが使われた場合、それらは変化しません。リネームが使
われた場合、そのユーザーがファイルの所有者となり、ファイルのグループはデ
フォルト(オペレーティングシステムごとにグループのデフォルトは異なります
)のグループになります。

   リネームとコピーの選択は、以下の変数により行われます:

   • 変数‘backup-by-copying’が非‘nil’(デフォルトは‘nil’)の場合、コピーが
     使用されます。

   • 上記以外の場合、変数‘backup-by-copying-when-linked’が非‘nil’(デフォ
     ルトは‘nil’)で、ファイルが複数の名前をもつ場合は、コピーが使用され
     ます。

   • 上記以外の場合、変数‘backup-by-copying-when-mismatch’が非‘nil’(デフ
     ォルトは‘t’)で、リネームによりファイルの所有者かグループが変更され
     る場合は、コピーが使用されます。

     ‘backup-by-copying-when-mismatch’を‘nil’に変更すると、Emacsはファイ
     ルの所有者のユーザーIDの数字をチェックします。もしこの数字が
     ‘backup-by-copying-when-privileged-mismatch’の値より大きい場合、
     ‘backup-by-copying-when-mismatch’が非‘nil’であるかのように振る舞い
     ます。

   • 上記以外の場合、リネームがデフォルトの選択となります。

   ファイルがバージョンコントロールシステムで管理されている場合(*note
Version Control::を参照してください)、通常、Emacsは普通の方法でそのファ
イルのバックアップを作りません。しかしチェックインとチェックアウトは、バ
ックアップを作るのと似たところがあります。これらの操作は通常ハードリンク
をこわし、同じファイルにたいする別のファイル名でのvisitを切断します。
Emacsにできることはありません。バージョンコントロールシステムがこれを行
うのです。


File: emacs-ja.info,  Node: Customize Save,  Next: Interlocking,  Prev: Backup,  Up: Saving

18.3.3 ファイル保存のカスタマイズ
---------------------------------

変数‘require-final-newline’の値が‘t’のとき、ファイルの保存または書き込み
により、ファイルの終端に改行がないときは、何も尋ねずに改行を追加します。
値が‘visit’の場合、Emacsはファイルをvisitした直後に、終端に改行がないフ
ァイルの改行を追加します(これによりバッファーは変更されたとマークされま
す。undoはできません)。値が‘visit-save’の場合、Emacsはそのような改行を
visitと保存のときに追加します。値が‘nil’の場合、Emacsはファイルの終端を
変更しません。それ以外の非‘nil’値は、改行を追加するか尋ねることを意味し
ます。デフォルトは‘nil’です。

   ファイルの終端に常に改行があると想定する、特定の種類のファイルのため
にデザインされたメジャーモードがいくつかあります。そのようなメジャーモー
ドは、変数‘require-final-newline’に、変数‘mode-require-final-newline’の
値(デフォルトは‘t’)をセットします。後者の変数の値をセットすることにより
、これらのモードが終端の改行を取り扱う方法を制御できます。

   通常プログラムがファイルに書き込むとき、オペレーティングシステムはデ
ータをディスクにコミットする前に、ファイルのデータをメインメモリーにキャ
ッシュします。これにより大幅にパフォーマンスを向上できます。たとえばラッ
プトップを使っている場合、ファイルを書き込む度にディスクをスピンアップ
(spin-up)しなくて済みます。しかし、キャッシュをディスクにコミットする前
にオペレーティングシステムがクラッシュすることにより、データを失うリスク
もあります。

   このリスクを減少させるため、Emacsはファイルを保存した後に‘fsync’シス
テムコールを呼び出すことができます。‘fsync’により、データを失うリスクを
皆無にすることはできません。その理由の一部は、多くのシステムは‘fsync’を
正しく実装していないことであり、他の理由の一部はEmacsのファイル保存手段
は通常ディレクトリー更新に頼っており、これは‘fsync’が正しく実装されてい
ても、クラッシュを生き延びることはできないでしょう。

   ‘write-region-inhibit-fsync’変数は、ファイルを保存した後にEmacsが
‘fsync’を呼び出すかを制御します。この変数のデフォルト値は、Emacsを対話的
に使用しているときは‘nil’、バッチモードの時は‘t’です。

   Emacsは自動保存ファイルの書き込みに‘fsync’を使うことはありません。な
ぜなら、それらのファイルのデータは、いずれにせよ失われるものだからです。


This is emacs.info, produced by makeinfo version 6.1 from emacs.texi.

This is the ‘GNU Emacs Manual’, updated for Emacs version 24.5.

   Copyright © 2015–2016 Ayanokoji Takesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).            拡張可能なセルフドキュメント形式のテキストエディター。
END-INFO-DIR-ENTRY


File: emacs.info,  Node: Rmail Coding,  Next: Rmail Editing,  Prev: Rmail Display,  Up: Rmail

33.14 Rmailとコーディングシステム
=================================

Rmailは、Emacsがファイルをvisitしたりサブプロセスの出力にたいして行なう
ように、非ASCII文字を含むメッセージを自動的にデコードします。Rmailはメッ
セージで標準の‘charset=CHARSET’ヘッダーを使用し、もしそれがあれば、送信
者によりメッセージがどのようにエンコードされたか決定します。これは
CHARSETを、対応するEmacsコーディングシステム(*note Coding Systems::を参
照してください)にマップして、メッセージテキストをデコードするために、そ
のコーディングシステムを使います。メッセージヘッダーに‘charset’指定がな
い場合、またはCHARSETが認識されなかった場合、Rmailは通常のEmacsの経験則
とデフォルトに則ったコーディングシステムを選択します(*note Recognize
Coding::を参照してください)。

   メッセージが間違ってデコードされることもあります。これは‘charset’指定
がないためにEmacsが間違ったコーディングシステムを推測したか、そもそも指
定が間違っているかです。たとえば間違って設定されたメーラーが、メッセージ
が実際には‘koi8-r’でエンコードされているのに、‘charset=iso-8859-1’という
ヘッダーでメッセージを送るかもしれません。メッセージテキストが文字化けし
ていたり、文字が16進コードや空ボックスで表示されているときは、おそらくこ
れが発生しています。

   正しいコーディングシステムを解決または推測できる場合、正しいコーディ
ングシステムを使ってメッセージを再デコードすることにより、問題を訂正する
ことができます。これを行なうには‘M-x rmail-redecode-body’コマンドを呼び
出します。これはコーディングシステムの名前を読み取り、指定したコーディン
グシステムを使って、メッセージを再デコードします。正しいコーディングシス
テムを指定した場合、デコード結果は読めるようになるでしょう。

   Rmailで新しいメールを受信したとき、各メッセージは、それらがあたかも個
別のファイルであるかのように、それぞれが記述されたコーディングシステムに
自動的に変換されます。これは指定されたコーディングシステムの優先順を使用
します。MIMEメッセージが文字セットを指定している場合、Rmailはその指定に
したがいます。Rmailファイルの読み込みと保存にたいして、Emacsは、変数
‘rmail-file-coding-system’で指定されたコーディングシステムを使用します。
デフォルト値は‘nil’で、これはRmailファイルが変換されないことを意味します
(これらはEmacsの内部文字セットで読み書きされます)。


File: emacs.info,  Node: Rmail Editing,  Next: Rmail Digest,  Prev: Rmail Coding,  Up: Rmail

33.15 メッセージの編集
======================

通常のEmacsのキーバインドのほとんどはRmailモードで利用可能ですが、
‘C-M-n’や‘C-M-h’のように、他の目的のためにRmailにより再定義されているも
のもあります。しかしRmailバッファーは通常読み取り専用で、ほとんどの文字
はRmailコマンドに再定義されています。メッセージのテキストを編集したい場
合、Rmailの‘e’コマンドを使わなければなりません。

‘e’
     カレントメッセージを通常のテキストとして編集します。

   ‘e’ command (‘rmail-edit-current-message’)は、Rmailモードから、Rmail
Editモードという、Textモードと類似した、別のメジャーモードに切り替えます
。メジャーモードの変更はモードラインに示されます。

   Rmail Editモードでは、文字は通常どおり文字自身を挿入し、Rmailコマンド
は利用できません。メッセージの本文とヘッダーフィールドを編集することがで
きます。メッセージの編集を終えたら、‘C-c C-c’でRmailモードに戻ります。か
わりに‘C-c C-]’とタイプすれば、編集をキャンセルしてRmailモードに戻ること
ができます。

   Rmail Editモードに入ることにより、フック‘text-mode-hook’、その後にフ
ック‘rmail-edit-mode-hook’が実行されます(*note Hooks::を参照してください
)。通常のRmailモードにもどると、メッセージを変更した場合には、そのメッセ
ージに属性‘edited’が追加されます。


File: emacs.info,  Node: Rmail Digest,  Next: Rmail Rot13,  Prev: Rmail Editing,  Up: Rmail

33.16 ダイジェストメッセージ
============================

“ダイジェストメッセージ(digest message)”は、複数の他のメッセージを含み、
それを運ぶために存在するメッセージです。ダイジェストは、いくつかのメーリ
ングリストで使用されています。1日というような一定の期間の間にメーリング
リストに到着したすべてのメッセージが、1つのダイジェストにまとめられて、
メーリングリストに登録した人に送られます。1つのダイジェストを送信するの
にかかるコンピューター時間は、たとえ合計サイズが同じでも個別にメッセージ
を送信するより短くなります。なぜならネットワークでのメール送信において、
メッセージ単位のオーバーヘッドがあるからです。

   ダイジェストメッセージを受信したとき、それを読むもっとも便利な方法は
、それを“非ダイジェスト化(undigestify)”することです。これはダイジェスト
を複数のメッセージに戻します。それから個別にメッセージを読んだり削除でき
ます。これを行なうにはダイジェストメッセージを選択して、コマンド‘M-x
undigestify-rmail-message’をタイプします。これはダイジェストに含まれるメ
ッセージを個別のRmailメッセージに抽出し、ダイジェストの後に挿入します。
ダイジェストメッセージ自身には、削除のフラグがつけられます。


File: emacs.info,  Node: Rmail Rot13,  Next: Movemail,  Prev: Rmail Digest,  Up: Rmail

33.17 Rot13メッセージを読む
===========================

読む人を怒らせたり不快にするかもしれないメーリングリストのメッセージは、
“rot13”と呼ばれる単純なコードでエンコードされているときがあります。この
名前は、エンコードの方法がアルファベットを13文字分巡回させることに由来し
ます。このコードに機密性はなく、それを提供もしません。むしろ、実際のテキ
ストを見るのを避けたいと思う人のためのものです。たとえばビデオの講評など
では、重要なあらすじを隠すためにrot13を使います。

   rot13を使ったバッファーを閲覧するには、コマンド‘M-x
rot13-other-window’を使用します。これはカレントバッファーを他のウィンド
ウで表示します。このウィンドウではテキストを表示するときこのコードを適用
します。


File: emacs.info,  Node: Movemail,  Next: Remote Mailboxes,  Prev: Rmail Rot13,  Up: Rmail

33.18 ‘movemail’プログラム
==========================

Rmailは、inboxからRmailファイルにメールを移動するために、‘movemail’プロ
グラムを使用します。最初にロードされたとき、Rmailは‘movemail’プログラム
を探して、そのバージョンを判断します。‘movemail’プログラムには2つのバー
ジョンがあります。生来のものはGNU Emacsと共に配布されるもの(“emacsバージ
ョン”)で、もう1つはGNU mailutilsに含まれるもの(“mailutilsバージョン”。
*note (mailutils)movemail::を参照してください)です。これらのコマンドは、
同じコマンドラインシンタックスをもち、同じ基本的なサブセットオプションを
もちます。しかしMailutilsバージョンは、追加の機能を提供します。

   Emacsバージョンの‘movemail’は、通常のUnix mailbox形式と、POP3プロトコ
ルを使用してリモートのmailboxからメールを取得することができます。

   Mailutilsバージョンは、プレーンUnix mailbox、‘maildir’および‘MH’のメ
ールボックスなどの、より広範なmailbox形式を処理することができます。これ
はPOP3またはIMAP4プロトコルを使用してリモートのmailboxにアクセスでき、
TLS暗号化チャンネル(TLS encrypted channel)を使用してメールを取得できます
。これはURL形式でのmailbox引数を受けとることもできます。mailboix URLの詳
細な説明は、*note (mailutils)URL::で見ることができます。短く言うと、
URLは以下のようなものです:

     PROTO://[USER[:PASSWORD]@]HOST-OR-FILE-NAME

角カッコ(bracket)はオプションの要素を意味します。

PROTO
     “mailboxプロトコル”、または使用する“フォーマット”を指定します。
     URLの残りの要素の正確な意味は、PROTOの実際の値に依存します(以下参照
     )。

USER
     リモートmailboxにアクセスするためのユーザー名です。

PASSWORD
     リモートmailboxにアクセスするためのユーザーパスワードです。

HOST-OR-FILE-NAME
     リモートmailboxのリモートサーバーのホスト名、またはローカル
     mailboxのファイル名です。

PROTOには以下の1つを指定します:

‘mbox’
     通常のUnix mailbox形式です。この場合USERとPASSは使用せず、
     HOST-OR-FILE-NAMEはmailboxファイルのファイル名を意味します(例:
     ‘mbox://var/spool/mail/smith’)。

‘mh’
     MH形式のローカルmailboxです。USERとPASSは使用せず、
     HOST-OR-FILE-NAMEはMHフォルダーのファイル名を意味します(例:
     ‘mh://Mail/inbox’)。

‘maildir’
     maildir形式のローカルmailboxです。USERとPASSは使用せず、
     HOST-OR-FILE-NAMEは‘maildir’ mailboxの名前を意味します(例:
     ‘maildir://mail/inbox’)。

‘file’
     任意のmailbox形式です。実際の形式は‘movemail’により自動的に決定され
     ます。

‘pop’
     POP3プロトコルを通じてアクセスされるリモートmailboxです。USERは使用
     するリモートのユーザー名を指定し、PASSはユーザーパスワードを指定す
     るのに使用され、HOST-OR-FILE-NAMEは接続するリモートメールサーバーの
     ホスト名かIPアドレスです(例:
     ‘pop://smith:guessme@remote.server.net’)。

‘imap’
     IMAP4プロトコルを通じてアクセスされるリモートmailboxです。USERは使
     用するリモートのユーザー名を指定し、PASSはユーザーパスワードを指定
     するのに使用され、HOST-OR-FILE-NAMEは接続するリモートメールサーバー
     のホスト名かIPアドレスです(例:
     ‘imap://smith:guessme@remote.server.net’)。

   かわりに、使用するmailboxのファイル名を指定できます。これはプロトコル
に‘file’を指定するのと等価です:

     /var/spool/mail/USER ≡ file://var/spool/mail/USER

   変数‘rmail-movemail-program’は、どのバージョンの‘movemail’を使用する
かを制御します。文字列の場合、それは‘movemail’実行ファイルの絶対ファイル
名を指定します。‘nil’の場合、Rmailは‘rmail-movemail-search-path’、
‘exec-path’(*note Shell::を参照してください)、‘exec-directory’の順で、こ
れらの変数にリストされたディレクトリーから、‘movemail’を検索します。


File: emacs.info,  Node: Remote Mailboxes,  Next: Other Mailbox Formats,  Prev: Movemail,  Up: Rmail

33.19 リモートmailboxからのメールの取得
=======================================

inboxファイルにデータを格納するかわりに、ユーザーのinboxデータにアクセス
するために、POPと呼ばれる方式を使うサイトがいくつかあります。デフォルト
では、‘Emacs movemail’はPOPで動作します(ただしEmacsの‘configure’スクリプ
トが、オプション‘--without-pop’)を指定して実行された場合を除きます)。

   同様にMailutils ‘movemail’も、デフォルトでPOPをサポートします(ただし
‘--disable-pop’オプションを指定してconfigureされた場合を除きます)。

   どちらのバージョンの‘movemail’もPOP3だけで動作し、それより古いバージ
ョンのPOPでは動作しません。

   どちらの‘movemail’を使用するかにかかわらず、POP “URL”(*note
Movemail::)を使用してPOP inboxを指定できます。POP URLは、
‘pop://USERNAME@HOSTNAME’という形式の“ファイル名”で、HOSTNAMEはリモート
メールサーバーのホスト名かIPアドレス、USERNAMEはそのサーバーでのユーザー
名です。これに加えて‘pop://USERNAME:PASSWORD@HOSTNAME’のようなmailbox
URLでパスワードを指定することもできます。この場合、PASSWORDは
‘rmail-remote-password’で指定された値より優先されます(以下参照)。これは
複数のリモートメールサーバーで異なるパスワードを指定するとき、特に便利で
す。

   後方互換のため、RmailはリモートのPOP mailboxを指定する他の方法もサポ
ートします。‘po:USERNAME:HOSTNAME’によるinbox名の指定は、
‘pop://USERNAME@HOSTNAME’と等価です。:HOSTNAMEの部分を省略した場合、環境
変数‘MAILHOST’で、どのマシンのPOPサーバーを探すか指定します。

   リモートmailboxesにアクセスする他の方法に、IMAPがあります。この方法は
Mailutils ‘movemail’だけでサポートされます。inboxリストでIMAP mailboxを
指定するには、‘imap://USERNAME[:PASSWORD]@HOSTNAME’の形式のmailbox URLを
使用します。上記で説明したように、PASSWORDの部分はオプションです。

   リモートmailboxへのアクセスにはパスワードが要求されます。これを取得す
るためにRmailは以下のアルゴリズムを使います:

  1. mailbox URL(上記参照)でPASSWORDが与えられた場合はそれを使います。
  2. 変数‘rmail-remote-password-required’が‘nil’の場合、Rmailはパスワー
     ドが要求されないと想定します。
  3. 変数‘rmail-remote-password’が非‘nil’の場合はその値を使います。
  4. 上記以外の場合、Rmailはパスワードの入力を求めます。

   追加のコマンドラインフラグを‘movemail’に渡す必要がある場合は、使いた
いフラグのリストを変数‘rmail-movemail-flags’にセットします。inboxの内容
を保持するために。この変数を使ってフラグ‘-p’を渡さないでください。かわり
に‘rmail-preserve-inbox’を使用してください。

   あなたのサイトにインストールされた‘movemail’プログラムは、ケルベロス
認証(Kerberos authentication)をサポートするでしょう(Emacsが
‘--with-kerberos’または‘--with-kerberos5’のオプションでconfigureされてい
る場合、Emacs ‘movemail’はこれを行ないます)。もしサポートされている場合
、‘rmail-remote-password’および‘rmail-remote-password-required’がセット
されていないときに、POPメールの取得を試みたときは、デフォルトでケルベロ
ス認証を使います。

   メッセージを逆順に保存するPOPサーバーもあります。あなたのサーバーがこ
れを行なっている場合、到着した順にメールを読みたいときは、
‘rmail-movemail-flags’に‘-r’フラグを追加することにより、逆順でメッセージ
をダウンロードするよう、‘movemail’に指示できます。

   Mailutils ‘movemail’は、TLS暗号化(TLS encryption)をサポートします。こ
れを使いたい場合は、‘rmail-movemail-flags’に‘--tls’フラグをセットしてく
ださい。


File: emacs.info,  Node: Other Mailbox Formats,  Prev: Remote Mailboxes,  Up: Rmail

33.20 さまざまな形式のローカルmailboxからのメールの取得
=======================================================

受信したメールがローカルマシンのUnix mailbox以外の形式に保存される場合、
これを取得するためにMailutils ‘movemail’を使う必要があるでしょう。
‘movemail’のバージョンについての詳細な説明は、*note Movemail::を参照して
ください。たとえば‘/var/spool/mail/in’にある‘maildir’形式のinboxのメール
にアクセスするには、Rmailのinboxリストに以下を含める必要があるでしょう:

     maildir://var/spool/mail/in


File: emacs.info,  Node: Gnus,  Next: Document View,  Prev: Rmail,  Up: Top

34 Gnus
*******

Gnusは、主にUsenetニュースを読んだりポストするためにデザインされた、
Emacsパッケージです。これはいくつかの異なるソース — 電子メール、リモート
ディレクトリー、ダイジェスト、などを読んだり、メッセージを返すためにも使
うことができます。以下はGnusの紹介と、いくつかの基本的な機能の説明です。
完全な詳細に付いては、*note Gnus: (gnus)Top.を参照してください。

* Menu:

* Buffers of Gnus::          グループ、サマリー、アーティクルバッファー。
* Gnus Startup::             Gnusの開始するにあたって知っておくべきこと。
* Gnus Group Buffer::        Gnusグループコマンドの短い説明。
* Gnus Summary Buffer::      Gnusサマリーコマンドの短い説明。


File: emacs.info,  Node: Buffers of Gnus,  Next: Gnus Startup,  Up: Gnus

34.1 Gnusバッファー
===================

Gnusは、情報を表示したり返信コマンドのために、複数のバッファーを使用しま
す。もっとも一般的に使用される3つのGnusバッファーは“グループバッファー
(group buffer)”、“サマリーバッファー(summary buffer)”、“アーティクルバッ
ファー(article buffer)”です。

   “グループバッファー”は、アーティクルソースのリスト(たとえばニュースグ
ループや電子メールのinbox)を含んでおり、それらは“グループ”として参照され
ます。これはGnusを開始したときに最初に表示されるバッファーです。これは通
常、あなたが登録したグループと、未読のアーティクルだけを表示します。この
バッファーから、読みたいグループを選択できます。

   “サマリーバッファー”は1つのグループのアーティクルをリストし、1行に1つ
のアーティクルを表示します。デフォルトでは、アーティクルの作者、
subject、 行数が表示されますが、これはカスタマイズできます。*note
(gnus)Summary Buffer Format::を参照してください。 サマリーバッファーは、
グループバッファーでグループを選択すると作成され、グループを抜けると
killされます。

   サマリーバッファーから、閲覧するアーティクルを選択できます。アーティ
クルは“アーティクルバッファー”で表示されます。通常のGnusの使い方では、こ
のバッファーを閲覧はしますが選択はしません — すべての便利なGnusコマンド
はサマリーバッファーから呼び出すことができます。しかし望むなら、アーティ
クルバッファーを選択して、そこからGnusコマンドを実行することもできます。


File: emacs.info,  Node: Gnus Startup,  Next: Gnus Group Buffer,  Prev: Buffers of Gnus,  Up: Gnus

34.2 Gnusを起動した時
=====================

あなたのシステムがUsenetニュースをよむためにセットアップされていれば、
Gnusを始めるのは簡単です — ‘M-x gnus’とタイプするだけです。

   起動時に、Gnusはホームディレクトリーにある‘.newsrc’という名前の“ニュ
ース初期化ファイル(news initialization file)”を読み込みます。これにはあ
なたのUsenetニュースグループと購読状況がリストされています(これはGnus固
有のファイルではありません。他の多くのニュースリーダープログラムにより使
用されています)。その後システムのデフォルトのニュースサーバーへの接続を
試みます。これは通常、環境変数‘NNTPSERVER’により指定されます。

   あなたのシステムがデフォルトのニュースサーバーをもっていない場合、ま
たは電子メールを読むためにGnusを使いたい場合は、‘M-x gnus’を呼び出す前に
、どこでニュースおよび/またはメールを取得するか、Gnusに指示する必要があ
ります。これを行なうには、変数‘gnus-select-method’および/または
‘gnus-secondary-select-methods’をカスタマイズします。 *note
(gnus)Finding the News::を参照してください。

   1度Gnusを開始すると、グループバッファーを表示します。デフォルトでは少
数の“subscribedグループ(subscribed groups: 登録されたグループ)”だけが表
示されます。他の状態 — “unsubscribed”、“killed”、“zombie” — のグループは
表示されません。最初にGnusを開始したとき、登録していないグループは
killedグループになります。その後にニュースサーバーに現れたグループは
zombieグループになります。

   先に進むには、グループバッファーでグループを選択して、そのグループの
サマリーバッファーを開かなければなりません。その後サマリーバッファーのア
ーティクルを選択して、別のウィンドウでアーティクルバッファーを閲覧します
。以下のセクションでは、これを行なうための、グループバッファーとサマリー
バッファーの使用について説明します。

   Gnusを終了するには、グループバッファーで‘q’とタイプします。これは自動
的にグループの状態をファイル‘.newsrc’ト‘.newsrc.eld’に記録するので、その
後のGnusセッションでも効果があります。


File: emacs.info,  Node: Gnus Group Buffer,  Next: Gnus Summary Buffer,  Prev: Gnus Startup,  Up: Gnus

34.3 Gnus Groupバッファーの使用
===============================

以下のコマンドは、Gnusグループバッファーで利用可能です:

‘<SPC>’
     カレント行のグループの、サマリーバッファーに切り替えます。

‘l’
‘A s’
     グループバッファーでは、未読のアーティクルを含む登録したグループだ
     けをリストします(これはデフォルトの一覧方法です)。

‘L’
‘A u’
     すべてのsubscribed(登録)およびunsubscribed(未登録)のグループをリス
     トしますが、killedまたはzombieのグループは表示しません。

‘A k’
     killedグループをリストします。

‘A z’
     zombieグループをリストします。

‘u’
     カレント行のグループの登録状態を切り替えます(たとえばsubscribedグル
     ープをunsubscribedグループにしたり、その逆を行ないます)。killedまた
     はzombieのグループにたいしてこれを呼び出すと、そのグループを
     unsubscribedグループにします。

‘C-k’
     カレント行のグループをkillします。killedとなったグループは
     ‘.newsrc’ファイルに記録され、‘l’または‘L’のリストには表示されなくな
     ります。

‘<DEL>’
     未読アーティクルを含む、前のグループにポイントを移動します。

‘n’
     次の未読グループにポイントを移動します。

‘p’
     前の未読グループにポイントを移動します。

‘q’
     Gnusのセッティングを更新してGnusを終了します。


File: emacs.info,  Node: Gnus Summary Buffer,  Prev: Gnus Group Buffer,  Up: Gnus

34.4 Gnus Summaryバッファーの使用
=================================

以下のコマンドは、Gnusサマリーバッファーで利用可能です:

‘<SPC>’
     選択されたアーティクルがない場合、カレント行のアーティクルを選択し
     て、それをアーティクルバッファーに表示します。そうでない場合、選択
     されたアーティクルバッファーのウィンドウでスクロールを試みます。バ
     ッファーの最後に到達した場合、次の未読アーティクルを選択します。

     したがって、繰り返し<SPC>をタイプすることにより、すべてのアーティク
     ルを読むことができます。

‘<DEL>’
     アーティクルのテキストを後方にスクロールします。

‘n’
     次の未読アーティクルを選択します。

‘p’
     前の未読アーティクルを選択します。

‘s’
     選択されたアーティクルバッファーで、あたかもそのバッファーに切り替
     えて‘C-s’(*note Incremental Search::を参照してください)とタイプした
     かのように、インクリメンタル検索を行ないます。

‘M-s REGEXP <RET>’
     REGEXPへのマッチを含むアーティクルを、前方に検索します。

‘q’
     サマリーバッファーをexitして、グループバッファーに戻ります。


File: emacs.info,  Node: Document View,  Next: EWW,  Prev: Gnus,  Up: Top

35 ドキュメントの閲覧
*********************

DocViewモードは、DVI、PostScript(PS)、PDF、OpenDocument、Microsoft
Officeドキュメントを閲覧するためのメジャーモードです。このモードはスライ
ス、ズーム、ドキュメント内の検索などの機能を提供します。これは、
‘gs’(GhostScript)、または‘mudraw’/‘pdfdraw’(MuPDF)、およびその他の外部ツ
ール(1)を使用して、ドキュメントを一連のイメージに変換し、それらのイメー
ジを表示することにより機能します

   DocViewモードで表示可能なドキュメントをvisitすると、Emacsは自動的に
DocViewモードを使用します(2)。例外として、PostScriptファイルをvisitした
とき、EmacsはPostScriptファイルをテキストとして編集するためのメジャーモ
ードの、PSモードに切り替わります。しかし、これはDocView minorモードも有
効にするので、‘C-c C-c’とタイプして、そのドキュメントを閲覧することがで
きます。DocViewモードまたはDocView minorモードでは、‘C-c C-c’
(‘doc-view-toggle-display’)を繰り返すことにより、DocViewとその背後にある
ファイル内容を切り替えることができます。

   いくつかの要件が満たされないとき(たとえばテキスト端末のフレームを操作
していたり、そのemacsはPNGをサポートしないときなど)に、通常DocViewモード
で処理されるファイルをvisitした場合は、そのドキュメントの内容をプレーン
テキストとして閲覧したいか問い合わせます。これに同意すると、そのバッファ
ーはtextモードとなり、DocView minorモードがアクティブになります。したが
って‘C-c C-c’とタイプすることにより、fallbackモードに切り替わります。も
う1度‘C-c C-c’とタイプすると、DocViewモードに戻ります。DocViewモードで
‘C-c C-t’ (‘doc-view-open-text’)とタイプすることにより、プレーンテキスト
で内容を表示することもできます。

   コマンド‘M-x doc-view-mode’で、DocViewモードを明示的に有効にすること
ができます。また、‘M-x doc-view-minor-mode’で、DocView minorモードに切り
替えることができます。

   DocViewモードを開始したときは、ウェルカム画面を表示して、そのファイル
を1ページずつフォーマットしていきます。最初のページがフォーマットされる
と、そのページを表示します。

   DocViewバッファーをkillするには、‘k’
(‘doc-view-kill-proc-and-buffer’)とタイプします。バッファーを隠す
(bury)には、‘q’ (‘quit-window’)とタイプします。

* Menu:

* Navigation: DocView Navigation.  DocViewバッファーの操作。
* Searching: DocView Searching.  ドキュメント内の検索。
* Slicing: DocView Slicing.  ページのどの部分を表示するか指定する。
* Conversion: DocView Conversion.  変換に影響を与えたり、それを誘発するもの。

   ---------- Footnotes ----------

   (1) PostScriptファイルにたいしてはGhostScriptが絶対条件です。DVIファ
イルにたいしては‘dvipdf’または‘dvipdfm’が必要です。OpenDocumentおよび
Microsoft Officeドキュメントにたいしては‘unoconv’ツールが必要です。

   (2) そのドキュメントに必要な外部ツールが利用可能でなければならず、
Emacsがグラフィカルなフレームで実行されていて、PNGイメージをサポートしな
ければなりません。これらの条件が満たされなければ、Emacsは他のメジャーモ
ードにフォールバックします。


File: emacs.info,  Node: DocView Navigation,  Next: DocView Searching,  Up: Document View

35.1 DocViewの操作
==================

DocViewモードでは通常のEmacs移動キー、つまり‘C-p’、‘C-n’、‘C-b’、‘C-f’、
および矢印キーを使って、ページをスクロールできます。

   デフォルトでは、行移動キーの‘C-p’と‘C-n’は、カレントページの先頭また
は最後でスクロールを止めます。しかし、変数‘doc-view-continuous’を非
‘nil’値に変更した場合、カレントページの先頭で‘C-p’とタイプすると前のペー
ジを表示し、カレントページの最後で‘C-n’とタイプすると次のページを表示し
ます。

   ‘n’、<next>、‘C-x ]’をタイプすることにより、次のページを表示すること
もできます(‘doc-view-next-page’)。前のページを表示するには、‘p’、
<prior>、‘C-x [’をタイプします(‘doc-view-previous-page’)。

   <SPC> (‘doc-view-scroll-up-or-next-page’)は、ドキュメントを順に読んで
いくのに便利な方法です。これはカレントページをスクロールするか、次のペー
ジに移動します。<DEL> (‘doc-view-scroll-down-or-previous-page’)は、同様
の方法で後方に移動します。

   最初のページに移動するには、‘M-<’ (‘doc-view-first-page’)とタイプしま
す。最後のページに移動するには、‘M->’ (‘doc-view-last-page’)とタイプしま
す。ページ番号を指定して移動するには、‘M-g M-g’または‘M-g g’
(‘doc-view-goto-page’)とタイプしてください。

   ‘+’ (‘doc-view-enlarge’)と‘-’ (‘doc-view-shrink’)で、ドキュメントを拡
大したり縮小することができます。これらのコマンドはドキュメントを新しいサ
イズに再変換することにより機能します。DocViewにたいするデフォルトサイズ
を指定するには、変数‘doc-view-resolution’をカスタマイズしてください。


File: emacs.info,  Node: DocView Searching,  Next: DocView Slicing,  Prev: DocView Navigation,  Up: Document View

35.2 DocViewの検索
==================

DocViewモードでは、ファイルのテキストにたいして正規表現の検索を行なうこ
とができます(*note Regexps::を参照してください)。検索のインターフェース
は‘isearch’が元になっています(*note Incremental Search::を参照してくださ
い)。

   検索を開始するには、‘C-s’ (‘doc-view-search’)または‘C-r’
(‘doc-view-search-backward’)とタイプします。これはミニバッファーを使用し
て正規表現を読み取り、そのドキュメントでマッチした数をエコーします。
‘C-s’または‘C-r’とタイプすることにより、マッチ間を前方または後方に移動で
きます。DocViewモードはページイメージの中でマッチを表示できません。かわ
りに、カレントページのマッチするすべての行を一覧するツールチップを、(マ
ウス位置に)表示します。このツールチップを強制的に表示するには‘C-t’
(‘doc-view-show-tooltip’)とタイプしてください。

   新しい検索を開始するには、たとえば前方検索では‘C-u C-s’、後方検索では
‘C-u C-r’のように、検索コマンドにプレフィクス引数を使用します。


File: emacs.info,  Node: DocView Slicing,  Next: DocView Conversion,  Prev: DocView Searching,  Up: Document View

35.3 DocViewのスライス
======================

印刷のために広い余白をもつドキュメントもあります。これらはスクリーンでド
キュメントを読むとき邪魔になることがあります。なぜならこれらは画面スペー
スを消費して、スクロールが不便になるからです。

   DocViewでは、表示するページの“スライス(slice)”を選択することにより、
これらの余白を隠すことができます。スライスはページ内の矩形領域です。
DocViewで1度スライスを指定すると、閲覧するすべてのページに適用されます。

   数値でスライスを指定するには、‘s s’ (‘doc-view-set-slice’)とタイプし
ます。その後、スライスの左上のピクセル位置(pixel position)と、スライスの
幅(width)と高さ(height)を入力します。

   スライスを指定するための、もっと便利でグラフィカルな方法は、‘s m’
(‘doc-view-set-slice-using-mouse’)で、スライスの選択にマウスを使う方法で
す。これは単に、スライスにしたいリージョンの左上隅で左マウスボタンを押し
て、そのまま右下隅にマウスポインターを移動してマウスボタンを離します。

   最適なスライスをセットする一番簡単な方法は、‘s b’
(‘doc-view-set-slice-from-bounding-box’)とタイプすることにより、そのドキ
ュメントから自動的に判断されるBoundingBox情報を使う方法です。

   選択されたスライスを取り消すには、‘s r’ (‘doc-view-reset-slice’)とタ
イプします。するとDocViewは、余白全体を含めたページ全体を表示します。


File: emacs.info,  Node: DocView Conversion,  Prev: DocView Slicing,  Up: Document View

35.4 DocViewの変換
==================

効率のために、DocViewは‘gs’により生成されたイメージをキャッシュします。
このディレクトリーの名前は、変数‘doc-view-cache-directory’により与えられ
ます。‘M-x doc-view-clear-cache’とタイプすることにより、キャッシュディレ
クトリーをクリアーできます。

   現在閲覧中のドキュメントを強制的に再変換するには、type ‘r’または‘g’
(‘revert-buffer’)とタイプします。カレントバッファーに関連付けられた変換
プロセスをkillするには、‘K’ (‘doc-view-kill-proc’)とタイプします。コマン
ド‘k’ (‘doc-view-kill-proc-and-buffer’)は、変換プロセスとDocViewバッファ
ーをkillします。


File: emacs.info,  Node: EWW,  Next: Shell,  Prev: Document View,  Up: Top

36 EWWによるウェブブラウズ
**************************

“EWW”(Emacs Web Wowser)は、Emacs用のウェブブラウザーのパッケージです。こ
れはEmacsバッファーでURLブラウズすることを可能にします。コマンド‘M-x
eww’により、URLを開いたり、ウェブを検索します。コマンド‘M-x
eww-open-file’を使用して、ファイルを開くことができます。‘browse-url’にた
いするウェブブラウザーとして。EWWを使うことができます(*note
Browse-URL::を参照してください)。完全な詳細に付いては、*note EWW:
(eww)Top.を参照してください。


File: emacs.info,  Node: Shell,  Next: Emacs Server,  Prev: EWW,  Up: Top

37 Emacsからのシェルコマンドの実行
**********************************

Emacsには、シェルサブプロセスに1つのコマンドラインを渡したり、入出力に
Emacsバッファーを使用して対話的にシェルを実行するコマンドや、端末エミュ
レーターウィンドウでシェルを実行するコマンドがあります。

‘M-! CMD <RET>’
     シェルコマンドCMDを実行して、出力を表示します(‘shell-command’)。
‘M-| CMD <RET>’
     リージョンの内容を入力としてシェルコマンドCMDを実行します。オプショ
     ンでリージョンを出力で置き換えます(‘shell-command-on-region’)。
‘M-& CMD <RET>’
     シェルコマンドCMDを非同期で実行し、出力を表示します
     (‘async-shell-command’)。
‘M-x shell’
     Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その
     後で、コマンドを対話的に与えることができます。
‘M-x term’
     Emacsバッファーを通じて入出力を行なう、サブシェルを実行します。その
     後でコマンドを対話的に与えることができます。完全な端末エミュレーシ
     ョンが利用できます。

   (上記のコマンドのCMD引数、または他のコンテキストにおいて)実行可能プロ
グラムとして相対ファイル名を指定したときは、Emacsは変数‘exec-path’により
指定されるディレクトリーのプログラムを検索します。この変数の値は、ディレ
クトリー名のリストでなければなりません。デフォルト値は、Emacsが開始され
たときの環境変数‘PATH’により初期化されます(*note General Variables::を参
照してください)。

   ‘M-x eshell’は、Emacsで完全に実装されたシェルを呼び出します。eshellに
ついては、自身のマニュアルにドキュメントされています。 *note Eshell:
(eshell)Top.を参照してください。

* Menu:

* Single Shell::             シェルコマンドを実行してから、戻る方法。
* Interactive Shell::        Emacsを通じて入力を行なう永続的なシェル。
* Shell Mode::               永続的なシェルで使用される特別なEmacsコマンド。
* Shell Prompts::            シェルプロンプトを認識する2つの方法。
* History: Shell History.    シェルバッファーで前のコマンドを繰り返す。
* Directory Tracking::       サブシェルでのディレクトリーの変更の追跡。
* Options: Shell Options.    Shellモードをカスタマイズするオプション。
* Terminal emulator::        端末エミュレーターとしてのEmacsウィンドウ。
* Term Mode::                Termモードで使用される特別なEmacsコマンド。
* Remote Host::              他のコンピューターへの接続。
* Serial Terminal::          シリアルポートへの接続。


File: emacs.info,  Node: Single Shell,  Next: Interactive Shell,  Up: Shell

37.1 単一のシェルコマンド
=========================

‘M-!’ (‘shell-command’)は、ミニバッファーを使って1行のテキストを読み取り
、それをシェルコマンドとして、そのコマンドのためだけに作成されたサブシェ
ルで実行します。そのコマンドの標準入力はnullデバイスです。シェルコマンド
が出力を生成する場合、その出力はエコーエリア(出力が短い場合)、または別の
ウィンドウの‘*Shell Command Output*’という名前のEmacsバッファー(出力が長
い場合)に表示されます。

   たとえば‘foo.gz’という名前のファイルを解凍する1つの方法は、‘M-!
gunzip foo.gz <RET>’とタイプすることです。このシェルコマンドは通常、ファ
イル‘foo’を作成して、端末出力を生成しません。

   たとえば‘M-1 M-!’のように‘shell-command’に数引数を指定した場合、別の
バッファーではなく、カレントバッファーに端末出力を挿入します。これはポイ
ントを出力の前に配し、出力の後にマークを配します。たとえば‘M-1 M-!
gunzip < foo.gz <RET>’は、カレントバッファーにファイル‘foo.gz’の解凍され
た内容を挿入します。

   最後が‘&’でないシェルコマンドを指定した場合、コマンドは“同期
(synchronously)”で実行され、Emacsを継続して使用するには、コマンドが
exitするのを待たなければなりません。待つのを中止するには、‘C-g’とタイプ
します。これはシェルコマンドを終了するために、シグナル‘SIGINT’を送ります
(これは通常、シェルで‘C-c’とタイプしたときに生成されるのと同じシグナルで
す)。その後、Emacsはコマンドが実際に終了するまで待ちます。シェルコマンド
が終了しない場合(そのコマンドがシグナル‘SIGINT’を無視する場合)は、再度
‘C-g’とタイプします。これは　そのコマンドにたいして、無視することが不可能
なシグナル‘SIGKILL’を送ります。

   ‘&’で終わるシェルコマンドは“非同期(asynchronously)”で実行され、それを
実行した後でも、継続してEmacsを使用できます。シェルコマンドを非同期で実
行する前に、‘M-&’ (‘async-shell-command’)とタイプすることもできます。こ
れは最後の‘&’が必要ない点を除き、最後に‘&’を指定して‘M-!’を呼び出すこと
と同じです。非同期シェルコマンドにたいするデフォルトの出力バッファーは、
‘*Async Shell Command*’という名前のバッファーです。このバッファーがウィ
ンドウに表示されているかに関わらず、Emacsは出力をこのバッファーに挿入し
ます。

   同時に複数の非同期シェルコマンドを実行した場合、出力バッファーが競合
します。この場合どのようにするか — たとえば既存の出力バッファーをリネー
ムしたり、新しいコマンドに異なるバッファーを使用する — を、オプション
‘async-shell-command-buffer’で指定できます。他の可能なオプションについて
は、この変数のドキュメントを参照してください。

   ‘M-|’ (‘shell-command-on-region’)は‘M-!’と同様ですが、入力を与えない
かわりに、リージョンの内容をシェルコマンドの標準入力として渡します。数引
数を指定した場合、古いリージョンの内容を、シェルコマンドの出力で置き換え
ます。

   たとえば‘M-|’で‘gpg’プログラムを使用して、そのバッファーのキーが何か
を見ることができます。そのバッファーがGnuPGキーを含む場合、‘C-x h M-|
gpg <RET>’とタイプして、バッファー全体の内容を‘gpg’に送ることができます
。これはキーのリストを、‘*Shell Command Output*’バッファーに出力します。

   上記のコマンドは、変数‘shell-file-name’で指定されたシェルを使用します
。この変数のデフォルト値は、Emacsが開始されたときの環境変数‘SHELL’により
決定されます。相対ファイル名の場合、Emacsは‘exec-path’にリストされたディ
レクトリーを検索します(*note Shell::を参照してください)。

   ‘M-!’または‘M-|’にたいするコーディングシステムを指定するには、あらか
じめコマンド‘C-x <RET> c’を使用します。*note Communication Coding::を参
照してください。

   デフォルトでは、出力バッファーではエラー出力と標準出力が混ざって出力
されます。しかし変数‘shell-command-default-error-buffer’の値を文字列に変
更すると、エラー出力はその名前のバッファーに出力されます。


File: emacs.info,  Node: Interactive Shell,  Next: Shell Mode,  Prev: Single Shell,  Up: Shell

37.2 対話的なサブシェル
=======================

対話的にサブシェルを実行するには、‘M-x shell’とタイプします。これは
‘*shell*’という名前のバッファーを作成(または再使用)して、そのバッファー
にたいして入出力を行なう、シェルのサブプロセスを実行します。つまりサブシ
ェルからの端末出力はポイントの後に挿入されてポイントを進め、サブシェルに
たいする端末入力はそのバッファーのテキストになります。サブシェルにたいし
て入力を与えるには、バッファーの最後に移動して入力をタイプし、<RET>で終
了します。

   サブシェルがコマンドの実行を待つ間、ウィンドウまたはバッファーを切り
替えてEmacsで他の編集を行なうことができます。Emacsはそれを処理するときが
きたら(たとえばキーボード入力待ちになったとき)、サブシェルからの出力を
Shellバッファーに挿入します。

   Shellバッファーでは、プロンプトはフェイス‘comint-highlight-prompt’で
表示され、サブミットされた入力行はフェイス‘comint-highlight-input’で表示
されます。これにより入力行とシェル出力を容易に区別することができます。
*note Faces::を参照してください。

   複数のサブシェルを作成するには、(‘C-u M-x shell’)のように)プレフィク
ス引数を指定して‘M-x shell’を呼び出します。その後、このコマンドはバッフ
ァー名を読み取り、そのバッファーでサブシェルを作成(または再使用)します。
‘M-x rename-uniquely’を使用して‘*shell*’バッファーをリネームしてから、
‘M-x shell’で新しい‘*shell*’バッファーを作成することもできます。異なるバ
ッファーのサブシェルは、並行して独立に実行されます。

   ‘M-x shell’によりシェルファイル名を指定するには、変数
‘explicit-shell-file-name’をカスタマイズします。これが‘nil’(デフォルト
)の場合、もし存在すればEmacsは環境変数‘ESHELL’を使用します。そうでない場
合は通常、変数‘shell-file-name’を使用します(*note Single Shell::を参照し
てください)。しかしデフォルトディレクトリーがリモートの場合(*note Remote
Files::を参照してください)、シェルファイル名の入力を求めます。

   Emacsは新しいシェルにたいする入力として、もしそれが存在すればファイル
‘~/.emacs_SHELLNAME’の内容を送ります。ここでSHELLNAMEは、そのシェルがロ
ードされたファイルの名前です。たとえばbashを使う場合、送られるファイルは
‘~/.emacs_bash’になります。ファイルが見つからない場合、Emacsは
‘~/.emacs.d/init_SHELLNAME.sh’の使用を試みます。

   シェルにたいしてコーディングシステムを指定するには、‘M-x shell’の直前
にコマンド‘C-x <RET> c’を使用します。‘C-x <RET> p’とタイプすることにより
、実行されているサブシェルにたいするコーディングシステムを変更することも
できます。*note Communication Coding::を参照してください。

   サブシェルでは、Emacsは環境変数‘INSIDE_EMACS’に‘VERSION,comint’をセッ
トします。ここでVERSIONは、Emacsのバージョン(たとえば‘24.1’)です。プログ
ラムはこの変数をチェックして、Emacsの内部で実行されているかを判断するこ
とができます(環境変数‘EMACS’が定義されていない場合は、環境変数‘EMACS’も
‘t’にセットします。しかし、この環境変数は時代遅れなので、これを使うプロ
グラムは、かわりに‘INSIDE_EMACS’を使うべきです)。


File: emacs.info,  Node: Shell Mode,  Next: Shell Prompts,  Prev: Interactive Shell,  Up: Shell

37.3 Shellモード
================

ShellバッファーのためのメジャーモードはShellモードです。このモードの特別
なコマンドは‘C-c’プレフィクスにバインドされており、最初に‘C-c’をタイプし
なければならない点を除けば、通常のシェルでの編集やジョブ制御文字と共通点
があります。以下はShellモードのコマンドのリストです:

‘<RET>’
     サブシェルの入力にカレント行を送ります(‘comint-send-input’)。行頭の
     シェルプロンプトは省略されます(*note Shell Prompts::を参照してくだ
     さい)。ポイントがバッファーの最後にある場合、これは通常の対話的なシ
     ェルにおいてコマンド行をサブミットするのに似ています。しかし、シェ
     ルバッファーの他の場所でも、<RET>を呼び出してカレント行を入力として
     サブミットできます。

‘<TAB>’
     シェルバッファーのポイントの前のコマンド名、またはファイル名を補完
     します(‘completion-at-point’)。これは通常のEmacs補完ルールを使用し
     ます(*note Completion::を参照してください)。ファイル名、環境変数名
     、シェルコマンドヒストリー、ヒストリー参照が補完候補になります
     (*note History References::を参照してください)。補完を制御するオプ
     ションについては、*note Shell Options::を参照してください。

‘M-?’
     ポイントの前のファイル名にたいして、可能性のある補完リストを一時的
     に表示します(‘comint-dynamic-list-filename-completions’)。

‘C-d’
     delete文字、またはEOF文字を送ります
     (‘comint-delchar-or-maybe-eof’)。シェルバッファーの最後でこれをタイ
     プすると、サブシェルにEOFが送られます。バッファーの他の場所でタイプ
     すると、通常どおり文字を削除します。

‘C-c C-a’
     行の先頭に移動しますが、プロンプトがある場合はプロンプトの後に移動
     します(‘comint-bol-or-process-mark’)。このコマンドを連続して繰り返
     すと、2回目はプロセスマーク(process mark)に戻ります。これはサブシェ
     ルにまだ送信されていない入力の開始位置のことです(通常これは同じ場所
     — その行のプロンプトの最後 — ですが、‘C-c <SPC>’の後では、プロセス
     マークは前の行にあるかもしれません)。

‘C-c <SPC>’
     複数行の入力を累積して、それらを合わせて送ります。このコマンドはポ
     イントの前に改行を挿入しますが、その前のテキストをサブシェルの入力
     として — 少なくともその時点では — 送りません。改行の前後の行は両方
     、(それらを分割する改行も含めて)<RET>をタイプしたとき一緒に送られま
     す。

‘C-c C-u’
     まだ入力として送られていない、バッファーの最後のすべてのテキストを
     killします(‘comint-kill-input’)。ポイントがバッファーの最後にない場
     合、これはポイントの前のテキストだけをkillします。

‘C-c C-w’
     ポイントの前の単語をkillします(‘backward-kill-word’)。

‘C-c C-c’
     シェルまたは(もしあれば)カレントのサブジョブに割り込み(interrupt)ま
     す(‘comint-interrupt-subjob’)。このコマンドはシェルバッファーの最後
     の、まだ送られていない任意のシェル入力もkillします。

‘C-c C-z’
     シェルまたは(もしあれば)カレントのサブジョブを停止(stop)します。
     (‘comint-stop-subjob’)。このコマンドはシェルバッファーの最後の、ま
     だ送られていない任意のシェル入力もkillします。

‘C-c C-\’
     シェルまたは(もしあれば)カレントのサブジョブに、シグナルQUITを送り
     ます(‘comint-quit-subjob’)。このコマンドはシェルバッファーの最後の
     、まだ送られていない任意のシェル入力もkillします。

‘C-c C-o’
     前のシェルコマンドからの出力の一群を削除します
     (‘comint-delete-output’)。これはシェルコマンドが大量の出力を吐くと
     きに便利です。

‘C-c C-s’
     前のシェルコマンドからの出力の一群をファイルに書き込みます
     (‘comint-write-output’)。プレフィクス引数を指定した場合は、ファイル
     に追加で書き込みます。出力の最後のプロンプトは書き込まれません。

‘C-c C-r’
‘C-M-l’
     前の一群の出力の最初がウィンドウの最上部になるようにスクロールし、
     カーソルもそこに移動します(‘comint-show-output’)。

‘C-c C-e’
     バッファーの最後がウィンドウの最下部になるようにスクロールします
     (‘comint-show-maximum-output’)。

‘C-c C-f’
     シェルコマンド1つ分、前方に移動しますが、カレント行を超えては移動し
     ません(‘shell-forward-command’)。変数‘shell-command-regexp’は、コマ
     ンドの最後を認識する方法を指定します。

‘C-c C-b’
     シェルコマンド1つ分、後方に移動しますが、カレント行を超えて移動はし
     ません(‘shell-backward-command’)。

‘M-x dirs’
     シェルに作業ディレクトリーを尋ね、Shellバッファーのデフォルトディレ
     クトリーを更新します。*note Directory Tracking::を参照してください
     。

‘M-x send-invisible <RET> TEXT <RET>’
     エコーなしでTEXTを読み取った後、それをシェルの入力として送ります。
     これはシェルコマンドでパスワードを尋ねるプログラムを実行するとき便
     利です。

     デフォルトではEmacsはパスワードをエコーしないことに注意してください
     。もし本当にエコーさせたいときは、以下のLisp式を評価します(*note
     Lisp Eval::を参照してください):

          (remove-hook 'comint-output-filter-functions
                       'comint-watch-for-password-prompt)

‘M-x comint-continue-subjob’
     シェルプロセスを継続します。これは間違ってシェルプロセスをサスペン
     ドしてしまったときなどに便利です。(1)

‘M-x comint-strip-ctrl-m’
     シェル出力のカレントグループから、すべてのcontrol-M文字を破棄します
     。このコマンドを使うもっとも便利な方法は、サブシェルからの出力を受
     け取ったときに自動的に実行されるようにする方法です。これを行なうに
     は、以下のLisp式を評価します:

          (add-hook 'comint-output-filter-functions
                    'comint-strip-ctrl-m)

‘M-x comint-truncate-buffer’
     このコマンドはシェルバッファーを、変数
     ‘comint-buffer-maximum-size’により指定される、特定の最大行数に切り
     詰めます。以下は、サブシェルから出力を受けとるとき、毎回自動的にこ
     れを行なう方法です:

          (add-hook 'comint-output-filter-functions
                    'comint-truncate-buffer)

   Shellモードは、サブプロセスと対話的に通信を行なう一般的な用途向けの
Comintモードから派生したモードです。上記のコマンド名からも判るとおり、
Shellモードのほとんどの機能は、実際にはComintモードが由来です。Shellモー
ドの特別な機能には、ディレクトリー追跡機能、およびいくつかのユーザーコマ
ンドが含まれます。

   Comintモードの変種を使う他のEmacs機能には、GUD (*note Debuggers::を参
照してください)や、‘M-x run-lisp’ (*note External Lisp::を参照してくださ
い)が含まれます。

   サブプロセスとして選択した任意のプログラムを実行するために、Shellモー
ドに特化しない未修正のComintモードを使用するには、‘M-x comint-run’を使用
することができます。

   ---------- Footnotes ----------

   (1) シェルプロセスをサスペンドするべきではありません。これはシェルの
サブジョブのサスペンドとはまったく違います。サブジョブのサスペンドは通常
行なわれますが、サブジョブを継続するためにはシェルを使用しなければなりま
せん。このコマンドはそれを行ないません。


File: emacs.info,  Node: Shell Prompts,  Next: Shell History,  Prev: Shell Mode,  Up: Shell

37.4 Shellプロンプト
====================

プロンプトとは、新しいユーザー入力を受け取る準備ができたことを表す、プロ
グラムによるテキスト出力のことです。Comintモード(したがってShellモードも
)は通常、サブプロセスからの出力にもとづいて、バッファーの一部をプロンプ
トとして自動的に判断します(具体的には、改行で終端されていない任意の出力
行を受け取ったときは、プロンプトとみなします)。

   Comintモードは、バッファーを2つのタイプの“フィールド(fields)”に分けま
す。1つは入力フィールド(ユーザーの入力がタイプされるところ)で、もう1つは
出力フィールド(入力フィールド以外)です。プロンプトは出力フィールドの一部
です。ほとんどのEmacs移動コマンドは、そのコマンドが複数行を移動しない限
り、フィールド境界を超えることはありません。たとえば、ポイントがシェルコ
マンドの入力フィールドにある場合、‘C-a’はポイントを入力フィールドの先頭
、プロンプトの後に配します。内部的には、フィールドはテキストプロパティー
‘field’を使って実装されています(*note (elisp)Text Properties::を参照して
ください)。

   変数‘comint-use-prompt-regexp’を非‘nil’値に変更した場合、Comintモード
は正規表現を使ってプロンプトを認識します(*note Regexps::を参照してくださ
い)。Shellモードでは、その正規表現は変数‘shell-prompt-pattern’により指定
されます。‘comint-use-prompt-regexp’のデフォルト値は‘nil’です。なぜなら
プロンプト認識のためのこの方法は信頼性が低いためです。しかし特殊な状況で
は、これを非‘nil’値にセットしたいと思うこともあるでしょう。そのような場
合、EmacsはComintバッファーをフィールドに分割しないので、一般的な移動コ
マンドは、テキストプロパティーを使用せず、それらのコマンドがバッファーで
通常行なうように振る舞います。しかし、バッファーを便利に操作するために、
パラグラフ移動コマンドを使うことができます(*note Paragraphs::を参照して
ください)。Shellモードでは、Emacsはパラグラフ境界に
‘shell-prompt-pattern’を使用します。


File: emacs.info,  Node: Shell History,  Next: Directory Tracking,  Prev: Shell Prompts,  Up: Shell

37.5 Shellコマンドヒストリー
============================

Shellバッファーは、以前のコマンドを繰り返す3つの方法をサポートします。
1つ目はミニバッファーヒストリーにたいして使うのと同じようなキーを使う方
法です。つまり、これらはミニバッファーで行なうのと同じように、前のコマン
ドからテキストを挿入して、ポイントを常にバッファーの最後に保ちます。2つ
目は、バッファーを移動して元の場所から前の入力を取得して、それらを再実行
したり、バッファーの最後にコピーする方法です。3つ目は‘!’スタイルのヒスト
リー参照を使う方法です。

* Menu:

* Ring: Shell Ring.          ヒストリーリストからコマンドを取り出す。
* Copy: Shell History Copying.  コマンドに移動して、それをコピーする。
* History References::       ‘!’スタイルのヒストリー参照の展開。


File: emacs.info,  Node: Shell Ring,  Next: Shell History Copying,  Up: Shell History

37.5.1 Shellヒストリーリング
----------------------------

‘M-p’
‘C-<UP>’
     以前のシェルコマンドから、次に古いコマンドを取り出します。

‘M-n’
‘C-<DOWN>’
     以前のシェルコマンドから、次に新しいコマンドを取り出します。

‘M-r’
     以前のシェルコマンドにたいして、インクリメンタルregexp検索を開始し
     ます。

‘C-c C-x’
     ヒストリーから次のコマンドを取り出します。

‘C-c .’
     以前のシェルコマンドから引数を1つ取り出します。

‘C-c C-l’
     そのバッファーのシェルコマンドのヒストリーを、別のウィンドウに表示
     します(‘comint-dynamic-list-input-ring’)。

   Shellバッファーは、以前に入力したシェルコマンドのヒストリーを提供しま
す。ヒストリーからシェルコマンドを再利用するには、編集コマンド‘M-p’、
‘M-n’、‘M-r’、‘M-s’を使用します。これらは、ミニバッファーではなくShellバ
ッファーを操作する点を除き、ミニバッファーヒストリーコマンド(*note
Minibuffer History::を参照してください)と同じように機能します。

   ‘M-p’は、シェルバッファーの最後から以前のシェルコマンドを取り出します
。連続して‘M-p’を使用すると、古いシェルコマンドを連続して取り出し、その
度にシェル入力の候補として表示されているテキストを置き換えます。‘M-n’も
同様に機能しますが、これはバッファーから、より新しいシェルコマンドを連続
して探します。‘C-<UP>’は‘M-p’と同様に機能し、‘C-<DOWN>’は‘M-n’と同様に機
能します。

   ヒストリー検索コマンド‘M-r’は、以前のシェルコマンドにたいしてインクリ
メンタル正規表現検索を開始します。‘M-r’とタイプした後に、検索したい文字
列か正規表現のタイプを開始します。するとマッチする最後のシェルコマンドが
カレント行に表示されます。インクリメンタル検索コマンドは通常の効果をもち
ます — たとえば‘C-s’および‘C-r’は前方または後方に、次のマッチを検索しま
す(*note Incremental Search::を参照してください)。探している入力が見つか
ったら、検索を終了するために<RET>をタイプします。これにより、入力がコマ
ンドラインに配されます。ヒストリーリストを操作する前にタイプしていた入力
の一部は、ヒストリーリングの先頭または最後に達したときに復元されます。

   以前に実行した一連のシェルコマンドを、同じ順番で再実行できたら便利な
こともあります。これを行なうには、最初に順番に再実行する1番目のコマンド
を検索します。その後‘C-c C-x’とタイプします。これは次のコマンド — つまり
再実行したコマンドの次のコマンドを取り出します。それから<RET>でそのコマ
ンドを実行します。‘C-c C-x <RET>’を繰り返しタイプすることにより、連続す
る複数のコマンドを再実行することができます。

   コマンド‘C-c .’ (‘comint-input-previous-argument’)は、Bashの‘<ESC>
.’のように、以前のコマンドから個別に引数をコピーします。一番簡単な使い方
は、以前のシェルコマンドから最後の引数をコピーする方法です。プレフィクス
引数Nを指定すると、N番目の引数をコピーします。繰り返し‘C-c .’とタイプす
ることにより、さらに古いシェルコマンドからコピーします。この場合、常に同
じNの値を使用します(‘C-c .’を繰り返すときは、プレフィクス引数を与えない
でください)。

   これらのコマンドは、以前のシェルコマンドのテキストを、シェルバッファ
ー自身からではなく、特別なヒストリーリストから取得します。したがってシェ
ルバッファーを編集したり、広い範囲をkillしても、これらのコマンドがアクセ
スするヒストリーに影響はありません。

   シェルの中には、コマンドヒストリーをファイルに保存して、以前のシェル
セッションからコマンドを参照できるようにするものがあります。Emacsは選択
されたシェルにたいして、コマンドヒストリーを初期化するために、コマンドヒ
ストリーファイルを読み込みます。ヒストリーファイル名は、bashでは
‘~/.bash_history’、kshでは‘~/.sh_history’、他のシェルでは‘~/.history’で
す。


File: emacs.info,  Node: Shell History Copying,  Next: History References,  Prev: Shell Ring,  Up: Shell History

37.5.2 Shellヒストリーのコピー
------------------------------

‘C-c C-p’
     前のプロンプトにポイントを移動します(‘comint-previous-prompt’)。

‘C-c C-n’
     次のプロンプトにポイントを移動します(‘comint-next-prompt’)。

‘C-c <RET>’
     ポイント位置の入力コマンドをコピーして、そのコピーをバッファーの最
     後に挿入します(‘comint-copy-old-input’)。これは以前のコマンドにポイ
     ントを移動したときに便利です。コマンドをコピーした後、<RET>でそのコ
     ピーを入力として実行することができます。再実行する前に、そのコピー
     を編集することもできます。このコマンドを出力行で使用した場合、その
     行をバッファーの最後にコピーします。

‘Mouse-2’
     ‘comint-use-prompt-regexp’が‘nil’(デフォルト)の場合、クリックした以
     前の入力コマンドをコピーして、そのコピーをバッファーの最後に挿入し
     ます(‘comint-insert-input’)。‘comint-use-prompt-regexp’が非‘nil’、
     または以前の入力以外の場所をクリックしたときは、通常のようにyankし
     ます。

   以前の入力に移動して、‘C-c <RET>’または‘Mouse-2’でコピーすることは、
‘M-p’を充分な回数使用して、ヒストリーリングから以前の入力を取り出したと
きと同じ結果 — つまり同じバッファー内容 — を生成します。しかし‘C-c
<RET>’は、バッファーからテキストをコピーするので、入力をシェルに送信した
後に入力テキストを編集していた場合は、ヒストリーリストと異なります。


File: emacs.info,  Node: History References,  Prev: Shell History Copying,  Up: Shell History

37.5.3 Shellヒストリーの参照
----------------------------

cshやbashを含むさまざまなシェルは、‘!’や‘^’で始まる“ヒストリー参照
(history references)”をサポートします。Shellモードはこれらを認識して、ヒ
ストリーの置き換える処理をします。

   ヒストリー参照を挿入して<TAB>とタイプすると、これは入力ヒストリーから
マッチするコマンドを検索して、必要なら置換を行い、結果をバッファー内のヒ
ストリー参照の場所に配します。たとえば、一番最近の‘mv’で始まるコマンドを
取り出すには、‘! m v <TAB>’とタイプします。必要ならコマンドを編集して、
<RET>でシェルにたいしてコマンドを再実行できます。

   Shellモードはヒストリー参照をシェルに送るとき、オプションでヒストリー
参照を展開できます。これを行なうには、変数‘comint-input-autoexpand’を
‘input’にセットします。<SPC>を‘comint-magic-space’にバインドすれば、
<SPC>でヒストリー参照を展開できます。

   Shellモードは、ヒストリー参照がプロンプトの後にあればヒストリー参照を
認識します。Shellモードがプロンプトを認識する方法については、*note Shell
Prompts::を参照してください。


File: emacs.info,  Node: Directory Tracking,  Next: Shell Options,  Prev: Shell History,  Up: Shell

37.6 ディレクトリーの追跡
=========================

Shellモードは、Shellバッファーのデフォルトディレクトリー(*note File
Names::を参照してください)をシェルの作業ディレクトリーと同一に保つために
、サブシェルに与えられる‘cd’、‘pushd’、‘popd’のコマンドを追跡します。こ
れは、送信する入力行を調べることにより認識されます。

   これらのコマンドにたいしてエイリアスを使用する場合、変数
‘shell-pushd-regexp’、‘shell-popd-regexp’、‘shell-cd-regexp’に適切な正規
表現(*note Regexps::を参照してください)をセットすることにより、それらも
認識するようEmacsに指示できます。たとえば、‘shell-pushd-regexp’がシェル
コマンドラインの先頭にマッチした場合、その行は‘pushd’コマンドとして記録
されます。これらのコマンドは、シェルコマンドラインの先頭だけで認識されま
す。

   Emacsが作業ディレクトリーの変更に際して混乱した場合は、‘M-x dirs’を試
してください。このコマンドはシェルに作業ディレクトリーを尋ねて、それに対
応してデフォルトディレクリーを更新します。これは、一般的なコマンド構文の
ほとんどをサポートするシェルでは機能しますが、特殊なシェルでは機能しない
かもしれません。

   シェルの作業ディレクトリーを追跡する他の方法を実装した、バッファーロ
ーカルなマイナーモードの、Dirtrackモードを使うこともできます。この方法を
使うには、シェルプロンプトに常に作業ディレクトリーが含まれていなければな
らず、プロンプトのどの部分が作業ディレクトリーを含むか認識するための正規
表現を与えなければなりません。詳細は、変数‘dirtrack-list’のドキュメント
を参照してください。Dirtrackモードを使用するには、Shellバッファーで‘M-x
dirtrack-mode’とタイプするか、‘shell-mode-hook’に‘dirtrack-mode’を追加し
ます(*note Hooks::を参照してください)。


File: emacs.info,  Node: Shell Options,  Next: Terminal emulator,  Prev: Directory Tracking,  Up: Shell

37.7 Shellモードのオプション
============================

変数‘comint-scroll-to-bottom-on-input’が非‘nil’の場合、挿入およびyankコ
マンドは、挿入する前に選択されたウィンドウを、バッファーの最後までスクロ
ールします。デフォルトは‘nil’です。

   ‘comint-scroll-show-maximum-output’が非‘nil’の場合、ポイントが最後に
あるとき到着した出力は、可能な限り有用なテキストを表示するために、テキス
トの最後の行がウィンドウの一番下になるようなスクロールを試みます(これは
ほとんどの端末のスクロール動作を真似た動作です)。デフォルトは‘t’です。

   ‘comint-move-point-for-output’をセットすることにより、出力が到着した
ときにバッファーの最後にポイントをジャンプさせることができます — その前
にポイントがバッファーのどこにあろうと関係ありません。値が‘this’の場合、
選択されたウィンドウ内でポイントがジャンプします。値が‘all’の場合、
Comintバッファーを表示するすべてのウィンドウでポイントがジャンプします。
値が‘other’の場合、カレントバッファーを表示する、選択されていないすべて
のウィンドウでポイントがジャンプします。デフォルト値は‘nil’で、これはポ
イントが最後にジャンプしないことを意味します。

   ‘comint-prompt-read-only’をセットした場合、Comintバッファーのプロンプ
トは読み取り専用になります。

   変数‘comint-input-ignoredups’は、連続する同じ入力を入力ヒストリーに保
存するかを制御します。非‘nil’値は、入力が前の入力と同じ場合は省略するこ
とを意味します。デフォルトは‘nil’で、これは入力が前の入力と同じでも保存
することを意味します。

   ファイル名の補完をカスタマイズする3つの変数があります。変数
‘comint-completion-addsuffix’は、完全に補完されたファイル名またはディレ
クトリー名の最後にスペースまたはスラッシュを挿入するかを制御します(非
‘nil’は、スペースまたはスラッシュを挿入することを意味します)。
‘comint-completion-recexact’が非‘nil’の場合、通常のEmacs補完アルゴリズム
が1文字も追加できないようなときは、<TAB>で一番短い利用可能な補完を選択す
るよう指示します。‘comint-completion-autolist’が非‘nil’の場合、補完が完
全でないときは、利用可能なすべての候補をリストするよう指示します。

   コマンド補完は通常、実行可能ファイルだけを考慮します。
‘shell-completion-execonly’を‘nil’にセットした場合は、実行可能ファイル以
外も同様に考慮します。

   変数‘shell-completion-fignore’は、Shellモードで無視するファイル名の拡
張子のリストを指定します。デフォルトは‘nil’ですが、‘~’、‘#’、‘%’で終わる
ファイル名を無視するために‘("~" "#" "%")’をセットするユーザーもいます。
他のComintモードに関連するモードは、かわりに変数
‘comint-completion-fignore’を使用します。

   シェルコマンド補完の実装の詳細は、‘shell-dynamic-complete-command’関
数のlispドキュメントで見ることもできます。

   ‘pushd’の動作を設定することができます。‘shell-pushd-tohome’は、引数を
与えない場合に‘pushd’が‘cd’のように振る舞うかを制御します。
‘shell-pushd-dextract’は、数引数を与えたときローテートするのではなく
popするかを制御します。‘shell-pushd-dunique’は、ディレクトリースタックに
ディレクトリーがない場合だけ追加するかを制御します。もちろん選択する値は
背後のシェルに適合する必要があります。


File: emacs.info,  Node: Terminal emulator,  Next: Term Mode,  Prev: Shell Options,  Up: Shell

37.8 Emacsの端末エミュレーター
==============================

テキスト端末エミュレーターでサブシェルを実行するには、‘M-x term’を使用し
ます。これは‘*terminal*’という名前のバッファーを作成(または再利用)して、
キーボードを入力とするサブシェルを実行し、出力はそのバッファーになります
。

   端末エミュレーターは、2つの入力モードをもつTermモードを使用します。
“lineモード(line mode)”では、Termは基本的にShellモードのように振る舞いま
す(*note Shell Mode::を参照してください)。“charモード(char mode)”では、
文字は端末入力として直接サブシェルに送られます。唯一の例外は端末エスケー
プ文字で、デフォルトは‘C-c’です(*note Term Mode::を参照してください)。入
力をエコーするのはサブシェルの役目です。サブシェルからの端末出力は、バッ
ファーのポイントの後に送られます。

   (Emacsのような)いくつかのプログラムでは、端末スクリーンで詳細に外観を
制御する必要があります。これらのプログラムは特別な制御コードを送ることに
よりこれを行ないます。Termモードは、‘xterm’を含むほとんどの現代的な端末
で使用できる、ANSI標準のVT100スタイルのエスケープシーケンスを認識・処理
します(したがって、実際にEmacsのTermウィンドウ内でEmacsを実行することも
できます)。

   ‘term’フェイスは、端末エミュレーターのテキストのデフォルトの外観を指
定します(デフォルトは‘default’フェイスと同じ外観です)。端末の制御コード
がテキストの外観を変更するために使用される場合、これらは端末エミュレータ
ー内で、フェイス‘term-color-black’、‘term-color-red’、
‘term-color-green’、‘term-color-yellow’、‘term-color-blue’、
‘term-color-magenta’、‘term-color-cyan’、‘term-color-white’、
‘term-color-underline’、‘term-color-bold’で表示されます。*note Faces::を
参照してください。

   シリアルポートに接続されたデバイスと通信するために、Termモードを使う
こともできます。*note Serial Terminal::を参照してください。

   サブシェルをロードするために使用されるファイル名は、Shellモードと同じ
方法で決定されます。複数の端末エミュレーターを作成するには、Shellモード
と同じように、‘M-x rename-uniquely’を使って、バッファー‘*terminal*’を違
う名前にリネームします。

   Shellモードとは異なり、Termモードは入力を調べてカレントディレクトリー
を追跡することはしません。しかし、いくつかのシェルはカレントディレクトリ
ーをTermに告げることができます。これは‘bash’のバージョン1.15以降では自動
的に行なわれます。


File: emacs.info,  Node: Term Mode,  Next: Remote Host,  Prev: Terminal emulator,  Up: Shell

37.9 Termモード
===============

端末エミュレーターは、2つの入力モードをもつTermモードを使用します。
lineモードでは、Termは基本的にShellモードのように振る舞います(*note
Shell Mode::を参照してください)。charモードでは、Termのエスケープ文字(通
常は‘C-c’)を除き、文字は直接サブシェルに送られます。

   lineモードとcharモードを切り替えるには、以下のコマンドを使用します:

‘C-c C-j’
     lineモードに切り替えます(‘term-line-mode’)。すでにlineモードのとき
     は何もしません。

‘C-c C-k’
     charモードに切り替えます(‘term-char-mode’)。すでにcharモードのとき
     は何もしません。

   以下のコマンドはcharモードだけで利用可能です:

‘C-c C-c’
     サブシェルに、リテラルの‘C-c’を送ります。

‘C-c CHAR’
     これは通常のEmacsでの‘C-x CHAR’と等価です。たとえば‘C-c o’は、通常
     ‘C-x o’にグローバルにバインドされている‘other-window’を呼び出します
     。

   Termモードにはpage-at-a-time(1度に1ページ)機能があります。これが有効
な場合、出力の画面の最後で一時停止します。

‘C-c C-q’
     page-at-a-timeを切り替えます。このコマンドはlineモードとcharモード
     の両方で機能します。この機能が有効な場合、モードラインには単語
     ‘page’が表示され、Termが1画面に収まらない出力を受け取ったときは、一
     時停止してモードラインに‘**MORE**’を表示します。<SPC>とタイプすると
     次の1画面分の出力を表示し、‘?’でオプションを見ることができます。こ
     のインターフェースは、‘more’プログラムと同様です。


File: emacs.info,  Node: Remote Host,  Next: Serial Terminal,  Prev: Term Mode,  Up: Shell

37.10 リモートホストのシェル
============================

Termウィンドウから、通常の端末から使うコマンド(たとえば‘telnet’や
‘rlogin’)で、リモートコンピューターにログインすることができます。

   パスワードを尋ねるようなプログラムは、通常パスワードをエコーしないの
で、パスワードはバッファーにも表示されません。バッファーがcharモードの場
合、実際の端末で使用しているのと同じ動作になります。lineモードの場合、パ
スワードは一時的に表示されますが、リターンをタイプするとパスワードは消去
されます(これは自動的に行なわれます。特別なパスワード処理は行なっていま
せん)。

   別のマシンにログインしているときは、リモートログインコマンドのために
、環境変数‘TERM’をセットすることにより、端末タイプを指定する必要がありま
す(bashを使用している場合、リモートログインコマンドの前に、カンマで区切
らず値割り当てを記述することにより、これを行なうことができます)。端末タ
イプ‘ansi’または‘vt100’は、ほとんどのシステムで動作するでしょう。


File: emacs.info,  Node: Serial Terminal,  Prev: Remote Host,  Up: Shell

37.11 シリアル端末
==================

コンピューターに、シリアルポートに接続されたデバイスがあるとき、‘M-x
serial-term’とタイプすることにより、デバイスと通信することができます。こ
のコマンドは新しいTermモードのバッファーのために、ポート番号、スピード、
スイッチを尋ねます。Emacsは、通常のTermモードの端末で行なうのと同じよう
に、このバッファーを通じてシリアルデバイスと通信します。

   シリアルポートのスピードはビット毎秒で計ります。もっとも一般的なスピ
ードは9600ビット毎秒です。モードラインをクリックすることにより、このスピ
ードを対話的に変更できます。

   シリアルポートはモードラインの“8N1”をクリックしても設定できます。デフ
ォルトでは、シリアルポートは“8N1”に設定されており、これは各バイトは8ビッ
トからなり、パリティービットチェックなし、ストップビットが1であることを
意味します。

   スピードや設定が間違っている場合、デバイスと通信できず、おそらくウィ
ンドウにはゴミが出力されるでしょう。


File: emacs.info,  Node: Emacs Server,  Next: Printing,  Prev: Shell,  Up: Top

38 サーバーとしてのEmacsの使用
******************************

さまざまなプログラムが、特定のテキスト断片を編集するために、あなたが選択
したエディターを呼び出すことができます。たとえば、バージョンコントロール
システム(*note Version Control::を参照してください)は、バージョンコント
ロールログを入力するためのエディターを呼び出し、Unixの‘mail’ユーティリテ
ィーは送信メッセージの入力にエディターを呼び出します。慣例により、選択す
るエディターは、環境変数‘EDITOR’で指定されます。しかし‘EDITOR’を
‘emacs’にセットした場合、Emacsが呼び出されますが、これは便利な方法ではあ
りません — なぜなら新しいEmacsプロセスが開始されるからです。なぜこれが不
便かというと、新たなEmacsプロセスは、既存のEmacsプロセスのバッファー、コ
マンドヒストリー、その他の情報を共有しないからです。

   Emacsを“edit server(編集サーバー)”としてセットアップして、Emacsが外部
からの編集リクエストを“listen”し、それに応じて動作させることにより、この
問題を解決できます。Emacsサーバーを開始するには2つの方法があります:

   • ‘M-x server-start’とタイプするか、initファイル(*note Init File::を
     参照してください)に式‘(server-start)’を記述して、既存のEmacsプロセ
     スでコマンド‘server-start’を実行します。既存のEmacsプロセスがサーバ
     ーになり、Emacsを終了すると、サーバーはそのEmacsプロセスとともに終
     了します。

   • コマンドラインオプション‘--daemon’を使用して、Emacsを“daemon”として
     実行します。*note Initial Options::を参照してください。Emacsがこの
     方法で開始された場合、初期化の後に‘server-start’を呼び出し、初期フ
     レームを開くかわりに、呼び出した端末に制御を戻します。その後バック
     グラウンドで待機(wait)して、編集リクエストを待ちます(listen)。

   どちらの方法も、1度Emacsサーバーを開始すると、‘emacsclient’というシェ
ルコマンドを使用してEmacsに接続し、ファイルをvisitするよう指示できます。
環境変数‘EDITOR’に‘emacsclient’をセットすれば、外部プログラムは編集のた
めに既存のEmacsプロセスを使用できます。(1)

   変数‘server-name’を使って、一意な“サーバー名”を与えることにより、同一
マシン上で複数のEmacsサーバーを実行することができます。たとえば‘M-x
set-variable <RET> server-name <RET> foo <RET>’は、サーバー名を‘foo’にセ
ットします。‘emacsclient’プログラムは、‘-s’オプションで、名前によりサー
バーを指定できます(*note emacsclient Options::を参照してください)。

   一意なサーバー名によりサーバーを定義した場合、他のEmacsインスタンスか
らそのサーバーに接続し、‘server-eval-at’関数を使用して、そのサーバーで
Lisp式を評価できます。たとえば‘(server-eval-at "foo" '(+ 1 2))’は、式‘(+
1 2)’をサーバー‘foo’で評価して、‘3’を返します(そのような名前のサーバーが
存在しない場合はエラーをシグナルします)。現在のところ、これは主に開発者
に有用な機能です。

* Menu:

* Invoking emacsclient::     Emacsサーバーへの接続。
* emacsclient Options::      Emacsクライアントの開始オプション。

   ---------- Footnotes ----------

   (1) 別の環境変数を使うプログラムもいくつかあります。たとえば、TeXが
‘emacsclient’を使うようにするには、環境変数‘TEXEDIT’を‘emacsclient +%d
%s’にセットします。


File: emacs.info,  Node: Invoking emacsclient,  Next: emacsclient Options,  Up: Emacs Server

38.1 ‘emacsclient’の呼び出し
============================

‘emacsclient’プログラムを使う一番簡単な方法は、シェルコマンド
‘emacsclient FILE’を実行する方法です。ここでFILEはファイル名です。これは
Emacsサーバーに接続して、Emacsプロセスの既存のフレームの1つ — グラフィカ
ルなフレーム、またはテキスト端末のフレーム(*note Frames::を参照してくだ
さい) — でFILEをvisitするよう指示します。それから、そのフレームを選択し
て編集を開始できます。

   Emacsサーバーが存在しない場合、‘emacsclient’はエラーメッセージと共に
終了します。Emacsプロセスに既存のフレームがない場合 — これはサーバーがデ
ーモン(*note Emacs Server::を参照してください)として開始されたときに発生
し得ます — は、‘emacsclient’を呼び出した端末でEmacsフレームをオープンし
ます。

   オプション‘-c’および‘-t’を使用して、新しいフレームをグラフィカルなデ
ィスプレーまたはテキスト端末で開くように、‘emacsclient’に強制することも
できます。*note emacsclient Options::を参照してください。

   単一のテキスト端末で実行している場合、‘emacsclient’のシェルとEmacsサ
ーバーを、次の2つの方法で切り替えることができます。1つ目は、Emacsサーバ
ーと、別の仮想端末で‘emacsclient’を実行して、‘emacsclient’を呼び出した後
にEmacsサーバーの仮想端末に切り替える方法です。2つ目は、Emacsサーバー自
身からShellモード(*note Interactive Shell::を参照してください)、または
Termモード(*note Term Mode::を参照してください)を使って‘emacsclient’を呼
び出す方法です。‘emacsclient’は、Emacs配下のサブシェルのときだけブロック
するので、依然としてファイルの編集にEmacsを使用できます。

   EmacsサーバーでFILEの編集を終えたら、そのバッファーで‘C-x #’
(‘server-edit’)とタイプします。これはファイルを保存して、‘emacsclient’プ
ログラムに終了を告げるメッセージを送り返します。通常、‘EDITOR’を使うプロ
グラムは、何か他のことを行なう前に“エディター” — この場合は‘emacsclient’
— の終了を待ちます。

   複数のファイル名を引数にして‘emacsclient’を呼び出すこともできます。
‘emacsclient FILE1 FILE2 ...’は、EmacsサーバーにFILE1、FILE2、...を
visitするよう指示します。EmacsはFILE1をvisitしているバッファーを選択して
、他のバッファーをバッファーリストの最後に隠します(*note Buffers::を参照
してください)。指定されたすべてのファイルを終了したら(たとえば各サーバー
バッファーで‘C-x #’をタイプしたら)、‘emacsclient’プログラムは終了します
。

   サーバーバッファーを終了すると、そのバッファーがサーバーバッファーを
作成する前から存在していたバッファーでないかぎり、そのバッファーもkillさ
れます。しかし‘server-kill-new-buffers’を‘nil’にセットした場合、別の基準
が使用されます。この場合、サーバーバッファーの終了は、ファイル名が正規表
現‘server-temp-file-regexp’にマッチするときは、バッファーをkillします。
これはある種の“一時ファイル”を区別するための仕組みです。

   各‘C-x #’は、さまざまなファイルを編集する、保留されている外部要求が他
にないかチェックして、次のそのようなファイルを選択します。サーバーバッフ
ァーに辿り着くのに、‘C-x #’だけを使わなければならない訳ではありません。
サーバーバッファーに手動で切り替えることもできます。しかし‘C-x #’は、
‘emacsclient’に終了したことを告げる方法なのです。

   変数‘server-window’の値をウィンドウやフレームにした場合、‘C-x #’は常
に次のサーバーバッファーを、そのウィンドウまたはそのフレームに表示します
。


File: emacs.info,  Node: emacsclient Options,  Prev: Invoking emacsclient,  Up: Emacs Server

38.2 ‘emacsclient’のオプション
==============================

以下のようなオプション引数を‘emacsclient’プログラムに渡すことができます:

     emacsclient -c +12 FILE1 +4:3 FILE2

引数‘+LINE’および‘+LINE:COLUMN’は、その後に続くファイルの行番号、または
行番号と列番号を指定します。これらはEmacs自身に対するコマンドライン引数
と同じように機能します。 *note Action Arguments::を参照してください。

   その他の‘emacsclient’により認識されるオプション引数を以下にリストしま
す:

‘-a COMMAND’
‘--alternate-editor=COMMAND’
     ‘emacsclient’が、Emacsとの接続に失敗したとき実行するコマンドを指定
     します。これはスクリプト内で‘emacsclient’を実行するとき便利です。

     特別な例外として、COMMANDが空文字列の場合、接続に失敗したら
     ‘emacsclient’は(‘emacs --daemon’のように)Emacsをデーモンモードで開
     始して、再度接続を試みます。

     環境変数‘ALTERNATE_EDITOR’は、‘-a’オプションと同じ効果をもちます。
     両方が指定された場合は、後者のオプションが優先されます。

‘-c’
     既存のEmacsフレームを使うかわりに、新しいグラフィカルな“クライアン
     トフレーム(client frame)”を作成します。クライアントフレームでの、
     ‘C-x C-c’の特別な振る舞いについては、以下を参照してください。(Xサー
     バーに接続できない等で)新たにグラフィカルなフレームを作成しない場合
     、あたかも‘-t’オプションが指定されたかのように、テキスト端末でクラ
     イアントフレームの作成を試みます。

     MS-Windowsでは、単一のEmacsセッションがグラフィカルなフレームとテキ
     スト端末のフレームの両方を表示することはできず、複数のテキスト端末
     のフレームを表示することもできません。したがってEmacsサーバーがテキ
     スト端末で実行されている場合、‘-c’オプションは‘-t’オプションのよう
     に、サーバーのカレントテキスト端末で新たなフレームを作成します。
     *note Windows Startup::を参照してください。

     ‘-c’オプションを指定するときに、ファイル名の引数を省略した場合、新
     しいフレームはデフォルトで‘*scratch*’バッファーを表示します。変数
     ‘initial-buffer-choice’でこの振る舞いをカスタマイズできます(*note
     Entering Emacs::を参照してください)。

‘-F ALIST’
‘--frame-parameters=ALIST’
     新たに作成される、グラフィカルなフレームのパラメーターをセットしま
     す(*note Frame Parameters::を参照してください)。

‘-d DISPLAY’
‘--display=DISPLAY’
     与えられたファイルを、(複数のXディスプレーがあることを想定して)Xデ
     ィスプレーDISPLAYで開くようEmacsに指示します。

‘-e’
‘--eval’
     ファイルをvisitするかわりに、Emacs Lispコードを評価するようEmacsに
     指示します。このオプションが与えられた場合、‘emacsclient’は引数を
     visitするファイルではなく、式のリストと解釈します。

‘-f SERVER-FILE’
‘--server-file=SERVER-FILE’
     TCPを通じてEmacsサーバーに接続するための、“サーバーファイル(server
     file)”を指定します。

     Emacsサーバーは通常、接続をlistenするために、オペレーティングシステ
     ムの“ローカルソケット(local socket)”と呼ばれる仕組みを使用します。
     Microsoft Windowsのようないくつかのシステムは、ローカルソケットをサ
     ポートしません。このような場合、サーバーはTCPを通じて
     ‘emacsclient’と通信します。

     TCP Emacsサーバーを開始したとき、Emacsは‘emacsclient’がサーバーに接
     続するために使用する、TCP情報を含む“サーバーファイル(server file)”を
     作成します。デフォルトでは、これは‘~/.emacs.d/server/’です。
     ‘emacsclient’が特定のサーバーファイルを使ってTCPでサーバーに接続す
     るよう指示するには、オプション‘-f’または‘--server-file’を使用するか
     、環境変数‘EMACS_SERVER_FILE’をセットしてください。

‘-n’
‘--no-wait’
     すべてのサーバーバッファーが終了するのを待つかわりに、
     ‘emacsclient’が即座に終了するようにします。Emacsのサーバーバッファ
     ーで編集したいときに、このオプションを指定します。‘C-x #’をタイプし
     ても、これらはkillされません。

‘--parent-id ID’
     XEmbedプロトコルを通じて、IDがIDの親Xウィンドウでクライアントフレー
     ムとして、‘emacsclient’フレームをオープンします。現在のところ、これ
     は主に開発者に有用なオプションです。

‘-q’
‘--quiet’
     ‘emacsclient’がEmacsを待つメッセージ、またはリモートのサーバーソケ
     ットに接続するメッセージを表示しないようにします。

‘-s SERVER-NAME’
‘--socket-name=SERVER-NAME’
     名前がSERVER-NAMEのEmacsサーバーに接続します。サーバー名は、Emacsサ
     ーバー上の変数‘server-name’により与えられます。このオプションが省略
     された場合、‘emacsclient’は見つかったサーバーに接続します(このオプ
     ションはMS-Windowsではサポートされません)。

‘-t’
‘--tty’
‘-nw’
     既存のEmacsフレームを使うかわりに、カレントテキスト端末に新たなクラ
     イアントフレームを作成します。これはテキスト端末のフレームを作成す
     る点を除き、上記で説明した‘-c’と同じように振る舞います(*note
     Non-Window Terminals::を参照してください)。

     MS-Windowsでは、Emacsサーバーがグラフィカルなディスプレーを使ってい
     る場合は‘-c’のように振る舞いますが、Emacsサーバーがテキスト端末で実
     行されている場合は、カレントテキスト端末に新たなフレームを作成しま
     す。

   オプション‘-c’または‘-t’で作成された、グラフィカルなフレームおよびテ
キスト端末のフレームは、“クライアントフレーム(client frames)”とみなされ
ます。クライアントフレームから作成した新たなフレームも、クライアントフレ
ームとみなされます。クライアントフレームで‘C-x C-c’
(‘save-buffers-kill-terminal’)とタイプした場合、それが通常行なうような
Emacsセッションのkill(*note Exiting::を参照してください)は行なわれません
。かわりにEmacsはクライアントフレームを削除します。さらに、制御を取り戻
すために待っている‘emacsclient’をクライアントフレームがもつ場合(たとえば
‘-n’オプションを与えなかった場合)、Emacsは同じくクライアントの他のすべて
のフレームを削除し、(それらすべてにたいして‘C-x #’をタイプしたかのように
)クライアントのサーバーバッファーが終了したとマークします。クライアント
フレームが削除された後、残ったフレームが存在しない場合、Emacsセッション
は終了します。

   例外として、Emacsがデーモンとして開始された場合、すべてのフレームはク
ライアントフレームとみなされ、‘C-x C-c’がEmacsをkillすることはありません
。デーモンセッションを終了するには、‘M-x kill-emacs’とタイプします。

   ‘-t’と‘-n’は、矛盾するオプションであることに注意してください。‘-t’は
カレントテキスト端末に新たにクライアントフレームを作成して制御することを
指示し、‘-n’はテキスト端末で制御を行なわないことを指示するからです。両方
のオプションを与えた場合、‘-t’の効果は打ち消されて、Emacsは新たにフレー
ムを作成せず、既存のフレームで指定されたファイルをvisitします。


File: emacs.info,  Node: Printing,  Next: Sorting,  Prev: Emacs Server,  Up: Top

39 ハードコピーの印刷
*********************

Emacsは、バッファーの全体、または一部のハードコピーを印刷するコマンドを
提供します。以下で詳しく述べるとおり、直接印刷コマンドを呼び出したり、メ
ニューバーの‘File’メニューを使うことができます。

   このセクションで説明するコマンドとは別に、Dired(*note Operating on
Files::を参照してください)からハードコピーを印刷したり、ダイアリー(*note
Displaying the Diary::を参照してください)から印刷することもできます。コ
マンド‘M-x htmlfontify-buffer’で、EmacsバッファーをHTMLに“印刷”すること
もできます。これはEmacsのフェイスをCSSベースのマークアップに置換して、カ
レントバッファーをHTMLに変換します。さらにOrgモード(*note Org Mode::を参
照してください)では、OrgファイルをPDFのような様々なフォーマットに“印刷
”できます。

‘M-x print-buffer’
     ファイル名を含むページヘッダーとともに、カレントバッファーのハード
     コピーを印刷します。
‘M-x lpr-buffer’
     ページヘッダーなしで、カレントバッファーのハードコピーを印刷します
     。
‘M-x print-region’
     ‘print-buffer’と同様ですが、カレントリージョンだけを印刷します。
‘M-x lpr-region’
     ‘lpr-buffer’と同様ですが、カレントリージョンだけを印刷します。

   ほとんどのオペレーティングシステムでは、上記のハードコピーコマンドは
、‘lpr’プログラムを呼び出して、印刷のためにファイルをサブミットします。
印刷プログラムを変更するには、変数‘lpr-command’をカスタマイズします。追
加のスイッチを指定して、印刷プログラムにに与えるには、リスト変数
‘lpr-switches’をカスタマイズします。この変数の値はオプション文字列のリス
トで、それぞれが‘-’で始まります(たとえばオプション文字列‘"-w80"’は1行に
80列を指定します)。デフォルトは、空リスト‘nil’です。

   使用するプリンターを指定するには、変数‘printer-name’をセットします。
デフォルトは‘nil’で、これはデフォルトプリンターを指定します。これにプリ
ンター名(文字列)をセットした場合、その名前は‘-P’スイッチとともに‘lpr’に
渡されます。‘lpr’コマンドを使用しない場合は、スイッチを
‘lpr-printer-switch’で指定する必要があります。

   同様に変数‘lpr-headers-switches’は、ページヘッダーを作成するために使
用する追加のスイッチを指定します。変数‘lpr-add-switches’は、印刷プログラ
ムに‘-T’および‘-J’オプション(‘lpr’向きのオプションです)を渡すかどうかを
制御します。‘nil’は、これらを追加しないことを意味します(印刷プログラムが
‘lpr’)互換でない場合は、この値を使用するべきです)。

* Menu:

* PostScript::               バッファーまたはリージョンを、PostScriptとして印刷する。
* PostScript Variables::     PostScript印刷コマンドのカスタマイズ。
* Printing Package::         オプションの上級向け印刷インターフェース。


File: emacs.info,  Node: PostScript,  Next: PostScript Variables,  Up: Printing

39.1 PostScriptのハードコピー
=============================

これらのコマンドはバッファーの内容をPostScriptに変換して、それを印刷また
は別のEmacsバッファーに出力します。

‘M-x ps-print-buffer’
     PostScript形式で、カレントバッファーのハードコピーを印刷します。
‘M-x ps-print-region’
     PostScript形式で、カレントリージョンのハードコピーを印刷します。
‘M-x ps-print-buffer-with-faces’
     PostScript形式で、カレントバッファーのハードコピーを印刷し、テキス
     トで使用されているフェイスはPostScript機能により表示します。
‘M-x ps-print-region-with-faces’
     PostScript形式で、カレントリージョンのハードコピーを印刷し、テキス
     トで使用されているフェイスで表示します。
‘M-x ps-spool-buffer’
     カレントバッファーのテキストにたいするPostScriptイメージを生成およ
     びスプールします。
‘M-x ps-spool-region’
     カレントリージョンにたいするPostScriptイメージを生成およびスプール
     します。
‘M-x ps-spool-buffer-with-faces’
     カレントバッファーにたいするPostScriptイメージを生成およびスプール
     し、使用されているフェイスで表示します。
‘M-x ps-spool-region-with-faces’
     カレントリージョンにたいするPostScriptイメージを生成およびスプール
     し、使用されているフェイスで表示します。
‘M-x ps-despool’
     Send the spooled PostScript to the printer.
‘M-x handwrite’
     カレントバッファーにたいして、手書きされたようなPostScriptを生成・
     印刷します。

   ‘ps-print-buffer’および‘ps-print-region’コマンドは、バッファーの内容
をPostScript形式で印刷します。一方はバッファー全体を印刷し、もう一方はリ
ージョンだけを印刷します。コマンド‘ps-print-buffer-with-faces’および
‘ps-print-region-with-faces’も同様に振る舞いますが、バッファーテキストの
フェイス(フォントとカラー)を表示するためにPostScript機能を使用します。

   プレフィクス引数(‘C-u’)を使用した場合、このコマンドは対話的にユーザー
にファイル名の入力を求め、PostScriptイメージをプリンターに送るかわりに、
そのファイルに保存します。

   ‘print’のかわりに‘spool’が名前につくコマンドは、PostScript出力をプリ
ンターに送るかわりに、Emacsバッファーに出力することを意味します。

   コマンド‘ps-despool’を使用して、スプールされたイメージをプリンターに
送ります。このコマンドは‘-spool-’コマンド(上記コマンド参照)により生成さ
れたPostScriptをプリンターに送ります。プレフィクス引数(‘C-u’)を指定した
場合は、ファイル名の入力を求め、スプールされたPostScriptイメージをプリン
ターに送るかわりに、そのファイルに保存します。

   ‘M-x handwrite’はもっと他愛ない機能です。これはカレントバッファーの
PostScript表現を、草書体の手書きドキュメントのように生成します。これはグ
ループ‘handwrite’でカスタマイズできます。この関数はISO 8859-1文字だけサ
ポートします。


File: emacs.info,  Node: PostScript Variables,  Next: Printing Package,  Prev: PostScript,  Up: Printing

39.2 PostScriptハードコピーにたいする変数
=========================================

すべてのPostScriptハードコピーコマンドは、どのように出力を印刷するかの指
定に、変数‘ps-lpr-command’と‘ps-lpr-switches’を使用します。
‘ps-lpr-command’は実行するコマンド名、‘ps-lpr-switches’は使用するコマン
ドラインオプション、‘ps-printer-name’はプリンターを指定します。最初の2つ
の変数をセットしない場合、変数の初期値を‘lpr-command’と‘lpr-switches’か
ら取得します。‘ps-printer-name’が‘nil’の場合、‘printer-name’が使用されま
す。

   変数‘ps-print-header’は、これらのコマンドが各ページにヘッダー行を追加
するかを制御します。これを‘nil’にセットするとヘッダーはオフになります。

   プリンターがカラーをサポートしない場合は、‘ps-print-color-p’を‘nil’に
セットして、カラー処理をオフにするべきです。デフォルトでは、ディスプレー
がカラーをサポートしていれば、Emacsはカラー情報をもったハードコピー出力
を生成します。モノクロプリンターでは、カラーはグレーの濃淡でエミュレート
されます。スクリーンカラーがグレーの濃淡だけしか使用していなくても、これ
は読みにくい出力を生成するかもしれません。

   かわりに‘ps-print-color-p’を‘black-white’にセットして、モノクロプリン
ターで印刷する色をセットできます。

   デフォルトでは、変数‘ps-use-face-background’が非‘nil’でなければ、
PostScript印刷はフェイスのバックグラウンドカラーは無視します。これは望ま
しくないゼブラストライプや、バックグラウンドイメージとテキストの干渉を避
けるためです。

   変数‘ps-paper-type’は、フォーマットする用紙サイズを指定します。妥当な
値には‘a4’、‘a3’、‘a4small’、‘b4’、‘b5’、‘executive’、‘ledger’、
‘legal’、‘letter’、‘letter-small’、‘statement’、‘tabloid’が含まれます。
デフォルトは‘letter’です。変数‘ps-page-dimensions-database’を変更するこ
とにより、追加の用紙サイズを定義できます。

   変数‘ps-landscape-mode’は、ページの印刷向きを指定します。デフォルトは
‘nil’で、これは縦向き印刷モード(portrait mode)を意味します。非‘nil’値は
横向き印刷モード(landscape mode)を指定します。

   変数は列番号を指定します。この変数は横向きモードと縦向きモードの両方
で効果をもちます。デフォルトは1です。

   変数‘ps-font-family’は、通常のテキストを印刷するために使用するフォン
トファミリーを指定します。妥当な値には、‘Courier’、‘Helvetica’、
‘NewCenturySchlbk’、‘Palatino’、‘Times’が含まれます。変数
‘ps-font-size’は、通常のテキストのためのフォントサイズを指定します。デフ
ォルトは8.5ポイントです。

   Emacsは、通常のPostScriptプリンターより多くのスクリプトと文字をサポー
トします。したがってバッファーのいくつかの文字は、プリンターに組み込まれ
たフォントを使って印刷できないかもしれません。プリンターが提供するフォン
トをGNU Intlfontsパッケージのフォントで増強したり、EmacsにIntlfontsフォ
ントだけを使うように命令できます。変数‘ps-multibyte-buffer’がこれを制御
します。デフォルト値の‘nil’は、ASCIIおよびLatin-1文字を印刷するのに適し
ています。‘non-latin-printer’は、プリンターにASCII、Latin-1、Japanese、
Korean文字にたいするフォントが組み込まれている場合の値です。_すべて_の文
字にたいして使用される、IntlfontsパッケージのBDFフォントのための値が
‘bdf-font’です。最後に値‘bdf-font-except-latin’は、ASCIIおよびLatin-1文
字にたいしては組み込みフォントを使用し、それ以外の文字にたいしては
IntlfontsのBDFフォントを使用するよう指示します。

   BDFフォントを使えるようにするには、それをどこで見つけることができるか
を、Emacsが知る必要があります。変数‘bdf-directory-list’は、Emacsがこれら
のフォントを探すべきディレクトリーのリストを保持します。デフォルト値には
、1つのディレクトリー‘/usr/local/share/emacs/fonts/bdf’が含まれます。

   これらのコマンドに対する、その他多くのカスタマイズ変数は、Lispファイ
ル‘ps-print.el’および‘ps-mule.el’で定義・説明されています。


File: emacs.info,  Node: Printing Package,  Prev: PostScript Variables,  Up: Printing

39.3 印刷のためのパッケージ
===========================

ハードコピーを印刷するためのEmacsの基本的な機能は、Printingパッケージを
使って拡張できます。これは何を印刷するかの選択、印刷前のPostScriptファイ
ルのプレビュー、プリントヘッダーなどのさまざまな印刷オプションの設定、横
向きモードや縦向きモード、duplexモードにたいする使いやすいインターフェー
スを提供します。GNU/LinuxシステムまたはUnixシステムでは、Printingパッケ
ージは、GhostScriptプログラムの一部として配布される、‘gs’および‘gv’ユー
ティリティーに依存しています。MS-Windowsでは、Ghostscriptのポート版の
‘gstools’が使用されます。

   Printingパッケージを使用するには、initファイル(*note Init File::を参
照してください)に‘(require 'printing)’を追加して、その後に
‘(pr-update-menus)’と記述します。この関数はメニューバーの通常の印刷コマ
ンドを、さまざまな印刷オプションを含む‘Printing’サブメニューに置き換えま
す。‘M-x pr-interface <RET>’とタイプすることもできます。これはカスタマイ
ズバッファーに似た‘*Printing Interface*’バッファーを作成し、そこで印刷オ
プションをセットできます。何をどのようにして印刷するかセットした後、
‘Print’ボタン(それを‘Mouse-2’でクリックするか、その上にポイントを移動し
て<RET>をタイプします)で印刷ジョブを開始します。さまざまなオプションにつ
いての詳細は、‘Interface Help’ボタンを使用してください。


File: emacs.info,  Node: Sorting,  Next: Picture Mode,  Prev: Printing,  Up: Top

40 テキストのソート
*******************

Emacsは、バッファーのテキストをソートするためのコマンドをいくつか提供し
ています。これらはすべて、リージョンの内容にたいして処理を行ないます。こ
れらのコマンドはリージョンのテキストを、多数の“ソートレコード(sort
records)”に分割し、各レコードを“ソートキー(sort key)”で識別した後、ソー
トキーにより決定される順序にレコードを並び替えます。レコードは並び替えら
れ、レコードのキーはアルファベット順、または数値ソートでは数値順になりま
す。アルファベット順のソートでは、ASCII文字順にしたがい、‘A’から‘Z’のす
べての大文字は、小文字の‘a’の前になります。

   種々のソートコマンドは、テキストをどのようにソートレコードに分割する
か、そして各レコードのどの部分がソートキーとして使用されるかという点で異
なります。ほとんどのコマンドは行ごとにソートレコードを分割しますが、ソー
トレコードとしてパラグラフやページを使うコマンドもあります。ほとんどのソ
ートコマンドは、ソートレコード全体をソートキーとして使用しますが、レコー
ドの一部をソートキーとして使用するものもあります。

‘M-x sort-lines’
     リージョンを行に分割して、行のテキスト全体を比較してソートします。
     数引数は降順でソートすることを意味します。

‘M-x sort-paragraphs’
     リージョンをパラグラフに分割して、パラグラフのテキスト全体(先頭の空
     行は除く)を比較してソートします。数引数は降順にソートすることを意味
     します。

‘M-x sort-pages’
     リージョンをページに分割して、ページのテキスト全体(先頭の空行は除く
     )を比較してソートします。数引数は降順にソートすることを意味します。

‘M-x sort-fields’
     リージョンを行に分割して、各行のあるフィールドの内容を比較すること
     によりソートします。フィールドは空白で区切ることにより定義されるの
     で、ある行の最初の連続する非空白文字がフィールド1を構成し、2番目の
     そのような文字構成がフィールド2、...となります。

     どのフィールドでソートするかは数引数で指定します。1はフィールド1、
     2はフィールド2、...となります。負の引数はフィールドを左からではなく
     右から数えることを意味します。したがって、-1は最後のフィールドでソ
     ートするという意味です。ソートされるフィールドの内容が同じ行が複数
     存在する場合、バッファーの元の並び順が維持されます。

‘M-x sort-numeric-fields’
     ‘M-x sort-fields’と同様ですが、各行の指定されたフィールドを整数に変
     換して、その数字を比較します。テキストとして比較したとき‘10’は‘2’の
     前になりますが、数字として比較すると‘2’の後になります。デフォルトで
     は、数字は‘sort-numeric-base’により解釈されますが、‘0x’または‘0’で
     始まる数字は16進および8進で解釈されます。

‘M-x sort-columns’
     ‘M-x sort-fields’と同様ですが、各行で比較に使用されるテキストは固定
     長の列範囲です。以下の説明を参照してください。

‘M-x reverse-region’
     リージョンの行を逆順にソートします。フィールドまたは列でソートする
     コマンドは降順でソートする機能がないので、フィールドまたは列で降順
     にソートできるのは便利です。

   たとえば、以下のようなバッファー内容のとき:

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

バッファー全体に‘M-x sort-lines’を適用すると以下のようになります:

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

大文字の‘O’はすべての小文字の前にソートされます。かわりに‘C-u 2 M-x
sort-fields’を使用すると、以下が得られます:

     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

ここで、ソートキーは‘Emacs’、‘If’、‘buffer’、‘systems’、‘the’です。

   ‘M-x sort-columns’は説明が必要でしょう。ある列にポイントを配し、別の
列をマークして、ソート列を指定します。ソートしたいテキストの最初の行の先
頭にポイントまたはマークを配すことはできないので、このコマンドは特殊な
“リージョン”の定義を使用します。ポイントがある行はすべてリージョンの一部
と判断されます。マークがある行もすべてリージョンの一部と判断されます。同
様にその間にあるすべての行もリージョンの一部となります。

   たとえば、10列目から15列目までの情報でテーブルをソートするには、テー
ブルの最初の行の10列目にマークを置き、最後の行の15列目にポイントを置いて
、‘sort-columns’を実行します。最初の行の15列目にマークを置き、最後の行の
10列目にポイントを置いても、同じように実行できます。

   これはポイントとマークで指定された矩形領域をソートすると考えることが
できます。1つ違うのは、各行の矩形領域の左右にあるテキストも、矩形領域内
のテキストとともに移動するという点です。*note Rectangles::を参照してくだ
さい。

   ‘sort-fold-case’が非‘nil’の場合、多くのソートコマンドは比較時の大文字
小文字の違いを無視します。


File: emacs.info,  Node: Picture Mode,  Next: Editing Binary Files,  Prev: Sorting,  Up: Top

41 ピクチャーの編集
*******************

テキスト文字で作られたピクチャー(たとえばプログラムのコメントにあるよう
な、レジスターをフィールドに分割したピクチャーなど)を編集するには、コマ
ンド‘M-x picture-mode’を使用してPictureモードに入ります。

   Pictureモードでは、編集はテキストの“quarter-plane(1/4平面)”モデルにも
とづき、テキスト文字は、右方および下方に無限に広がる領域に点在します。こ
のモデルには、行の終端という概念は存在しません。せいぜい言えるのは、その
行の空白でない最後の文字がどこにあるかぐらいです。

   もちろん、実際にはEmacsはテキストを文字シーケンスとして考え、行は終端
をもちます。しかしPictureモードは、もっともよく使われるコマンドを、テキ
ストのquarter-planeモデルをシミュレートする変種に置き換えます。これらの
コマンドはスペースの挿入、またはタブをスペースに置き換えることにより、こ
れを行ないます。

   Emacsのほとんどの基本的な編集コマンドは、本質的には同等なことを
quarter-planeの方法で行なうように、Pictureモードにより再定義されます。そ
れに加えてPictureモードは、‘C-c’プレフィクスで始まる、特別なピクチャー編
集コマンドを実行する、さまざまなキーを定義します。

   これらのキーのうち特に重要なのは‘C-c C-c’です。ピクチャーが、通常は他
のメジャーモードで編集する、大きなファイルの一部ということもあります。
Pictureモードは以前のメジャーモードを記録するので、後で‘C-c C-c’
(‘picture-mode-exit’)コマンドでそのモードに戻ることができます。‘C-c
C-c’は数引数を与えなければ、行末のスペースの削除も行ないます。

   Pictureモードの特別なコマンドのすべては、(‘picture’ライブラリーがロー
ドされていれば)他のモードでも機能しますが、Pictureモード以外ではキーにバ
インドされません。以下の説明では、“1列”移動...のような言い方をしますが、
通常の同等なコマンドと同じように、Pictureモードのコマンドは数引数を扱う
ことができます。

   Pictureモードをオンにすることにより、フック‘picture-mode-hook’が実行
されます。Pictureモードにたいする追加の拡張は、‘artist.el’で見ることがで
きます。

* Menu:

* Basic Picture::            Pictureモードの基本概念と簡単なコマンド。
* Insert in Picture::        自己挿入文字の後のカーソル移動方向の制御。
* Tabs in Picture::          タブストップとインデントにたいするさまざまな機能。
* Rectangles in Picture::    矩形領域のクリアーと重ね合わせ。


File: emacs.info,  Node: Basic Picture,  Next: Insert in Picture,  Up: Picture Mode

41.1 Pictureモードでの基本的な編集
==================================

ほとんどのキーは、Pictureモードでも通常と同じことを、quarter-planeスタイ
ルで行ないます。たとえば‘C-f’は、‘picture-forward-column’を実行するよう
にリバインドされます。これはポイントを1列右に移動します。必要ならスペー
スを挿入するので実際の行末は関係ありません。‘C-b’は、
‘picture-backward-column’を実行するようにリバインドされます。必要ならタ
ブを複数のスペースに変換して、常に1列ポイントを左に移動します。‘C-n’と
‘C-p’は、‘picture-move-down’と‘picture-move-up’を実行するようにリバイン
ドされ、どちらもポイントが同じ列に留まるように、必要に応じてスペースの挿
入とタブの変換を行ないます。‘C-e’は、‘picture-end-of-line’を実行します。
これは、その行の最後の非空白文字の後に移動します。‘C-a’は、
‘picture-beginning-of-line’を実行します(スクリーンモデルの選択は行の開始
に影響を与えません。このコマンドが行なう追加事項は、カレントピクチャー列
を0に更新することです)。

   テキストの挿入は、Overwriteモードを通じてquarter-planeモデルに適合さ
れます (*note Minor Modes::を参照してください)。 自己挿入文字は既存のテ
キストを右にずらすのではなく、列ごとに既存のテキストを置き換えます。
<RET>は‘picture-newline’を実行し、これは単に次の行の先頭に移動するので、
新しいテキストでその行を置き換えることができます。

   Pictureモードでは、通常は削除やkillを行なうコマンドは、かわりにテキス
トを消去(スペースで置き換え)します。<DEL>
(‘picture-backward-clear-column’)は、前の文字を削除するのではなく、スペ
ースで置き換えます。これはポイントを後方に移動します。‘C-d’
(‘picture-clear-column’)は、次の文字をスペースで置き換えますが、ポイント
は移動しません(文字をクリアーして前方に移動したいときは<SPC>を使用します
)。‘C-k’ (‘picture-clear-line’)は、実際に行の内容をkillしますが、バッフ
ァーから改行は削除しません。

   実際に挿入を行なうには、特別なコマンドを使わなければなりません。‘C-o’
(‘picture-open-line’)は、カレント行の後に空行を作成します。行の分割はし
ません。Pictureモードでも‘C-M-o’ (‘split-line’)は意味があるので、変更さ
れていません。‘C-j’ (‘picture-duplicate-line’)は、カレント行の下に同じ内
容の行を挿入します。

   Pictureモードで実際の削除を行なうには、‘C-w’、‘C-c C-d’(これは他のモ
ードでは‘C-d’にバインドされている‘delete-char’にバインドされています)、
またはピクチャー矩形コマンドの1つを使用します(*note Rectangles in
Picture::を参照してください)。


File: emacs.info,  Node: Insert in Picture,  Next: Tabs in Picture,  Prev: Basic Picture,  Up: Picture Mode

41.2 挿入後の移動の制御
=======================

Pictureモードでは、“自己挿入”文字は上書きとポイント移動を行なうので、ポ
イントを移動する方法に、本質的に制限はありません。ポイントは通常右に移動
しますが、“自己挿入”文字の後に移動する方向は、直行方向と対角方向の8つの
うちから任意の方向を指定できます。これはバッファーに線を描くとき便利です
。

‘C-c <’
‘C-c <LEFT>’
     挿入の後、左に移動します(‘picture-movement-left’)。
‘C-c >’
‘C-c <RIGHT>’
     挿入の後、右に移動します(‘picture-movement-right’)。
‘C-c ^’
‘C-c <UP>’
     挿入の後、上に移動します(‘picture-movement-up’)。
‘C-c .’
‘C-c <DOWN>’
     挿入の後、下に移動します(‘picture-movement-down’)。
‘C-c `’
‘C-c <Home>’
     挿入の後、左上(“北西”)に移動します(‘picture-movement-nw’)。
‘C-c '’
‘C-c <prior>’
     挿入の後、右上(“北東”)に移動します(‘picture-movement-ne’)。
‘C-c /’
‘C-c <End>’
     挿入の後、左下(“南西”)に移動します(‘picture-movement-sw’)。
‘C-c \’
‘C-c <next>’
     挿入の後、右下(“南東”)に移動します(‘picture-movement-se’)。

   カレントPicture挿入方向にもとづき移動を行なうコマンドは2つです。1つは
コマンド‘C-c C-f’ (‘picture-motion’)で、その時点で“挿入”後に移動すると定
められた方向と同じ方向に移動するのが‘C-c C-f’ (‘picture-motion’)で、逆方
向へは‘C-c C-b’ (‘picture-motion-reverse’)です。


File: emacs.info,  Node: Tabs in Picture,  Next: Rectangles in Picture,  Prev: Insert in Picture,  Up: Picture Mode

41.3 Pictureモードでのタブ
==========================

Pictureモードでは、タブのような動作が2つ提供されます。コンテキストベース
のタブ動作には、‘M-<TAB>’ (‘picture-tab-search’)を使用します。引数を与え
ないと、前の空でない行で、空白の後の次の“意味をもつ”文字の下にポイントを
移動します。ここで“次”とは、“開始した位置から水平方向に大な位置”という意
味です。‘C-u M-<TAB>’のように引数を指定した場合、このコマンドはカレント
行で次の意味のある文字に移動します。‘M-<TAB>’はテキストを変更せず、ポイ
ントだけを移動します。“意味のある”文字は変数‘picture-tab-chars’により定
義され、これは一連の文字で定義されます。この変数の構文は正規表現での
‘[...]’の内側で使用される構文と似ていますが、‘[’と‘]’はありません。デフ
ォルト値は‘"!-~"’です。

   <TAB>は‘picture-tab’を実行し、これはカレントのタブストップの設定にも
とづき動作します。Pictureモードでは‘tab-to-tab-stop’と等価です。通常はポ
イントを移動するだけですが、数引数を指定した場合は、移動先までのテキスト
をクリアーします。

   コンテキストベースとタブストップベースのタブ動作形式は、‘C-c <TAB>’
(‘picture-set-tab-stops’)で合わせることができます。このコマンドは、カレ
ント行にたいして、‘M-<TAB>’が意味をもつと判断するであろう位置に、タブス
トップをセットします。このコマンドの使い方としては、<TAB>と合わせて、コ
ンテキストベースの効果を得ることができます。しかし‘M-<TAB>’で充分な場合
は、そちらのほうが便利です。

   ピクチャー内では、実際のタブ文字を抑止するほうが便利かもしれません。
たとえば、これにより‘C-x <TAB>’がピクチャーをめちゃくちゃにするのを防ぐ
ことができます。変数‘indent-tabs-mode’を‘nil’にセットすることにより、こ
れを行なうことができます。


File: emacs.info,  Node: Rectangles in Picture,  Prev: Tabs in Picture,  Up: Picture Mode

41.4 Pictureモードの矩形領域コマンド
====================================

Pictureモードは、quarter-planeモデルに適合する方法で、テキストの矩形部分
に作用するコマンドを定義します。標準の矩形領域コマンドも便利でしょう
*note Rectangles::を参照してください。

‘C-c C-k’
     矩形領域をスペースでクリアーします(‘picture-clear-rectangle’)。プレ
     フィクス引数を指定した場合、テキストを削除します。
‘C-c C-w R’
     同様ですが、最初にレジスターRに矩形領域の内容を保存します
     (‘picture-clear-rectangle-to-register’)。
‘C-c C-y’
     ポイント位置を左上隅として、最後にkillされた矩形領域をバッファーに
     上書きコピーします。引数を指定した場合は、上書きではなく挿入します
     。
‘C-c C-x R’
     同様ですが、レジスターRの矩形領域を使用します
     (‘picture-yank-rectangle-from-register’)。

   ピクチャー矩形領域コマンドの‘C-c C-k’ (‘picture-clear-rectangle’)と
‘C-c C-w’ (‘picture-clear-rectangle-to-register’)が、標準の矩形領域コマ
ンドと異なる点は、通常は矩形領域を削除するかわりにクリアーすることです。
これはPictureモードで‘C-d’が変更された方法と類似しています。

   しかしPictureモードで矩形領域を削除するのが便利なときもあるかもしれな
いので、これらのコマンドは数引数を与えたときは矩形領域を削除します。数引
数の指定の有無に関わらず、‘C-c C-k’は‘C-c C-y’のために矩形領域を保存しま
す。

   矩形領域をyankするPictureモードのコマンドは、挿入ではなく上書きすると
いう点で、標準の矩形領域コマンドと異なります。これはPictureモードでのテ
キストの挿入方法が他のモードと異なるのと同じです。‘C-c C-y’
(‘picture-yank-rectangle’)は、一番最近killされた矩形領域を(上書きにより
)挿入し、‘C-c C-x’ (‘picture-yank-rectangle-from-register’)は、指定され
たレジスターの矩形領域で同様のことを行ないます。


File: emacs.info,  Node: Editing Binary Files,  Next: Saving Emacs Sessions,  Prev: Picture Mode,  Up: Top

42 バイナリーファイルの編集
***************************

バイナリーファイルを編集する特別なメジャーモードに、Hexlモードがあります
。これを使用するには、ファイルをvisitするのに。‘C-x C-f’のかわりに‘M-x
hexl-find-file’を使用します。このコマンドはファイル内容を16進に変換して
、その変換結果を編集できるようにします。ファイルを保存するときは、自動的
にバイナリーに変換されます。

   既存のバッファーをhexに変換するために、‘M-x hexl-mode’を使用すること
もできます。これは普通にファイルをvisitしてから、それがバイナリーファイ
ルだと気づいた場合などに便利です。

   Hexlモードでは通常のテキスト文字は上書きです。これはファイル内のデー
タのアラインメントを意図せず壊してしまう危険を減らすためです。挿入のため
には特別なコマンドがあります。以下はHexlモードのコマンドのリストです:

‘C-M-d’
     10進でタイプされたバイトコードを挿入します。

‘C-M-o’
     8進でタイプされたバイトコードを挿入します。

‘C-M-x’
     16進でタイプされたバイトコードを挿入します。

‘C-x [’
     1Kバイト“ページ”の先頭に移動します。

‘C-x ]’
     1Kバイト“ページ”の最後に移動します。

‘M-g’
     16進で指定されたアドレスに移動します。

‘M-j’
     10進で指定されたアドレスに移動します。

‘C-c C-c’
     Hexlモードを抜けて、‘hexl-mode’モードを呼び出す前の、このバッファー
     のメジャーモードに戻ります。

他のHexlコマンドには、バイナリーバイトの文字列(シーケンス)の挿入、
‘short’、‘int’単位での移動などがあります。詳細については、‘C-h a
hexl-<RET>’とタイプしてください。


File: emacs.info,  Node: Saving Emacs Sessions,  Next: Recursive Edit,  Prev: Editing Binary Files,  Up: Top

43 Emacsセッションの保存
************************

Emacsの状態を1つのセッションから別のセッションのために保存するためには、
desktopライブラリーを使用します。1度Emacsの“デスクトップ(desktop)” — バ
ッファーと、それらのファイル名、メジャーモード、バッファーでの位置など —
を保存すると、後のEmacsセッションで、保存されたデスクトップをリロードで
きます。デフォルトでは、デスクトップはフレームとウィンドウ設定も保存しよ
うと試みます。これを無効にするには、‘desktop-restore-frames’を‘nil’にセ
ットします(この振る舞いを調整するためにマスタマイズできる関連オプション
については、変数のドキュメントを参照してください)。

   コマンド‘M-x desktop-save’で、デスクトップを手動で保存できます。
Emacs終了時のデスクトップの自動保存を有効にすることもできます。また
Emacs開始時に最後に保存されたデスクトップを自動的に復元することもできま
す。将来のセッションのためには、Customizationバッファー(*note Easy
Customization::を参照してください)を使用して、‘desktop-save-mode’を‘t’に
セットするか、initファイル(*note Init File::を参照してください)に以下の
行を追加します:

     (desktop-save-mode 1)

‘desktop-save-mode’がアクティブで、desktopファイルが存在する場合、
Emacsは‘desktop-auto-save-timeout’秒ごと(非‘nil’かつ非0の場合)にデスクト
ップを自動保存します。

   initファイルで‘desktop-save-mode’をオンにした場合、Emacsはカレントデ
ィレクトリーで保存されたデスクトップを探します(より正確には、
DESKTOP-PATHで指定されたディレクトリーを探して、最初に見つかったデスクト
ップを使用します)。したがって異なるディレクトリーに別のデスクトップを保
存でき、開始ディレクトリーによりEmacsがリロードするデスクトップを決定で
きます。‘M-x desktop-change-dir’とタイプすることにより、カレントデスクト
ップを保存して、他のディレクトリーに保存されたデスクトップをリロードでき
ます。‘M-x desktop-revert’とタイプすることにより、前にリロードされたデス
クトップをリバートできます。

   保存されたデスクトップをリロードしたくないときは、コマンドラインでオ
プション‘--no-desktop’を指定します。これはカレントセッションにたいして、
‘desktop-save-mode’をオフにします。‘--no-init-file’オプションを指定して
Emacsを開始することにより、通常‘desktop-save-mode’をオンにしているinitフ
ァイルをバイパスして、デスクトップのリロードを無効にすることもできます。

   デフォルトでは、デスクトップのすべてのバッファーは1度に復元されます。
しかし、デスクトップにたくさんのバッファーがあるときは遅くなるかもしれま
せん。変数‘desktop-restore-eager’で、即座に復元するバッファーの最大数を
指定できます。残りのバッファーはEmacsのアイドル時に、“ゆっくり
(lazily)”と復元されます。

   Emacsのデスクトップを空にするには、‘M-x desktop-clear’とタイプします
。これは内部バッファーを除いてすべてのバッファーをkillし、
‘desktop-globals-to-clear’にリストされたグローバル変数をクリアーします。
特定のバッファーを残したい場合は、変数
‘desktop-clear-preserve-buffers-regexp’をカスタマイズします。この変数の
値には、killしないバッファーの名前にマッチする正規表現を指定します。

   あるセッションから別のセッションへ、ミニバッファーのヒストリーを保存
したい場合は、‘savehist’ライブラリーを使用してください。


File: emacs.info,  Node: Recursive Edit,  Next: Hyperlinking,  Prev: Saving Emacs Sessions,  Up: Top

44 再帰編集レベル
*****************

“再帰編集(recursive edit)”とは、あるEmacsコマンドの途中で、別のEmacsコマ
ンドを使用して自由に編集を行なうような状況を指します。たとえば
‘query-replace’の途中で‘C-r’をタイプすると、カレントバッファーを変更する
ことができる再帰編集に入ります。再帰編集から抜けると、‘query-replace’に
戻ります。*note Query Replace::を参照してください。

   再帰編集を“抜ける(exit)”とは、実行を継続中の、終了していないコマンド
に戻ることを意味します。再帰編集を抜けるコマンドは‘C-M-c’
(‘exit-recursive-edit’)です。

   再帰編集を“中断(abort)”することもできます。これはexitと似ていますが、
終了していないコマンドも即座に終了します。これを行なうには、コマンド
‘C-]’ (‘abort-recursive-edit’)を使用します。*note Quitting::を参照してく
ださい

   モードラインで常にメジャーモードとマイナーモードの周りを囲む丸カッコ
(parentheses)を、さらに角カッコ(square brackets)で囲んで表示することによ
り、再帰編集中であることが示されます。再帰編集は特定のウィンドウやバッフ
ァーにたいするものではなく、Emacs全体が再帰編集中であるため、すべてのウ
ィンドウのモードラインは同じように表示されます。

   再帰編集中に、さらに再帰編集に入ることも可能です。たとえば
‘query-replace’の途中で‘C-r’とタイプした後、デバッガーに入るコマンドをタ
イプしたとします。これは‘C-r’にたいする再帰編集レベルから、デバッガーに
たいする再帰編集を開始します。モードラインには、現在進行中の再帰編集レベ
ルが角カッコのペアで表示されます。

   (デバッガーでの‘c’コマンドのように)内側の再帰編集を抜けると、次に上の
レベルのコマンドの実行が再開されます。コマンドが終了したら、他の再帰編集
レベルに抜けるために‘C-M-c’を使用することができます。exitは最内レベルだ
けに適用されます。abortも1レベルの再帰編集だけを抜けて、前の再帰編集レベ
ルのコマンドに即座に戻ります。もし望むなら次の再帰編集レベルもabortでき
ます。

   かわりにコマンド‘M-x top-level’は、すべてのレベルの再帰編集をabortし
て、即座にトップレベルのコマンドリーダーに戻ります。ミニバッファーがアク
ティブなときは、ミニバッファーも抜けます。

   再帰編集の中で編集されるテキストは、トップレベルで編集しているテキス
トと同じである必要はありません。これは、何にたいしての再帰編集かに依存し
ます。再帰編集を呼び出したコマンドが最初に別のバッファーを選択する場合、
そのバッファーが再帰編集を行なうバッファーになります。どんな場合でも再帰
編集中に、(バッファーを切り替えるキーがリバインドされていないかぎり)通常
の方法でバッファーを切り替えることができます。再帰編集の中で、ファイルを
visitしたりその他のことを行ない、残りのすべての編集を行なうことも、おそ
らく可能です。しかしこれは、(スタックオーバーフローのような)驚くべき効果
をもたらすことがあります。そのため必要なくなったときは、再帰編集をexitま
たはabortすることを忘れないでください。

   一般的に、わたしたちはGNU Emacsでは再帰編集レベルを最小限にしようと努
めています。これは、特定の順 — 最内のレベルからトップレベルに向かって —
で“戻る”ことをあなたに強いるからです。可能な場合は、異なる作業には別のバ
ッファーを供し、それらを切り替えられるようにします。いくつかのコマンドは
、元のメジャーモードに戻るコマンドを提供する、新しいメジャーモードに切り
替えます。これらの試みは、あなたの選択にしたがい、まだ終了していないタス
クにもどる、柔軟性を与えます。


File: emacs.info,  Node: Hyperlinking,  Next: Amusements,  Prev: Recursive Edit,  Up: Top

45 ハイパーリンクと操作機能
***************************

以下のサブセクションでは、URLや、Emacsバッファーのテキスト内にある他の種
類のリンクを扱う便利な機能を説明します。

* Menu:

* Browse-URL::               URLをフォローするには。
* Goto Address mode::        URLのアクティブ化について。
* FFAP::                     ポイント位置のファイルを探す、など。


File: emacs.info,  Node: Browse-URL,  Next: Goto Address mode,  Up: Hyperlinking

45.1 URLのフォロー
==================

‘M-x browse-url <RET> URL <RET>’
     ウェブブラウザーへのURLのロード。

   Browse-URLパッケージは、Emacsで簡単にURLをフォロー(辿る)することを可
能にします。ほとんどのURLは、ウェブブラウザーを呼び出すことによりフォロ
ーされます。‘mailto:’のURLは、指定されたアドレスにメールを送るために、
Emacsコマンドの‘compose-mail’でフォローされます。

   コマンド‘M-x browse-url’は、URLの入力を求め、それをフォローします。ポ
イントがURLのようなテキストの近くにある場合、そのURLがデフォルトとして提
示されます。Browse-URLパッケージは、‘browse-url-at-point’や
‘browse-url-at-mouse’のような、キーにバインドしたいと思うような、他のコ
マンドも提供します。

   Customizeグループ‘browse-url’の、さまざまなオプションを通じて、
Browse-URLの振る舞いをカスタマイズできます。特に、オプション
‘browse-url-mailto-function’では‘mailto:’のURL、
‘browse-url-browser-function’ではそれ以外のタイプのURLにたいして、どのよ
うな方法でフォローするか定義することができます。詳細は、‘C-h P
browse-url <RET>’とタイプすることにより表示される、パッケージのコメント
を参照してください。


File: emacs.info,  Node: Goto Address mode,  Next: FFAP,  Prev: Browse-URL,  Up: Hyperlinking

45.2 URLのアクティブ化
======================

‘M-x goto-address-mode’
     カレントバッファーのURLとメールアドレスをアクティブにします。

   ‘M-x goto-address-mode’とタイプすることにより、Emacsにカレントバッフ
ァーのURLを特別にマークさせることができます。このバッファーローカルなマ
イナーモードが有効な場合、バッファーのすべてのURLを探して、それらをハイ
ライトするとともに、クリックできるボタンに変更します。そのようなテキスト
の上にポイントを移動して‘C-c <RET>’ (‘goto-address-at-point’)とタイプす
るか、‘Mouse-2’をクリック、または‘Mouse-1’を素早くクリックすることにより
(*note Mouse References::を参照してください)、そのURLをフォローできます
。URLのフォローは、‘browse-url’をサブルーチンとして呼び出すことにより行
なわれます(*note Browse-URL::を参照してください)。

   モードフックや受信メッセージを表示するフック(たとえばRmailの
‘rmail-show-message-hook’や、MH-Eの‘mh-show-mode-hook’)に
‘goto-address-mode’を追加するのは便利かもしれません。Gnusには類似の機能
があるので必要ありません。


File: emacs.info,  Node: FFAP,  Prev: Goto Address mode,  Up: Hyperlinking

45.3 ポイント位置のファイルやURLを開く
======================================

FFAPパッケージは、‘C-x C-f’のようなファイルを探すためのキーにバインドさ
れているコマンドを、よりセンシティブなデフォルトを提供するコマンドに置き
換えます。これらのコマンドにプレフィクス引数を与えたときは、通常のコマン
ドと同様に振る舞います。それ以外の場合、ポイント周辺のテキストからデフォ
ルトのファイル名を取得します。バッファーから見つかったのがファイル名では
なくURLの場合、このコマンドはそれを閲覧するために‘browse-url’を使用しま
す(*note Browse-URL::を参照してください)。

   この機能は、メールバッファーやニュースバッファー内の参照、‘README’フ
ァイル、‘MANIFEST’ファイルなどをフォローするのに便利です。詳細については
、‘C-h P ffap <RET>’とタイプして、パッケージのコメントを参照してください
。

   FFAPを有効にするには、‘M-x ffap-bindings’とタイプします。これにより、
以下のキーバインドが作成され、Rmail、Gnus、VMアーティクルバッファーでの
、追加FFAP機能にたいするフックもインストールされます。

‘C-x C-f FILENAME <RET>’
     FILENAMEを検索します(‘find-file-at-point’)。デフォルトのファイル名
     は、ポイント周辺のテキストから推測します。
‘C-x C-r’
     ‘ffap-read-only’。‘find-file-read-only’に相当します。
‘C-x C-v’
     ‘ffap-alternate-file’。‘find-alternate-file’に相当します。
‘C-x d DIRECTORY <RET>’
     ポイント位置のディレクトリー名をデフォルトとして、DIRECTORYで
     Diredを開始します(‘dired-at-point’)。
‘C-x C-d’
     ‘ffap-list-directory’。‘list-directory’に相当します。
‘C-x 4 f’
     ‘ffap-other-window’。‘find-file-other-window’に相当します。
‘C-x 4 r’
     ‘ffap-read-only-other-window’。‘find-file-read-only-other-window’に
     相当します。
‘C-x 4 d’
     ‘ffap-dired-other-window’。‘dired-other-window’と同様です。
‘C-x 5 f’
     ‘ffap-other-frame’。‘find-file-other-frame’に相当します。
‘C-x 5 r’
     ‘ffap-read-only-other-frame’。‘find-file-read-only-other-frame’に相
     当します。
‘C-x 5 d’
     ‘ffap-dired-other-frame’。‘dired-other-frame’に相当します。
‘M-x ffap-next’
     バッファーから次のファイル名またはURLを検索して、そのファイルまたは
     URLを開きます。
‘S-Mouse-3’
     ‘ffap-at-mouse’は、マウスがクリックされた周辺のテキストから推測され
     たファイルを開きます。
‘C-S-Mouse-3’
     カレントバッファーに記述されたファイルとURLのメニューを表示して、選
     択されたものを開きます(‘ffap-menu’)。


File: emacs.info,  Node: Amusements,  Next: Packages,  Prev: Hyperlinking,  Up: Top

46 その他の娯楽
***************

‘animate’パッケージは、テキストをダンスさせます(たとえば‘M-x
animate-birthday-present’)。

   ‘M-x blackbox’、‘M-x mpuz’、‘M-x 5x5’はパズルです。‘blackbox’はボック
ス内のボールの位置を、トモグラフィー(断層撮影)により当てるパズルです。
‘mpuz’は掛け算パズルを表示します。掛け算の中の英字が何の数字かを当てなけ
ればなりません。数字を入力するには、英字をタイプしてから、その数字をタイ
プします。‘5x5’の目標は、すべてのマスを埋めることです。

   ‘M-x bubbles’は、より少ない回数の移動で、多くのbubble(シャボン玉)を取
り除くゲームです。

   ‘M-x decipher’は、単純なアルファベット置換で暗号化されたバッファーを
解読するのに役立ちます。

   ‘M-x dissociated-press’は、Emacsのカレントバッファーのテキストをスク
ランブルします。スクランブルは単語単位または文字単位で行なわれ、
‘*Dissociation*’という名前のバッファーに出力されます。正の引数は文字単位
での操作を指定し、数にはオーバーラップする文字数を指定します。負の引数は
単語単位での操作を指定し、数にはオーバーラップする単語数を指定します。
Dissociated Pressはマルコフ連鎖と酷似した結果を生成しますが、それとは独
自のigオリジナルな創案です。手法としては、単語または文字の後ろにランダム
にジャンプするマルコフ連鎖とは異なり、ランダムなジャンプの間にあるサンプ
ルから、連続する複数の文字をコピーします。ユーザーに受け入れられ、正確で
ありたいなら、ドキュメントにはdissociwordsを使用しないでください。

   ‘M-x dunnet’は、テキストベースのアドベンチャーゲームを開始します。

   個人的な満足感を得たいなら、‘M-x gomoku’に挑戦してみてください。これ
はあなたと五目並べゲームを対戦します。

   少し退屈していたら‘M-x hanoi’に挑戦してみてください。かなり退屈してい
るなら、数引数を指定します。とてもとても退屈なら、引数9に挑戦してみまし
ょう。さあ、座って眺めましょう。

   ‘M-x life’は、Conwayの“Life” cellular automatonを実行します。

   ‘M-x landmark’は比較的に非参加型なゲームを実行します。これは4方向から
の一意な嗅覚の合図にもとづいて、中央のツリーを目指して操縦されるロボット
です。

   ‘M-x morse-region’は、リージョンのテキストをモールス信号に変換し、
‘M-x unmorse-region’で元に戻します。‘M-x nato-region’は、リージョンのテ
キストをNATO発音記号(NATO phonetic alphabet)に変換し、‘M-x
denato-region’で元に戻します。

   ‘M-x pong’、‘M-x snake’、‘M-x tetris’は、有名なPong、Snake、Tetrisの
実装です。

   ‘M-x solitaire’はソリティアーゲームをプレーします。これはピンを他のピ
ンを超えてジャンプさせるゲームです。

   ‘M-x zone’は、Emacsがアイドル時にプレーするゲームです。

   最後に、もし不満を感じているときは、有名な精神分析医のElizaに問題の説
明を試みてください。これは‘M-x doctor’とタイプするだけです。各入力の最後
には、<RET>を2回タイプしてください。


File: emacs.info,  Node: Packages,  Next: Customization,  Prev: Amusements,  Up: Top

47 Emacs Lispパッケージ
***********************

Emacsには、追加の機能を実装する“パッケージ(packages)”を、簡単にダウンロ
ードしてインストールする機能が含まれています。それぞれのパッケージは個別
のEmacs Lispプログラムで、Infoマニュアルのような他の構成要素が含まれてい
るときもあります。

   ‘M-x list-packages’により、すべてのパッケージのリストを含む、
‘*Packages*’という名前のバッファーが表示されます。このバッファーを通じて
パッケージをインストールしたりアンインストールできます。*note Package
Menu::を参照してください。

   コマンド‘C-h P’ (‘describe-package’)はパッケージ名の入力を求め、その
パッケージの属性や、実装する機能を説明するヘルプバッファーを表示します。

   デフォルトでは、Emacsはemacs開発者により保守されGNUプロジェクトにより
ホスティングされる、“パッケージアーカイブ(package archive)”からパッケー
ジをダウンロードします。オプションでサードパーティーにより保守されるアー
カイブから、パッケージをダウンロードすることもできます。*note Package
Installation::を参照してください。

   Emacs Lispプログラムをインストール可能なパッケージにチューニングする
情報については、*note (elisp)Packaging::を参照してください。サードパーテ
ィーのパッケージや、その他のEmacs Lisp拡張については、*note
(efaq)Packages that do not come with Emacs::を参照してください。

* Menu:

* Package Menu::             パッケージを閲覧・管理するためのバッファー。
* Package Installation::     パッケージのインストールにたいするオプション。
* Package Files::            パッケージがインストールされる場所。


File: emacs.info,  Node: Package Menu,  Next: Package Installation,  Up: Packages

47.1 Package Menuバッファー
===========================

コマンド‘M-x list-packages’は、“パッケージメニュー(package menu)”を立ち
上げます。これはEmacsが把握するすべてのパッケージをリストするバッファー
です。リストの各行には以下の情報が表示されます:

   • パッケージ名(例: ‘auctex’)。

   • パッケージのバージョン番号(例: ‘11.86’)。

   • パッケージのステータス(status: 状態) — 通常は、‘available’(利用可能
     。パッケージアーカイブからダウンロードできます)、‘installed’(インス
     トール済み)、‘built-in’(ビルトイン、組み込み。デフォルトでEmacsに含
     まれます)のうちの1つです。

     ステータスが‘new’のこともあります。これは‘available’と同じですが、
     最後に‘M-x list-packages’を呼び出した後に、そのパッケージがパッケー
     ジアーカイブで新たに利用可能になったことを意味します。他にもパッケ
     ージは‘held’、‘disabled’、‘obsolete’のステータスをもつかもしれませ
     ん。*note Package Installation::を参照してください。

   • パッケージの短い説明。

‘list-packages’は、パッケージアーカイブサーバーから利用可能なパッケージ
のリストを取得するために、ネットワークにアクセスします。ネットワークが利
用できない場合、一番最近取得したリストにフォールバックします。

   パッケージメニューでは、以下のコマンドが利用可能です:

‘h’
     パッケージメニューの使い方を要約した短いメッセージを表示します
     (‘package-menu-quick-help’)。

‘?’
‘<RET>’
     カレント行のパッケージにたいして、‘C-h P’コマンド(*note Packages::を
     参照してください)により表示されるヘルプウィンドウと同様の、ヘルプバ
     ッファーを表示します(‘package-menu-describe-package’)。

‘i’
     カレント行のパッケージをインストールのためにマークします
     (‘package-menu-mark-install’)。パッケージのステータスが
     ‘available’の場合、行の先頭に文字‘I’を追加します。‘x’とタイプすると
     、パッケージをダウンロードしてインストールします(以下参照)。

‘d’
     カレント行のパッケージを削除のためにマークします
     (‘package-menu-mark-delete’)。パッケージのステータスが‘installed’の
     場合、行の先頭に文字‘D’を追加します。‘x’とタイプすると、パッケージ
     を削除します(以下参照)。パッケージ削除の結果、何が起こるかについて
     の情報は、*note Package Files::を参照してください。

‘u’
     ‘i’や‘d’コマンドにより、でカレント行に追加された、以前のインストー
     ルまたは削除のマークを外します。

‘U’
     新たに利用可能になったすべてのパッケージを、“更新”のためにマークし
     ます(‘package-menu-mark-upgrades’)。これは新たに利用可能になったバ
     ージョンにインストールのマークをつけ、インストール済みの古いバージ
     ョンに削除のマークをつけます。

‘x’
     ‘i’でマークされたすべてのパッケージをダウンロードしてインストールす
     るとともに、‘d’でマークされたすべてのパッケージを削除します
     (‘package-menu-execute’)。これによりマークは削除されます。

‘r’
     パッケージリストを更新します(‘package-menu-refresh’)。これは再度パ
     ッケージアーカイブから利用可能なパッケージのリストを取得して、パッ
     ケージリストを再計算します。

‘f’
     パッケージリストをフィルターします(‘package-menu-filter’)。これはキ
     ーワード(例: ‘games’)の入力を求め、そのキーワードに関連するパッケー
     ジだけを表示します。完全なパッケージリストを復元するには、‘q’をタイ
     プします。

たとえばパッケージをインストールするには、そのパッケージの行で‘i’をタイ
プしてから、‘x’をタイプします。


File: emacs.info,  Node: Package Installation,  Next: Package Files,  Prev: Package Menu,  Up: Packages

47.2 パッケージのインストール
=============================

パッケージを一番便利にインストールするのはパッケージメニューを使う方法
(*note Package Menu::を参照してください)ですが、コマンド‘M-x
package-install’を使用することもできます。これはステータスが
‘available’のパッケージ名の入力を求め、それをダウンロードしてインストー
ルします。

   他のパッケージが提供する機能に依存するために、それらのパッケージがイ
ンストール済みであることを“必要(require)”とするパッケージもあるでしょう
。Emacsがそのようなパッケージをインストールするときは、必要なパッケージ
がインストールされていなければ、それらのパッケージのダウンロードとインス
トールも自動に行ないます(必要なパッケージが何らかの理由で利用できない場
合、Emacsはエラーをシグナルしてインストールを中止します)。パッケージの必
要条件リスト(requirements list)は、そのパッケージのヘルプバッファーに表
示されます。

   デフォルトでは、パッケージはEmacs開発者により保守される単一のパッケー
ジアーカイブからダウンロードされます。これは変数‘package-archives’により
制御されます。この変数の値は、Emacsが認識するパッケージアーカイブのリス
トです。リストの各要素は‘(ID . LOCATION)’という形式でなければなりません
。ここで、IDはパッケージアーカイブの名前、LOCATIONはパッケージアーカイブ
のHTTPアドレスかディレクトリー名です。サードパーティーのアーカイブを使用
したい場合はこのリストを変更できます — が、自己責任で行い、信用できるサ
ードパーティーだけを使用してください!

   パッケージアーカイブのメンテナーは、パッケージに“サイン(signing)”を付
して、信頼度を増すことができます。これらはプライベートとパブリックの対に
なる暗号化キーにより生成されます。プライベートキーは各パッケージにたいす
る“署名ファイル(signature file)”を作成するのに使用されます。パブリックキ
ーにより、署名ファイルを使用してそのパッケージを作成したのが誰か、そして
それが変更されていないかを検証できます。有効な署名であっても、それが悪意
がないパッケージであることを厳正に保証する訳ではなく、用心するべきです。
パッケージアーカイブは、パブリックキーの入手方法について、説明を提供する
べきです。<http://pgp.mit.edu/>のようなサーバーからキーをダウンロードす
るのも1つの方法です。Emacsにキーをインポートするには、‘M-x
package-import-keyring’を使用します。Emacsは‘package-user-dir’のサブディ
レクトリー‘gnupg’に、パッケージのキーを保管します。GNUパッケージアーカイ
ブにたいするパブリックキーはEmacsと共に配布され、
‘etc/package-keyring.gpg’にあります。Emacsはこれを自動的に使用します。

   ユーザーオプション‘package-check-signature’が非‘nil’の場合、Emacsはパ
ッケージのインストール時に書名の検証を試みます。このオプションが値
‘allow-unsigned’をもつ場合、サインされていないパッケージのインストールが
できます。パッケージにサインしないアーカイブを使用する場合、それらを
‘package-unsigned-archives’に追加できます。

   暗号化キーとサインについての詳細は、*note Top: (gnupg)Top.を参照して
ください。EmacsのGNU Privacy Guardにたいするインターフェースについては、
*note EasyPG: (epa)Top.を参照してください。

   複数のパッケージアーカイブが有効で、同じパッケージにたいして異なるバ
ージョンを提供する場合は、オプション‘package-pinned-packages’が便利かも
しれません。指定したパッケージが指定されたアーカイブだけからダウンロード
されるように、このリストにパッケージとアーカイブのペアーを追加できます。

   1度パッケージをダウンロードしてインストールすると、そのパッケージはカ
レントEmacsセッションに“ロード”されます。パッケージのロードは、Lispライ
ブラリーのロード(*note Lisp Libraries::を参照してください)とまったく同一
ではありません。その効果はパッケージごとにさまざまです。ほとんどのパッケ
ージは、いくつかの新たなコマンドを利用可能にするだけですが、Emacsセッシ
ョンにたいして広範な影響を及ぼすものもあります。この種の情報については、
パッケージのヘルプバッファーを参照してください。

   デフォルトでは、インストールされたパッケージは、Emacsその後のはセッシ
ョンで、自動的にロードされます。これはEmacs開始時、initファイル処理後
(*note Init File::を参照してください)に行なわれます。例外として、‘-q’ま
たは‘--no-init-file’オプション(*note Initial Options::を参照してください
)で呼び出されたときは、Emacs開始時のパッケージのロードは行なわれません。

   自動的なパッケージのロードを無効にするには、変数
‘package-enable-at-startup’を‘nil’に変更してください。

   自動的なパッケージのロードがinitファイルのロード後である理由は、(パッ
ケージシステムに影響するものも含む)ユーザーオプションが、カスタマイズさ
れた値を受けとるのがinitファイルののロード後だからです。initファイルの中
で明示的にパッケージをロードしたい状況があるかもしれません(たいていは、
initファイルの他のコードが、あるパッケージに依存する等の理由により)。そ
のような場合、initファイルで関数‘package-initialize’を呼び出す必要があり
ます。‘package-initialize’の呼び出しの前に、‘package-load-list’(以下参照
)などの関連するユーザーオプションをセットアップするのは、あなたの責任で
す。initファイルを処理した後に、パッケージを重複してロードするのを避ける
ために、‘package-enable-at-startup’も‘nil’にセットするべきです。かわりに
、開始時にパッケージのロードを完全に抑止して、後でコマンド‘M-x
package-initialize’を呼び出して手動でパッケージをロードする方法を選択し
たいと思うかもしれません。

   パッケージのロードをより精密に制御するために、変数
‘package-load-list’を使用することができます。この変数の値にはリストを指
定します。リストの要素は‘(NAME VERSION)’という形式で、これはEmacsにパッ
ケージ名NAMEのバージョンVERSIONをロードするよう指示します。ここで、
VERSIONには、(そのパッケージの特定のバージョンに対応する)バージョン文字
列か、‘t’(これは任意のインストール済みのバージョンを意味します)、または
‘nil’(これはバージョンを意味しません。パッケージがロードされるのを防いで
、そのパッケージを“無効”にします)を指定します。リストの要素にはシンボル
‘all’も指定でき、これは他のリスト要素で名前指定されていない、任意のパッ
ケージのインストール済みバージョンをロードすることを意味します。デフォル
ト値は、単に‘'(all)’となっています。

   たとえば‘package-load-list’を‘'((muse "3.20") all)’にセットした場合、
Emacsは‘muse’のバージョン3.20と、‘muse’以外のパッケージのインストール済
みの任意のバージョンをロードします。‘muse’の他のバージョンがインストール
されていたとしても、それらは無視されます。‘muse’パッケージは、‘held’とい
うステータスでパッケージメニューにリストされるはずです。


File: emacs.info,  Node: Package Files,  Prev: Package Installation,  Up: Packages

47.3 パッケージのファイルとディレクトリー
=========================================

各パッケージはパッケージアーカイブから単一ファイル形式 －－－ 1つのEmacs
Lispソースファイル、または複数のEmacs Lispソースと他のファイルを含む
tarファイル — でダウンロードされます。パッケージファイルは、パッケージを
インストールするEmacsコマンドにより自動的に取得、処理、配置されます。パ
ッケージを作成する(*note (elisp)Packaging::を参照してください)のでない限
り、通常これらを直接扱う必要はないでしょう。パッケージファイルから直接パ
ッケージをインストールする必要があるときは、コマンド‘M-x
package-install-file’を使用してください。

   1度インストールされると、パッケージの内容はそのサブディレクトリーに配
置されます(変数‘package-user-dir’を変更することにより、ディレクトリーの
名前を変更できます)。パッケージのサブディレクトリーは‘NAME-VERSION’とい
う名前で、NAMEはパッケージ名、VERSIONはバージョン文字列です。

   ‘package-user-dir’に加えて、Emacsは‘package-directory-list’にリストさ
れたディレクトリーからインストール済みパッケージを探します。これらのディ
レクトリーはシステム管理者のためのディレクトリーで、Emacsパッケージをシ
ステムワイドに利用可能にするためのものです。Emacs自身がこれらのディレク
トリーにパッケージをインストールすることはありません。
‘package-directory-list’にたいするパッケージのサブディレクトリーは、
‘package-user-dir’と同じ方法で配置されます。

   パッケージの削除(*note Package Menu::を参照してください)は、対応する
パッケージのサブディレクトリーを削除します。これは‘package-user-dir’にイ
ンストールされたパッケージだけに機能します。システムワイドなパッケージデ
ィレクトリーにたいして呼び出された場合、削除コマンドはエラーをシグナルし
ます。


File: emacs.info,  Node: Customization,  Next: Quitting,  Prev: Packages,  Up: Top

48 カスタマイズ
***************

このチャプターでは、Emacsの振る舞いをカスタマイズするシンプルな方法をい
くつか説明します。

   ここで説明する方法とは別に、EmacsをカスタマイズするためにX resourcesを
使用する情報については*note X Resources::、キーボードマクロの記録と再生
については*note Keyboard Macros::を参照してください。より広範で制限のな
い変更を行なうには、Emacs Lispコードを記述する必要があります。 *note
Emacs Lisp: (elisp)Top.を参照してください。

* Menu:

* Easy Customization::       設定を閲覧したり変更する便利な方法。
* Variables::                多くのEmacsコマンドは何を行なうか決定するためにEmacs変数を調べるので、変数をセットすることによりこれらの機能を制御できます。
* Key Bindings::             keymapsは各キーがどのコマンドを実行するか指定します。これらを変更することによりキーを再定義できます。
* Init File::                初期化ファイルで一般的なカスタマイズを記述する方法。


File: emacs.info,  Node: Easy Customization,  Next: Variables,  Up: Customization

48.1 Easy Customizationインターフェース
=======================================

Emacsには変更できる多くの“セッティング(settings)”があります。ほとんどの
セッティングは“カスタマイズ可能な変数(customizable variables。*note
Variables::を参照してください)”で、これらは“ユーザーオプション(user
options)”とも呼ばれます。非常にたくさんのカスタマイズ可能な変数があり、
それらはEmacsの振る舞いを数々の側面から制御します。このマニュアルにドキ
ュメントされている変数は、*note Variable Index::にリストされています。セ
ッティングの別のクラスには“フェイス(faces)”があり、これはフォント、カラ
ー、その他のテキスト属性を決定します(*note Faces::を参照してください)。

   セッティング(変数およびフェイスの両方)を閲覧したり変更するには、‘M-x
customize’とタイプします。これは論理的に組織化されたセッティングのリスト
の操作、値の編集とセット、永続的な保存を行なうことができる、“カスタマイ
ズバッファー(customization buffer)”を作成します。

* Menu:

* Customization Groups::     セッティングがクラス化される方法。
* Browsing Custom::          セッティングのブラウズとサーチ。
* Changing a Variable::      オプション値の編集、およびオプションをセットする方法。
* Saving Customizations::    将来のEmacsセッションのためにカスタマイズを保存する。
* Face Customization::       フェイスの属性を編集する方法。
* Specific Customization::   グループの特定のセッティングのカスタマイズ。
* Custom Themes::            カスタマイズセッティングのコレクション。
* Creating Custom Themes::   新しいカスタムテーマを作成する方法。


File: emacs.info,  Node: Customization Groups,  Next: Browsing Custom,  Up: Easy Customization

48.1.1 カスタマイズグループ
---------------------------

カスタマイズセッティングは、“カスタマイズグループ(customization
groups)”に組織化されています。これらのグループはより大きなグループに集め
られ、最終的に‘Emacs’と呼ばれるマスターグループに集約されます。

   ‘M-x customize’は、トップレベルの‘Emacs’グループを表示するカスタマイ
ズバッファーを作成します。これは、部分的には以下のようなものです:

     For help, see [Easy Customization] in the [Emacs manual].

     ________________________________________ [ Search ]

      Operate on all settings in this buffer:
      [ Revert... ] [ Apply ] [ Apply and Save ]


     Emacs group: Customization of the One True Editor.
           [State]: visible group members are all at standard values.
           See also [Manual].

     [Editing] : Basic text editing facilities.
     [Convenience] : Convenience features for faster editing.

     MORE SECOND-LEVEL GROUPS

このバッファーも表示されている主要な部分は‘Emacs’カスタマイズグループで
、これはいくつかの他のグループ(‘Editing’、‘Convenience’など)を含みます。
これらのグループの内容はここではリストされず、それぞれにたいして1行のド
キュメントだけが表示されています。

   グループの“state(ステート、状態)”には、そのグループ内のセッティングが
、編集されているか(edited)、セットされているか(set)、保存されているか
(saved)が示されます。*note Changing a Variable::を参照してください。

   カスタマイズバッファーのほとんどは読み取り専用ですが、編集できるいく
つかの“編集可能フィールド(editable fields)”が含まれています。たとえばカ
スタマイズバッファーの最上部にある編集可能フィールドは、セッティングを検
索するためのものです(*note Browsing Custom::を参照してください)。マウス
でクリック、またはポイントをそこに移動して<RET>をタイプすることによりア
クティブにできる、“ボタン(buttons)”や“リンク(links)”もあります。たとえば
‘[Editing]’のようなグループ名はリンクで、これらのリンクをアクティブにす
ることにより、そのグループにたいするカスタマイズバッファーが立ち上がりま
す。

   カスタマイズ可能なバッファーでは、<TAB> (‘widget-forward’)とタイプす
ると、次のボタンまたは編集可能フィールドに前方へ移動します。‘S-<TAB>’
(‘widget-backward’)は、前のボタンまたは編集可能フィールドに後方へ移動し
ます。


File: emacs.info,  Node: Browsing Custom,  Next: Changing a Variable,  Prev: Customization Groups,  Up: Easy Customization

48.1.2 セッティングのブラウズと検索
-----------------------------------

‘M-x customize’により作成されたトップレベルのカスタマイズバッファーから
、カスタマイズグループ‘Emacs’のサブグループへのリンクをフォローできます
。これらのサブグループは、カスタマイズするためのセッティングを含んでいる
でしょう。また、これらのサブグループには、Emacsのより特化したサブシステ
ムを扱うサブグループが、さらに含まれているかもしれません。カスタマイズグ
ループの階層を移動していけば、カスタマイズしたい、いくつかのセッティング
が見つかるでしょう。

   特定のセッティングまたはカスタマイズグループのカスタマイズに興味があ
る場合は、コマンド‘M-x customize-option’、‘M-x customize-face’、‘M-x
customize-group’で直接移動することもできます。*note Specific
Customization::を参照してください。

   どのグループまたはセッティングをカスタマイズしたいか確信がもてない場
合、各カスタマイズバッファーの上部にある、編集可能なサーチフィールドを使
用して、それらを検索できます。このフィールドで検索条件 — 1つの単語または
スペースで区切られた複数の単語、または正規表現(*note Regexps::を参照して
ください) — をタイプできます。それからそのフィールドで<RET>をタイプする
か、となりの‘Search’ボタンをアクティブにすることにより、その条件にマッチ
するグループとセッティングを含むカスタマイズバッファーに切り替わります。
しかし、この機能はカレントEmacsセッションにロードされたグループ、または
セッティングだけを探すことに注意してください。

   カスタマイズバッファーにサーチフィールドを表示したくない場合は、変数
‘custom-search-field’を‘nil’に変更してください。

   コマンド‘M-x customize-apropos’は、同じようにサーチフィールドを使用し
ますが、これはミニバッファーを使用して検索条件を読み取ります。*note
Specific Customization::を参照してください。

   ‘M-x customize-browse’は、利用可能なセッティングをブラウズする別の方
法です。このコマンドは、グループまたはセッティングの名前だけを、構造化さ
れたレイアウトで表示する、特別なカスタマイズバッファーを作成します。グル
ープ名のとなりの‘[+]’ボタンを呼び出すことにより、同じバッファーでグルー
プの内容を表示できます。グループの内容が表示されている場合、ボタンは
‘[-]’に変化し、それを呼び出すことにより、再びグループ内容を隠すことがで
きます。このバッファーのグループまたはセッティングには、それぞれ
‘[Group]’、‘[Option]’、‘[Face]’というリンクがあります。このリンクを呼び
出すことにより、そのグループ、オプション、フェイスだけを表示する、通常の
カスタマイズバッファーが作成されます。‘M-x customize-browse’では、この方
法によりセッティングを変更します。


File: emacs.info,  Node: Changing a Variable,  Next: Saving Customizations,  Prev: Browsing Custom,  Up: Easy Customization

48.1.3 変数の変更
-----------------

以下は変数またはユーザーオプションが、カスタマイズバッファーではどのよう
に表示されるかの例です:

     [Hide] Kill Ring Max: 60
        [State]: STANDARD.
        Maximum length of kill ring before oldest elements are thrown away.

   最初の行には、この変数の名前が‘kill-ring-max’であることが、見やすいよ
う‘Kill Ring Max’のようにフォーマットされてに表示されています。この変数
の値は‘60’です。‘[Hide]’というラベルのボタンは、アクティブにした場合は、
この変数の値とステートを隠します。これは、変数がもし非常に長い値をもつ場
合、カスタマイズバッファーが見にくくなるのを避けるために便利です(この理
由により、非常に長い値をもつ変数は、最初は隠されています)。‘[Hide]’ボタ
ンを使用すると、ボタンは‘[Show Value]’に変化し、これをアクティブにすると
値とステートが表示されます。グラフィカルなディスプレーでは、‘[Hide]’と
‘[Show Value]’ボタンは、下向きまたは右向きのグラフィカルな三角形で置き換
えられます。

   変数名の次の行は、変数の“カスタマイズ状態(customization state)”を示し
ます。この例では‘STANDARD’で、これは変数を変更していないので、値はデフォ
ルトのままだということを意味します。‘[State]’ボタンは、変数をカスタマイ
ズするためのオペレーションメニューを提供します。

   カスタマイズのステートの下は、変数のドキュメントです。これは‘C-h v’コ
マンド(*note Examining::を参照してください)で表示されるのと同じドキュメ
ントです。ドキュメントが複数行の場合、1行だけが表示されます。この場合、
その行の最後に‘[More]’ボタンが表示されるので、これをアクティブにすれば完
全なドキュメントを表示できます。

   ‘Kill Ring Max’に新しい値を入力するには、値にポイントを移動してそれを
編集するだけです。たとえば‘M-d’とタイプして‘60’を削除して、別の値をタイ
プします。テキストの変更を開始すると、‘[State]’行が変化します:

     [State]: EDITED, shown value does not take effect until you
              set or save it.

値を編集してもすぐに変更は反映されません。変更を反映するには、
‘[State]’をアクティブにして、‘Set for Current Session’を選択することによ
り、変数を“セット(set)”しなければなりません。すると変数のステートは以下
のようになります:

     [State]: SET for current session only.

無効な値を指定してしまうことを心配する必要はありません。‘Set for Current
Session’オペレーションは正当性をチェックして、不当な値はインストールしま
せん。

   ファイル名、ディレクトリー名、Emacsコマンドのようなタイプの値を編集す
るときは、‘C-M-i’ (‘widget-complete’)、または等価なキー‘M-<TAB>’、‘<ESC>
<TAB>’で補完を行なうことができます。これはミニバッファーでの補完と同じよ
うに振る舞います(*note Completion::を参照してください)。

   編集可能な値フィールドで<RET>とタイプすることにより、<TAB>のように、
次のフィールドまたはボタンに移動できます。したがってフィールドの編集を終
えたら<RET>とタイプして、次のボタンまたはフィールドに移動できます。編集
可能なフィールドに改行を挿入するには、‘C-o’または‘C-q C-j’を使用します。

   あらかじめ決められた値しかセットできず、値を直接編集することができな
い変数もいくつかあります。そのような変数の値の前には、かわりに‘[Value
Menu]’ボタンが表示されます。このボタンをアクティブにすると、値の選択肢が
表示されます。“onかoff”のブーリーン値にたいしては、‘[Toggle]’ボタンが表
示され、このボタンにより値のオンとオフを切り替えることができます。
‘[Value Menu]’ボタンや‘[Toggle]’ボタンを使用した後は、変数をセットして、
選択した値を反映するために、再度値をセットしなければなりません。

   複雑な構造の値をもつ変数もいくつか存在します。たとえば、
‘minibuffer-frame-alist’の値は連想配列(association list、alist)です。こ
れはカスタマイズバッファーでは、以下のように表示されます:

     [Hide] Minibuffer Frame Alist:
     [INS] [DEL] Parameter: width
                 Value: 80
     [INS] [DEL] Parameter: height
                 Value: 2
     [INS]
        [ State ]: STANDARD.
        Alist of parameters for the initial minibuffer frame. [Hide]
        [...more lines of documentation...]

この場合、リストの各association要素は2つのアイテムからなり、1つは
‘Parameter’というラベルがつき、もう1つは‘Value’というラベルがつき、両方
とも編集可能フィールドです。となりにある‘[DEL]’ボタンでリストから
associationを削除できます。associationを追加するには、挿入したい位置の
‘[INS]’ボタンを使用します。一番最後の‘[INS]’ボタンはリストの最後に挿入し
ます。

   変数をセットした場合、新しい値はカレントEmacsセッションでだけ効果があ
ります。将来のセッションのために値を“保存(save)”するには、‘[State]’ボタ
ンを使用して、‘Save for Future Sessions’オペレーションを選択します。
*note Saving Customizations::を参照してください。

   ‘[State]’ボタンを使用して‘Erase Customization’オペレーションを選択す
ることにより、変数の値をその変数の標準値に復元することもできます。実際に
は4つのリセットオペレーションがあります:

‘Undo Edits’
     値を変更したが、まだ変数をセットしていない場合は、実際の値にマッチ
     するようにバッファーのテキストを復元します。

‘Reset to Saved’
     これは変数の値を最後に保存された値に復元し、テキストもそれに合わせ
     て更新します。

‘Erase Customization’
     これは変数をその変数の標準値にセットします。保存した値も削除します
     。

‘Set to Backup Value’
     これはこのセッションでカスタマイズバッファーでセットされる前の値に
     、変数をリセットします。変数をカスタマイズしてからリセットすると、
     これはカスタマイズした値を破棄するので、このオペレーションにより、
     破棄した値に戻すことができます。

   特定のカスタマイズにたいして、コメントを記録できれば便利なこともあり
ます。コメントを入力するフィールドを作成するには、‘[State]’メニューの
‘Add Comment’アイテムを使用します。

   カスタマイズバッファーの上部には2行のボタン行があります:

      [Set for Current Session] [Save for Future Sessions]
      [Undo Edits] [Reset to Saved] [Erase Customization]   [Exit]

最初の5つのボタンは、このバッファーでのすべてのセッティングが意味をもち
反映されるように、ステートのオペレーション — セット、保存、リセットなど
— を行ないます。これらのボタンは、隠されたセッティング、隠されたサブグル
ープのセッティング、このバッファーに表示されていないセッティングは操作し
ません。

   コマンド‘C-c C-c’ (‘Custom-set’)は、‘[Set for Current Session]’ボタン
を使用するのと等価です。コマンド‘C-x C-s’ (‘Custom-save’)は、‘[Save for
Future Sessions]’ボタンを使用するのと同様です。

   ‘[Exit]’ボタンはカスタマイズバッファーを、バッファーリストの最後のバ
ッファーに隠し(bury)ます。カスタマイズバッファーをkillさせるようにするに
は、変数‘custom-buffer-done-kill’を‘t’に変更します。


File: emacs.info,  Node: Saving Customizations,  Next: Face Customization,  Prev: Changing a Variable,  Up: Easy Customization

48.1.4 カスタマイズの保存
-------------------------

カスタマイズバッファーでは、カスタマイズしたセッティングの‘[State]’ボタ
ンで‘Save for Future Sessions’を選択することにより、それを“保存(save)”で
きます。‘C-x C-s’ (‘Custom-save’)コマンド、またはカスタマイズバッファー
のトップにある‘[Save for Future Sessions]’ボタンで、そのバッファー内で適
用可能なすべてのセッティングが保存されます。

   ファイル(通常は初期化ファイル。*note Init File::を参照してください)に
コードを書き込むことにより保存は機能します。将来のEmacsセッションは、開
始時に自動的にこのファイルを読み込んで、カスタマイズを再びセットします。

   初期化ファイル以外の他のファイルにカスタマイズを保存する選択もできま
す。これが機能するには、変数‘custom-file’に保存したいファイル名をセット
して、そのファイルをロードするコード行を追加しなければなりません。たとえ
ば:

     (setq custom-file "~/.emacs-custom.el")
     (load custom-file)

   以下のようにして、Emacsのバージョンごとに違うカスタマイズファイルを指
定することさえ可能です:

     (cond ((< emacs-major-version 22)
            ;; Emacs 21 customization.
            (setq custom-file "~/.custom-21.el"))
           ((and (= emacs-major-version 22)
                 (< emacs-minor-version 3))
            ;; Emacs 22 customization, before version 22.3.
            (setq custom-file "~/.custom-22.el"))
           (t
            ;; Emacs version 22.3 or later.
            (setq custom-file "~/.emacs-custom.el")))

     (load custom-file)

   Emacsが‘-q’または‘--no-init-file’オプションで呼び出されたときは、カス
タマイズを初期化ファイルに保存しません。なぜならそのようなセッションから
カスタマイズを保存することにより、初期化ファイルに記述されていた他のすべ
てのカスタマイズが消されてしまうからです。


File: emacs.info,  Node: Face Customization,  Next: Specific Customization,  Prev: Saving Customizations,  Up: Easy Customization

48.1.5 フェイスのカスタマイズ
-----------------------------

フェイス(*note Faces::を参照してください)をカスタマイズできます。フェイ
スは、異なる種類のテキストをEmacsがどのように表示するか決定します。カス
タマイズグループは、変数とフェイスの両方を含むことができます。

   たとえばプログラミング言語のモードでは、ソースコードのコメントはフェ
イス‘font-lock-comment-face’で表示されます(*note Font Lock::を参照してく
ださい)。カスタマイズバッファーでは、このフェイスについて以下のように表
示されます:

     [Hide] Font Lock Comment Face:[sample]
        [State] : STANDARD.
        Font Lock mode face used to highlight comments.
        [ ] Font Family: --
        [ ] Font Foundry: --
        [ ] Width: --
        [ ] Height: --
        [ ] Weight: --
        [ ] Slant: --
        [ ] Underline: --
        [ ] Overline: --
        [ ] Strike-through: --
        [ ] Box around text: --
        [ ] Inverse-video: --
        [X] Foreground: Firebrick     [Choose]  (sample)
        [ ] Background: --
        [ ] Stipple: --
        [ ] Inherit: --
        [Hide Unused Attributes]

最初の3行にはフェイス名、‘[State]’ボタン、そのフェイスにたいするドキュメ
ントが表示されます。その下は、“フェイス属性(face attributes)”のリストで
す。それぞれの属性の前にはチェックボックスがあります。チェックされている
チェックボックスは‘[X]’と表示され、このフェイスがその属性に値を指定して
いることを意味します。空のチェックボックスは‘[ ]’と表示され、このフェイ
スがその属性に特に値を指定していないことを意味します。チェックボックスを
アクティブにすることにより、その属性を指定または未指定にできます。

   フェイスにすべての属性を指定する必要はありません。実際のところ、ほと
んどのフェイスは少しの属性しか指定していません。上記の例では、
‘font-lock-comment-face’はフォアグラウンドカラーだけを指定しています。未
指定の属性にたいしては、すべての属性が指定された特別なフェイス
‘default’の属性が使用されます。‘default’フェイスは、明示的にフェイスが割
り当てられていない任意のテキストを表示するために使用されるフェイスです。
さらに、このフェイスのバックグラウンドカラー属性には、フレームのバックグ
ラウンドカラーが使用されます。

   属性リストの最後にある‘Hide Unused Attributes’ボタンは、このフェイス
の未指定の属性を隠します。隠された属性があるとき、ボタンは‘[Show All
Attributes]’に変化し、これはすべての属性リストを表示します。カスタマイズ
バッファーは、インターフェースが見にくくなるのを避けるため、未指定の属性
が隠された状態で開始されるでしょう。

   属性を指定するときは、通常の方法で値を変更できます。

   フォアグラウンドカラーとバックグラウンドカラーは、カラーネームとRGBト
リプレットの両方を使用して指定できます(*note Colors::を参照してください
)。カラーネームのリストに切り替えるために、‘[Choose]’ボタンも使用できま
す。そのバッファーで<RET>でカラーを選択すると、値フィールドにそのカラー
ネームが入ります。

   フェイスのセット・保存。リセットは、変数にたいする操作と同様に機能し
ます(*note Changing a Variable::を参照してください)。

   フェイスは、異なるタイプのディスプレーにたいして、違う外観を指定でき
ます。たとえば、カラーディスプレーではテキストを赤にして、モノクロディス
プレーでは太字フォントを使うようにフェイスを設定できます。フェイスにたい
して複数の外観を指定するには、‘[State]’で呼び出されるメニューで‘For All
Kinds of Displays’を選択してください。


File: emacs.info,  Node: Specific Customization,  Next: Custom Themes,  Prev: Face Customization,  Up: Easy Customization

48.1.6 特定のアイテムのカスタマイズ
-----------------------------------

‘M-x customize-option <RET> OPTION <RET>’
‘M-x customize-variable <RET> OPTION <RET>’
     1つのユーザーオプションOPTIONにたいするカスタマイズバッファーをセッ
     トアップします。
‘M-x customize-face <RET> FACE <RET>’
     1つのフェイスFACEにたいするカスタマイズバッファーをセットアップしま
     す。
‘M-x customize-group <RET> GROUP <RET>’
     1つのグループGROUPにたいするカスタマイズバッファーをセットアップし
     ます。
‘M-x customize-apropos <RET> REGEXP <RET>’
     REGEXPにマッチする、すべてのセッティングとグループにたいするカスタ
     マイズバッファーをセットアップします。
‘M-x customize-changed <RET> VERSION <RET>’
     EmacsのバージョンVERSIONから意味が変更された、すべてのセッティング
     とグループにたいするカスタマイズバッファーをセットアップします。
‘M-x customize-saved’
     カスタマイズバッファーを使って保存された、すべてのセッティングを含
     むカスタマイズバッファーをセットアップします。
‘M-x customize-unsaved’
     セットしたが保存していない、すべてのセッティングを含むカスタマイズ
     バッファーをセットアップします。

   特定のユーザーオプションをカスタマイズしたい場合は、‘M-x
customize-option’とタイプします。これは変数名を読み取り、そのユーザーオ
プション1つだけのためのカスタマイズバッファーをセットアップします。ミニ
バッファーから変数名を入力するときは、補完が利用可能ですが、Emacsにロー
ドされた変数名だけが補完されます。

   同様に‘M-x customize-face’を使用して、特定のフェイスをカスタマイズで
きます。‘M-x customize-group’を使用して、特定のカスタマイズグループにた
いするカスタマイズバッファーをセットアップできます。

   ‘M-x customize-apropos’は検索条件 — 1つの単語か、スペースで区切られた
複数の単語、または正規表現 — の入力を求め、名前がそれにマッチする、_ロー
ドされた_すべてのセッティングとグループにたいするカスタマイズバッファー
をセットアップします。これはカスタマイズバッファーのトップにあるサーチフ
ィールドを使用するのと同様です(*note Customization Groups::を参照してく
ださい)。

   新しいバージョンのEmacsにアップグレードしたとき、新しいセッティングを
カスタマイズしたり、意味やデフォルト値が変更されたものをセッティングした
いと思うかもしれません。これを行なうには‘M-x customize-changed’を使用し
て、ミニバッファーから以前のEmacsのバージョンを指定します。これは指定さ
れたバージョンから変更されたすべてのセッティングとグループを表示するカス
タマイズバッファーを作成し、必要ならそれらをロードします。

   セッティングを変更した後、その変更が間違いだと気づいたときは、変更を
戻すために2つのコマンドを使用できます。保存されたカスタマイズのセッティ
ングには、‘M-x customize-saved’を使用します。セットしたが保存していない
カスタマイズのセッティングには、‘M-x customize-unsaved’を使用します。


File: emacs.info,  Node: Custom Themes,  Next: Creating Custom Themes,  Prev: Specific Customization,  Up: Easy Customization

48.1.7 カスタムテーマ
---------------------

“カスタムテーマ(Custom themes)”は、1つの単位として有効または無効にできる
、セッティングのコレクションです。カスタムテーマを使用して、さまざまなセ
ッティングコレクション間を簡単に切り替えることができ、あるコンピューター
から別のコンピューターへそのようなコレクションを持ち運ぶことができます。

   カスタムテーマは、Emacs Lispソースファイルとして保存されています。カ
スタムテーマの名前がNAMEなら、そのテーマのファイル名は‘NAME-theme.el’で
す。テーマファイルのフォーマットと、それを作成する方法については、*note
Creating Custom Themes::を参照してください。

   ‘M-x customize-themes’とタイプすると、Emacsが認識するカスタムテーマを
リストする、‘*Custom Themes*’という名前のバッファーに切り替わります。デ
フォルトでは、Emacsは2つの場所からテーマファイルを探します。1つは
‘custom-theme-directory’により指定されるディレクトリー(デフォルトは
‘~/.emacs.d/’))で、もう1つはEmacsがインストールされた場所(変数
‘data-directory’を参照してください)の‘etc/themes’というディレクトリーで
す。後者にはEmacsと共に配布されるいくつかのカスタムテーマが含まれており
、これらはさまざまなカラースキーム(color schemes)に適合するように、
Emacsフェイスをカスタマイズします(しかし、カスタムテーマの目的はこれだけ
に制限される必要はなく、変数をカスタマイズするのにも使用できることに注意
してください)。

   Emacsに他の場所からカスタムテーマを探させたい場合は、リスト変数
‘custom-theme-load-path’にディレクトリー名を追加します。この変数のデフォ
ルト値は‘(custom-theme-directory t)’です。ここでシンボル
‘custom-theme-directory’は、変数‘custom-theme-directory’の値を指定すると
いう特別な意味をもち、‘t’はビルトインのテーマディレクトリー
‘etc/themes’を意味します。‘custom-theme-load-path’で指定されるディレクト
リーにあるテーマが、‘*Custom Themes*’バッファーにリストされます。

   ‘*Custom Themes*’バッファーでは、カスタムテーマの隣のチェックボックス
をアクティブにすることにより、カレントEmacsセッションで、そのテーマを有
効または無効にできます。カスタムテーマが有効な場合、そのテーマのすべての
セッティング(変数とフェイス)がEmacsセッションで効果をもちます。選択した
テーマを将来のEmacsセッションに適用するには、‘C-x C-s’
(‘custom-theme-save’)とタイプするか、‘[Save Theme Settings]’ボタンを使用
してください。

   最初にカスタムテーマを有効にするとき、Emacsはテーマファイルの内容を表
示して、本当にロードするか確認を求めます。これはカスタムテーマのロードに
より不定なLispコードが実行されるからで、テーマが安全だと判っているときだ
けyesと答えるべきです。この場合、Emacsは将来のセッションのために、そのテ
ーマが安全だということを記憶するか尋ねます(これは変数
‘custom-safe-themes’にテーマファイルのSHA-256ハッシュ値を保存することに
より行なわれます)。すべてのテーマを安全なものとして扱いたい場合は、変数
の値を‘t’)に変更します。(ディレクトリー‘etc/themes’の)Emacsと共に配布さ
れるテーマは、このチェックから除外されていて、常に安全だと判断されます。

   カスタムテーマのセッティングと保存は、変数‘custom-enabled-themes’をカ
スタマイズすることにより機能します。この変数の値は、カスタムテーマ名
(‘tango’のようなLispシンボル)のリストです。‘custom-enabled-themes’のセッ
トに‘*Custom Themes*’バッファーを使用するかわりに、たとえば‘M-x
customize-option’のような通常のカスタマイズインターフェースを使用して、
変数をカスタマイズできます。カスタムテーマ自身では、
‘custom-enabled-themes’をセットできないことに注意してください。

   カスタマイズバッファーを通じて行なう任意のカスタマイズは、テーマのセ
ッティングより優先されます。これによりテーマのセッティングを簡単にオーバ
ーライドできます。2つの異なるテーマのセッティングがオーバーラップする場
合には、‘custom-enabled-themes’で先に指定されたテーマが優先されます。カ
スタマイズバッファーでは、カスタムテーマによりセッティングがデフォルトか
ら変更されているときは、‘State’には‘STANDARD’ではなく‘THEMED’が表示され
ます。

   ‘M-x load-theme’とタイプすることにより、カレントEmacsセッションで特定
のカスタムテーマを有効にできます。これはテーマ名の入力を求め、テーマファ
イルからテーマをロードし、それを有効にします。すでにテーマファイルがロー
ドされているときは、‘M-x enable-theme’とタイプすることにより、ファイルを
ロードせずにテーマを有効にできます。カスタムテーマを無効にするには、‘M-x
disable-theme’とタイプしてください。

   カスタムテーマの説明を見るには、‘*Custom Themes*’バッファーのその行で
、‘?’とタイプするか、Emacsの任意のバッファーで‘M-x describe-theme’とタイ
プしてテーマ名を入力してください。


File: emacs.info,  Node: Creating Custom Themes,  Prev: Custom Themes,  Up: Easy Customization

48.1.8 カスタムテーマの作成
---------------------------

‘M-x customize-create-theme’とタイプすることにより、カスタマイズバッファ
ーと似たインターフェースを使用して、カスタムテーマを定義できます。これは
‘*Custom Theme*’という名前のバッファーに切り替えます。これは、一般的な
Emacsフェイスをそのテーマに挿入するかも尋ねます(カスタムテーマは、フェイ
スをカスタマイズするのに使用される場合があるので便利です)。これにnoと答
えると、そのテーマには最初は何もセッティングが含まれません。

   ‘*Custom Theme*’バッファーの上部には、テーマ名と説明を入力できる、編
集可能フィールドがあります。‘user’を除く任意の名前を指定できます。説明は
、テーマにたいして‘M-x describe-theme’を呼び出したときに表示される文です
。最初の行は1センテンスの概要であるべきです。‘M-x customize-themes’によ
り作成されたバッファーでは、このセンテンスがテーマ名のとなりに表示されま
す。

   テーマに新しいセッティングを追加するには、‘[Insert Additional Face]’ボ
タンか、‘[Insert Additional Variable]’ボタンを使用します。これらのボタン
はミニバッファーを使用して、補完つきでフェイス名または変数名を読み取り、
そのフェイスまたは変数にたいするカスタマイズエントリーを挿入します。通常
のカスタマイズバッファーと同じ方法で、変数の値またはフェイスの属性を編集
できます。テーマからフェイスまたは変数を削除するには、名前の横のチェック
ボックスのチェックを外してください。

   カスタムテーマのフェイスや変数を指定した後は、‘C-x C-s’
(‘custom-theme-write’)とタイプするか、そのバッファーの‘[Save Theme]’ボタ
ンを使用します。これは‘custom-theme-directory’のディレクトリーに、
‘NAME-theme.el’(NAMEはテーマ名)という名前で、テーマファイルを保存します
。

   ‘*Custom Theme*’バッファーから、‘[Visit Theme]’ボタンをアクティブにし
てテーマ名を指定することにより、既存のカスタムテーマの閲覧と編集ができま
す。‘[Merge Theme]’ボタンを使用して、他のテーマのセッティングをバッファ
ーに追加することもできます。‘[Merge Theme]’ボタンを使用して、‘user’とい
う名前の特別なテーマ名を指定することにより、非テーマセッティングをカスタ
ムテーマにインポートできます。

   テーマファイルは単なるEmacs Lispソースファイルで、カスタムテーマのロ
ードはLispファイルをロードすることにより機能します。したがって‘*Custom
Theme*’バッファーを使用するかわりに、テーマファイルを直接編集することも
できます。詳細は、*note (elisp)Custom Themes::を参照してください。


File: emacs.info,  Node: Variables,  Next: Key Bindings,  Prev: Easy Customization,  Up: Customization

48.2 変数
=========

“変数(variable)”とは、値をもつLipシンボルです。このようなシンボルの名前
は、“変数名(variable name)”とも呼ばれます。変数名には、ファイルに記述で
きる任意の文字を含めることもできますが、ほとんどの変数名は通常の単語をハ
イフンで区切って構成されます。

   変数の名前には、その変数の役割を簡単に説明する役目があります。ほとん
どの変数は“ドキュメント文字列(documentation string)”ももっていて、これは
変数の目的、どのような種類の値をもつべきか、値がどのように使用されるかを
説明します。ヘルプコマンド‘C-h v’ (‘describe-variable’)を使用して、この
ドキュメントを閲覧できます。*note Examining::を参照してください。

   Emacsは内部の記録維持のために多くのLisp変数を使用しますが、非プログラ
マーに一番興味があるのはユーザーが変更することを意図したLisp変数であり、
これらは“カスタマイズ可能変数(customizable variables)”や“ユーザーオプシ
ョン(user options)”と呼ばれます(*note Easy Customization::を参照してくだ
さい)。以下のセクションでは、カスタマイズのためのインターフェース以外か
ら変数をセットする方法など、他の観点からEmacs変数を説明します。

   (少数の例外を除き)Emacs Lispでは、任意の変数は任意のタイプの値をもつ
ことができます。しかし多くの変数は、特定のタイプの値を割り当てられた場合
だけ意味をもちます。たとえばkillリングの最大長さを指定する
‘kill-ring-max’の値としては、数字だけが意味をもちます。‘kill-ring-max’の
値として文字列を与えた場合、‘C-y’ (‘yank’)のようなコマンドはエラーをシグ
ナルするでしょう。一方、タイプを気にしない変数もあります。たとえば、変数
の値が‘nil’のときはある効果をもたらし、“非‘nil’”のときは別の効果をもたら
す場合、シンボル‘nil’以外の任意の値は、そのタイプに関わらず2番目の効果を
もたらします(慣例により、非‘nil’値を指定するために、通常は値‘t’ — これは
“true”が由来です — を使用します)。カスタマイズバッファーを使用して変数を
セットする場合、無効なタイプを与えてしまう心配はありません。カスタマイズ
バッファーでは通常、意味のある値しか入力できないからです。判別がつかない
ときは、その変数が期待する値の種類を見るために、‘C-h v’
(‘describe-variable’)を使用して、変数のドキュメント文字列をチェックして
ください(*note Examining::を参照してください)。

* Menu:

* Examining::                変数の値の検証とセッティング。
* Hooks::                    フック変数によりEmacsの一部にたいして特定の機会に実行するプログラムを指定できます。
* Locals::                   変数のバッファーごとの値。
* File Variables::           ファイルが変数の値を指定する方法。
* Directory Variables::      ディレクトリーにより変数の値を指定する方法。


File: emacs.info,  Node: Examining,  Next: Hooks,  Up: Variables

48.2.1 変数の確認とセット
-------------------------

‘C-h v VAR <RET>’
     変数VARの値とドキュメントを表示します(‘describe-variable’)。
‘M-x set-variable <RET> VAR <RET> VALUE <RET>’
     変数VARの値をVALUEに変更します。

   変数の値を調べるには、‘C-h v’ (‘describe-variable’)を使用します。これ
はミニバッファーを使用して補完つきで変数名を読み取り、、変数の値とドキュ
メントの両方を表示します。たとえば、

     C-h v fill-column <RET>

これは以下のような出力を表示します:

     fill-column is a variable defined in `C source code'.
     fill-column's value is 70

     Automatically becomes buffer-local when set.
     This variable is safe as a file local variable if its value
     satisfies the predicate `integerp'.

     Documentation:
     Column beyond which automatic line-wrapping should happen.
     Interactively, you can set the local value with C-x f.

     You can customize this variable.

“You can customize the variable”の行は、この変数がユーザーオプションであ
ることを示します。‘C-h v’はユーザーオプションだけに制限されません。これ
はカスタマイズ可能でない変数にも使用できます。

   特定のカスタマイズ可能な変数をセットする一番簡単な方法は、‘M-x
set-variable’です。これはミニバッファーで変数名を読み取り(補完つき)、次
にミニバッファーを使用して新しい値にたいするLisp式を読み取ります(‘M-n’を
使用してミニバッファーで編集するために、古い値を挿入することができます
)。たとえば、

     M-x set-variable <RET> fill-column <RET> 75 <RET>

これは‘fill-column’を75にセットします。

   ‘M-x set-variable’はカスタマイズ可能な変数に制限されていますが、以下
のようなLisp式で任意の変数をセットできます:

     (setq fill-column 75)

このような式を実行するには、‘M-:’ (‘eval-expression’)とタイプして、ミニ
バッファーで式を入力します(*note Lisp Eval::を参照してください)。かわり
に‘*scratch*’バッファーに移動して、式をタイプしてから‘C-j’とタイプするこ
ともできます(*note Lisp Interaction::を参照してください)。

   変数のセットは、Emacsのカスタマイズと同様、特に明記しない限りは、カレ
ントEmacsセッションだけに影響します。将来のセッションのために変数を変更
する唯一の方法は、初期化ファイルにそれを記述することです(*note Init
File::を参照してください)。


File: emacs.info,  Node: Hooks,  Next: Locals,  Prev: Examining,  Up: Variables

48.2.2 フック
-------------

“フック(hook)”とは、Emacsをカスタマイズするための重要な仕組みです。フッ
クは関数のリストを保持するLisp変数で、これらの関数は、ある定められたタイ
ミングで呼び出されます(これは、“フックを実行する(running the hook)”)、と
呼ばれます)。リストの中の個別の関数は、そのフックの“フック関数(hook
functions)”と呼ばれます。たとえばフック‘kill-emacs-hook’は、Emacsを終了
する直前に実行されます(*note Exiting::を参照してください)。

   ほとんどのフックは“ノーマルフック(normal hooks)”です。これは、Emacsが
フックを実行するとき、フック関数が引数なしで順に呼び出します。わたしたち
は、ほとんどのフックをノーマルフックに保つために努力しているので、あなた
はこれらのフックを一貫した方法で使用することができます。変数名の最後が
‘-hook’の変数は、ノーマルフックです。

   多くはありませんが、“アブノーマルフック(abnormal hooks)”もあります。
アブノーマルフックは、名前の最後が‘-hook’ではなく‘-functions’です(古いコ
ードの中には時代遅れのサフィックス‘-hooks’を使うものもあります)。これら
のフックがアブノーマルな理由は、関数が呼び出される方法にあります — もし
かしたら引数が与えられているかもしれず、ことによると関数が返す値が何かに
使用されるかもしれません。たとえば‘find-file-not-found-functions’はアブ
ノーマルです。なぜならフック関数のうちの1つが非‘nil’値を返した場合、残り
の関数は呼び出されないからです(*note Visiting::を参照してください)。アブ
ノーマルフック変数のドキュメントには、フック関数がどのように使用されるか
の説明があります。

   他のLisp変数と同じように、‘setq’でフック変数をセットすることもできま
すが、フック(ノーマルとアブノーマルの両方)に関数を追加するための推奨され
る方法は、以下の例で示されるような、‘add-hook’を使う方法です。詳細は、
*note (elisp)Hooks::を参照してください。

   ほとんどのメジャーモードは初期化の最終ステップで、1つ以上の“モードフ
ック(mode hooks)”を実行します。モードフックは個々のモードの振る舞いをカ
スタマイズするための便利な方法で、常にノーマルフックです。たとえば、以下
はTextモードと、Textモードを基礎とする他のモードで、Auto Fillモードをオ
ンにするフックをセットアップする方法です:

     (add-hook 'text-mode-hook 'auto-fill-mode)

これは、引数を与えられない場合にマイナーモードを有効にする
‘auto-fill-mode’を呼び出すことにより機能します(*note Minor Modes::を参照
してください)。次に、Textモードを基礎とするLaTeXモードではAuto Fillモー
ドをオンにしたくない場合、以下の行を追加してこれを行なうことができます:

     (add-hook 'latex-mode-hook (lambda () (auto-fill-mode -1)))

ここでは、無名関数(anonymous function。*note (elisp)Lambda
Expressions::を参照してください)を構築するために、特別なマクロ‘lambda’を
使用しており、‘auto-fill-mode’に‘-1’を与えて呼び出すことにより、マイナー
モードを無効にしています。LaTeXモードは、‘text-mode-hook’を実行した後に
、‘latex-mode-hook’モードを実行するので、その結果Auto Fillモードが無効に
なります。

   以下はもっと複雑な例で、Cコードのインデントをカスタマイズするのにフッ
クを使う方法です:

     (setq my-c-style
       '((c-comment-only-line-offset . 4)
         (c-cleanup-list . (scope-operator
                            empty-defun-braces
                            defun-close-semi))))

     (add-hook 'c-mode-common-hook
       (lambda () (c-add-style "my-style" my-c-style t)))

   メジャーモードフックは、それを元のモードとして“派生された(derived)”他
のメジャーモードにも適用されます(*note (elisp)Derived Modes::を参照して
ください)。たとえばHTMLモード(*note HTML Mode::を参照してください)は
Textモードから派生しており、HTMLモードが有効になるときは、
‘html-mode-hook’を実行する前に‘text-mode-hook’が実行されます。これは1つ
のフックを複数の関連するモードに作用させるための便利な方法を提供します。
特に任意のプログラミング言語にたいしてフック関数を適用したい場合は、それ
を‘prog-mode-hook’モードに追加します。Progモードは、それを継承する他のメ
ジャーモードと比較すると、ほとんど何も行なわないメジャーモードで、まさに
この目的のために存在します。

   実行される順番に依存しないようにフック関数をデザインするのがベストで
す。実行順への依存はトラブルを招きます。しかし実行順は予測可能です。フッ
ク関数はフックに登録された順に実行されます。

   何度も‘add-hook’を呼び出すことにより、さまざまな異なるバージョンのフ
ック関数を追加した場合、追加されたすべてのバージョンのフック関数がフック
変数に残ることを忘れないでください。‘remove-hook’を呼び出すことにより関
数を個別にクリアーするか、‘(setq HOOK-VARIABLE nil)’ですべてのフック関数
を削除できます。

   フック変数がバッファーローカルな場合、グローバル変数のかわりにバッフ
ァーローカル変数が使用されます。しかしバッファーローカル変数が要素‘t’を
含む場合は、グローバル変数も同様に実行されます。


File: emacs.info,  Node: Locals,  Next: File Variables,  Prev: Hooks,  Up: Variables

48.2.3 ローカル変数
-------------------

‘M-x make-local-variable <RET> VAR <RET>’
     変数VARが、カレントバッファーでローカル値をもつようにします。
‘M-x kill-local-variable <RET> VAR <RET>’
     変数VARが、カレントバッファーでグローバル値を使うようにします。
‘M-x make-variable-buffer-local <RET> VAR <RET>’
     変数VARがセットされた時点で、カレントバッファーにたいしてローカルに
     なるようマークします。

   ほとんどの変数は、特定のEmacsバッファーにたいして“ローカル(local)”に
することができます。これは、そのバッファーでの変数の値が、他のバッファー
での変数の値とは、独立していることを意味します。多くはありませんが、常に
バッファーごとにローカルな変数もあります。他のすべてのEmacs変数は、バッ
ファーで変数をローカルにしていないかぎりは、すべてのバッファーに効果を及
ぼす“グローバル(global)”な値をもちます。

   ‘M-x make-local-variable’は変数名を読み取り、それをカレントバッファー
にたいしてローカルにします。その後、このバッファーで変数の値を変更しても
他のバッファーには影響せず、変数のグローバル値を変更してもこのバッファー
には影響しなくなります。

   ‘M-x make-variable-buffer-local’は、変数がセットされたとき自動的にロ
ーカルになるように、変数をマークします。より正確には、1度この方法で変数
がマークされると、通常の方法による変数のセットは、最初に自動的に
‘make-local-variable’を呼び出します。このような変数を“パーバッファー
(per-buffer: バッファーごと)”変数と呼びます。Emacsの多くの変数は、通常は
パーバッファーです。変数のドキュメント文字列には、いつこれを行なうかが記
述されています。パーバッファー変数のグローバル値は、通常は任意のバッファ
ーには影響しませんが、それでもまだ意味があります。グローバル値は、新しい
バッファーにたいする、この変数の初期値として使用されます。

   メジャーモード(*note Major Modes::を参照してください)は常に変数をセッ
トする前に、変数をローカルにします。あるバッファーでメジャーモードを変更
しても、他のバッファーに影響がないのは、これが理由です。マイナーモードは
変数をセットすることにより機能します — 通常、各マイナーモードは1つの制御
変数(controlling variable)をもっていて、この変数が非‘nil’の場合はモード
が有効になります(*note Minor Modes::を参照してください)。多くのマイナー
モードにたいして制御変数はパーバッファーであり、したがって常にバッファー
ローカルです。そうでない場合、他の変数と同様に特定のバッファーで変数をロ
ーカルにできます。

   多くはありませんが、バッファーでローカルにできない(かわりに各ディスプ
レーにたいして常にローカル。*note Multiple Displays::を参照してください
)変数も存在します。そのような変数をバッファーローカルにしようとすると、
エラーメッセージが表示されます。

   ‘M-x kill-local-variable’は、指定された変数が、カレントバッファーにた
いしてローカルであることを終了させます。その後は、そのバッファーにたいし
て、その変数のグローバル値が効力をもちます。メジャーモードのセットにより
、数少ない“パーマネントローカル(permanent locals: 永久にローカル)”な変数
を除いて、そのバッファーのすべてのローカル変数はkillされます。

   変数がカレントバッファーでローカル値をもつかに関わらず、変数にグロー
バル値をセットするには、Lispコンストラクト‘setq-default’を使用することが
できます。このコンストラクトは‘setq’と同じように使用されますが、(もしあ
れば)ローカル値のかわりにグローバル値をセットします。カレントバッファー
がローカル値をもつ場合、新しいグローバル値は他のバッファーに切り替えるま
で見えないでしょう。以下は例です:

     (setq-default fill-column 75)

‘setq-default’は、‘make-variable-buffer-local’でマークされた変数のグロー
バル値をセットする唯一の方法です。

   Lispプログラムは変数のデフォルト値を得るために、‘default-value’を使用
することができます。この関数はシンボルを引数として受け取り、それのデフォ
ルト値を返します。引数は評価されるので、通常は明示的にクォートする必要が
あります。たとえば、以下は‘fill-column’のデフォルト値を得る方法です:

     (default-value 'fill-column)


File: emacs.info,  Node: File Variables,  Next: Directory Variables,  Prev: Locals,  Up: Variables

48.2.4 ファイル内のローカル変数
-------------------------------

ファイルに、Emacsでそのファイルを編集するときに使用するローカル変数の値
を指定できます。ファイルをvisitすることにより、Emacsはローカル変数指定を
チェックします。これは自動的にこれらの変数をバッファーにたいしてローカル
にし、ファイルで指定された値にセットします。

* Menu:

* Specifying File Variables::  ファイルローカル変数の指定。
* Safe File Variables::      ファイルローカル変数が安全であることを確認する。


File: emacs.info,  Node: Specifying File Variables,  Next: Safe File Variables,  Up: File Variables

48.2.4.1 ファイル変数の指定
...........................

ファイルローカル変数を指定するには2つの方法があります。1つは最初の行に記
述する方法で、もう1つはローカル変数リストを使用する方法です。以下は最初
の行でこれらを指定する方法の例です:

     -*- mode: MODENAME; VAR: VALUE; ... -*-

この方法により、任意の数の変数/値(variable/value)ペアーを指定できます。
各ペアーはコロンとセミコロンで区切ります。特別な変数/値ペアー‘mode:
MODENAME;’が与えられた場合、これはメジャーモードを指定します。VALUEは文
字列として使用され、評価はされません。

   手作業でエントリーを追加するかわりに、‘M-x
add-file-local-variable-prop-line’を使用することができます。このコマンド
は変数と値の入力を求め、適切な方法で最初の行にこれらを追加します。‘M-x
delete-file-local-variable-prop-line’は変数の入力を求め、最初の行から変
数のエントリーを削除します。コマンド‘M-x
copy-dir-locals-to-file-locals-prop-line’は、カレントのディレクトリーロ
ーカル変数を最初の行にコピーします(*note Directory Variables::を参照して
ください)。

   以下は、最初の行でLispモードを指定して、2つの変数に数値をセットする例
です:

     ;; -*- mode: Lisp; fill-column: 75; comment-column: 50; -*-

‘mode’の他に、ファイル変数として特別な意味をもつキーワードは‘coding’、
‘unibyte’、‘eval’です。これらは以下で説明します。

   シェルスクリプトでは、最初の行はスクリプトのインタープリターの識別に
使用されるので、ローカル変数をそこに置くことはできません。これに対処する
ために、Emacsは最初の行がインタープリターを指定しているときは、_2行目_か
らローカル変数指定を探します。man pagesにも同じことが言えます。man
pagesはtroffプリプロセッサーのリストを指定するマジック文字列‘'\"’で始ま
るからです(しかし、すべてがこれを行なう訳ではありません)。

   ‘-*-’行を使用するのではなく、ファイルの終端付近で“ローカル変数リスト
(local variables list)”を使用することにより、ファイルローカル変数を定義
することもできます。ローカル変数リストは、ファイル終端から3000文字以内で
開始され、ファイルがページに分かれているときは最後のページになければなり
ません。

   ファイルにローカル変数リストと‘-*-’の両方がある場合、Emacsは最初に
‘-*-’行の_すべて_を処理してから、ローカル変数リストの_すべて_を処理しま
す。例外はメジャーモード指定です。Emacsはメジャーモード指定がどこにあろ
うと、まずそれを適用します。なぜならほとんどのメジャーモードは、初期化部
分ですべてのローカル変数をkillするからです。

   ローカル変数リストは、文字列‘Local Variables:’を含む行で開始され、文
字列‘End:’を含む行で終了します。この間には、以下のように1行に変数名と値
のペアーが記述されます:

     /* Local Variables:  */
     /* mode: c           */
     /* comment-column: 0 */
     /* End:              */

この例では、各行はプレフィクス‘/*’で始まり、サフィックス‘*/’で終了します
。Emacsは、リストの最初の行のマジック文字列‘Local Variables:’を囲む文字
列から、プレフィクスとサフィックスを識別します。その後はリストの他の行で
自動的にこれらを破棄します。プレフィクスおよび/またはサフィックスを使用
する通常の理由は、そのファイルが意図する他のプログラムが混乱しないように
、ローカル変数をコメントに埋め込むためです。上記は、コメントが‘/*’で始ま
り‘*/’で終わるCプログラミング言語での例です。

   ローカル変数を直接タイプするかわりに、コマンド‘M-x
add-file-local-variable’を使用することができます。これは変数と値の入力を
求め、それらをリストに追加し、‘Local Variables:’と、必要なら開始・終了マ
ーカーも追加します。コマンド‘M-x delete-file-local-variable’は、リストか
ら変数を削除します。‘M-x copy-dir-locals-to-file-locals’は、ディレクトリ
ーローカル変数をリストにコピーします(*note Directory Variables::を参照し
てください)。

   ‘-*-’行と同じように、ローカル変数リストの変数は文字列として使用され、
最初に評価されることはありません。長い文字列値をファイル内で複数行に分割
したい場合、改行とバックスラッシュを使用できます(Lisp文字列定数では無視
されます)。各行には、プレフィクスとサフィックスを記述するべきです。たと
え行がその文字列で開始または終了していても、それらはリストを処理するとき
取り除かれます。以下は例です:

     # Local Variables:
     # compile-command: "cc foo.c -Dfoo=bar -Dhack=whatever \
     #   -Dmumble=blaah"
     # End:

   いくつかの“変数名”は、ローカル変数リスト内で特別な意味をもちます:

   • ‘mode’は、指定されたメジャーモードを有効にします。

   • ‘eval’は、指定されたLisp式を評価します(式が返す値は無視されます)。

   • ‘coding’は、このファイルでの文字コード変換にたいするコーディングシ
     ステムを指定します。*note Coding Systems::を参照してください。

   • ‘unibyte’の値が‘t’の場合、Emacs Lispのロードとコンパイルをunibyteモ
     ードで行ないます。*note Disabling Multibyte Characters:
     (elisp)Disabling Multibyte.を参照してください。

これら4つのキーワードは、実際には変数ではありません。他のコンテキストで
これらをセットしても、特別な意味はありません。

   マイナーモードにたいして‘mode’キーワードを使用しないでください。ロー
カル変数リストでマイナーモードを有効または無効にするには、‘eval’でモード
コマンドを実行するLisp式を指定します(*Note Minor Modes::を参照してくださ
い)。たとえば以下のローカル変数リストは、引数なし(引数に1を指定しても同
じことを行ないます)で‘eldoc-mode’を呼び出すことにより、Eldocモード(*note
Lisp Doc::を参照してください)を有効にし、引数-1で‘font-lock-mode’を呼び
出すことにより、Font Lockモードを無効にする例です。

     ;; Local Variables:
     ;; eval: (eldoc-mode)
     ;; eval: (font-lock-mode -1)
     ;; End:

しかしこの方法でマイナーモードを指定するのは、間違っている場合もあること
に注意してください。マイナーモードは個人の好みを表しており、そのファイル
を編集するユーザーにあなたの好みを強制するのは、不適切かもしれません。状
況に依存して自動的にマイナーモードを有効または無効にしたい場合は、たいて
いメジャーモードフックでこれを行なう方がよいのです(*note Hooks::を参照し
てください)。

   ローカル変数と、ファイル名とファイル内容にしたがったバッファーのメジ
ャーモード(もしあればローカル変数リストも)をリセットするには、コマンド
‘M-x normal-mode’を使用します。*note Choosing Modes::を参照してください
。


File: emacs.info,  Node: Safe File Variables,  Prev: Specifying File Variables,  Up: File Variables

48.2.4.2 安全なファイル変数
...........................

ファイルローカル変数が危険な場合もあります。他の誰かのファイルをvisitす
るとき、そのファイルのローカル変数リストがEmacsに何を行なうか、告げるも
のはありません。‘eval’ “variable”や、その他の‘load-path’などにたいする不
正な値は、実行する意図がないLispコードを実行するかもしれません。

   したがって、安全と判っていないファイルローカル変数を発見した場合、
Emacsはファイルのローカル変数リスト全体を表示して、それらをセットする前
に継続するか尋ねます。‘y’または<SPC>をタイプすると、ローカル変数リストは
効果をもち、‘n’の場合は無視します。Emacsがバッチモード(*note Initial
Options::を参照してください)で実行されている場合、Emacsは確認することが
できないので、‘n’と応えられたとみなします。

   Emacsは通常、特定の変数/値ペアーが安全だと認識できます。たとえば
‘comment-column’や‘fill-column’には、任意の整数値を与えても安全です。フ
ァイルが安全だと判っている変数/値ペアーだけを指定する場合、Emacsはそれら
をセットする前に確認を求めません。そうでない場合、確認プロンプトで‘!’と
タイプすることにより、このファイル内のすべての変数/値ペアーが安全なこと
を記録するようEmacsに指示できます。その後、Emacsが同じファイルまたは別の
ファイルで、これらの変数/値ペアーに出会うと、これらを安全だとみなします
。

   ‘load-path’のようないくつかの変数は、特に“危険”だと判断されます。これ
らをローカル変数として指定すべき理由はほとんどなく、それらを変更するのは
危険です。ファイルに危険なローカル変数だけが含まれる場合、Emacsは確認プ
ロンプトで‘!’の選択肢を提示することも、それを受け入れることもしません。
ファイル内のいくつかのローカル変数が危険で、いくつかの変数は潜在的に安全
ではない場合は、プロンプトで‘!’を入力できます。これはすべての変数に適用
されますが、危険ではない変数だけを将来のセッションのために安全とマークし
ます。もし危険な変数を安全な値として記録したいと本当に望むなら、
‘safe-local-variable-values’をカスタマイズすることによりこれを行ないます
(*note Easy Customization::を参照してください)。

   変数‘enable-local-variables’により、Emacsがローカル変数を処理する方法
を変更できます。デフォルト値は‘t’で、これは上述の振る舞いを指定します。
‘nil’の場合、Emacsは単にすべてのファイルローカル変数を無視します。
‘:safe’は安全な値だけを使用して、残りは無視します。他の値の場合、安全と
判っている値かどうかの決定を試みずに、ローカル変数をもつ各ファイルごとに
尋ねます。

   変数‘enable-local-eval’は、Emacsが‘eval’変数を処理するかどうかを制御
します。‘enable-local-variables’のように、変数に対する可能な値は3つで、
‘t’、‘nil’、およびそれ以外です。デフォルトは、‘t’や‘nil’ではない
‘maybe’で、通常Emacsは‘eval’変数を処理するときに確認を求めます。

   例外として、評価する任意の‘eval’形式が、変数‘safe-local-eval-forms’で
指定された形式の場合、Emacsは確認を求めません。


File: emacs.info,  Node: Directory Variables,  Prev: File Variables,  Up: Variables

48.2.5 ディレクトリーごとのローカル変数
---------------------------------------

大きなソフトウェアプロジェクトでのディレクトリーツリーのような、特定のデ
ィレクトリーや、それのサブディレクトリーのすべてのファイルにたいして、同
じローカル変数を定義したいことがあるかもしれません。これは“ディレクトリ
ーローカル変数(directory-local variables)”で行なうことができます。

   ディレクトリーローカル変数を定義する通常の方法は、そのディレクトリー
に‘.dir-locals.el’(1)というファイルを置く方法です。そのディレクトリー、
またはそれのサブディレクトリーの任意のファイルをEmacsがvisitするとき、
‘.dir-locals.el’で指定されたディレクトリーローカル変数が、あたかもそのフ
ァイルのファイルローカル変数(*note File Variables::を参照してください)と
して定義されたかのように、ファイルに適用されます。Emacsはvisitされたファ
イルのディレクトリーから、ディレクトリーツリーを上に移動しながら
‘.dir-locals.el’を検索します。スローダウンを避けるために、検索はリモート
ファイルをスキップします。必要なら、変数‘enable-remote-dir-locals’を
‘t’にセットして、検索範囲をリモートファイルに広げることができます。

   ‘.dir-locals.el’は、特別な構成のリストをもちます。これはモード名(シン
ボルで指定)をalist(Association Lists: 連想リスト。*note
(elisp)Association Lists::を参照してください)にマップします。各alistエン
トリーは、変数名と、指定されたメジャーモードが有効なときに、その変数に割
り当てるディレクトリーローカル値からなります。モード名のかわりに‘nil’を
指定でき、これはalistが任意のモードで適用されることを意味します。サブデ
ィレクトリー名(文字列で指定)を指定することもできます。この場合、そのサブ
ディレクトリーのすべてのファイルにalistが適用されます。

   以下は、‘.dir-locals.el’ファイルの例です:

     ((nil . ((indent-tabs-mode . t)
              (fill-column . 80)))
      (c-mode . ((c-file-style . "BSD")
                 (subdirs . nil)))
      ("src/imported"
       . ((nil . ((change-log-default-name
                   . "ChangeLog.local"))))))

これはディレクトリーツリーの任意のファイルにたいして、
‘indent-tabs-mode’と‘fill-column’をセットし、任意のCソースファイルにたい
してインデントスタイルをセットします。特別な要素‘subdirs’は変数ではあり
ません。これは特別なキーワードで、Cモードのセッティングがカレントディレ
クトリーだけに適用され、任意のサブディレクトリーには適用されないことを示
します。最後に、これは‘src/imported’サブディレクトリー内の任意のファイル
にたいして、違う‘ChangeLog’ファイル名を指定します。

   ‘.dir-locals.el’ファイルを手で編集するかわりに、コマンド‘M-x
add-dir-local-variable’を使用できます。これはモード名またはサブディレク
トリー名、および変数名と値の入力を求め、ディレクトリーローカル変数を定義
するエントリーを追加します。‘M-x delete-dir-local-variable’は、エントリ
ーを削除します。‘M-x copy-file-locals-to-dir-locals’は、カレントファイル
内のファイルローカル変数を、‘.dir-locals.el’にコピーします。

   ディレクトリーローカル変数を指定する他の方法は、
‘dir-locals-set-class-variables’関数を使用して、“ディレクトリークラス
(directory class)”の中に、変数/値ペアーのグループを定義する方法です。そ
の後、‘dir-locals-set-directory-class’関数を使用して、そのクラスに対応す
るディレクトリーをEmacsに指示します。これらの関数呼び出しは通常、初期化
ファイルで行なわれます(*note Init File::を参照してください)。この方法は
、何らかの理由でディレクトリーに‘.dir-locals.el’を置けないときに便利です
。たとえば、この方法で書き込み不可なディレクトリーにセッティングを適用で
きます:

     (dir-locals-set-class-variables 'unwritable-directory
        '((nil . ((some-useful-setting . value)))))

     (dir-locals-set-directory-class
        "/usr/include/" 'unwritable-directory)

   変数にたいしてディレクトリーローカル値とファイルローカル値の両方が指
定された場合、ファイルローカル値が効果をもちます。安全ではないディレクト
リーローカル値は、安全でないファイルローカル値と同じ方法で扱われます
(*note Safe File Variables::を参照してください)。

   ディレクトリーローカル変数は、Diredバッファー(*note Dired::を参照して
ください)のような、ファイルを直接visitしていないが、ディレクトリーで処理
を行なうバッファーにたいしても効果があります。

   ---------- Footnotes ----------

   (1) MS-DOSでは、DOSファイルシステムの制限により、このファイルの名前は
‘_dir-locals.el’になります。ファイルシステムによりファイル名が8+3に制限
されている場合、OSによりファイル名が‘_dir-loc.el’に切り詰められるでしょ
う。


File: emacs.info,  Node: Key Bindings,  Next: Init File,  Prev: Variables,  Up: Customization

48.3 キーバインディングのカスタマイズ
=====================================

このセクションでは、キーをコマンドにマップする“キーバインド(key
bindings)”と、そのキーバインドを記録する“キーマップ(keymaps)”を説明しま
す。それにinitファイルを編集して、キーバインドをカスタマイズする方法も説
明します(*note Init Rebinding::を参照してください)。

* Menu:

* Keymaps::                  一般的な考え方。グローバルキーマップ。
* Prefix Keymaps::           プレフィクスキーにたいするキーマップ。
* Local Keymaps::            キーマップをもつメジャーモードとマイナーモード。
* Minibuffer Maps::          ミニバッファーが使用する独自のキーマップ。
* Rebinding::                あるキーの意味を再定義する便利な方法。
* Init Rebinding::           初期化ファイルでのキーのリバインド。
* Modifier Keys::            キーバインドでの修飾キーの使用。
* Function Keys::            端末のファンクションキーのリバインド。
* Named ASCII Chars::        <TAB>と‘C-i’などを区別する方法。
* Mouse Buttons::            Emacsでのマウスボタンのリバインド。
* Disabling::                コマンドを無効にするとは、それを実行できるようにする前に確認が要求されることを意味します。これはビギナーを戸惑わせないようにするために行なわれます。


File: emacs.info,  Node: Keymaps,  Next: Prefix Keymaps,  Up: Key Bindings

48.3.1 キーマップ
-----------------

*note Commands::で説明されているように、各Emacsコマンドは、対話的に使用
することを条件として定義されたLisp関数です。すべてのLisp関数と同様に、コ
マンドは小文字とハイフンからなる関数名をもちます。

   “キーシーケンス(key sequence)” — 短くは“キー(key)” — とは、1つの単位
として意味をもつ、連続する“入力イベント(input events)”のことです。入力イ
ベントとは文字、ファンクションキー、マウスボタン — つまりコンピューター
に送ることができるすべての入力のことです。キーシーケンスは、それが何のコ
マンドを実行するかを指示する“バインディング(binding)”により、意味をもち
ます。

   キーシーケンスとコマンド関数との間のバインディングは、“keymaps(キーマ
ップ)”と呼ばれるデータ構造に記録されます。Emacsには多くのkeymapsがあり、
それぞれが特別の機会に使用されます。

   一番重要なキーマップは、“グローバルキーマップ(global keymap)”です。な
ぜならグローバルキーマップは常に効果があるからです。グローバルキーマップ
はFundamentalモードにたいしてキーを定義します(*note Major Modes::を参照
してください)。これらの定義のほとんどは、、ほとんどすべてのメジャーモー
ドでは一般的です。メジャーモードまたはマイナーモードは、いくつかのキーに
たいするグローバル定義をオーバーライドするために、それぞれ独自のkeymapを
もつことができます。

   たとえば‘g’のような自己挿入文字(self-inserting character)は、グローバ
ルキーマップがそれをコマンドcommand ‘self-insert-command’にバインドする
ので、自己挿入を行なうのです。‘C-a’のような標準的なEmacsの編集文字もグロ
ーバルキーマップから、それらの標準的な意味を取得します。‘M-x
global-set-key’のような、キーをリバインドするコマンドは、新しいバインデ
ィングをグローバルマップの適切な位置に保存することにより機能します(*note
Rebinding::を参照してください)。

   ほとんどの現代的なキーボードは、文字キーと同じようにファンクションキ
ーをもちます。ファンクションキーは文字キーが行なうように入力イベントを送
り、キーマップはファンクションキーにたいするバインディングをもつことがで
きます。キーシーケンスにはファンクションキーと文字をミックスすることもで
きます。たとえば、キーボードにファンクションキー<Home>がある場合、
Emacsは‘C-x <Home>’のようなキーシーケンスを認識できます。
‘S-down-mouse-1’のように、マウスイベントとキーボードイベントをミックスす
ることさえ可能です。

   テキスト端末では、ファンクションキーをタイプすることにより、文字シー
ケンスがコンピューターに送られます。シーケンスの正確な詳細は、ファンクシ
ョンキーと端末タイプに依存します(シーケンスが‘<ESC> [’で始まることもしば
しばあります)。Emacsが端末タイプを理解する場合、自動的にそのようなシーケ
ンスを1つの入力イベントとして処理します。


File: emacs.info,  Node: Prefix Keymaps,  Next: Local Keymaps,  Prev: Keymaps,  Up: Key Bindings

48.3.2 プレフィクスキーマップ
-----------------------------

内部的には、Emacsは各キーマップの1つのイベントだけを記録します。複数イベ
ントのキーシーケンスの解釈は、キーマップの連鎖を生じます。最初のイベント
にたいして最初のキーマップが定義を与え、シーケンス内の2番目のイベントを
探すのに他のキーマップが使用され...と連鎖していきます。したがって‘C-x’や
<ESC>などのプレフィクスキーは独自のキーマップをもち、それらはプレフィク
スの直後のイベントにたいする定義を保持します。

   プレフィクスキーの定義は通常、それに続くイベントを探すのに使用するキ
ーマップです。プレフィクスキーの定義として、関数定義がキーマップであるよ
うなLispシンボルを指定することもできます。効果は同じですが、そのプレフィ
クスキーが何のためなのか説明するためのコマンド名を提供します。たとえば、
‘C-x’のバインディングはシンボル‘Control-X-prefix’で、このシンボルの関数
定義は、‘C-x’コマンドにたいするキーマップです。プレフィクスキーとしての
‘C-c’、‘C-x’、‘C-h’、<ESC>は、グローバルキーマップに定義されているので、
これらのプレフィクスキーは常に利用できます。

   通常のプレフィクスキー以外に、“架空のプレフィクスキー(fictitious
prefix key)”もあり、これらはメニューバーを表します。メニューバーのキーバ
インディングについての特別な情報は、*note (elisp)Menu Bar::を参照してく
ださい。ポップアップメニューを呼び出すマウスボタンイベントもプレフィクス
キーです。詳細については、*note (elisp)Menu Keymaps::を参照してください
。

   いくつかのキーマップは、名前のついた変数に格納されています:

   • ‘ctl-x-map’は、‘C-x’の後の文字に使用されるマップにたいする変数名で
     す。
   • ‘help-map’は。‘C-h’の後の文字のためのマップです。
   • ‘esc-map’は、<ESC>の後の文字のためのマップです。したがって、すべて
     のメタ文字がこのマップで定義されています。
   • ‘ctl-x-4-map’は、‘C-x 4’の後の文字のためのマップです。
   • ‘mode-specific-map’は、‘C-c’の後の文字のためのマップです。


File: emacs.info,  Node: Local Keymaps,  Next: Minibuffer Maps,  Prev: Prefix Keymaps,  Up: Key Bindings

48.3.3 ローカルキーマップ
-------------------------

ここまではグローバルマップの詳細を説明してきました。メジャーモードは、
“ローカルキーマップ(local keymaps)”で独自のキーバインディングを提供する
ことにより、Emacsをカスタマイズします。たとえばCモードは、C言語のために
カレント行をインデントするために、<TAB>をオーバーライドします。マイナー
モードもローカルキーマップをもつことができます。マイナーモードが効力をも
つとき、マイナーモードのキーマップの定義は、メジャーモードのローカルキー
マップとグローバルキーマップの両方をオーバーライドします。それに加えて、
バッファーの一部のテキストに、他のすべてのキーマップをオーバーライドする
独自のキーマップを指定できます。

   ローカルキーマップは、あるキーをプレフィクスキーマップとして定義する
ことにより、そのキーをプレフィクスキーとして再定義できます。そのキーがグ
ローバルでもプレフィクスとして定義されている場合、そのキーのグローバルお
よびローカルの定義(両方のキーマップ)が、相乗して効果をもちます。つまりプ
レフィクスキーに続くイベントを探すのに、両方の定義が使用されます。たとえ
ばローカルキーマップが‘C-c’をプレフィクスキーマップとして定義し、そのキ
ーマップが‘C-z’をコマンドとして定義する場合、これは‘C-c C-z’にローカルな
意味を提供します。これは‘C-c’で始まる他のシーケンスには影響を与えません
。これらのシーケンスが独自のローカルバインディングをもたない場合、グロー
バルバインディングが効果をもちます。

   これを別の方法で考えると、Emacsはキーシーケンス全体のバインディングに
たいして、複数のキーマップを1つずつ探して、複数イベントキーシーケンスを
処理すると考えることができます。最初にマイナーモードが有効な場合はマイナ
ーモードのキーマップをチェックして、次にメジャーモードのキーマップをチェ
ックして、それからグローバルキーマップをチェックするのです。これはキーの
照合が機能する正確な方法ではありませんが、通常の場面における結果を理解す
るには充分です。


File: emacs.info,  Node: Minibuffer Maps,  Next: Rebinding,  Prev: Local Keymaps,  Up: Key Bindings

48.3.4 ミニバッファーキーマップ
-------------------------------

ミニバッファーは独自のローカルキーマップのセットをもちます。これにはさま
ざまな補完やexitコマンドが含まれます。

   • ‘minibuffer-local-map’は、通常の入力(補完なし)に使用されます。
   • ‘minibuffer-local-ns-map’は同様ですが、<SPC>で<RET>と同じように
     exitします。
   • ‘minibuffer-local-completion-map’は、寛大な補完(permissive
     completion)のためのキーマップです。
   • ‘minibuffer-local-must-match-map’は、強い補完(strict completion)と
     慎重な補完(cautious completion)のためのキーマップです。
   • ‘minibuffer-local-filename-completion-map’と
     ‘minibuffer-local-filename-must-match-map’は、前の2つと同様ですが、
     特にファイル名補完のためのキーマップです。これらは<SPC>をバインドし
     ません。


File: emacs.info,  Node: Rebinding,  Next: Init Rebinding,  Prev: Minibuffer Maps,  Up: Key Bindings

48.3.5 対話的なキーバインディングの変更
---------------------------------------

Emacsがキーを再定義する方法は、キーマップのそのキーのエントリーを変更す
る方法です。グローバルキーマップを変更できます。この場合すべてのメジャー
モードで変更が効果をもちます(ただし同じキーにたいしてそれをオーバーライ
ドする独自のローカルバインディングをもつ場合を除きます)。ローカルキーマ
ップを変更することもできます。これは同じメジャーモードを使用するすべての
バッファーに効果があります。

   このセクションでは、現在のEmacsセッションでキーをリバインドする方法を
説明します。将来のEmacsセッションで効果をもつようにキーをリバインドする
方法については、*note Init Rebinding::を参照してください。

‘M-x global-set-key <RET> KEY CMD <RET>’
     CMDを実行するKEYをグローバルに定義します。
‘M-x local-set-key <RET> KEY CMD <RET>’
     CMDを実行するKEYを、(そのとき効力をもつメジャーモードで)ローカルに
     定義します。
‘M-x global-unset-key <RET> KEY’
     グローバルマップでKEYを未定義にします。
‘M-x local-unset-key <RET> KEY’
     (そのとき効力をもつメジャーモードで)ローカルにKEYを未定義にします。

   たとえば以下は、通常の‘C-z’にたいするグローバルな定義を置き換えて、
‘C-z’を‘shell’コマンド(*note Interactive Shell::を参照してください)にバ
インドします:

     M-x global-set-key <RET> C-z shell <RET>

‘global-set-key’コマンドは、キーの後にコマンド名を読み取ります。キーを押
した後、以下のようなメッセージが表示されるので、そのキーにバインドしたい
コマンドを入力できます:

     Set key C-z to command:

   ファンクションキーとマウスイベントも同じ方法で再定義できます。リバイ
ンドするキーを指定するときに、ファンクションキーをタイプするか、マウスを
クリックするだけです。

   複数のイベントを含むキーも、同じ方法で再定義できます。Emacsは、(プレ
フィクスキーではない)完了キーまで、リバインドするキーの読み取りを続けま
す。したがってKEYに‘C-f’をタイプすると、それで完了です。これによりミニバ
ッファーに入って、すぐにCMDを読み取ります。しかし‘C-x’をタイプした場合、
これはプレフィクスなので、他の文字を読み取ります。それが‘4’の場合、これ
もプレフィクス文字なので、さらに文字を読み取ります。たとえば、

     M-x global-set-key <RET> C-x 4 $ spell-other-window <RET>

これは、(架空のコマンド)‘spell-other-window’を実行するように、‘C-x 4 $’を
再定義します。

   ‘global-unset-key’で、キーのグローバルな定義を削除できます。これはそ
のキーを“未定義(undefined)”にします。その後このキーをタイプしても、
Emacsはビープ音を鳴らすだけです。同様に‘local-unset-key’は、カレントメジ
ャーモードのキーマップでキーを未定義にして、メジャーモードにおいて、その
キーにたいするグローバル定義(またはグローバル定義に無い状態)が有効になり
ます。

   あるキーを再定義(または未定義に)してから、後でその変更を取り消したく
なった場合、キーを未定義にしても上手くいきません — そのキーを標準の定義
に再定義する必要があります。そのキーの標準の定義の名前を見つけるには、フ
レッシュなEmacsのFundamentalモードで、‘C-h c’を使用します。このマニュア
ルのキーのドキュメントにも、それらのコマンド名がリストされています。

   間違ってコマンドを呼び出すことから自分を守りたい場合、そのキーを未定
義にするより、コマンドを無効にするほうがよいでしょう。無効にされたコマン
ドは、実際にそれを実行したくなったとき、少しの手間で呼び出すことができま
す。*note Disabling::を参照してください。


File: emacs.info,  Node: Init Rebinding,  Next: Modifier Keys,  Prev: Rebinding,  Up: Key Bindings

48.3.6 キーのリバインド
-----------------------

いつでも使いたいキーバインドがある場合、初期化ファイルにLispコードを記述
することにより、それらを指定できます。初期化ファイルの説明については、
*note Init File::を参照してください。

   Lispを使用してキーバインディングを記述するには、いくつかの方法があり
ます。一番簡単なのは‘kbd’関数を使う方法で、これはキーシーケンスのテキス
ト表現 — このマニュアルでキーシーケンスを記述するのと同様な方法 — を、
‘global-set-key’の引数として渡す形式に変換します。たとえば以下は、
‘C-z’を‘shell’コマンド(*note Interactive Shell::を参照してください)にバ
インドする方法の例です:

     (global-set-key (kbd "C-z") 'shell)

コマンド名‘shell’の前のシングルクォートは、それを変数ではなくシンボル定
数としてマークします。クォートを省略した場合、Emacsは‘shell’を変数として
評価しようとします。これはおそらくエラーを引き起こし、もちろんあなたはそ
れを望まないはずです。

   以下に、ファンクションキーやマウスイベントなどを含めた、追加の例を示
します:

     (global-set-key (kbd "C-c y") 'clipboard-yank)
     (global-set-key (kbd "C-M-q") 'query-replace)
     (global-set-key (kbd "<f5>") 'flyspell-mode)
     (global-set-key (kbd "C-<f5>") 'linum-mode)
     (global-set-key (kbd "C-<right>") 'forward-sentence)
     (global-set-key (kbd "<mouse-2>") 'mouse-save-then-kill)

   ‘kbd’を使うかわりに、キーシーケンスの指定にLisp文字列やベクターを使用
することができます。文字列を使用するのは単純ですが、これはASCII文字とメ
タ修飾されたASCII文字だけで機能します。たとえば以下は、‘C-x M-l’を
‘make-symbolic-link’(*note Misc File Ops::を参照してください)にバインド
する方法の例です:

     (global-set-key "\C-x\M-l" 'make-symbolic-link)

   文字列内に<TAB>、<RET>、<ESC>、<DEL>を記述するには、Emacs Lispのエス
ケープシーケンス‘\t’、‘\r’、‘\e’、‘\d’を使用します。以下は、‘C-x <TAB>’を
‘indent-rigidly’(*note Indentation::を参照してください)にバインドする例
です:

     (global-set-key "\C-x\t" 'indent-rigidly)

   キーシーケンスがファンクションキーやマウスボタンイベント、または
‘C-=’や‘H-a’のような非ASCII文字を含む場合、キーシーケンスを指定するのに
ベクターを使用することができます。ベクター内の各要素は入力イベントを意味
します。要素はスペースで区切られ、一対の角カッコ(square brackets)で囲ま
れます。ベクターの要素が文字の場合は、それをLisp文字定数、つまり‘?’の後
ろにその文字を、文字列内で表記されるような方法で記述します。ファンクショ
ンキーはシンボルで表され(*note Function Keys::を参照してください)、他の
区切り文字や句読点なしで、単にシンボル名を記述します。以下に例をいくつか
示します:

     (global-set-key [?\C-=] 'make-symbolic-link)
     (global-set-key [?\M-\C-=] 'make-symbolic-link)
     (global-set-key [?\H-a] 'make-symbolic-link)
     (global-set-key [f7] 'make-symbolic-link)
     (global-set-key [C-mouse-1] 'make-symbolic-link)

単純な場合でもベクターを使用できます:

     (global-set-key [?\C-z ?\M-l] 'make-symbolic-link)

   非ASCII文字にたいするキーバインディングは、言語とコーディングシステム
に問題を起こすかもしれません。 *note Init Non-ASCII::を参照してください
。

   *note Local Keymaps::で説明したように、メジャーモードとマイナーモード
はローカルキーマップを定義できます。これらのキーマップは、セッションで最
初にそのモードが使用されるときに構築されます。これらのキーマップを変更し
たい場合は、“モードフック(mode hook)”を使用しなければなりません(*note
Hooks::を参照してください)。

   たとえばTexinfoモードは、フック‘texinfo-mode-hook’を実行します。以下
はTexinfoモードで、‘C-c n’と‘C-c p’にローカルバインディングを追加するた
めに、どのようにフックを使用できるかの例です:

     (add-hook 'texinfo-mode-hook
               (lambda ()
                 (define-key texinfo-mode-map "\C-cp"
                             'backward-paragraph)
                 (define-key texinfo-mode-map "\C-cn"
                             'forward-paragraph)))


File: emacs.info,  Node: Modifier Keys,  Next: Function Keys,  Prev: Init Rebinding,  Up: Key Bindings

48.3.7 修飾キー
---------------

Emacsでは、デフォルトのキーバインディングがセットアップされているので、
修飾されたアルファベット文字は大文字小文字が区別されません。つまり
‘C-A’は‘C-a’と同じことを行い、‘M-A’は‘M-a’と同じことを行ないます。これは
アルファベット文字だけに当てはまり、他のキーの“シフトキーが押された
(shifted)”バージョンには適用されません。たとえば、‘C-@’は‘C-2’と同じでは
ありません。

   <Control>修飾されたアルファベット文字は、常に大文字小文字が区別されま
せん。Emacsは常に‘C-A’を‘C-a’、‘C-B’を‘C-b’、...として扱います。これは歴
史的な理由によります。

   他の修飾キーでは、Emacsをカスタマイズするとき修飾されたアルファベット
の大文字小文字を区別するようにできます。たとえば‘M-a’と‘M-A’で別のコマン
ドを実行できます。

   一般的に使用される修飾キーは<Control>と<META>だけですが、Emacsは他の
修飾キーもサポートします。これらは<Super>、<Hyper>、<Alt>と呼ばれます。
これらの修飾キーを使用する方法を提供する端末の数は多くありません。ほとん
どのキーボードで<Alt>とラベルされたキーは、通常は<Alt>ではなく<META>修飾
を発行します。Emacsの標準のキーバインディングでは、これらのキーで修飾さ
れた文字は含まれません。しかしこれらに意味を割り当てるようにEmacsをカス
タマイズできます。修飾ビットは、それぞれ‘s-’、‘H-’、‘A-’になります。

   これらの追加的な修飾キーがキーボードになくても、‘C-x @’を使用して入力
できます。‘C-x @ h’は“hyper”フラグ、‘C-x @ s’は“super”フラグ、‘C-x @ a’は
“alt”フラグを次の文字に加えます。たとえば‘Hyper-Control-a’を入力するには
、‘C-x @ h C-a’とタイプします(残念なことに同じ文字にたいして‘C-x @’を使
用して、2つの修飾を追加する方法はありません。なぜなら最初の1つは2回目の
‘C-x’にたいして作用するからです)。


File: emacs.info,  Node: Function Keys,  Next: Named ASCII Chars,  Prev: Modifier Keys,  Up: Key Bindings

48.3.8 ファンクションキーのリバインド
-------------------------------------

キーシーケンスには、通常の文字と同じようにファンクションキーを含めること
ができます。Lisp文字(実際は整数です)がキーボードの文字を表すように、
Lispシンボルはファンクションキーを表します。ファンクションキーのラベルに
示された単語が、それにタイプするLispシンボルの名前になります。以下は一般
的なファンクションキーにたいする、慣例的なLisp名です:

‘LEFT’、‘UP’、‘RIGHT’、‘DOWN’
     カーソル矢印キーです。

‘Begin’、‘End’、‘Home’、‘next’、‘prior’
     その他のカーソルを再配置するキーです。

‘select’、‘print’、‘execute’、‘backtab’
‘insert’、‘undo’、‘redo’、‘clearline’
‘insertline’、‘deleteline’、‘insertchar’、‘deletechar’
     その他のファンクションキーです。

‘f1’、‘f2’、...、‘f35’
     (キーボード上部にある)番号つきのファンクションキーです。

‘kp-add’、‘kp-subtract’、‘kp-multiply’、‘kp-divide’
‘kp-backtab’、‘kp-space’、‘kp-tab’、‘kp-enter’
‘kp-separator’、‘kp-decimal’、‘kp-equal’
     (標準的なキーボードでは右側にある)キーパッドの名前や句読点のキーで
     す。

‘kp-0’、‘kp-1’、...、‘kp-9’
     キーパッドの数字キーです。

‘kp-f1’、‘kp-f2’、‘kp-f3’、‘kp-f4’
     キーパッドのPFキーです。

   これらの名前は便利ですが、いくつかのシステム(特にXを使用するシステム
)では、異なる名前を使用するかもしれません。端末のファンクションキーにた
いして、どのシンボルが使用されているか確認するには、‘C-h c’とタイプして
、その後にそのファンクションキーを入力してください。

   ファンクションキーにバインドする例については、*note Init Rebinding::を
参照してください。

   多くのキーボードの右手側には、“テンキーボード(numeric keypad)”があり
ます。キーパッドのテンキーは‘Num Lock’とラベルされたキーで切り替えるにこ
とにより、カーソル移動キーにもなります。デフォルトでは、Emacsはこれらの
キーを、メインのキーボードの対応するキーに変換します。たとえば‘Num
Lock’がオンの場合、テンキーのlabeled ‘8’のラベルがついたキーは‘kp-8’を生
成し、これは‘8’に変換されます。また‘Num Lock’がオフの場合、このキーは
‘kp-up’を生成し、これは<UP>に変換されます。‘8’や<UP>のようなキーをリバイ
ンドした場合、それはキーパッドの対応するキーにも影響します。しかし直接
‘kp-’をリバインドした場合、これはメインのキーボードの等価なキーに影響を
与えません。修飾されたキーは変換されないことに注意してください。たとえば
<META>キーを押したまま、テンキーの‘8’を押すと、これは‘M-<kp-8>’を生成し
ます。

   Emacsは変数‘keypad-setup’、‘keypad-numlock-setup’、
‘keypad-shifted-setup’、‘keypad-numlock-shifted-setup’を使用することによ
り、テンキーのキーをバインドするための便利な方法を提供します。これらの変
数は‘keyboard’カスタマイズグループで見つけることができます(*note Easy
Customization::を参照してください)。キーをリバインドして、数引数を発行す
るなど、他のタスクを行なうことができます。


File: emacs.info,  Node: Named ASCII Chars,  Next: Mouse Buttons,  Prev: Function Keys,  Up: Key Bindings

48.3.9 名前のあるASCIIコントロール文字
--------------------------------------

当初<TAB>、<RET>、<BS>、<LFD>、<ESC>、<DEL>は、特定のASCIIコントロール文
字の名前として使用され、多用されるために自身の特別なキーをもつようになり
ました。たとえば<TAB>は‘C-i’の別の名前です。その後、ユーザーはEmacsでこ
れらのキーと、<Ctrl>キーと一緒にタイプするコントロール文字を区別できると
便利なことに気づきました。したがってほとんどの現代的な端末では、これらは
同じではありません。つまり<TAB>は‘C-i’と異なります。

   これら2種類の入力を、キーボードが区別するなら、Emacsも区別することが
できます。Emacsは“特別”なキーを‘tab’、‘return’、‘backspace’、
‘linefeed’、‘escape’、‘delete’という名前のファンクションキーとして扱いま
す。これらのファンクションキーは、そのキー自体に何もバインドされていない
場合は、対応するASCII文字に自動的に変換されます。結果として、ユーザーも
Lispプログラマーも、彼らがそうしたいと望まない限りは、これらの区別に注意
を払う必要はありません。

   (たとえば)<TAB>と‘C-i’を区別したくない場合は、ASCII文字の<TAB>(8進コ
ード011)だけにたいしてバインディングを1つ指定します。これらを区別したい
ときは、ASCII文字にたいして1つのバインディング、“ファンクションキー”の
‘tab’にたいして別のバインディングを指定します。

   通常のASCII端末では、<TAB>と‘C-i’(および同じような他のペアー)を区別す
る方法はありません。なぜなら端末はどちらの場合も同じ文字を送るからです。


File: emacs.info,  Node: Mouse Buttons,  Next: Disabling,  Prev: Named ASCII Chars,  Up: Key Bindings

48.3.10 マウスボタンのリバインド
--------------------------------

Emacsはマウスボタンを表すためにもLispシンボルを使用します。Emacsで通常の
マウスイベントは、“クリック(click)”イベントです。これはボタンを押して、
マウスを移動せずにボタンを離すと発生します。“ドラッグ(drag)”イベントも取
得できます。これはボタンを押したままマウスを移動したとき発生します。ドラ
ッグイベントは、最後にボタンを離したときにも発生します。

   基本的なクリックイベントにたいするシンボルは、一番左のボタンが
‘mouse-1’、次が‘mouse-2’、...となります。以下は、カレントウィンドウを2番
目のマウスボタンで分割するように再定義する方法です:

     (global-set-key [mouse-2] 'split-window-below)

   ドラッグイベントにたいするシンボルも同様ですが、単語‘mouse’の前にプレ
フィクス‘drag-’がつきます。たとえば左ボタンでのドラッグは
‘drag-mouse-1’イベントを生成します。

   マウスボタンが押されたときに発生するイベントにたいして、バインディン
グを定義することもできます。これらのイベントは‘drag-’ではなく‘down-’で始
まります。このようなイベントは、それらにキーがバインドされているときだけ
生成されます。ボタンダウンイベントを受け取った場合、その後に常にそれに対
応するクリックまたはドラッグイベントが続きます。

   もし望むならシングルクリック、ダブルクリック、トリプルクリックを区別
することもできます。ダブルクリックとは、マウスボタンをほぼ同じ場所で2回
クリックすることを意味します。最初のクリックは通常のクリックイベントを生
成します。2回目のクリックが充分早ければ、かわりにダブルクリックイベント
を生成します。ダブルクリックイベントにたいするイベントタイプは、たとえば
‘double-mouse-3’のように、‘double-’で始まります。

   これは同じ場所での2回目のクリックに特別な意味を与えることができること
を意味しますが、それは最初のクリックを受け取ったときに実行される、通常の
シングルクリックにたいする定義も実行されることを前提にしなければなりませ
ん。

   これはダブルクリックで行なえることを制限しますが、ユーザーインターフ
ェースデザイナーはこの制限は任意のケースにおいて従うべき制限だと言います
。ダブルクリックは、シングルクリックで行なう何かを、“よりもっと”行なうた
めのものであるべきです。ダブルクリックイベントにたいするコマンドは、ダブ
ルクリックにたいして追加の作業を処理するべきです。

   ダブルクリックイベントにバインディングがない場合、これは対応するシン
グルクリックイベントに変化します。したがって、特にダブルクリックイベント
を定義していない場合、これはシングルクリックコマンドを2回実行します。

   Emacsはトリプルクリックイベントもサポートし、それらの名前は
‘triple-’で始まります。Emacsはクワドループルクリック(quadruple clicks:
4連クリック)をイベントタイプとして区別しません。3回目以降のクリックは、
追加のトリプルクリックイベントを生成します。しかしクリックされた数はすべ
てイベントリストに記録されるので、Emacs Lispを知っていて、本当にそれを使
いたい場合はそれらを区別できます(*note (elisp)Click Events::を参照してく
ださい)。わたしたちは3連クリックを超えるクリックに明確な意味を与えるのは
推奨しませんが、連続するクリックが同じ3つの意味のセットを巡回する — たと
えば4連クリックは1クリックに等しく、5連クリックは2連クリックに等しく、
6連クリックは3連クリックに等しい、とするのが便利なときがあるかもしれませ
ん。

   Emacsはドラッグおよびボタンダウンイベントで、複数回ボタンが押されたこ
とも記録します。たとえば、ボタンを2回押して、それからボタンを押したまま
マウスを移動した場合、Emacsは‘double-drag-’イベントを受け取ります。2回目
にボタンを押した瞬間、Emacsは‘double-down-’イベントを受け取ります(そして
すべてのボタンダウンイベントと同様に、なにもバインドされていなければ無視
されます)。

   変数‘double-click-time’は、複数回のクリックをグループ化するのに、クリ
ックの間にどれだけの時間経過を許すかを指定します。変数の値の単位はミリ秒
です。値が‘nil’の場合、ダブルクリックは検知されません。値が‘t’の場合、時
間の制限はありません。デフォルトは500です。

   変数‘double-click-fuzz’は、複数回のクリックをグループ化するのに、クリ
ックの間にどれだけマウスが移動できるかを指定します。変数の値はウィンドウ
化されたディスプレーではピクセル単位で、テキストモード端末では文字セルの
1/8を単位とし、デフォルトは3です。

   マウスイベントにたいするシンボルは、修飾キーの状態も示し、‘C-’、
‘M-’、‘H-’、‘s-’、‘A-’、‘S-’のプレフィクスが通常つきます。‘double-’や
‘triple-’は常に‘drag-’や‘down-’の前にきますが、これらのプレフィクスは常
にそれより前にきます。

   フレームにはバッファーのテキストを表示しない、モードラインやスクロー
ルバーのような領域が含まれます。スクリーンの特別な領域でマウスボタンが押
されたかどうかは、ダミーの“プレフィクスキー”で知ることができます。たとえ
ばモードラインでマウスをクリックした場合、通常のマウスボタンシンボルの前
にプレフィクスキー‘mode-line’を受け取ります。したがって、以下はモードラ
インで左ボタンをクリックしたときに‘scroll-up-command’を実行する方法です:

     (global-set-key [mode-line mouse-1] 'scroll-up-command)

   以下はダミーのプレフィクスキーと、その意味の完全なリストです:

‘mode-line’
     マウスはウィンドウのモードラインにあります。
‘vertical-line’
     マウスは横に並んだウィンドウを分ける垂直ラインにあります(スクロール
     バーを使用している場合は、垂直ラインに表示されます)。
‘vertical-scroll-bar’
     マウスは垂直スクロールバーにあります(これはEmacsが現在サポートして
     いるスクロールバーにたいしてだけです)。
‘menu-bar’
     マウスはメニューバーにあります。
‘header-line’
     マウスはヘッダーラインにあります。

   キーシーケンスにマウスボタンを複数配することもできますが、これは通常
行なわれません。


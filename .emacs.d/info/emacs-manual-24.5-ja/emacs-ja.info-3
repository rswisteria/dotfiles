This is emacs-ja.info, produced by makeinfo version 6.1 from emacs.texi.

This is the ‘GNU Emacs Manual’, updated for Emacs version 24.5.

   Copyright © 2015–2016 Ayanokoji Takesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).            拡張可能なセルフドキュメント形式のテキストエディター。
END-INFO-DIR-ENTRY


File: emacs-ja.info,  Node: Interlocking,  Next: File Shadowing,  Prev: Customize Save,  Up: Saving

18.3.4 同時編集からの保護
-------------------------

同時編集(Simultaneous editing)は、2人のユーザーが同じファイルをvisitして
、両者が変更と保存を行ったときに発生します。これが発生していることを誰も
知らせなければ、最初に保存したユーザーは、後で自分の変更が失われているこ
とに気付くでしょう。

   いくつかのシステムでは、Emacsは2番目のユーザーがファイルの変更を開始
すると、すぐに警告を発します。また、すべてのシステムにおいて、Emacsはフ
ァイルを保存するときにチェックして、他のユーザーの変更を上書きすることを
警告します。ファイルを保存するかわりに適切な訂正アクションをとることによ
り、他のユーザーの変更を失わなわずに済みます。

   ファイルをvisitしているEmacsバッファーで最初の変更を行うとき、Emacsは
ファイルが“ロック(locked)”されていることを記録します(これは同じディレク
トリーにある、特別な内容の、特別な名前のシンボリックリンク(1)を作ること
により行われます)。変更を保存したとき、Emacsはロックを解除します。このア
イデアは、ファイルをvisitしているEmacsバッファーに保存されていない変更が
あるとき、ファイルはロックされているとするものです。

   変数‘create-lockfiles’を‘nil’にセットすることにより、ロックファイルの
作成を抑制することができます。*警告:*これにより、この機能が提供する利点
を失うことになります。

   他のユーザーによりロックされているファイルをvisitしているバッファーの
変更を開始すると、“衝突(collision)”が起こります。Emacsが衝突を検知すると
、Lisp関数‘ask-user-about-lock’を呼び出して、何を行うか尋ねます。カスタ
マイズのためにこの関数を再定義できます。この関数の標準定義は、ユーザーに
質問をして、3つの有効な応えを受け取ります。

‘s’
     ロックを横取りします。すでにファイルを変更したユーザーはロックを失
     い、あなたがロックを取得します。
‘p’
     続行します。他のユーザーがロックしている如何にかかわらずファイルの
     編集を続けます。
‘q’
     終了します。これはエラー(‘file-locked’)を引き起こし、バッファーの内
     容は変更されません。あなたが試みた修正は実際には行われません。

   Emacsまたはオペレーティングシステムがクラッシュすると、偽のロックファ
イルが残ることがあり、このような偽のロックファイルによる警告を受けること
があります。偽の衝突だと確信できるときは、Emacsにとにかく実行させる‘p’を
使います。

   ロックはファイル名にもとづいて機能するので、ファイルが複数の名前を持
っていて、2人のユーザーがそれぞれ別のファイル名で同時編集を行うことを、
Emacsが防ぐことはできないことに注意してください。

   ロックファイルに書き込みできない状況がいくつかあります。たとえばシス
テム権限不足や他の理由により、Emacsがロックファイルが作成できない場合で
す。このような場合でも保存を試みたときに、ファイルの最終変更日時をチェッ
クすることにより、Emacsは衝突を検知できます。最後にEmacsがvisitまたは保
存したときからファイルが変更されているとき、それは他の何らかの手段により
ファイルが変更されたことを示し、Emacsが保存を行うことによりそれらが失わ
れることを意味します。そのようなときEmacsは警告メッセージを表示して、保
存する前に確認を求めます。保存するときは‘yes’、保存を取り消すときは
‘no’または‘C-g’と応えてください。

   すでに同時編集が発生しているとき、バッファーとファイルを比較する方法
の1つは、‘M-x diff-buffer-with-file’コマンドです。*note Comparing
Files::を参照してください。

   ---------- Footnotes ----------

   (1) システムがシンボリックリンクをサポートしていなければ、通常のファ
イルが使われます。


File: emacs-ja.info,  Node: File Shadowing,  Next: Time Stamps,  Prev: Interlocking,  Up: Saving

18.3.5 ファイルのシャドーイング
-------------------------------

‘M-x shadow-initialize’
     ファイルのシャドーイング(shadowing)をセットアップします。
‘M-x shadow-define-literal-group’
     サイト間で共有される単一のファイルを定義します。
‘M-x shadow-define-regexp-group’
     ファイルのグループがマッチするすべてのファイルを、ホスト間で共有す
     るようにします。
‘M-x shadow-define-cluster <RET> NAME <RET>’
     shadowファイルのクラスターNAMEを定義します。
‘M-x shadow-copy-files’
     すべての保留中のshadowファイルをコピーします。
‘M-x shadow-cancel’
     ファイルにたいするshadow指示を取り消します。

   特定のファイルと等しい“shadow”コピーを１つ以上の場所、ことによると異
なるマシン間で保持するように計画できます。これを行うにはまず、“shadowフ
ァイルグループ”をセットアップしなければなりません。これはリストにあるサ
イト間で共有される同じ名前のファイルのセットです。ファイルグループは永続
的で、将来のEmacsセッションでも、現在のセッションと同様に適用されます。
一度グループをセットアップすると、Emacsを終了する度に、編集したファイル
をグループの他のファイルにコピーします。‘M-x shadow-copy-files’をタイプ
することにより、Emacsを終了せずにコピーすることもできます。

   shadowファイルグループをセットアップするには、‘M-x
shadow-define-literal-group’または‘M-x shadow-define-regexp-group’を使い
ます。詳細な情報は、これらの関数のドキュメント文字列を参照してください。

   ファイルをshadowにコピーする前に、Emacsは確認を求めます。“no”を応える
ことにより、その時だけはコピーを回避できます。特定のファイルにたいして今
後もshadowingを取り消したい場合、‘M-x shadow-cancel’を使うことにより、
shadowファイルグループを削除または変更します。

   “shadowクラスター”は、ディレクトリーを共有するホストのグループなので
、それらのコピーは、そのディレクトリーにあるすべてのファイルを更新するの
に充分です。shadowクラスターはそれぞれ名前を持ち、プライマリーホスト(コ
ピーを行うホスト)のネットワークアドレスと、プライマリーホスト以外でクラ
スターに含めるホストを選択するための正規表現を指定します。‘M-x
shadow-define-cluster’によりshadowクラスターを定義できます。


File: emacs-ja.info,  Node: Time Stamps,  Prev: File Shadowing,  Up: Saving

18.3.6 タイムスタンプの自動更新
-------------------------------

ファイルにタイムスタンプを書き込むことができます。これによりファイルを編
集・保存する度に、タイムスタンプが自動的に更新されます。タイムスタンプは
、ファイルの最初の8行になければならず、以下のような形式、

     Time-stamp: <>

または以下のような形式です:

     Time-stamp: " "

   その後、フック‘before-save-hook’に関数‘time-stamp’を追加します(*note
Hooks::を参照してください)。ファイルを保存するとき、この関数は現在の日時
で自動的にタイムスタンプを更新します。コマンド‘M-x time-stamp’を使って、
手動でタイムスタンプを更新することもできます。その他のカスタマイズとして
は、Custom groupの‘time-stamp’を参照してください。タイムスタンプの書式は
、localeのセッティングに従うことに注意して下さい(*note Environment::を参
照してください)。


File: emacs-ja.info,  Node: Reverting,  Next: Autorevert,  Prev: Saving,  Up: Files

18.4 バッファーのリバート
=========================

ファイルをvisitしているバッファーにたいして、広範な変更をした後に気が変
わったときは、“リバート(revert: 復元)”することにより。変更をファイルの保
存されたバージョンに戻すことができます。間違えてリバートしてしまうことに
より、大量の作業結果を失うこともあり得るので、Emacsは最初に確認を求めま
す。

   ‘revert-buffer’コマンドは、ファイルが少ししか変更されていないときは、
前にポイントがあったテキスト部分とだいたい同じ位置にポイントを置くよう試
みます。しかし広範な変更を行っていた場合、ポイントは大きく異なる場所に置
かれることになります。

   リバートはバッファーを“not modified(変更されていない)”とマークします
。また、バッファーのundoヒストリーもクリアーされます(*note Undo::を参照
してください)。したがってリバートはundoできません。再び気を変えても、
undoコマンドを使ってリバートした変更を元にもどすことはできません。

   ファイルに関連付けられていない、Diredバッファーのようなバッファーでも
、リバートすることができます。それらの場合、リバートはその内容を再計算す
ることを意味します。‘C-x b’で明示的に作成したバッファーは、リバートでき
ません。リバートを試みると‘revert-buffer’はエラーを報告します。

   自動的かつ頻繁に変更されるファイル、たとえば実行を続けるプロセスのロ
グ出力などを編集しているとき、Emacsが確認なしにリバートできたら便利でし
ょう。このような振る舞いをさせるには、変数‘revert-without-query’に正規表
現のリストをセットします。ファイル名がそれらの正規表現の1つにマッチした
とき、‘find-file’および‘revert-buffer’は、バッファーが変更されていないと
きは、ファイルが変更される度に自動的にリバートします(もしテキストを編集
していた場合、変更を放棄するのはおそらく正しくありません)。

   Emacsにバッファーを定期的にリバートするよう、指示することもできます。
特定のバッファーにたいしてこれを行うには、‘M-x auto-revert-mode’とタイプ
して、マイナーモードのAuto-Revertモードを有効にします。これは現在のバッ
ファーを5秒ごとに自動的にリバートします。リバートの間隔は
‘auto-revert-interval’で変更できます。すべてのバッファーにたいして同じこ
とを行うには、‘M-x global-auto-revert-mode’とタイプして、Global
Auto-Revertモードを有効にします。これらのマイナーモードはリモートのファ
イルにたいするチェックやリバートはしません。なぜならそれは通常とても遅い
からです。

   Auto-Revertモードの1つの使い方は、システムログのようなファイルを
“tail”することです。これにより、それらのファイルにたいする、他のプログラ
ムによる変更を、継続的に表示できます。これを行うには、ポイントをバッファ
ーの最後に移動します。そうすればファイル内容が変更されても、ポイントはそ
の位置に留まります。しかし、ファイルがファイルの終端方向に向かって変更さ
れるだけだと確信できるときは、かわりにAuto-Revert Tailモード
(‘auto-revert-tail-mode’)を使います。このモードは、これをより効果的に行
います。Auto-Revert Tailモードは、リモートのファイルにたいしても機能しま
す。

   バージョンコントロールシステムの下にあるファイルを、以前のバージョン
にリバーとするコマンドについては、*note VC Undo::を参照してください。バ
ージョンコントロールシステムの下にあるファイルをvisitしているときの自動
リバートの特性については、*note VC Mode Line::を参照してください。


File: emacs-ja.info,  Node: Autorevert,  Next: Auto Save,  Prev: Reverting,  Up: Files

18.5 非ファイルバッファーの自動リバート
=======================================

通常Global Auto Revertモードは、ファイルのバッファーだけをリバートします
。非ファイルバッファーにたいして自動リバートを行うには、2つの方法があり
ます。1つはそれらのバッファーにたいしてAuto Revertモードを有効にする方法
です(‘M-x auto-revert-mode’を使います)。もう1つは
‘global-auto-revert-non-file-buffers’に非‘nil’値をセットする方法です。後
者はそれが実装されているすべての種類のバッファーにたいして、自動リバート
を有効にします(以下のメニューにリストされています)。

   ファイルバッファーと同様、非ファイルバッファーはそれらにたいして作業
を行っているときや、リバートすると失われてしまう情報が含まれているとき、
通常はリバートすべきではありません。したがって、それらが“modified(変更さ
れている)”のときはリバートしません。非ファイルバッファーが変更されている
とマークするのは、ファイルバッファーのときより通常難しいので、トリッキー
になり得ます。

   他のトリッキーな点に関する詳細は、効率の問題です。自動リバートはしば
しばバッファーにたいするすべての可能な変更を検知しようとせず、“広範”また
は簡単に検知できる変更だけを検知します。したがって、非ファイルバッファー
に自動リバートを有効にすることは、バッファーのすべての情報が最新であると
常に保証はしませんし、手動によるリバートを無用にする必要もないからです。

   それとは反対に、特定のバッファーは‘auto-revert-interval’で指定された
秒数ごとに自動的にリバートします(これは現在のところBuffer Menuだけに適用
されます)。この場合、自動リバートはリバートの際、‘auto-revert-verbose’が
非‘nil’でも、何もメッセージを表示しません。

   詳細はバッファーの特性に依存し、それらは対応するセクションで説明され
ています。

* Menu:

* Auto Reverting the Buffer Menu::  Buffer
                                      Menuの自動リバートについて。
* Auto Reverting Dired::     Diredバッファーの自動リバートについて。
* Supporting additional buffers::  自動リバートのサポートを追加する方法。


File: emacs-ja.info,  Node: Auto Reverting the Buffer Menu,  Next: Auto Reverting Dired,  Up: Autorevert

18.5.1 Buffer Menuの自動リバート
--------------------------------

非ファイルバッファーの自動リバートが有効なとき、必要性の有無にかかわらず
、Buffer Menuは‘auto-revert-interval’で指定された秒数ごとに自動的にリバ
ートされます。(これは多分実際にリバートする必要があるかチェックするより
長い間隔です)。

   Buffer Menuがmodifiedと不適切にマークされたときは、‘g’により手動でリ
バートして自動リバートを再開します。しかし特定のバッファーにたいして削除
や表示のマークをつけた場合は、慎重になる必要があります。なぜならリバート
はすべてのマークを消去するからです。マークの追加はバッファーのmodifiedフ
ラグをセットするという事実は、自動的なマークの消去からの自動リバートを防
ぎます。


File: emacs-ja.info,  Node: Auto Reverting Dired,  Next: Supporting additional buffers,  Prev: Auto Reverting the Buffer Menu,  Up: Autorevert

18.5.2 Diredバッファーの自動リバート
------------------------------------

Diredバッファーの自動リバートは、現在のところUnixスタイルのオペレーティ
ングシステムだけで機能します。他のシステムでは満足に機能しないでしょう。

   Diredバッファーは、バッファーのメインディレクトリーのファイルリストが
変化したとき(たとえば新しいファイルの追加)だけ、自動リバートします。特定
のファイルの情報が変化したとき(たとえばサイズの変化)や、サブディレクトリ
ーへの追加は自動リバートしません。_すべて_のリストされた情報が最新である
ことを確実にするには、Diredバッファーで自動リバートが_有効であっても_、
手動で‘g’を使ってリバートする必要があります。メインディレクトリーにリス
トされているファイルへの変更や保存で、実際に自動リバートが起こるのに気付
くかもしれません。これはファイルの変更や保存は、たとえばバックアップファ
イルやauto-saveファイルにより、高い確率でディレクトリー自身を変更するか
らです。しかし、これは保証されているわけではありません。

   Diredバッファーがmodifiedとマークされ、残したい変更がない場合、大抵は
‘g’でバッファーを手動でリバートすることにより、自動リバートを再開できま
す。しかし1つ例外があります。ファイルにフラグやマークをつけた場合、安全
にバッファーをリバートできます。これはフラグやマークを消去しません(もち
ろんマークされたファイルが削除されていない場合です)。しかしバッファーは
リバートの後でさえmodifiedの状態に留まるので、自動リバートは再開しません
。これは、もしファイルにたいしてフラグやマークをつけた場合、それはバッフ
ァーにたいして作業をしており、警告なしにバッファーが変更されることを望ま
ないだろうからです。マークやフラグがある状態で自動リバートを再開したいと
きは、‘M-~’を使ってバッファーをnon-modifiedとマークします。しかしマーク
やフラグの追加・削除・変更により、バッファーは再びmodifiedとマークされま
す。

   リモートのDiredバッファーは、自動リバートされません(これは遅くなるか
らです)。特定のファイルだけをリストするように、シェルのワイルドカードや
ファイル引数を与えられたDiredバッファーも同じです。‘*Find*’および
‘*Locate*’は、どちらも自動リバートしません。


File: emacs-ja.info,  Node: Supporting additional buffers,  Prev: Auto Reverting Dired,  Up: Autorevert

18.5.3 追加のバッファーにたいする自動リバートのサポートの追加
-------------------------------------------------------------

このセクションは、新しいタイプのバッファーに自動リバートのサポートを追加
したいElispプログラマーのために意図されています。

   バッファーに自動リバートのサポートを追加するには、まず最初に適切な
‘revert-buffer-function’をもつことです。*Note Reverting:
(elisp)Definition of revert-buffer-function.を参照してください。

   それに加えて、適切な‘buffer-stale-function’をもたなければなりません。

 -- Variable: buffer-stale-function
     この変数の値は、バッファーがリバートする必要があるかチェックする関
     数です。これは1つのオプション引数NOCONFIRMをもつ関数です。この関数
     はバッファーがリバートされるべきときは、非‘nil’を返します。バッファ
     ーは、この関数が呼ばれたときのバッファーです。

     この関数は主に自動リバートで使うことを意図していますが、他の目的に
     も同様に使うことができます。たとえば自動リバートが無効の場合、これ
     はバッファーをリバートする必要があるとユーザーに警告するのに使えま
     す。このアイデアは引数NOCONFIRMが背景にあります。もしこれが‘t’のと
     きは、ユーザーに尋ねることなくリバートを行い、この関数をバッファー
     が無効だとユーザーに警告するために使うときは、‘nil’を指定します。特
     に自動リバートに使う場合、NOCONFIRMは‘t’になります。関数を自動リバ
     ートだけに使う場合、引数NOCONFIRMは無視できます。

     (Buffer Menuのように)‘auto-revert-interval’で指定した秒数ごとに自動
     リバートを自動的に行いたいだけのときは、以下のようにします:

          (setq-local buffer-stale-function
               #'(lambda (&optional noconfirm) 'fast))

     これをバッファーのモード関数の中に記述します。

     特別な戻り値‘fast’は、呼出側にリバートの必要性チェックは必要ないが
     、バッファーのリバートは早く行うことを呼出側に伝えます。これは
     ‘auto-revert-verbose’が非‘nil’のときも、自動リバートがリバートメッ
     セージを表示しないことも伝えます。これは重要です。なぜなら
     ‘auto-revert-interval’秒ごとにリバートメッセージが表示されるのは、
     とても煩わしくなり得るからです。この戻り値で提供される情報は、関数
     が自動リバート以外の目的で使われる場合にも有用です。

   バッファーが適切な‘revert-buffer-function’および
‘buffer-stale-function’をもっていても、通常は問題がいくつか残ります。

   バッファーは、unmodifiedとマークされているときだけ自動リバートします
。したがって、さまざまな関数がバッファーをmodifiedとマークするのは、バッ
ファーがリバートされることにより失われる情報を持つとき、またはユーザーが
バッファーで作業しているので、自動リバートが迷惑だと信じる理由があるとき
だと確信する必要があります。ユーザーはmodifiedのステータスを手作業で調整
することにより、常にこれをオーバーライドできます。これをサポートするため
に、unmodifiedとマークされたバッファーでの‘revert-buffer-function’の呼び
出しは、そのバッファーのunmodifiedのマークを維持すべきです。

   一連の自動リバートで、ポイントがあちこちジャンプしないことを保証する
のは重要です。もちろんバッファーが活発に変化するとき、ポイントが移動する
のは仕方ありません。

   ‘revert-buffer-function’が、‘auto-revert-verbose’が‘t’のとき出力され
る自動リバート自身のメッセージと重複する、不要なメッセージを出力しないこ
とと、‘auto-revert-verbose’にセットされた‘nil’値を、効果的にオーバーライ
ドすることを確実にするべきです。したがってモードを自動リバートに適合させ
ることは、しばしばそのようなメッセージの削除をともないます。これは
‘auto-revert-interval’秒ごとに自動リバートを行うバッファーで特に重要です
。

   新しい自動リバートがEmacsの一部となったときは、
‘global-auto-revert-non-file-buffers’のドキュメント文字列にそれを記載す
るべきです。

   同様にこのチャプターのメニューにノードを追加するべきです。そのノード
は、バッファーの自動更新を有効にすることによりバッファーのすべての情報が
完全に最新(または最新から‘auto-revert-interval’秒後)であると保証されるか
を、最小限かつ明確にすべきです。


File: emacs-ja.info,  Node: Auto Save,  Next: File Aliases,  Prev: Autorevert,  Up: Files

18.6 自動保存－災害にたいする防御
=================================

Emacsは定期的に、visitしているファイルを、実際に使っているファイルを変更
せずに、別のファイルに自動的に保存するときがあります。これは“自動保存
(auto-saving)”と呼ばれます。これはシステムがクラッシュしたとき、失われて
しまう作業をある程度以下に制限するためのものです。

   Emacsが自動保存するときだと決定すると、各バッファーを判断して、それら
のバッファーの自動保存が有効で、最後に自動保存されてから変更されている場
合は、自動保存します。ファイルが実際に自動保存されている場合は、自動保存
の間、エコーエリアに‘Auto-saving...’というメッセージが表示されます。自動
保存の間のエラーはキャッチされるので、ユーザーがタイプして実行したコマン
ドに、干渉することはありません。

* Menu:

* Files: Auto Save Files.    ファイルを保存するまでの間、自動保存された変更が実際に保存されるファイル。
* Control: Auto Save Control.  自動保存をいつ、どのような間隔で行うかの制御。
* Recover::                  自動保存ファイルからのテキストの復旧。


File: emacs-ja.info,  Node: Auto Save Files,  Next: Auto Save Control,  Up: Auto Save

18.6.1 自動保存ファイル
-----------------------

自動保存は通常、visitしているファイルへの保存はしません。なぜなら永続化
したくない変更を保存するのは、好ましくないからです。そのかわりに、自動保
存は“auto-saveファイル”と呼ばれる別のファイルに保存し、visitしているファ
イルへの変更は、保存を明示的に要求したとき(‘C-x C-s’など)に行います。

   auto-saveファイルの名前は通常、visitしているファイル名の前後に‘#’をつ
けて作られます。したがって‘foo.c’というファイルをvisitしているバッファー
は、‘#foo.c#’というファイルに自動保存されます。ファイルをvisitしていない
バッファーのほとんどは、明示的に要求した場合だけ自動保存されます。それら
のバッファーが自動保存されるとき、auto-saveファイル名は、バッファー名の
前後に‘#’をつけて、その後ろに数字と文字を付け加えて一意な名前にします。
たとえば送信メッセージを作成する‘*mail*’バッファーは、‘#*mail*#704juu’の
ような名前のファイルに、自動保存されます。Emacsの一部(関数
‘make-auto-save-file-name’および‘auto-save-file-name-p’)を違った方法で再
プログラムしない限り、auto-saveファイル名はこの方法で作成されますバッフ
ァーの自動保存に使われるファイル名は、そのバッファーの自動保存をオンにし
たときに計算されます。

   変数‘auto-save-file-name-transforms’は、auto-saveファイル名をある程度
制御することを許します。これに一連の正規表現を指定して置換することにより
、auto-saveファイル名を変更します。デフォルト値は、リモートのファイル
(*note Remote Files::を参照してください)を、ローカルマシンの一時ディレク
トリーのauto-saveファイルに変換します。

   大きなバッファーから大量のテキストを削除したとき、そのバッファーにた
いする自動保存は一時的にオフになります。これは、もしテキストをうっかり削
除してしまった場合、それがauto-saveファイルに含まれていて、そこから探せ
る方が便利だからです。これが発生した後、再び自動保存を有効にするには、バ
ッファーを‘C-x C-s’で保存するか、‘C-u 1 M-x auto-save-mode’を使います。

   別のauto-saveファイルにするのではなく、visitしているファイルに自動保
存したいときは、変数‘auto-save-visited-file-name’を非‘nil’値にセットしま
す。このモードでは、自動保存と明示的な保存に実際の違いはありません。

   バッファーのauto-saveファイルは、そのバッファーをvisitしているファイ
ルに保存したとき削除されます(変数‘delete-auto-save-files’を‘nil’にセット
することにより、これを禁じることができます)。‘C-x C-w’または
‘set-visited-file-name’で、visitされているファイル名を変更することにより
、あたらしくvisitされているファイル名にもとづいてauto-saveファイル名はリ
ネームされます。


File: emacs-ja.info,  Node: Auto Save Control,  Next: Recover,  Prev: Auto Save Files,  Up: Auto Save

18.6.2 自動保存の制御
---------------------

ファイルをvisitする度に、そのファイルバッファーの自動保存は、オンになり
ます(バッチモードでは異なります。*note Initial Options::を参照してくださ
い)。この変数のデフォルトは‘t’なので、ファイルをvisitしているバッファー
の自動保存は通常、常に行われます。現在のバッファーの自動保存を切り替える
には、‘M-x auto-save-mode’とタイプします。Auto Saveモードはバッファーロ
ーカルに動作するマイナーモードです(*note Minor Modes::を参照してください
)。

   Emacsは最後に自動保存されてから何文字タイプしたかにもとづいて、定期的
に自動保存を行います。変数‘auto-save-interval’は、自動保存と自動保存の間
に何文字タイプされたかを指定します。デフォルトは300です。Emacsは小さすぎ
る値は受け付けません。‘auto-save-interval’を20より小さな値にカスタマイズ
した場合、Emacsは20と指定されたかのように振る舞います。

   自動保存はタイピングをストップしたときも行われます。デフォルトでは
30秒アイドル状態が続くと実行されます。(このときEmacsはガベージコレクショ
ンも実行します; *note (elisp)Garbage Collection::を参照してください)。こ
の間隔を変更するには、変数‘auto-save-timeout’をカスタマイズします。実際
の実行間隔は、現在のバッファーの大きさに応じて長くなります。これは、自動
保存が実感できるほど時間がかかるような大きなバッファーを編集しているとき
は、それをなるべく無くすようにする狙いです。アイドル状態のときの自動保存
は、2つの事を達成します。最初に、端末を少しの間離れるときなどに、すべて
の作業の保存を保証します。次に、実際にタイプしているときは自動保存を避け
ます。

   Emacsは、致命的なエラーが発生したときも自動保存を行います。これには
‘kill %emacs’のようなコマンドによるEmacsジョブのkill、電話回線やネットワ
ーク回線の切断が含まれます。

   コマンド‘M-x do-auto-save’により、明示的に自動保存を行うことができま
す。


File: emacs-ja.info,  Node: Recover,  Prev: Auto Save Control,  Up: Auto Save

18.6.3 自動保存からのデータ復旧
-------------------------------

コマンド‘M-x recover-file <RET> FILE <RET>’により、auto-saveファイルの内
容を使って、失われたデータを復旧できます。これはFILEをvisitして、(確認を
求めた後で)auto-saveファイル‘#FILE#’の内容をリストアします。その後‘C-x
C-s’で復旧したテキストを、FILE自身に保存できます。たとえばファイル
‘foo.c’を、そのauto-saveファイル‘#foo.c#’で復旧するには、以下のようにし
ます:

     M-x recover-file <RET> foo.c <RET>
     yes <RET>
     C-x C-s

   ‘M-x recover-file’は確認を求める前に、指定したファイルとauto-saveファ
イルのあるディレクトリー一覧を表示するので、ファイルのサイズや日付を確認
できます。auto-saveの方が古い場合、‘M-x recover-file’はそれを読み込むよ
うに提案しません。

   Emacsまたはコンピューターがクラッシュしたとき、‘M-x recover-session’コ
マンドで編集していたすべてのファイルを、それらのauto-saveファイルで復旧
できます。これは最初に中断されたセッションの記録された一覧を表示します。
ポイントを移動して選択してから、‘C-c C-c’をタイプします。

   ‘recover-session’は、そのセッションの間に編集されていた各ファイルにつ
いて、ファイルを復旧するか尋ねます。‘y’と応えると‘recover-file’を呼び出
し、通常の方法で復旧を行います。これは元のファイルとauto-saveファイルの
日付を表示して、ファイルの復旧を行うかもう1度尋ねます。

   ‘recover-session’が完了すると、復旧を選択したファイルがEmacsバッファ
ーに表示されます。実際にファイル自体を復旧するためには、これらを保存する
のが唯一の方法です。

   Emacsは中断されたセッションについての情報を、ディレクトリー
‘~/.emacs.d/auto-save-list/’の、‘.saves-PID-HOSTNAME’という名前のファイ
ルに記録します。‘auto-save-list-file-prefix’を‘nil’にセットすると、復旧
用にセッションが記録されなくなります。


File: emacs-ja.info,  Node: File Aliases,  Next: Directories,  Prev: Auto Save,  Up: Files

18.7 ファイルのエイリアス
=========================

シンボリックリンクとハードリンクは、同じファイルを参照するためにいくつか
の名前を使うことを可能にします。ハードリンクは、ファイルを直接参照する他
の名前です。それらすべての名前は同じように有効で、それらの間に優先順位は
ありません。対照的にシンボリックリンクは、ある種の定義されたエイリアス
(別名)です。‘foo’が‘bar’へのシンボリックリンクの場合、そのファイルをどち
らの名前でも参照できますが、‘bar’が実際の名前で、‘foo’はエイリアスに過ぎ
ません。シンボリックリンクがディレクトリーを指すときは、さらに複雑なケー
スが発生します。

   Emacsがすでに異なる名前でvisitしている場合、通常はエコーエリアにメッ
セージを表示して、そのファイルをvisitしている既存のバッファーを使います
。これはハードリンクおよびシンボリックリンクをサポートしているシステム、
または長いファイル名を切り詰めるシステムで長い名前のファイルを使っている
場合、またはファイル名の大文字小文字を区別しないシステムで発生します。変
数‘find-file-suppress-same-file-warnings’を非‘nil’値にセットすることによ
り、メッセージを表示しないようにできます。変数
‘find-file-existing-other-name’を‘nil’にセットすれば、この機能全体を無効
にできます。その場合、同じファイルを異なる名前でvisitすると、それぞれの
ファイル名で別々のバッファーが使われます。

   変数‘find-file-visit-truename’が非‘nil’の場合、バッファー用に記録され
るファイル名は、指定した名前ではなく、ファイルの“本当の名前”(これはすべ
てのシンボリックリンクを対象の名前で置き換えて作られます)が使われます。
‘find-file-visit-truename’をセットするは、
‘find-file-existing-other-name’にも暗に影響します。

   シンボリックリンクを通じてアクセスされるようなディレクトリーにたいし
ては通常、優先的に“リンクされた”名前をEmacsに表示させたいときがあります
。これを行うには‘directory-abbrev-alist’をカスタマイズします。このリスト
の各要素は‘(FROM . TO)’という書式です。これはディレクトリー名にFROMが出
現したときは常に、FROMをTOで置き換えることを意味します。文字列FROMは正規
表現です(*note Regexps::を参照してください)。正規表現はディレクトリー名
の最初の文字にマッチさせる必要があるので、‘\`’で始まります(埋め込みの改
行をサポートするディレクトリー名の場合は、‘^’で無効にします)。TOには同じ
ディレクトリーを指す、絶対パスによる普通のディレクトリー名を指定する必要
があります。文字列TOでホームディレクトリーを指定するのに、‘~’を使用しな
いでください。Emacsはこれらの変換を個別に行います。以下は通常シンボリッ
クリンク‘/fsf’でアクセスされる、‘/home/fsf’を指定する例です:

     (("\\`/home/fsf" . "/fsf"))


File: emacs-ja.info,  Node: Directories,  Next: Comparing Files,  Prev: File Aliases,  Up: Files

18.8 ファイルディレクトリー
===========================

ファイルシステムは、ファイルを“ディレクトリー”にグループ化します。“ディ
レクトリーリスト”は、ディレクトリーに含まれるファイルのリストです。
Emacsはディレクトリーを作成および削除するコマンドを提供し、簡単な形式(フ
ァイル名のみ)、および詳細な形式(サイズ、日付、作成者を含む)のディレクト
リーリストを作成します。EmacsにはDiredと呼ばれるディレクトリーブラウザー
も含まれています。詳細は*note Dired::を参照してください。

‘C-x C-d DIR-OR-PATTERN <RET>’
     簡単なディレクトリーリストを表示します(‘list-directory’)。
‘C-u C-x C-d DIR-OR-PATTERN <RET>’
     詳細なディレクトリーリストを表示します。
‘M-x make-directory <RET> DIRNAME <RET>’
     DIRNAMEという名前の新しいディレクトリーを作成します。
‘M-x delete-directory <RET> DIRNAME <RET>’
     DIRNAMEという名前のディレクトリーを削除します。もし空でない場合、そ
     れらを再帰的に削除するか尋ねます。

   ディレクトリーリストを表示するコマンドは、‘C-x C-d’
(‘list-directory’)です。これはミニバッファーを使って、リストを表示するデ
ィレクトリーと、リストするファイルを指定するワイルドカードが含まれたパタ
ーンの両方により、ファイル名を読み取ります。たとえば

     C-x C-d /u2/emacs/etc <RET>

これはディレクトリー‘/u2/emacs/etc’のファイルをリストします。以下はファ
イル名のパターンを指定する例です。

     C-x C-d /u2/emacs/src/*.c <RET>

   通常、‘C-x C-d’は名前だけを含む、簡単なディレクトリーリストを表示しま
す。数引数(値は関係なし)は、サイズ、日付、所有者を含む詳細な一覧を作成す
るよう指示します。

   ディレクトリーリストのテキストは、主に下位プロセスとして‘ls’を実行す
ることにより取得されます。2つのEmacs変数が、‘ls’に指定するスイッチを制御
します。‘list-directory-brief-switches’には、簡単な一覧に使うためのスイ
ッチを文字列で指定します(デフォルトは‘"-CF"’)。
‘list-directory-verbose-switches’には、詳細な一覧に使うためのスイッチを
文字列で指定します(デフォルトは‘"-l"’)。

   詳細なディレクトリー一覧では、Emacsはディレクトリーが含まれるディスク
の空き容量についての情報を追加します。これは
‘directory-free-space-program’で指定されたプログラムに、
‘directory-free-space-args’で指定された引数を指定して実行します。

   コマンド‘M-x delete-directory’は、ミニバッファーを使ってディレクトリ
ー名の入力を求め、空のときはディレクトリーを削除します。ディレクトリーが
空でない場合、再帰的に削除するか確認を求めます。“Trash(ごみ箱)”(または
“Recycle Bin”)の機能をもつシステムでは、変数
‘delete-by-moving-to-trash’を‘t’に変更することにより、指定したディレクト
リーを無条件に削除するかわりに、ごみ箱に移動します。ごみ箱の使い方につい
ての情報は、*note Misc File Ops::を参照してください。


File: emacs-ja.info,  Node: Comparing Files,  Next: Diff Mode,  Prev: Directories,  Up: Files

18.9 ファイルの比較
===================

コマンド‘M-x diff’は、ミニバッファーを使って2つのファイル名の入力を求め
、‘*diff*’という名前のバッファーに、2つのファイルの違いを表示します。こ
れは‘diff’プログラムに、変数‘diff-switches’で指定されたオプションを指定
して実行することにより機能します。‘diff-switches’には文字列を指定します
。デフォルトはcontext出力形式を指定する‘"-c"’です。プログラムについての
情報は、*note Diff: (diff)Top.を参照してください。

   ‘diff’コマンドの出力は、Diffモードと呼ばれるメジャーモードを使って表
示されます。*note Diff Mode::を参照してください。

   コマンド‘M-x diff-backup’は指定したファイルと、そのファイルの一番最近
のバックアップを比較します。バックアップファイル名を指定したときは、
‘diff-backup’は指定されたバックアップファイルと、それの元となるファイル
を比較します。それ以外の点は‘M-x diff’と同じです。

   コマンド‘M-x diff-buffer-with-file’は指定されたバッファーと、それに対
応するファイルを比較します。これはバッファーを保存すると、ファイルにどの
ような変更がされるかを表示します。

   コマンド‘M-x compare-windows’は現在のウィンドウと、次のウィンドウを比
較します(Emacsのウィンドウについての詳細は、*note Windows::を参照してく
ださい)。比較はそれぞれのウィンドウのポイント位置から、それぞれのバッフ
ァーのポイントの初期位置を、対応するバッファーのマークリングにpushした後
に開始されます。それから各ウィンドウのポイントを1文字ずつ前方に移動して
いきます。文字がマッチしなくなるとコマンドは終了します。

   コマンドを開始したとき、2つのウィンドウのポイントの後ろのテキストがマ
ッチしない場合、‘M-x compare-windows’は2つのウィンドウでマッチするテキス
トが見つかるまでポイントを進めてから終了します。したがって‘M-x
compare-windows’を繰り返し使うと、毎回1つのマッチする範囲をスキップする
か、次の開始点を探します。

   数引数を指定すると、‘compare-windows’は空白文字の違いを無視します。変
数‘compare-ignore-case’が非‘nil’の場合、大文字小文字の違いを無視して比較
します。変数‘compare-ignore-whitespace’が非‘nil’の場合、
‘compare-windows’は通常空白文字の違いを無視して、数引数が指定されたとき
はそれをオフにします。

   ‘M-x smerge-mode’を使って、Smergeモードに切り替えることができます。こ
れは‘diff3’プログラムの出力を編集するマイナーモードです。これは通常、バ
ージョン管理システムと、バージョン管理システムの外での“update”をマージす
るとき、ファイルへの変更が競合して失敗した結果です。Smergeモードは特定の
変更を選択することにより、競合を解決するコマンドを提供します。

   ファイルをマージする強力なインターフェースを提供するEmerge機能につい
ては、 *note Emerge::を参照してください。


File: emacs-ja.info,  Node: Diff Mode,  Next: Misc File Ops,  Prev: Comparing Files,  Up: Files

18.10 Diffモード
================

Diffモードは、‘M-x diff’や他の同様なコマンドの出力のために使用されるメジ
ャーモードです。この種の出力は“patch”と呼ばれます。なぜならそれが特定の
変更を自動的に適用するために、‘patch’コマンドに渡されるからです。手動で
Diffモードを選択するには、‘M-x diff-mode’とタイプします。

   パッチに指定された変更は、“hunk(欲張り)”にグループ化されます。これは
変更された行を１行以上含むテキストと、それに隣接するテキストです。
hunksには変更のコンテキストを提供するために、変更されていない行も含むこ
とができます。それぞれのhunkには“hunkヘッダー”が前についていて、これは
hunkが出現する古い方の行番号と、新しい行番号が指定されます。Diffモードは
実際のhunkの内容と区別するため、hunkヘッダーをハイライトします。

   他のバッファーと同様に、Diffモードのバッファーを編集することができま
す(もし読み込み専用の場合、最初にそれを書き込み可にする必要があります。
*note Misc Buffer::を参照してください)。hunkを変更すると、Diffモードは
patchを“正しい”状態に保つために、hunkヘッダーの行番号を自動的に修正しよ
うと試みます。自動的な行番号の修正を無効にするには、変数
‘diff-update-on-the-fly’を‘nil’に変更してください。

   DiffモードはCompilationモードと同様に、各hunkを“エラーメッセージ”とし
て扱います。したがって‘C-x '’のようなコマンドを使って、対応するソースの
位置をvisitすることができます。

   それに加えてDiffモードは、移動、操作、patchの一部を適用するために、以
下のコマンドを提供します:

‘M-n’
     次のhunkが開始される位置に移動します(‘diff-hunk-next’)。

     このコマンドには副作用があります。これは移動先のhunkを“refines(不純
     物を取り除く)”して、よりよい粒度で変更をハイライトします。この機能
     を無効にするには‘M-x diff-auto-refine-mode’とタイプして、マイナーモ
     ードのDiff Auto-Refineモードをオフに切り替えます。デフォルトでDiff
     Auto-Refineモードを無効にするには、以下をinitファイルに追加します
     (*note Hooks::を参照してください):

          (add-hook 'diff-mode-hook
                    (lambda () (diff-auto-refine-mode -1)))

‘M-p’
     前のhunkが開始される位置に移動します(‘diff-hunk-prev’)。これは
     ‘M-n’と同様、Diff Auto-Refineモードが無効でなければ、移動先のhunkを
     refiningする副作用があります。

‘M-}’
     複数ファイルへのpatchで、次のファイルが開始される位置に移動します
     (‘diff-file-next’)。

‘M-{’
     複数ファイルへのpatchで、前のファイルが開始される位置に移動します
     (‘diff-file-prev’)。

‘M-k’
     ポイントがある位置のhunkをkillします(‘diff-hunk-kill’)。

‘M-K’
     複数ファイルへのpatchで、現在のファイル部分をkillします
     (‘diff-file-kill’)。

‘C-c C-a’
     このhunkを対象ファイルに適用します(‘diff-apply-hunk’)。プレフィクス
     引数‘C-u’を指定すると、このhunkを復元します。

‘C-c C-b’
     ポイント位置のhunkの変更を、よりよい粒度でハイライトします
     (‘diff-refine-hunk’)。これにより変更された各行について実際に変更さ
     れた箇所を確実に見ることができます。

‘C-c C-c’
     このhunkに対応するソースファイルの行へジャンプします
     (‘diff-goto-source’)。

‘C-c C-e’
     このパッチでEdiffセッションを開始します。*note Ediff: (ediff)Top.を
     参照してください。

‘C-c C-n’
     表示を現在のhunkに制限します(‘diff-restrict-view’)。*note
     Narrowing::を参照してください。プレフィクス引数‘C-u’を指定すると、
     複数ファイルへのpatchで、表示を現在のファイルに制限します。制限を解
     除するには、‘C-x n w’ (‘widen’)を使います。

‘C-c C-r’
     バッファー全体の比較方向を逆転します(‘diff-reverse-direction’)。

‘C-c C-s’
     ポイント位置でhunkを分割します(‘diff-split-hunk’)。これは手動で
     patchを編集するためのもので、‘diff’プログラムに‘-u’または
     ‘--unified’オプションを指定して生成された、“unified diff format(統
     一diffフォーマット)”だけで機能します。‘diff’に‘-c’または
     ‘--context’オプションを指定して生成された、“context diff format(コ
     ンテキストdiffフォーマット)”のhunkを分割するには、最初に‘C-c C-u’で
     、バッファーをunified diff formatに変換する必要があります。

‘C-c C-d’
     バッファー全体を、“context diff format”に変換します
     (‘diff-unified->context’)。プレフィクス引数を指定すると、リージョン
     のテキストだけを変換します。

‘C-c C-u’
     バッファー全体をunified diff formatに変換します
     (‘diff-context->unified’)。プレフィクス引数を指定すると、unified
     formatからcontext formatに変換します。マークがアクティブのときは、
     リージョンのテキストだけを変換します。

‘C-c C-w’
     現在のhunkをrefineするので、空白文字の変更を無視します
     (‘diff-refine-hunk’)。

‘C-x 4 A’
     それぞれのhunkについて、‘C-x 4 a’が行うようにChangeLog(*note Change
     Log::を参照してください)のエントリーを生成します
     (‘diff-add-change-log-entries-other-window’)。これは、あとで実際に
     変更の説明を記入できるように、変更ログの雛形を作ります。Diffモード
     での‘C-x 4 a’自体は、現在のhunkのファイルのためのものですが、関数名
     はpatch自体から取得します。これはpatchにより削除される関数のための
     、ログエントリーを作るのに有用です。

   patchには変更された行の行末に、無意識に入力された望んでいない空白文字
が含まれている場合があります。この問題を扱うには2つの方法があります。1つ
目はDiffバッファーでWhitespaceモード(*note Useless Whitespace::を参照し
てください)を有効にする方法で、これは自動的に変更された行の行末にある空
白文字をハイライトします。2つ目はコマンド‘M-x
diff-delete-trailing-whitespace’を使う方法で、patchにより変更された行の
行末の空白文字を検索して、patchとpatchされたソースファイルの両方からそれ
を取り除きます。このコマンドは変更を保存しないので、ユーザーが変更を保存
するか決定することができます(変更されたファイルはエコーエリアに表示され
ます)。プレフィクス引数を指定すると、patchされたファイルではなく、元のソ
ースファイルを変更しようと試みます。


File: emacs-ja.info,  Node: Misc File Ops,  Next: Compressed Files,  Prev: Diff Mode,  Up: Files

18.11 その他のファイル操作
==========================

Emacsには、ファイルを操作する他のコマンドがたくさん存在します。それらは
すべて1つのファイルを操作します。ファイル名にワイルドカードは指定できま
せん。

   ‘M-x delete-file’はファイルの入力を求め、そのファイルを削除します。
1つのディレクトリーにある、複数のファイルを削除する場合、‘delete-file’よ
りDiredを使う方が便利でしょう。*note Dired Deletion::を参照してください
。

   ‘M-x move-file-to-trash’は、ファイルをシステムの“Trash”(または
“Recycle Bin”)に移動します。この機能は、ほとんどのオペレーティングシステ
ムで利用可能です。Trashに移動されたファイルは、後で気が変わったとき元に
戻すことができます。

   デフォルトでは、Emacsの削除コマンドはTrashを_使いません_。一般的な削
除コマンドでTrash(それが利用可能な場合)を使うには、変数
‘delete-by-moving-to-trash’を‘t’に変更します。これはコマンド‘M-x
delete-file’と‘M-x delete-directory’ (*note Directories::を参照してくだ
さい)、およびDired (*note Dired Deletion::を参照してください)の削除コマ
ンドに影響を与えます。‘M-x delete-file’および‘M-x delete-directory’にプ
レフィクス引数を与えると、‘delete-by-moving-to-trash’の値にかかわらず、
Trashを使わずに完全に削除します。

   ファイルがバージョンコントロール(*note Version Control::を参照してく
ださい)の配下にある時は、‘M-x delete-file’のかわりに‘M-x
vc-delete-file’を使って、ファイルを削除します。*note VC Delete/Rename::を
参照してください。

   ‘M-x copy-file’はファイルOLDを読み込んで、新しいNEWというファイルに同
じ内容を書き込みます。

   ‘M-x copy-directory’は、シェルコマンド‘cp -r’と同じようにディレクトリ
ーをコピーします。これはディレクトリーOLDと、コピー先のNEWを読み取ります
。NEWが既存のディレクトリーのとき、このコマンドはOLDディレクトリーのコピ
ーを作成して、それをNEWの下にコピーします。NEWが既存のディレクトリーでな
いとき、このコマンドはOLDの内容を、新しいNEWという名前のディレクトリーに
すべてコピーします。

   ‘M-x rename-file’は、ミニバッファーを使って2つのファイル名OLDとNEWを
読み取り、ファイルOLDをNEWにリネームします。NEWという名前のファイルが既
に存在するとき、確認に‘yes’と応えなければリネームは行われません。これは
リネームにより、NEWという名前で参照されていた古い内容が失われるからです
。OLDとNEWが異なるファイルシステムにある場合、OLDがコピーされてから削除
されます。引数NEWがディレクトリー名の場合、実際の新しい名前はそのディレ
クトリーと、その配下の非ディレクトリーOLDになります。たとえば‘M-x
rename-file <RET> ~/foo <RET> /tmp <RET>’は、‘~/foo’を‘/tmp/foo’にリネー
ムします。このルールはこのセクションの残りのコマンドにも適用されます。新
しい名前のファイルがすでに存在する場合は、確認を求めます。

   ファイルがバージョンコントロール(*note Version Control::を参照してく
ださい)の配下にある時は、‘M-x rename-file’のかわりに‘M-x
vc-rename-file’を使ってリネームします。*note VC Delete/Rename::を参照し
てください。

   ‘M-x add-name-to-file’は、既存のファイルの古い名前を削除せずに、新し
い名前を追加します。新しい名前は、既存のファイルの“ハードリンク”として作
成されます。新しい名前は、そのファイルがあるのと同じファイルシステムにな
ければなりません。MS-Windowsでは、このコマンドはファイルがNTFSファイルシ
ステムにあるときだけ機能します。MS-DOSではファイルをコピーすることにより
機能します。

   ‘M-x make-symbolic-link’は、2つのファイル名TARGETとLINKNAMEを読み取り
、TARGETを指すLINKNAMEという名前のシンボリックリンクを作成します。これに
よりLINKNAMEといファイルを開こうとすると、その時点でTARGETという名前のフ
ァイルを開きます。その時点でTARGETという名前のファイルが存在しないときは
エラーになります。このコマンドは引数TARGETを展開しないので、リンクの対象
を相対パスで指定できます。MS-Windowsでは、このコマンドはMS Windows
Vista以降だけで機能します。

   ‘M-x insert-file’(‘C-x i’も)は、指定したファイルの内容のコピーを、現
在のポイント位置に挿入し、ポイントの位置は変更せずに挿入された内容の前に
残します。挿入した内容の後の位置はマークリングに追加され、マークは非アク
ティブになります(*note Mark Ring::を参照してください)。

   ‘M-x insert-file-literally’も‘M-x insert-file’と同様ですが、ファイル
は“literally(そのまま)”挿入されます。つまり‘M-x find-file-literally’コマ
ンド(*note Visiting::を参照してください)と同様に、特別なエンコーディング
や変換なしに、ASCII文字の並びとして扱われます。

   ‘M-x write-region’は‘M-x insert-file’の逆です。このコマンドはリージョ
ンの内容を、指定されたファイルにコピーします。‘M-x append-to-file’はリー
ジョンのテキストを、指定されたファイルの末尾に加えます。*note
Accumulating Text::を参照してください。変数
‘write-region-inhibit-fsync’の値は、これらのコマンドおよびファイルの保存
に影響を与えます。*note Customize Save::を参照してください。

   ‘M-x set-file-modes’はファイル名と、その後に“ファイルモード(file
mode)”を読み込んで、指定されたファイルにそのファイルモードを適用します。
ファイルモード(または“ファイルパーミッション(file permissions)”とも呼ば
れます)は、ファイルが読み込み可能か、書き込み可能か、実行可能か、そして
それは誰にたいしてなのかを決定します。このコマンドは、‘chmod’コマンドに
指定する形式の、シンボルまたは8進のファイルモードを読み取ります。たとえ
ば‘u+x’は、そのファイルを所有するユーザーに実行可能の権限を追加すること
を意味します。ファイルモードをサポートしないオペレーティングシステムでは
、効果はありません。‘chmod’はこの関数の便利なエイリアスです。


File: emacs-ja.info,  Node: Compressed Files,  Next: File Archives,  Prev: Misc File Ops,  Up: Files

18.12 圧縮ファイルへのアクセス
==============================

Emacsは、圧縮されたファイルをvisitするとき、自動的に解凍します。また、そ
れらのファイルを変更して保存するときも、自動的に再圧縮します。Emacsは圧
縮ファイルを名前で認識します。ファイル名が‘.gz’で終わっていれば、それは
ファイルが‘gzip’で圧縮されていることを示します。他の拡張子の場合は、他の
圧縮プログラムを示します。

   自動的な解凍と圧縮は、Emacsがファイル内容を操作するすべてに適用されま
す。これにはvisit、保存、内容のバッファーへの挿入、ロード、バイトコンパ
イルが含まれます。

   この機能を無効にするには、コマンド‘M-x auto-compression-mode’とタイプ
します。変数‘auto-compression-mode’をカスタマイズすることにより、永続的
に無効にすることができます。


File: emacs-ja.info,  Node: File Archives,  Next: Remote Files,  Prev: Compressed Files,  Up: Files

18.13 ファイルアーカイブ
========================

名前が‘.tar’で終わるファイルは通常、‘tar’プログラムで作られた“アーカイブ
”です。Emacsはそれらを、Tarモードと呼ばれる特別なモードで表示します。こ
れは内容をDiredに似たリストで提供します(*note Dired::を参照してください
)。リストの移動はDiredのときと同様で、アーカイブに含まれるファイルを
visitできます。しかしTarモードでは、Diredコマンドのすべてが利用可能では
ありません。

   Auto Compressionモードが有効な場合(*note Compressed Files::を参照して
ください)、Tarモードは圧縮アーカイブ(ファイルの拡張子が‘.tgz’、
‘.tar.Z’、‘.tar.gz’)も使うことができます。

   キー‘e’、‘f’、<RET>はすべて、ファイルをファイル自身のバッファーに展開
します。それをバッファーで編集して、バッファーを保存すると、編集されたバ
ージョンでTarバッファーのものを置き換えます。Tarバッファーでファイル名を
マウスでクリックしても、同様なことが行えます。‘v’はファイルをバッファー
にViewモードで展開します(*note View Mode::を参照してください)。‘o’は、フ
ァイルを展開して他のウィンドウで表示するので、ファイルの編集とアーカイブ
の操作を同時に行うことができます。

   Diredと同様に、‘d’は後で‘x’を使ったときにファイルを削除するためにマー
クし、‘u’はマークを外します。‘C’はファイルをアーカイブからディスクにコピ
ーし、‘R’はアーカイブのファイルをリネームします。‘g’はバッファーをディス
ク上のアーカイブでリバートします。キー‘M’、‘G’、‘O’は、ファイルのパーミ
ッションビット、グループ、所有者を変更します。

   Tarバッファーの保存により、構成要素に変更が施された、新しいバージョン
のアーカイブをディスクに書き込みます。

   Tarモードを使うのに、‘tar’プログラムは必要ありません。Emacsは直接アー
カイブを読み込みます。しかし圧縮アーカイブへのアクセスには、適切な解凍プ
ログラムが必要です。

   ‘arc’、‘jar’、‘lzh’、‘zip’、‘rar’、‘7z’、‘zoo’、および自己解凍実行形
式の‘exe’には、互いに似通った異なるArchiveモードが使われます。

   ArchiveモードのキーバインドはTarモードと同様で、それに加えてキー‘m’は
後に続く操作のためにファイルをマークし、‘M-<DEL>’はマークされたファイル
のマークをすべて外します。キー‘a’は、1行に収まらないようなアーカイブの、
詳細なファイル情報の表示を切り替えます。ファイルのリネーム、ファイルモー
ドや所有者の変更をサポートするアーカイブ書式は、いくつかに限られます。

   Tarモードとは異なり、Archiveモードはアーカイブの展開と格納に、アーカ
イブプログラムを実行します。しかし、展開したりアーカイブ内のファイルを操
作するときだけこれらのプログラムが必要で、アーカイブの目録を見るには必要
ありません。プログラム名とセットできるオプションの詳細は、カスタマイズグ
ループ‘Archive’でセットできます。


File: emacs-ja.info,  Node: Remote Files,  Next: Quoted File Names,  Prev: File Archives,  Up: Files

18.14 リモートファイル
======================

他のマシンにあるファイルを、特別なファイル名構文を使って参照できます:

     /HOST:FILENAME
     /USER@HOST:FILENAME
     /USER@HOST#PORT:FILENAME
     /METHOD:USER@HOST:FILENAME
     /METHOD:USER@HOST#PORT:FILENAME

このリクエストを発行するために、Emacsは‘ftp’、‘ssh’、‘rlogin’、
‘telnet’のような、リモートログインプログラムを使います。どの方法を使うか
は、常にファイル名で指定できます。たとえば‘/ftp:USER@HOST:FILENAME’は
FTP、‘/ssh:USER@HOST:FILENAME’は‘ssh’を使います。ファイル名でログイン方
法を指定しない場合、Emacsは以下により方法を選択します:

  1. ホスト名が‘ftp.’(ドットを含む)で始まるとき、EmacsはFTPを使います。
  2. ユーザー名が‘ftp’または‘anonymous’のとき、EmacsはFTPを使います。
  3. 変数‘tramp-default-method’が‘ftp’にセットされているとき、Emacsは
     FTPを使います。
  4. ‘ssh-agent’が実行されているとき、Emacsは‘scp’を使います。
  5. 上記以外の場合、Emacsは‘ssh’を使います。

変数‘tramp-mode’を‘nil’にセットすることにより、リモートファイル名の機能
を完全にオフにすることができます。個別のケースについて機能をオフにするに
は、ファイル名を‘/:’でクォートします(*note Quoted File Names::を参照して
ください)。

   FTPを通じたリモートファイルへのアクセスは、以下で説明するAnge-FTPパッ
ケージで処理されます。他の方法によりリモートファイルへのアクセスは
Trampパッケージにより処理され、これにはそれ自身のマニュアルがあります。
*note The Tramp Manual: (tramp)Top.を参照してください。

   Ange-FTPパッケージでは、リモートファイル名にユーザー名USERがしている
ときは、FTPを通じてその名前でログインします。USERが指定されていないとき
、Emacsはローカルシステムのユーザー名でログインします。しかし変数
‘ange-ftp-default-user’に文字列がセットされているときは、かわりにその文
字列を使用します。Emacsは、ログイン時にパスワードの入力も求めます。

   パフォーマンス的な理由により、FTPを通じたファイルのアクセス時に、デフ
ォルトではEmacsはバックアップファイルを作成しません。バックアップを作成
するには、変数‘ange-ftp-make-backup-files’を非‘nil’値に変更してください
。

   デフォルトではリモートファイルの自動保存ファイルは、変数
‘auto-save-file-name-transforms’で指定された、ローカルマシンの一時ディレ
クトリーに作成されます。*note Auto Save Files::を参照してください。

   匿名FTPでアクセスできるファイルをvisitするには、特別なユーザー名
‘anonymous’または‘ftp’を使います。これらのユーザー名にたいするパスワード
は、特別に処理されます。これは変数
‘ange-ftp-generate-anonymous-password’により制御されます。この変数の値が
文字列の場合、その文字列がパスワードとして使用されます。非‘nil’(デフォル
ト)の場合、‘user-mail-address’の値が使用されます。‘nil’の場合、Emacsは通
常どおりパスワードの入力を求めます(*note Passwords::を参照してください
)。

   セキュリティー上の理由で、リモートマシンとの間にある“ファイアーウォー
ル(firewall)”により、ファイルにアクセスできないときがあります。対象ファ
イルにアクセスできるマシンから“ゲートウェイ(gateway)”マシンにログインで
きて、FTPサーバーがゲートウェイ機能をサポートしている場合は、リモートフ
ァイル名を使うことができます。これを行うには変数
‘ange-ftp-gateway-host’にゲートウェイマシンの名前をセットして、
‘ange-ftp-smart-gateway’を‘t’にセットする必要があります。それ以外の場合
でもリモートファイル名が機能するようにできますが、その方法は複雑です。こ
れらの方法は、‘M-x finder-commentary <RET> ange-ftp <RET>’とタイプして読
むことができます。


File: emacs-ja.info,  Node: Quoted File Names,  Next: File Name Cache,  Prev: Remote Files,  Up: Files

18.15 ファイル名のクォート
==========================

特殊な文字や構文を含むファイルにたいする特別な効果を防ぐために、絶対ファ
イル名を“クォート”できます。これを行うには先頭に‘/:’を追加します。

   たとえばリモートにあるように見える名前の、ローカルなファイルの名前を
クォートすることにより、リモートファイル名として扱われないようにすること
ができます。したがって名前が‘/foo:’というディレクトリーがあり、そこに
‘bar’という名前のファイルがある場合、Emacsでは、そのファイルを
‘/:/foo:/bar’という名前で参照できます。

   ‘/:’は、‘~’がユーザーのホームディレクトリーを意味する、特別な文字とし
て扱われることを防ぐこともできます。たとえば‘/:/tmp/~hack’は、ディレクト
リー‘/tmp’のファイル‘~hack’を参照します。

   ‘/:’によるクォートは、ミニバッファーでの名前に‘$’を含むファイル名の入
力にも使用できます。これが機能するには、ミニバッファーの最初の内容が
‘/:’で始まらなければなりません(2回‘$’を記述することでも同様な効果が得ら
れます。詳細は*note File Names with $::を参照してください)。

   ファイルをvisitするときに、ワイルドカードをクォートすることもできます
。たとえば‘/:/tmp/foo*bar’は、ファイル‘/tmp/foo*bar’をvisitします。

   同じ効果を得るための別の方法は、‘/tmp/foo[*]bar’と入力する方法です。
これは‘/tmp/foo*bar’だけにマッチするワイルドカード指定です。しかしクォー
トしなくても同じ結果が得られるので、ワイルドカード文字をクォートする必要
がない場合がたくさんあります。たとえば‘/tmp’の中に‘foo’で始まり‘bar’で終
わるファイルが‘foo*bar’だけの場合、‘/tmp/foo*bar’と指定することにより、
‘/tmp/foo*bar’だけをvisitすることができます。


File: emacs-ja.info,  Node: File Name Cache,  Next: File Conveniences,  Prev: Quoted File Names,  Up: Files

18.16 ファイル名キャッシュ
==========================

“ファイル名キャッシュ(file name cache)”により、ファイルがどこにあるか正
確に覚えていなくても、名前でファイルがどこにあるかを簡単に指定することが
できます。ファイル名をミニバッファーでタイプするとき、‘C-<TAB>’
(‘file-cache-minibuffer-complete’)で、ファイル名キャッシュを使ったファイ
ル名を補完が行なわれます。‘C-<TAB>’を繰り返すと、最初にタイプした内容か
ら補完できる利用可能な候補を順番に表示します(しかし‘C-<TAB>’文字は、多く
のテキスト端末でタイプできないことに注意してください)。

   ファイル名キャッシュは自動的に充填されません。かわりに以下のコマンド
を使ってファイル名をキャッシュにロードします。

‘M-x file-cache-add-directory <RET> DIRECTORY <RET>’
     DIRECTORYの各ファイルを、ファイル名キャッシュに加えます。
‘M-x file-cache-add-directory-using-find <RET> DIRECTORY <RET>’
     DIRECTORYの各ファイルを、ファイル名キャッシュに加えるとともに、ネス
     トされたサブディレクトリーのすべてのファイルを、ファイル名キャッシ
     ュに加えます。
‘M-x file-cache-add-directory-using-locate <RET> DIRECTORY <RET>’
     DIRECTORYの各ファイルを、ファイル名キャッシュに加えるとともに、ネス
     トされたサブディレクトリーのすべてのファイルを、ファイル名キャッシ
     ュに加えます。ファイルの検索には、‘locate’を使用します。
‘M-x file-cache-add-directory-list <RET> VARIABLE <RET>’
     VARIABLEにリストされた各ディレクトリーのファイル名を、ファイル名キ
     ャッシュに加えます。VARIABLEはLisp変数で、‘load-path’と同様、値はデ
     ィレクトリー名のリストです。
‘M-x file-cache-clear-cache <RET>’
     キャッシュをクリアーして、すべてのファイル名を削除します。

   ファイル名キャッシュは永続的ではありません。キャッシュが維持されるの
はEmacsのセッションの間だけです。キャッシュの内容は、
‘file-cache-display’コマンドで閲覧できます。


File: emacs-ja.info,  Node: File Conveniences,  Next: Filesets,  Prev: File Name Cache,  Up: Files

18.17 ファイル検索の便利な機能
==============================

このセクションでは、最近開いたファイルの検索、バッファーからのファイル名
の読み取り、イメージファイルの閲覧などの、便利な機能を紹介します。

   ‘M-x recentf-mode’でRecentfモードを有効にすると、‘File’メニューに最近
開いたファイルを含むサブメニューが含まれるようになります。‘M-x
recentf-save-list’は現在の‘recent-file-list’をファイルに保存し、‘M-x
recentf-edit-list’でそれを編集できます。

   ‘M-x ffap’コマンドは、‘find-file’を一般化した、より強力なデフォルト決
定のための機能で、基本的にはポイント位置のテキストにもとづいて決定を行な
います。Partial Completionモードは‘find-file’を拡張する、‘ffap’とともに
使用できるその他の機能を提案します。*note Completion Options::を参照して
ください。

   イメージファイルをvisitすることにより、Imageモードが選択されます。こ
のメジャーモードでは、‘C-c C-c’ (‘image-toggle-display’)とタイプすること
により、Emacsバッファーでファイルのイメージ表示と、イメージの元となるテ
キスト(またはraw byte)表示を切り替えることができます。ファイルのイメージ
表示は、Emacsがそのようなイメージの表示をサポートするようにコンパイルさ
れているときだけ機能します。イメージがフレームの高さまたは幅より大きい場
合、通常のポイント移動キー(‘C-f’、‘C-p’、...)は、イメージの他の部分の表
示に使われます。‘n’ (‘image-next-file’)および‘p’
(‘image-previous-file’)を押すことにより、同じディレクトリーにある次また
は前のイメージをvisitします。

   アニメーションが可能なイメージの場合、コマンド<RET>
(‘image-toggle-animation’)で、アニメーションの開始と停止ができます。オプ
ション‘image-animate-loop’が非‘nil’でなければ、アニメーションの再生は1回
です。‘f’ (‘image-next-frame’)と‘b’ (‘image-previous-frame’)により、アニ
メーションの各フレームを切り替えることができます。これらのコマンドは数引
数を指定することにより、指定した数の分だけ先のフレームを表示できます。
‘F’ (‘image-goto-frame’)により、特定のフレームを指定することができます。
‘a +’ (‘image-increase-speed’)とタイプすると、アニメーションのスピードが
早くなり、‘a -’ (‘image-decrease-speed’)で遅くなります。また‘a r’
(‘image-reverse-speed’)で逆再生されます。コマンド‘a 0’
(‘image-reset-speed’)は、スピードを元の値にリセットします。

   EmacsがImageMagickのサポートつきでコンパイルされている場合、さまざま
なイメージを描画するのに、ImageMagickを使うことができます。変数
‘imagemagick-enabled-types’は、EmacsがImageMagickを使って描画できるイメ
ージの種類のリストです。リストの各要素は、ImageMagick内部でのイメージ種
類にたいする名前で、シンボルまたは等価な文字列で指定します(たとえば
‘BMP’は‘.bmp’イメージです)。利用可能なイメージの種類にたいして
ImageMagickを有効にするには、‘imagemagick-enabled-types’を‘t’に変更しま
す。変数‘imagemagick-types-inhibit’は、変数‘imagemagick-enabled-types’の
値にかかわらずmImageMagickを使わずに描画するイメージ種類のリストです(リ
ストのデフォルトには‘C’および‘HTML’などが含まれ、これらはImageMagickは
“イメージ”として描画できるが、Emacsはイメージとして描画しないものです)。
ImageMagickを完全に無効にするには、‘imagemagick-types-inhibit’を‘t’に変
更してください。

   Image-Diredパッケージはイメージをサムネールとして表示するのにも使用さ
れます。*note Image-Dired::を参照してください。


File: emacs-ja.info,  Node: Filesets,  Prev: File Conveniences,  Up: Files

18.18 ファイルセット
====================

定期的に特定のファイルのグループを編集する場合、それらを“ファイルセット
(fileset)”として定義できます。これによりvisit、‘query-replace’、シェルコ
マンドなどの特別な操作を、すべてのファイルに一度に行うことができます。フ
ァイルセットを使うには、initファイル(*note Init File::を参照してください
)に、式‘(filesets-init)’を追加しなければなりません。これはメニューバーに
‘Filesets’メニューを追加します。

   ファイルセットを定義する一番簡単な方法は、ファイルを1つずつ追加する方
法です。ファイルセットNAMEにファイルを追加するには、そのファイルを
visitして‘M-x filesets-add-buffer <RET> NAME <RET>’をタイプします。ファ
イルセットNAMEが存在しない場合、現在のファイルだけを含む新しいファイルセ
ットを作成します。コマンド‘M-x filesets-remove-buffer’は、ファイルセット
から現在のファイルを削除します。

   ‘M-x filesets-edit’(または‘Filesets’メニューの‘Edit Filesets’を選択
)で、ファイルセットを直接編集することもできます。編集はCustomizeバッファ
ーで行われます(*note Easy Customization::を参照してください)。ファイルセ
ットは通常、単純なファイルのリストですが、ファイル名にマッチする正規表現
で、ファイルセットを定義することもできます。より複雑なファイルセットの例
は、Customizeバッファーに記されています。将来のEmacsセッションで同じファ
イルセットを使うには、‘Save for future sessions’を選択するのを忘れないで
ください。

   コマンド‘M-x filesets-open’を使って、ファイルセットのすべてのファイル
をvisitし、それらを‘M-x filesets-close’で閉じることができます。‘M-x
filesets-run-cmd’を使って、ファイルセットのすべてのファイルにたいして、
シェルコマンドを実行します。これらのコマンドは‘Filesets’メニューからも利
用可能で、メニューには既存のファイルセットが、サブメニューとして表示され
ています。

   異なるコンセプトの“ファイルセット(バージョンコントロール操作のために
グループにまとめられたファイル)”については、*note Version Control::を参
照してください。この種のファイルセットには名前がなく、Emacsセッション間
で引き継がれません。


File: emacs-ja.info,  Node: Buffers,  Next: Windows,  Prev: Files,  Up: Top

19 複数バッファーの使用
***********************

Emacsで編集するテキストは、“バッファー(buffer)”と呼ばれるオブジェクトの
中に存在します。ファイルをvisitするたびに、そのファイルのテキストを保持
するために、バッファーが使われます。Diredを呼び出すたびに、ディレクトリ
ーリストを保持するためにバッファーが使われます。‘C-x m’でメッセージを送
信すると、メッセージのテキストを保持するためにバッファーが使われます。コ
マンドのドキュメントは、‘*Help*’という名前のバッファーに表示されます。

   それぞれのバッファーは、任意の長さの一意な名前を持っています。バッフ
ァーがウインドウに表示されているとき、バッファーの名前はモードライン
(*note Mode Line::を参照してください)に表示されます。バッファー名での大
文字と小文字の違いは重要です。ほとんどの場合、ほとんどのバッファーは
visitしているファイルから作られ、それらの名前はファイル名から生成されま
す。しかし、新しい空のバッファーを、任意の名前で作成することもできます。
新しく開始されたEmacsにはいくつかのバッファーがあり、それらの中には
‘*scratch*’という名前の、Lisp式を評価するのに使用されるバッファーも含ま
れます。そのバッファーはファイルに関連付けられていません(*note Lisp
Interaction::を参照してください)。

   “選択”されるバッファーは、常に1つだけです。そのバッファーを“カレント
バッファー(current buffer: 現在のバッファー)”と呼びます。「コマンドは“そ
のバッファー(the buffer)”を操作します」という言い方をするときがあります
。これはカレントバッファーを操作するというのが、本当の意味です。Emacsの
ウィンドウが1つだけのとき、そのウィンドウに表示されているバッファーがカ
レントになります。複数のウィンドウがあるとき、“選択されたウィンドウ”に表
示されているバッファーがカレントになります。*note Windows::を参照してく
ださい。

   バッファーのテキスト的な内容は別として、それぞれのバッファーはいくつ
かの情報を記録しています。それらは、(もしあれば)visitしているファイルは
何か、変更されているか、有効なメジャーモードとマイナーモードは何か(*note
Modes::を参照してください)、などの情報です。これらは、“バッファーローカ
ルな変数(buffer-local variables)”に格納され、これらの変数はバッファーご
とに異なる値をもつことができます。*note Locals::を参照してください。

   バッファーのサイズは、いくつかの最大値を超えて大きくすることはできま
せん。これは一番大きいバッファーの位置が、“Emacsの整数(Emacs integers)”で
表されることにより定義されます。なぜならEmacsはそのデータ型を使用して、
バッファーの位置を追跡するからです。通常の64ビットマシンでは、バッファー
の最大サイズは2^{61} - 2バイト、およそ2EiBです。通常の32ビットマシンでは
、バッファーの最大サイズは通常2^{29} - 2バイト、およそ512MiBです。バッフ
ァーのサイズはシステムのメモリー量によっても制限されます。

* Menu:

* Select Buffer::            新しいバッファーの作成と既存のバッファーの再選択。
* List Buffers::             既存のバッファーリストの取得。
* Misc Buffer::              リネーム、読み取り専用属性の変更、テキストのコピー。
* Kill Buffer::              不必要なバッファーのkill。
* Several Buffers::          すべてのバッファーにたいするリストの操作と、複数バッファーにたいする操作。
* Indirect Buffers::         他のバッファーのテキストを共有するインダイレクトバッファー。
* Buffer Convenience::       バッファー操作のための便利な機能とカスタマイズ。


File: emacs-ja.info,  Node: Select Buffer,  Next: List Buffers,  Up: Buffers

19.1 バッファーの作成と選択
===========================

‘C-x b BUFFER <RET>’
     BUFFERという名前のバッファーを、選択または作成します
     (‘switch-to-buffer’)。
‘C-x 4 b BUFFER <RET>’
     同様ですが、他のウィンドウでBUFFERを選択します
     (‘switch-to-buffer-other-window’)。
‘C-x 5 b BUFFER <RET>’
     同様ですが、別のフレームでBUFFERを選択します
     (‘switch-to-buffer-other-frame’)。
‘C-x <LEFT>’
     バッファーリストの、前のバッファーを選択します(‘previous-buffer’)。
‘C-x <RIGHT>’
     バッファーリストの、次のバッファーを選択します(‘next-buffer’)。
‘C-u M-g M-g’
‘C-u M-g g’
     数字Nを読み取って、カレントバッファーではない、一番最近選択されたバ
     ッファーの、N行目に移動します。

   ‘C-x b’ (‘switch-to-buffer’)コマンドは、ミニバッファーを使ってバッフ
ァー名を読み取ります。それからそのバッファーをカレントとして、現在選択さ
れたウィンドウに表示します。空の入力は、そのとき他のウィンドウに表示され
ていない、一番最近カレントだったバッファーを指定します。

   バッファー名を入力するとき、通常の補完とヒストリーコマンドを使うこと
ができます(*note Minibuffer::を参照してください)。‘C-x b’および関連する
コマンドは、ミニバッファーの補完に、“確認つきの寛大な補完(permissive
completion with confirmation)”を使うことに注意してください。存在しないバ
ッファー名にたいする補完の後、すぐに<RET>をタイプすると、Emacsは
‘[Confirm]’を出力し、バッファー名を確定するために2回目の<RET>をタイプし
なければなりません。詳細は、*note Completion Exit::を参照してください。

   存在しないバッファーを指定すると、‘C-x b’はファイルをvisitしていない
新しい空のバッファーを作成し、編集用にそのバッファーを選択します。変数
‘major-mode’は、新しいバッファーのメジャーモードのデフォルトを決定します
。デフォルトでは、これはFundamentalモードです。*note Major Modes::を参照
してください。新しいバッファーを作る1つの理由は、それを一時的なノートと
して使うためです。これを保存しようと試みると、Emacsは保存に使うファイル
名を尋ね、バッファーのメジャーモードは、ファイル名にもとづきメジャーモー
ドを再割り当てします(*note Choosing Modes::を参照してください)。

   少ないバッファーの切り替えでは、コマンド‘C-x <LEFT>’および‘C-x
<RIGHT>’を使うのが便利です。‘C-x <LEFT>’ (‘previous-buffer’)は前のバッフ
ァー(現在のフレームの一番最近選択されたバッファー順)、‘C-x <RIGHT>’
(‘next-buffer’)は逆方向のバッファーに移動します。

   現在のウィンドウとは別のウィンドウにバッファーを選択するには、‘C-x 4
b’ (‘switch-to-buffer-other-window’)とタイプします。これはミニバッファー
を使ってバッファー名の入力を求め、選択されているウィンドウではない別のウ
ィンドウに、そのバッファーを表示します。

   同様に‘C-x 5 b’ (‘switch-to-buffer-other-frame’)はバッファー名の入力
を求め、他のフレームにそのバッファーを表示して、そのフレームを選択します
。他のウィンドウまたはフレームにすでにバッファーが表示されている場合、
Emacsは新しく作成するのではなく、そのウィンドウまたはフレームを選択しま
す。

   ‘C-x 4 b’および‘C-x 5 b’コマンドが表示するウィンドウまたはフレームを
取得する方法については、*note Displaying Buffers::を参照してください。

   これらに加えて、‘C-x C-f’や、その他のファイルをvisitするコマンドでも
、すでにファイルをvisitしているバッファーに切り替えることができます。
*note Visiting::を参照してください。

   プレフィクス引数だけを指定した‘C-u M-g M-g’ ‘goto-line’は、ミニバッフ
ァーを使って数字Nを読み取り、別のウィンドウにあるカレントバッファー以外
の、一番最近選択されたバッファーを選択して、ポイントをそのバッファーの
N行目の先頭に移動します。これは他のバッファーの行番号を参照するバッファ
ーで特に有用です。ポイントが数字の直後にある場合、‘goto-line’はNのデフォ
ルトとしてその数字を使います。ただの‘C-u’ではないプレフィクス引数では、
異なる振る舞いをすることに注意してください。‘C-u 4 M-g M-g’はミニバッフ
ァーから数字を読み取らず、_カレントバッファー_の4行目にジャンプします(プ
レフィクス引数を指定しない‘M-g M-g’は、数字Nを読み取ってカレントバッファ
ーのN行目に移動することを思い出してください。*note Moving Point::を参照
してください)。

   Emacsはスペースで開始される名前のバッファーを、内部的な用途のために使
用しています。それらのバッファーは特別な方法で扱われます。たとえば、それ
らのバッファーではundo情報が記録されません。そのようなバッファー名を使う
ことは避けるのが最良です。


File: emacs-ja.info,  Node: List Buffers,  Next: Misc Buffer,  Prev: Select Buffer,  Up: Buffers

19.2 既存のバッファーを一覧する
===============================

‘C-x C-b’
     既存のバッファーをリストします(‘list-buffers’)。

   既存のバッファーのリストを表示するには、‘C-x C-b’とタイプします。リス
トの各行にはバッファー名、サイズ、メジャーモード、visitしているファイル
が表示されます。バッファーは、カレントだった順でリストされます。したがっ
て、一番最近カレントだったバッファーが先頭に表示されます。

   行の最初のフィールドの‘.’は、そのバッファーがカレントであることを示し
ます。‘%’は読み取り専用バッファーであることを示します。‘*’はそのバッファ
ーが“変更”されていることを示します。いくつかのバッファーが変更されていて
、それらを保存するべきだと思ったときは、‘C-x s’ (*note Save Commands::を
参照してください)で保存します。以下はバッファーリストの例です:

     CRM Buffer                Size  Mode              File
     . * .emacs                3294  Emacs-Lisp        ~/.emacs
      %  *Help*                 101  Help
         search.c             86055  C                 ~/cvs/emacs/src/search.c
      %  src                  20959  Dired by name     ~/cvs/emacs/src/
       * *mail*                  42  Mail
      %  HELLO                 1607  Fundamental       ~/cvs/emacs/etc/HELLO
      %  NEWS                481184  Outline           ~/cvs/emacs/etc/NEWS
         *scratch*              191  Lisp Interaction
       * *Messages*            1554  Messages

この例でバッファー‘*Help*’は、ヘルプを要求されたことにより作成されます
(*note Help::を参照してください)。これはファイルをvisitしていません。バ
ッファー‘src’は、ディレクトリー‘~/cvs/emacs/src/’にたいして、Diredが作成
したバッファーです。ファイルをvisitしているバッファーだけを一覧するには
、‘C-u C-x C-b’のように、コマンドにプレフィクス引数を与えます。

   ‘list-buffers’は名前がスペースで始まるバッファーを省略します(そのバッ
ファーがファイルをvisitしていない限り)。これらのバッファーは、Emacsによ
り内部的に使用されます。


File: emacs-ja.info,  Node: Misc Buffer,  Next: Kill Buffer,  Prev: List Buffers,  Up: Buffers

19.3 その他のバッファー操作
===========================

‘C-x C-q’
     バッファーの読み取り専用の状態を切り替えます(‘read-only-mode’)。
‘M-x rename-buffer <RET> NAME <RET>’
     カレントバッファーの名前を変更します。
‘M-x rename-uniquely’
     カレントバッファーの末尾に‘<NUMBER>’を加えてリネームします。
‘M-x view-buffer <RET> BUFFER <RET>’
     バッファーBUFFERをスクロールして閲覧します。*note View Mode::を参照
     してください。

   バッファーを読み取り専用にすることができます、これは内容を変更するコ
マンドが許されないことを意味します。読み取り専用バッファーのモードライン
では、左余白の近くに‘%%’または‘%*’が表示されます。読み取り専用バッファー
は通常DiredやRmailのように、そのバッファーのテキストを操作する専用コマン
ドをもつ、サブシステムにより作成されます。アクセスコントロールにより制御
されているファイルをvisitしたときも、書き込めない旨が通知されます。

   コマンド‘C-x C-q’ (‘read-only-mode’)は、読み取り専用バッファーを書き
込み可能に、書き込み可能なバッファーを読み取り専用にします。これは各バッ
ファーにローカルな変数‘buffer-read-only’をセットすることにより機能します
(値が非‘nil’のときバッファーは読み取り専用)。オプション
‘view-read-only’を非‘nil’値に変更すると、‘C-x C-q’でバッファーを読み取り
専用にしたとき、そのバッファーでViewモードが有効になります(*note View
Mode::を参照してください)。

   ‘M-x rename-buffer’は、カレントバッファーの名前をリネームします。新し
い名前はミニバッファーで指定します。デフォルトはありません。他のバッファ
ーで使用済の名前を指定するとエラーとなり、リネームされません。

   ‘M-x rename-uniquely’は、カレントバッファーの後ろに数字を追加して、似
てはいるが異なる名前を作成します。このコマンドに引数は必要ありません。こ
れは複数のshellバッファーを作成するのに便利です。‘*shell*’バッファーをリ
ネームしてから、再度‘M-x shell’を行うと、これは新しく‘*shell*’という名前
のバッファーを作成します。一方リネームされた古いshellバッファーは、新し
い名前で実行を続けます。この方法はmailバッファー、compilationバッファー
、そして特定の名前で特別なバッファーを作成するEmacs機能に適しています(こ
れらの機能のいくつか、たとえば‘M-x compile’、‘M-x grep’などでは、コマン
ドを再度実行する前に他のバッファーに切り替える必要があります。さもないと
カレントバッファーの名前を変更せずに、そのバッファーを再使用します)。

   コマンド‘M-x append-to-buffer’および‘M-x insert-buffer’も、あるバッフ
ァーから他のバッファーへテキストをコピーするのに使用できます。*note
Accumulating Text::を参照してください。


File: emacs-ja.info,  Node: Kill Buffer,  Next: Several Buffers,  Prev: Misc Buffer,  Up: Buffers

19.4 バッファーのkill
=====================

しばらくの間、Emacsセッションを続けていると、多くのバッファーが溜まって
しまう場合があります。必要のないバッファーを“kill”したほうがよいと思うか
もしれません(他のエディターではこの操作を“close(閉じる)”と呼び、“バッフ
ァーを閉じる”とか、ファイルをvisitしているバッファーでは“ファイルを閉じ
る”のように表現するものもあります)。ほとんどのオペレーティングシステムで
は、バッファーをkillすることにより、そのスペースをオペレーティングシステ
ムに返却するので、他のプログラムがそれを使えるようになります。以下はバッ
ファーをkillするコマンドです:

‘C-x k BUFNAME <RET>’
     バッファーBUFNAMEをkillします(‘kill-buffer’)。
‘M-x kill-some-buffers’
     バッファーを1つずつkillするか尋ねます。
‘M-x kill-matching-buffers’
     正規表現にマッチするすべてのバッファーをkillするか尋ねます。

   ‘C-x k’ (‘kill-buffer’)は、ミニバッファーで指定した名前のバッファーを
1つkillします。<RET>だけをタイプしたときはデフォルトが使われ、これはカレ
ントバッファーをkillします。カレントバッファーをkillすると、最近カレント
だったが、今は別のウィンドウにも表示されていないバッファーがカレントにな
ります。ファイルをvisitしているバッファーが変更されているとき、それを
killしようとすると確認を求められます。そのバッファーをkillする前に、確認
に‘yes’を応えなければkillできません。

   コマンド‘M-x kill-some-buffers’は、各バッファーについて1つずつ確認を
求めます。‘y’と応えると、‘kill-buffer’と同様にバッファーをkillすることを
意味します。このコマンドは名前がスペースで始まる、Emacsが内部的に使用す
るバッファーは無視します。

   コマンド‘M-x kill-matching-buffers’は、正規表現の入力を求め、名前がそ
の正規表現にマッチするすべてのバッファーをkillします。*Note Regexps::を
参照してください。‘kill-some-buffers’と同様、このコマンドはkillする前に
確認を求めます。このコマンドは通常、名前がスペースで始まる、Emacsが内部
的に使うバッファーを無視します。内部的なバッファーも同じようにkillするに
は、プレフィクス引数を指定して‘kill-matching-buffers’を呼び出します。

   さまざまなバッファーをkillするにはBuffer Menu機能も便利です。*note
Several Buffers::を参照してください。

   バッファーがkillされるときに特別な処理を行いたい場合、フック
‘kill-buffer-hook’にフック関数を追加できます(*note Hooks::を参照してくだ
さい)。

   (多くの人がそうしているように)何日間も1つのEmacsセッションを使ってい
ると、何日か前に使ったバッファーが溜まってくるかもしれません。コマンド
‘M-x clean-buffer-list’は、それらを一掃するのに便利です。これは長い間使
用されていない、変更されていないバッファーをすべてkillします。3日間表示
されていない普通のバッファーはkillされます。しかし自動的にkillされるべき
ではない特定のバッファーを指定したり、使われていない時間が短いバッファー
でもkillするように指定できます。

   Midnightモードを有効にすることにより、1日ごとにバッファーを一掃するこ
ともできます。Midnightモードは毎日真夜中に‘clean-buffer-list’、またはノ
ーマルフック‘midnight-hook’に指定された関数を実行します(*note Hooks::を
参照してください)。Midnightモードを有効にするには、Customizationバッファ
ーを使って変数‘midnight-mode’を‘t’にセットします。*note Easy
Customization::を参照してください。


File: emacs-ja.info,  Node: Several Buffers,  Next: Indirect Buffers,  Prev: Kill Buffer,  Up: Buffers

19.5 複数バッファーにたいする操作
=================================

‘M-x buffer-menu’
     すべてのEmacsバッファーの、バッファーリストの編集を開始します。
‘M-x buffer-menu-other-window.’
     同様ですが、別のウィンドウで行います。

   ‘C-x C-b’ (*note List Buffers::を参照してください)でオープンされる
“Buffer Menu”は、単にバッファーを一覧するだけではありません。これは
Diredに似たインターフェースで、バッファーにたいしてさまざまな操作を行う
ことができます。ここでは、バッファーの保存、kill(Diredとの一貫性を保つた
め、ここではそれらを“削除(delete)”する、と呼びます)、表示ができます。

   Buffer Menuを使うには‘C-x C-b’とタイプして、‘*Buffer List*’バッファー
が表示されたウィンドウに切り替えます。‘M-x buffer-menu’とタイプして、選
択されたウィンドウにBuffer Menuを開くこともできます。コマンド‘M-x
buffer-menu-other-window’は、Buffer Menuを別のウィンドウに開いて、そのウ
ィンドウを選択します。

   Buffer Menuは読み取り専用バッファーで、このセクションで説明する特別な
コマンドだけを通じて変更します。このバッファーでは、通常のカーソル移動コ
マンドを使うことができます。以下のコマンドは、バッファーのカレント行に適
用されます。

‘d’
     そのバッファーの削除(kill)フラグをセットしてから、ポイントを次の行
     に移動します(‘Buffer-menu-delete’)。削除フラグは、各行のバッファー
     名の前の文字‘D’により示されます。削除は‘x’コマンド(以下参照)をタイ
     プしたときだけ発生します。

‘C-d’
     ‘d’と同様ですが、ポイントを下ではなく上に移動します
     (‘Buffer-menu-delete-backwards’)。

‘s’
     そのバッファーの保存フラグをセットします(‘Buffer-menu-save’)。保存
     フラグは各行のバッファー名の前の文字‘S’により示されます。保存は
     ‘x’コマンド(以下参照)をタイプしたときだけ発生します。同じバッファー
     に保存と削除の両方をリクエストできます。

‘x’
     すべての削除および保存フラグを処理します(‘Buffer-menu-execute’)。

‘u’
     カレント行のすべてのフラグを取り除いてから、下に移動します
     (‘Buffer-menu-unmark’)。

‘<DEL>’
     前の行に移動して、その行のすべてのフラグを取り除きます
     (‘Buffer-menu-backup-unmark’)。

フラグを追加または取り除くコマンド‘d’、‘C-d’、‘s’、‘u’には、すべて繰り返
し回数として数引数を指定できます。

   以下のコマンドは、カレント行にリストされたバッファーを即座に処理しま
す。これらのコマンドにも、繰り返し回数を数引数として指定できます。

‘~’
     バッファーを変更されていない(unmodified)とマークします
     (‘Buffer-menu-not-modified’)。*note Save Commands::を参照してくださ
     い。

‘%’
     バッファーの読み取り専用属性を切り替えます
     (‘Buffer-menu-toggle-read-only’)。*note Misc Buffer::を参照してくだ
     さい。

‘t’
     そのバッファーを、tagsテーブルとしてvisitします
     (‘Buffer-menu-visit-tags-table’)。*note Select Tags Table::を参照し
     てください。

   以下は、他のバッファーを選択するために使われるコマンドです:

‘q’
     Buffer Menuメニューを閉じます(‘quit-window’)。一番最近に表示されて
     いたバッファーが、その場所に表示されます。

‘<RET>’
‘f’
     そのウィンドウの‘*Buffer List*’バッファーを置き換えて。この行のバッ
     ファーを選択します(‘Buffer-menu-this-window’)。

‘o’
     ‘C-x 4 b’のように‘*Buffer List*’を表示したまま、その行のバッファー
     を他のウィンドウで選択します(‘Buffer-menu-other-window’)。

‘C-o’
     この行のバッファーを他のウィンドウで表示しますが、選択はしません
     (‘Buffer-menu-switch-other-window’)。

‘1’
     この行のバッファーを、フレーム全体のウィンドウで選択します
     (‘Buffer-menu-1-window’)。

‘2’
     現在のフレームを2つのウィンドウにセットアップして、この行のバッファ
     ーを一方のウィンドウで選択し、もう一方のウィンドウに以前のカレント
     バッファー(‘*Buffer List*’)は除く)を表示します
     (‘Buffer-menu-2-window’)。

‘b’
     この行のバッファーを、リストの最後に移動します
     (‘Buffer-menu-bury’)。

‘m’
     ‘v’コマンドで抜けるとき、この行のバッファーを他のウィンドウで表示さ
     れるようにマークします(‘Buffer-menu-mark’)。表示フラグは行の先頭に
     文字‘>’で示されます(1つのバッファーが削除と表示のフラグを両方もつこ
     とはないでしょう)。

‘v’
     この行のバッファーを選択し、‘m’コマンドでフラグづけされたバッファー
     も他のウィンドウで表示します(‘Buffer-menu-select’)。バッファーにフ
     ラグをつけていないとき、このコマンドは‘1’と等価です。

   以下はバッファーリスト全体に影響を与えるコマンドです:

‘S’
     ポイントがある列の数値にしたがって、Buffer Menu全体をソートします。
     数引数Nを指定すると、N番目の列でソートします
     (‘tabulated-list-sort’)。

‘T’
     非ファイルバッファーを削除または再挿入します
     ‘Buffer-menu-toggle-files-only’)。このコマンドは、そのようなバッフ
     ァーがバッファーリストに含まれるか否かを切り替えます。

   バッファー‘*Buffer List*’は通常、バッファーの作成およびkillにより自動
的に更新はされません(内容は単なるテキストです)。バッファーを作成・削除・
リネームした場合、それが行われたか確かめるために‘*Buffer List*’を更新す
るには、‘g’ (‘revert-buffer’)とタイプします。このバッファーのAuto
Revertモードを有効にすれば、このバッファーが変更されたとマークされない限
り、‘auto-revert-interval’秒ごとに定期的に更新させることができます。
Global Auto Revertモードは、‘global-auto-revert-non-file-buffers’が非
‘nil’のときだけ、‘*Buffer List*’バッファーに適用されます。 詳細は、*note
global-auto-revert-non-file-buffers: Autorevert.を参照してください。


File: emacs-ja.info,  Node: Indirect Buffers,  Next: Buffer Convenience,  Prev: Several Buffers,  Up: Buffers

19.6 インダイレクトバッファー
=============================

“インダイレクトバッファー(indirect buffer: 間接バッファー)”は、そのイン
ダイレクトバッファーの“ベースバッファー(base buffer: 基底バッファー)”と
呼ばれる、他のバッファーのテキストを共有します。ある点においては、ファイ
ルに置けるシンボリックリンクの、バッファー版に例えることができます。

‘M-x make-indirect-buffer <RET> BASE-BUFFER <RET> INDIRECT-NAME <RET>’
     ベースバッファーBASE-BUFFERの、インダイレクトバッファー
     INDIRECT-NAMEを作成します。
‘M-x clone-indirect-buffer <RET>’
     カレントバッファーの、インダイレクトバッファーを作成します。
‘C-x 4 c’
     カレントバッファーのインダイレクトバッファーを作成して、それを別の
     ウィンドウで選択します(‘clone-indirect-buffer-other-window’)。

   インダイレクトバッファーのテキストは、常にベースバッファーのテキスト
と等しく、どちらかを編集すると、その変更はすぐにもう一方から見えるように
なります。しかし他の観点では、インダイレクトバッファーとベースバッファー
は、完全に分離されています。これらのバッファーは異なる名前、異なるポイン
ト値、異なるナローイング、異なるマーカー、異なるメジャーモード、異なるロ
ーカル変数をもつことができます。

   インダイレクトバッファーはファイルをvisitできませんが、ベースバッファ
ーはvisitできます。インダイレクトバッファーの保存を試みると、それは実際
にはベースバッファーの保存として機能します。ベースバッファーをkillすると
インダイレクトバッファーもkillされますが、インダイレクトバッファーの
killは、ベースバッファーに影響を与えません。

   インダイレクトバッファーの1つの使い方としては、アウトラインの複数の視
点からの表示です。*note Outline Views::を参照してください。

   手早くインダイレクトバッファーを作成するには、コマンド‘M-x
clone-indirect-buffer’を使う方法があります。これはカレントバッファーをベ
ースバッファーとする、インダイレクトバッファーを作成して選択します。数引
数を指定すると、インダイレクトバッファーの名前の入力を求めます。指定しな
い場合、カレントバッファー名の後ろに‘<N>’を付加した名前を使います。‘C-x
4 c’ (‘clone-indirect-buffer-other-window’)は、‘M-x
clone-indirect-buffer’と同様に機能しますが、新しいバッファーを他のウィン
ドウで選択します。これらの関数はインダイレクトバッファーを作成した後、フ
ック‘clone-indirect-buffer-hook’を実行します。

   インダイレクトバッファーを作成する、より一般的な方法はコマンド‘M-x
make-indirect-buffer’です。これはバッファーBASE-BUFFERから、名前が
INDIRECT-NAMEのインダイレクトバッファーを作成します。これらの名前は、ミ
ニバッファーを使って入力が求められます。


File: emacs-ja.info,  Node: Buffer Convenience,  Prev: Indirect Buffers,  Up: Buffers

19.7 バッファー処理の便利な機能とカスタマイズ
=============================================

このセクションではバッファーを切り替えをもっと便利にする、モードと機能を
いくつか説明します。

* Menu:

* Uniquify::                 ディレクトリー部分でバッファー名を一意にする。
* Icomplete::                素早いミニバッファーの選択について。
* Buffer Menus::             バッファーメニューの設定。


File: emacs-ja.info,  Node: Uniquify,  Next: Icomplete,  Up: Buffer Convenience

19.7.1 バッファー名を一意にする
-------------------------------

同じ名前のファイルを複数のバッファーでvisitしているとき、Emacsはバッファ
ーに区別可能な名前をつけなければなりません。デフォルトの方法はファイルを
ディレクトリーの一部を後ろに追加する方法です。たとえば同時にファイル
‘/foo/bar/mumble/name’と‘/baz/quux/mumble/name’をvisitしている場合、バッ
ファーの名前は‘name<bar/mumble>’と‘name<quux/mumble>’になるでしょう。
Emacsは名前を一意にするために必要な分だけ、ディレクトリー名の一部を追加
します。

   オプション‘uniquify-buffer-name-style’をカスタマイズして、一意なバッ
ファー名を構築するための異なるスタイルを選択することができます。

   命名方法‘forward’は、バッファー名の先頭部分に、ファイルのディレクトリ
ー名の一部を含めます。この方法を使うとファイル‘/u/rms/tmp/Makefile’と
‘/usr/projects/zaphod/Makefile’をvisitしているバッファーの名前は、
‘tmp/Makefile’と‘zaphod/Makefile’になるでしょう。

   対照的に命名方法‘post-forward’は、バッファーを‘Makefile|tmp’および
‘Makefile|zaphod’と名づけます。デフォルトの
‘post-forward-angle-brackets’は、‘post-forward’と同様ですが、一意なパス
を山形カッコ(angle brackets)で囲います。命名方法‘reverse’では、
‘Makefile\tmp’および‘Makefile\zaphod’となります。‘post-forward’と
‘reverse’の重要な違いは、2つのファイルを区別するのに1つのディレクトリ名
では不足するときです。‘reverse’はディレクトリー名を逆順にして命名するの
で、ファイル‘/top/middle/file’は‘file\middle\top’となります。一方
‘post-forward’はディレクトリー名を正順でファイル名に追加するので
‘file|top/middle’となります。‘uniquify-buffer-name-style’が‘nil’にセット
されていると、バッファー名の後ろに単に‘<2>’、‘<3>’と加えることにより、バ
ッファー名を作成します。

   タイプする前にバッファー名に_注意_すれば、バッファー名にディレクトリ
ー名を付加する方法に重要な違いはありません。しかしルールを知った経験豊富
なユーザーは、それほど注意する必要はないでしょう。そして、その場合いずれ
かのルールでバッファー名が表示されていれば，思い出し利用するのが容易にな
ることでしょう。


File: emacs-ja.info,  Node: Icomplete,  Next: Buffer Menus,  Prev: Uniquify,  Up: Buffer Convenience

19.7.2 素早いミニバッファーの選択
---------------------------------

グローバルなマイナーモードのIcompleteモードは、ミニバッファーで利用可能
な補完候補を素早く選択する便利な方法を提供します。これが有効な場合、ミニ
バッファーでタイプすることにより、すでにタイプした文字にマッチする、利用
可能な候補を連続で表示します。

   ‘C-j’とタイプすることにより、常にリストの最初の補完候補を選択できます
。つまり特定の補完候補を選択するには、まずその候補をリストの先頭にするこ
とです。これを行うには2つの方法があります。1つ目の方法は、補完候補の名前
をさらにタイプすることにより、違う候補が含まれないように、希望する補完候
補にリストを絞りこむ方法です。もう1つは‘C-.’および‘C-,’を使って、望む候
補が先頭にくるまでリストをローテートする方法です。

   ‘M-<TAB>’は‘C-j’のようにリストの最初の補完候補を選択しますが、ミニバ
ッファーを抜けないので、さらに編集を続けることができます。これはファイル
名の入力で通常使われます。‘M-<TAB>’により、いくつかのディレクトリー階層
をたどることができます。

   Icompleteモードを有効にするには、‘M-x icomplete-mode’とタイプするか、
変数‘icomplete-mode’を‘t’にカスタマイズします(*note Easy
Customization::を参照してください)。


File: emacs-ja.info,  Node: Buffer Menus,  Prev: Icomplete,  Up: Buffer Convenience

19.7.3 バッファーメニューのカスタマイズ
---------------------------------------

‘M-x bs-show’
     ‘M-x list-buffers’と同様にバッファーリストを作成しますが、カスタマ
     イズが可能です。

   ‘M-x bs-show’は、通常‘C-x C-b’で表示されるのと同じようなバッファーリ
ストを表示しますが、カスタマイズが可能です。通常のバッファーリストよりこ
ちらのほうが好ましい場合、このコマンドを‘C-x C-b’にバインドできます。こ
のバッファーリストをカスタマイズするには、Customグループの‘bs’を使います
(*note Easy Customization::を参照してください)。

   MSBグローバルマイナーモード(“MSB”は“mouse select buffer(マウス選択バ
ッファー)”が由来)は、カスタマイズ可能なマウスによるBuffer Menuを提供しま
す。これは通常‘C-Down-Mouse-1’にバインドされている‘mouse-buffer-menu’と
、Buffer Menuのメニューを置き換えます。メニューはCustomグループ‘msb’でカ
スタマイズが可能です。


File: emacs-ja.info,  Node: Windows,  Next: Frames,  Prev: Buffers,  Up: Top

20 複数ウィンドウ
*****************

Emacsのフレームは、2つ以上のウィンドウに分割できます。複数のウィンドウで
異なるバッファーを表示したり、1つのバッファーの異なる部分を表示できます
。複数フレームは自ずと複数ウィンドウになります。なぜならフレームには、そ
れぞれウィンドウがあるからです。ウィンドウは1つのフレームだけに属します
。

* Menu:

* Basic Window::             Emacsウィンドウの紹介。
* Split Window::             既存のウィンドウを分割して新しいウィンドウを作る。
* Other Window::             他のウィンドウへの移動と操作。
* Pop Up Window::            他のウィンドウのファイルまたはバッファーの検索。
* Change Window::            ウィンドウの削除とサイズ変更。
* Displaying Buffers::       Emacsがバッファーを表示するためにウィンドウを選択する方法。
* Window Convenience::       ウィンドウ処理の便利な機能。


File: emacs-ja.info,  Node: Basic Window,  Next: Split Window,  Up: Windows

20.1 Emacsウィンドウの概念
==========================

Emacsの各ウィンドウには、常に1つのEmacsバッファーが表示されます。1つのバ
ッファーは、複数のウィンドウに表示される場合があります。この場合、バッフ
ァーのテキストへの任意の変更は、それが表示されているすべてのウィンドウで
表示されます。しかし各ウィンドウは独自にポイント値をもっているので、ウィ
ンドウごとにバッファーの異なる部分を表示できます。

   常に1つのEmacsウィンドウが、“選択されたウィンドウ”となります。このウ
ィンドウに表示されているバッファーが、カレントバッファーとなります。グラ
フィカルなディスプレーでは、選択されたウィンドウのカーソルは、点滅する塗
りつぶされたカーソルとなり、選択されていないウィンドウでは、中抜きボック
スのカーソルになります。テキスト端末では、カーソルは選択されたウィンドウ
だけで描画されます。*note Cursor Display::を参照してください。

   ポイントを移動するコマンドは、選択されたEmacsウィンドウのポイント値だ
けに影響します。他のEmacsウィンドウのポイント値は、たとえ同じバッファー
を表示していたとしても変更されません。これと同じことは、‘C-x b’のような
バッファー切り替えコマンドについても言えます。これらは他のウィンドウには
影響を与えません。しかし‘C-x 4 b’のような、別のウィンドウを選択して、バ
ッファーを切り替えるコマンドもあります。(たとえば)‘C-h f’
(‘describe-function’)や‘C-x C-b’ (‘list-buffers’)を含む、ウィンドウで情
報を表示するコマンドは、選択されたウィンドウに影響を与えることなく、選択
されていないウィンドウのバッファーを切り替えます。

   複数ウィンドウで同じバッファーを表示しているとき、これらは異なるリー
ジョンを持ちます。なぜなら、それらは異なるポイント値を持つことができるか
らです。しかしバッファーごとにマーク位置は1つだけなので、これらは同じマ
ーク位置をもちます。

   それぞれのウィンドウには、独自のモードラインがあり、それにはバッファ
ー名、変更状態、そのウィンドウに表示されているバッファーのメジャーモード
とマイナーモードが表示されます。選択されたウィンドウのモードラインは、異
なる色で表示されます。詳細については、*note Mode Line::を参照してくださ
い。


File: emacs-ja.info,  Node: Split Window,  Next: Other Window,  Prev: Basic Window,  Up: Windows

20.2 ウィンドウの分割
=====================

‘C-x 2’
     選択されたウィンドウを上下に2分割します(‘split-window-below’)。
‘C-x 3’
     選択されたウィンドウを左右に2分割します(‘split-window-right’)。
‘C-Mouse-2’
     ウィンドウのモードライン上では、ウィンドウを分割します。

   ‘C-x 2’ (‘split-window-below’)は、選択されたウィンドウを上下に2つのウ
ィンドウに分割します。分割した後は、上が選択されたウィンドウになり、新た
に分割されたウィンドウが下になります。2つのウィンドウは最初同じポイント
値をもち、(可能な限り)同じバッファー部分を表示します。必要ならポイントを
スクリーン上に残したまま、ウィンドウをスクロールできます。デフォルトでは
2つのウィンドウの高さは、元のウィンドウの高さの半分になります。正の数引
数は上のウィンドウの高さが何行分かを指定し、負の数引数は下のウィンドウが
何行分の高さかを指定します。

   変数‘split-window-keep-point’を‘nil’に変更すると、‘C-x 2’はスクリーン
に表示されるテキストができるだけ前と同じになるように、ウィンドウに表示さ
れるバッファー部分と、各ウィンドウのポイント位置を調整します。さらにポイ
ントが元のウィンドウの下半分にあったときは、上ではなく下のウィンドウが選
択されます。

   ‘C-x 3’ (‘split-window-right’)は、選択されたウィンドウを左右に2つのウ
ィンドウに分割します。左のウィンドウが選択されたウィンドウとなり、右のウ
ィンドウには同じバッファーの同じ部分が表示され、ポイント位置も同じです。
正の数引数は左のウィンドウの幅を列数で指定し、負の数引数は右のウィンドウ
の幅を数引数で指定します。

   ウィンドウを‘C-x 3’で分割すると、分割されたウィンドウの幅はフレーム全
体の幅より小さくなります。ウィンドウの幅が狭くなりすぎると、継続行が使わ
れたバッファーを読むことが困難になる場合があります(*note Continuation
Lines::を参照してください)。したがってウィンドウの幅が50列より狭くなった
とき、Emacsは自動的に行を切り詰めに切り替えます。この切り詰めは、変数
‘truncate-lines’の値に関係なく発生します(*note Line Truncation::を参照し
てください)。‘truncate-lines’のかわりに、この自動切り詰めを制御するのは
、変数‘truncate-partial-width-windows’です。この変数の値が正の整数(デフ
ォルトは50)の場合、それは自動的な行切り詰めが発生する前の、分割ウィンド
ウの最小幅を指定します。この値が‘nil’の場合、自動的な行切り詰めは無効で
す。他の非‘nil’値では、分割されたウィンドウの幅に関係なく、Emacsは行を切
り詰めます。

   テキスト端末では、左右に分割されたウィンドウを垂直に分割する分割線は
、‘vertical-border’フェイスで描画されます。

   ウィンドウのモードライン上で‘C-Mouse-2’をクリックすると、クリックした
位置に垂直分割線を配してウィンドウを分割します。Emacsがコンパイルされた
方法に依存しますが、ウィンドウのスクロールバー上で‘C-Mouse-2’をクリック
すると、クリックした位置に水平分割線を配してウィンドウを分割します(この
機能は、EmacsがGTK+のスクロールバーを使っているときは機能しません)。

   デフォルトでは、ウィンドウを分割したとき、Emacsは分割されたウィンドウ
のサイズをフレームのデフォルトフォントの整数倍にします。これによりスクリ
ーンが正確に2分割されない場合があります。変数‘window-resize-pixelwise’を
非‘nil’値にセットすると、Emacsは分割されたウィンドウのサイズを、同じピク
セル数にします(元のサイズが奇数のピクセル数の場合、1ピクセル増減されます
)。フレームのピクセル数がフレームの文字サイズ倍でない場合、このオプショ
ンが‘nil’でも、少なくとも1つのウィンドウがピクセル幅のサイズ変更をされる
ことに注意してください。


File: emacs-ja.info,  Node: Other Window,  Next: Pop Up Window,  Prev: Split Window,  Up: Windows

20.3 他のウィンドウの使用
=========================

‘C-x o’
     他のウィンドウを選択します(‘other-window’)。
‘C-M-v’
     次のウィンドウをスクロールします(‘scroll-other-window’)。
‘Mouse-1’
     ウィンドウのテキスト領域を‘Mouse-1’でクリックすると、そのウィンドウ
     を選択してクリックした位置にポイントを移動します。モードラインをク
     リックすると、ポイントを移動せずにそのウィンドウを選択します。

   キーボードで‘C-x o’ (‘other-window’)をタイプして、ウィンドウを切り替
えることができます。‘o’は“other”のoで、0(ゼロ)ではありません。2つ以上の
ウィンドウがある時、このコマンドはすべてのウィンドウを順繰りに選択します
(一般的に上からした、左から右)。一番右または一番下のウィンドウの後は、左
上のウィンドウに戻ります。数引数は上記の順番で何番目のウィンドウに移動す
るかを意味します。負の引数は逆向きで同じことを行います。ミニバッファーが
アクティブのとき、ミニバッファーはこの順番では最後のウィンドウになります
。ミニバッファーのウィンドウから他のウィンドウに切り替えて、後からミニバ
ッファーに戻って引数の入力を終了させることができます。*note Minibuffer
Edit::を参照してください。

   通常のスクロールコマンド(*note Display::を参照してください)は、選択さ
れたウィンドウだけに適用されますが、次のウィンドウをスクロールするコマン
ドが1つあります。‘C-M-v’ (‘scroll-other-window’)は、‘C-x o’が選択するウ
ィンドウをスクロールします(このコマンドは‘C-v’のように正または負の引数を
とります。ミニバッファーでの‘C-M-v’は、ミニバッファーに関連付けられたヘ
ルプウィンドウがあれば、標準的な次のウィンドウではなくヘルプウィンドウを
スクロールします。*note Minibuffer Edit::を参照してください)。

   ‘mouse-autoselect-window’を非‘nil’値にセットしている場合、マウスが選
択されたウィンドウ以外のウィンドウに移動すると、そのウィンドウが選択され
ます。この機能はデフォルトでオフです。


File: emacs-ja.info,  Node: Pop Up Window,  Next: Change Window,  Prev: Other Window,  Up: Windows

20.4 他のウィンドウでの表示
===========================

‘C-x 4’は、異なるウィンドウ(他の既存のウィンドウや、選択されたウィンドウ
を分割することにより新たに作成されたウィンドウ)のバッファーに切り替える
、さまざまなコマンドのプレフィクスキーです。Emacsがウィンドウを選択また
は作成する方法については、*note Window Choice::を参照してください。

‘C-x 4 b BUFNAME <RET>’
     他のウィンドウのバッファーBUFNAMEを選択します
     (‘switch-to-buffer-other-window’)。

‘C-x 4 C-o BUFNAME <RET>’
     バッファーBUFNAMEを選択せずに、別のウィンドウに表示します
     (‘display-buffer’)。ウィンドウが選択される方法についての詳細は、
     *note Displaying Buffers::を参照してください。

‘C-x 4 f FILENAME <RET>’
     ファイルFILENAMEをvisitして、他のウィンドウでバッファーを選択します
     (‘find-file-other-window’).  *note Visiting::を参照してください。

‘C-x 4 d DIRECTORY <RET>’
     DIRECTORYのDiredバッファーを、別のウィンドウで選択します
     (‘dired-other-window’)。*note Dired::を参照してください。

‘C-x 4 m’
     ‘C-x m’ (*note Sending Mail::を参照してください)と同様に、メールメ
     ッセージの編集を開始しますが、別のウィンドウで行います
     (‘mail-other-window’)。

‘C-x 4 .’
     ‘M-.’ (*note Tags::を参照してください)と同様に、現在のtagsテーブル
     のタグを検索しますが、別のウィンドウで行います
     (‘find-tag-other-window’)。
‘C-x 4 r FILENAME <RET>’
     ファイルFILENAMEを読み取り専用でvisitして、別のウィンドウでバッファ
     ーを選択します(‘find-file-read-only-other-window’)。*note
     Visiting::を参照してください。


File: emacs-ja.info,  Node: Change Window,  Next: Displaying Buffers,  Prev: Pop Up Window,  Up: Windows

20.5 ウィンドウの削除と再配置
=============================

‘C-x 0’
     選択されたウィンドウを削除します(‘delete-window’)。
‘C-x 1’
     フレームから選択されたウィンドウ以外のすべてのウィンドウを削除しま
     す(‘delete-other-windows’)。
‘C-x 4 0’
     選択されていたウィンドウを削除して、それに表示されていたバッファー
     をkillします(‘kill-buffer-and-window’)。このキーシーケンスの最後の
     文字はゼロです。
‘C-x ^’
     選択されたウィンドウの高さを増やします(‘enlarge-window’)。
‘C-x }’
     選択されたウィンドウの幅を増やします
     (‘enlarge-window-horizontally’)。
‘C-x {’
     選択されたウィンドウの幅を減らします
     (‘shrink-window-horizontally’)。
‘C-x -’
     バッファーに多くの行数が必要ない場合、そのウィンドウを縮小します
     (‘shrink-window-if-larger-than-buffer’)。
‘C-x +’
     すべてのウィンドウの高さを同じにします(‘balance-windows’)。

   選択されたウィンドウを削除するには、‘C-x 0’ (‘delete-window’)とタイプ
します(これはゼロです)。一度ウィンドウが削除されると、そのウィンドウが占
めていたスペースは隣接したウィンドウに与えられます(しかしミニバッファー
の場合、それがアクティブな場合でも適用されません)。ウィンドウの削除は、
ウィンドウを表示用に使っていたバッファーに影響を与えません。そのバッファ
ーは存在し続け、‘C-x b’で切り替えることができます。

   ‘C-x 4 0’ (‘kill-buffer-and-window’)は、コマンド‘C-x 0’より強力なコマ
ンドです。これはカレントバッファーをkillしてから、選択されたウィンドウを
削除します。

   ‘C-x 1’ (‘delete-other-windows’)は、選択されたウィンドウ_以外_のすべ
てのウィンドウを削除します。選択されたウィンドウはフレーム全体に拡張され
ます(このコマンドは、ミニバッファーのウィンドウがアクティブのとき使うこ
とができません。これを試みるとエラーがシグナルされます)。

   コマンド‘C-x ^’ (‘enlarge-window’)は、フレームの高さを変えずに垂直方
向に隣接するウィンドウのスペースを縮小して、選択されたウィンドウの高さを
増やします。正の数引数を与えると、このコマンドは指定した行数分ウィンドウ
の高さを増やします。負の数引数を与えると、指定した行数分ウィンドウの高さ
を増やします。垂直方向に隣接するウィンドウが存在しない場合(たとえばウィ
ンドウの高さがフレーム全体の高さと同じとき)、エラーをシグナルします。こ
のコマンドは変数‘window-min-height’(デフォルトは4)で指定された、最小行数
よりウィンドウの高さを縮小しようとしても、エラーをシグナルします。

   同様に‘C-x }’ (‘enlarge-window-horizontally’)は、選択されたウィンドウ
の幅を増やし、‘C-x {’ (‘shrink-window-horizontally’)は幅を減らします。こ
れらのコマンドは、変数‘window-min-width’(デフォルトは10)で指定された最小
列数よりウィンドウの幅を縮小すると、エラーをシグナルします。

   ‘C-x -’ (‘shrink-window-if-larger-than-buffer’)は、バッファー全体を表
示するのに必要な高さより選択されたウィンドウの高さが大きいときは、選択さ
れたウィンドウの高さを減らします。余った行数はフレームの他のウィンドウに
与えられます。

   ‘C-x +’ (‘balance-windows’)を使って、選択されたフレームのすべてのウィ
ンドウの高さを均等にすることもできます。

   モードライン上でマウスをクリックすることにより、ウィンドウの高さの変
更およびウィンドウを削除する、別の方法が提供されます。*note Mode Line
Mouse::を参照してください。


File: emacs-ja.info,  Node: Displaying Buffers,  Next: Window Convenience,  Prev: Change Window,  Up: Windows

20.6 ウィンドウでのバッファーの表示
===================================

ユーザーのコマンドの結果として、任意のバッファーが表示または“ポップアッ
プ”されるのは、Emacsでは一般的な処理です。コマンドがこれを行うには、いく
つかの異なる方法があります。

   ‘C-x C-f’ (‘find-file’)のような多くのコマンドは、選択されたウィンドウ
を“乗っ取って”バッファーを表示します。これらのコマンドは通常、
‘switch-to-buffer’を内部的に呼び出すことにより機能します(*note Select
Buffer::を参照してください)。

   選択されたウィンドウを乗っ取らずに、たとえばウィンドウを分割して新し
いウィドウを作り、そこにバッファーを表示するといったような、“利口な”表示
を試みるコマンドがいくつかあります。さまざまなヘルプコマンド(*note
Help::)を含む、そのようなコマンドは内部的に‘display-buffer’を呼び出すこ
とにより機能します。詳細は、*note Window Choice::を参照してください

   他のコマンドは‘display-buffer’と同じことを行いますが、それに加えてバ
ッファーの編集を開始できるように、表示されたウィンドウを選択します。コマ
ンド‘C-x `’ (‘next-error’)が1つの例です(*note Compilation Mode::を参照し
てください)。そのようなコマンドは、内部的に関数‘pop-to-buffer’を呼び出す
ことにより機能します。*note Switching to a Buffer in a Window:
(elisp)Switching Buffers.を参照してください。

   名前が‘-other-window’で終わるコマンドは、‘display-buffer’と同じように
振る舞います。例外はそれらが決して選択されたウィンドウに表示しない点です
。これらのコマンドのいくつかは、プレフィクスキー‘C-x 4’にバインドされて
います(*note Pop Up Window::を参照してください)。

   名前が‘-other-frame’で終わるコマンドは、‘display-buffer’と同じように
振る舞います。例外は、i)選択されたウィンドウに決して表示しない、ii)ウィ
ンドウを分割してバッファーを表示するのではなく新しいフレームを作成して表
示する(あたかも変数‘pop-up-frames’が‘t’されているかのように)、という2点
です(*note Window Choice::を参照してください)。これらのコマンドのいくつ
かは、プレフィクスキー‘C-x 5’にバインドされています。

* Menu:

* Window Choice::            ‘display-buffer’が機能する方法。


File: emacs-ja.info,  Node: Window Choice,  Up: Displaying Buffers

20.6.1 ‘display-buffer’が機能する方法
-------------------------------------

‘display-buffer’コマンド(およびこのコマンドを内部的に呼び出すコマンド)は
、以下で与えられたステップに従って、表示するウィンドウを選択します。この
ステップの順番を変更する方法については、*note Choosing a Window for
Display: (elisp)Choosing Window.を参照してください。

   • 最初に、他のバッファーを考慮せずに、そのバッファーが選択されたウィ
     ンドウに表示されるべきかをチェックします。これを行うようEmacsに指示
     するには、望むバッファー名をリスト‘same-window-buffer-names’に加え
     るか、リスト‘same-window-regexps’にバッファー名にマッチする正規表現
     を追加します。デフォルトではこれらの変数は‘nil’なので、このステップ
     はスキップされます。

   • 上記以外の場合、バッファーがすでに既存のウィンドウに表示されている
     ときは、そのウィンドウを“再利用”します。通常は選択されたフレームの
     ウィンドウだけが考慮されますが、変数‘pop-up-frames’を‘t’に変更して
     いる場合(以下参照)、他のフレームのウィンドウも再利用可能です、

   • 上記以外の場合、オプションで新しいフレームを作成して、バッファーを
     そこに表示します。デフォルトではこのステップはスキップされます。こ
     れを有効にするには変数‘pop-up-frames’を非‘nil’値に変更します。特別
     な値‘graphic-only’は、グラフィカルなディスプレーだけで、これを行う
     ことを意味します。

   • 上記以外の場合、選択されたウィンドウを分割することにより、新しいウ
     ィンドウを作成して、バッファーを新しく作成したウィンドウに表示しよ
     うと試みます。

     分割は垂直または水平に行われる可能性があり、それは変数
     ‘split-height-threshold’および‘split-width-threshold’に依存します。
     これらの変数には整数値を指定します。‘split-height-threshold’が選択
     されたウィンドウの高さより小さい場合、分割により下が新しいウィンド
     ウになります。上記以外の場合、‘split-width-threshold’が選択されたウ
     ィンドウの幅より小さい場合、分割により右が新しいウィンドウになりま
     す。どちらの条件も適用できなかったとき、Emacsは分割により下を新しい
     ウィンドウにしようと試みますが、それは選択されたウィンドウが以前に
     分割されていなかった場合に限られます(過剰な分割を避けるため)。

   • 上記以外の場合、選択されたフレームの既存のウィンドウのバッファーを
     表示します。

   • 何らかの理由により上記すべてが失敗した場合、新しいフレームを作成し
     て、そこにバッファーを表示します。


File: emacs-ja.info,  Node: Window Convenience,  Prev: Displaying Buffers,  Up: Windows

20.7 ウィンドウ処理のための便利な機能
=====================================

Winnerモードは、ウィンドウの設定変更(たとえばフレームのウィンドウがどの
ように分割されたか)を記録するグローバルマイナーモードなので、それらを
“undo”できます。Winnerモードは‘M-x winner-mode’、または変数
‘winner-mode’をカスタマイズすることにより、切り替えることができます。こ
のモードが有効な場合、‘C-c left’ (‘winner-undo’)は、左のウィンドウの設定
変更をundoします。undoしてから気が変わった場合、‘C-c right’ (‘M-x
winner-redo’)を使って、undoした変更を再実行することができます。

   Followモード(‘M-x follow-mode’)は、複数のウィンドウの同じバッファーを
同期するので、バッファーの隣接した部分が常に表示されます。*note Follow
Mode::を参照してください。

   Windmoveパッケージは、フレーム内の隣接したウィンドウ間を直接移動する
コマンドを定義します。“right”の部分を“left”、“up”、“down”に置き換えると
、対応する方向の隣接するウィンドウを選択します。‘M-x
windmove-default-keybindings’は、これらのコマンドを‘S-right’などにバイン
ドします。これにより、これらのキーを使ったシフト選択が無効になります
(*note Shift Selection::を参照してください)。

   コマンド‘M-x compare-windows’は、異なるウィンドウに表示されたテキスト
を比較します。*note Comparing Files::を参照してください。

   Scroll Allモード(‘M-x scroll-all-mode’)は、スクロールおよびポイント移
動コマンドが、表示されているすべてのウィンドウに適用されるグローバルマイ
ナーモードです。


File: emacs-ja.info,  Node: Frames,  Next: International,  Prev: Windows,  Up: Top

21 フレームとグラフィカルなディスプレー
***************************************

Emacsがグラフィカルなディスプレー(たとえばXウィンドウシステム)で開始され
たときは、システムレベルのグラフィカルな“ウィンドウ”を占有します。このマ
ニュアルではこれを“フレーム”と呼び、“ウィンドウ”という言葉はフレームでバ
ッファーを表示する部分のために使います。フレームには最初1つのウィンドウ
が含まれていますが、これを複数のウィンドウに分割することができます。フレ
ームには通常、メニューバー、ツールバー、エコーエリアも含まれます。

   追加のフレームを作ることもできます(*note Creating Frames::を参照して
ください)。同じEmacsセッションで作られたすべてのフレームは、背後にあるバ
ッファーや、その他のデータにアクセスします。たとえば１つ以上のフレームで
表示されているバッファーは、あるフレームに表示されているものに変更を加え
ると、即座に他のフレームに反映されます。

   ‘C-x C-c’とタイプすると、現在表示されているすべてのフレームを閉じて、
他に表示されているフレームがなければ、Emacsセッションを終了します(*note
Exiting::を参照してください)。選択されたフレームだけを閉じるには、‘C-x 5
0’(これは‘o’ではなくゼロです)とタイプします。

   このセクションでは、グラフィカルなディスプレーに特有の機能(特にマウス
コマンド)と、複数フレームを管理する機能について説明します。テキスト端末
では、これらの機能の多くは利用できません。しかしテキスト端末で複数の“フ
レーム”を作ることは可能です。そのようなフレームは1度に１つだけ表示され、
テキスト画面全体を占有します(*note Non-Window Terminals::を参照してくだ
さい)。テキスト端末の中には、マウスを使うことが可能なものがいくつかあり
ます(GNUおよびUnix systemsでこれを行うには、*note Text-Only Mouse::を、
MS-DOSでこれを使うには、 *note MS-DOS Mouse::を参照してください )。メニ
ューはすべてのテキスト端末でサポートされています。

* Menu:

* Mouse Commands::           マウスによる移動、切り取り、貼り付け。
* Word and Line Mouse::      単語または行全体を選択するマウスコマンド。
* Mouse References::         リストからアイテムを選択するのにマウスを使う。
* Menu Mouse Clicks::        メニューを表示させるマウスクリック。
* Mode Line Mouse::          モードライン上でのマウスクリック。
* Creating Frames::          さまざまな内容とともに追加のEmacsフレームを作成する。
* Frame Commands::           フレームのアイコン化とフレームの切り替え。
* Fonts::                    フレームフォントの変更。
* Speedbar::                 スピードバーフレームの作り方と使い方。
* Multiple Displays::        1つのEmacsインスタンスが複数ディスプレーと通信する方法。
* Frame Parameters::         フレームのカラーや他のモードの変更。
* Scroll Bars::              スクロールバーの有効と無効、および使い方。
* Drag and Drop::            ファイルを開いたりテキストを挿入するのにドラッグアンドドロップを使う。
* Menu Bars::                メニューバーの有効と無効。
* Tool Bars::                ツールバーの有効と無効。
* Dialog Boxes::             ダイアログボックス使用の制御。
* Tooltips::                 マウスの現在位置の情報の表示。
* Mouse Avoidance::          マウスポインターがテキストを隠すのを防ぐ。
* Non-Window Terminals::     フレームを1つだけ表示する端末での複数フレーム。
* Text-Only Mouse::          テキスト端末でのマウスの使用。


File: emacs-ja.info,  Node: Mouse Commands,  Next: Word and Line Mouse,  Up: Frames

21.1 編集のためのマウスコマンド
===============================

‘Mouse-1’
     クリックした場所にポイントを移動します(‘mouse-set-point’)。

‘Drag-Mouse-1’
     ドラッグにより選択されたテキストを取り囲むリージョンをアクティブ化
     して、そのテキストをプライマリー選択に置きます
     (‘mouse-set-region’)。

‘Mouse-2’
     クリックした場所にポイントを移動して、そこにプライマリー選択の内容
     を挿入します(‘mouse-yank-primary’)。

‘Mouse-3’
     リージョンがアクティブなときは、近くにあるリージョンの終端をクリッ
     クした位置に移動します。アクティブでないときは現在のポイントにマー
     クをセットして、ポイントをクリックした位置に移動します。結果となる
     リージョンはkillリングに保存されます。2回目のクリックでリージョンを
     killします(‘mouse-save-then-kill’)。

   もっとも基本的なマウスコマンドは‘mouse-set-point’で、これはウィンドウ
のテキスト領域でマウスの左ボタン、‘Mouse-1’をクリックすることにより呼び
出されます。これはポイントをクリックされた位置に移動します。そのウィンド
ウが選択されたウィンドウでなかったとき、そのウィンドウが選択されたウィン
ドウになります。

   クリックしたフレームが選択されたフレームでなかった場合は通常、クリッ
クされたフレームが選択されたフレームになるのに加えて、ウィンドウも選択さ
れカーソルがセットされます。Xウィンドウシステムでは、変数
‘x-mouse-click-focus-ignore-position’を‘t’にセットすることにより、これを
変更できます。この場合、選択されていないフレームへの最初のクリックではフ
レームだけを選択し、他は変更しません。次にクリックするとそのウィンドウを
選択してカーソルをその位置にセットします。

   ‘Mouse-1’を押してテキストの周辺を“ドラッグ”すると、最初にマウスボタン
を押した位置にマークが置かれ、ボタンを離した位置にポイントがセットされ
(*note Mark::を参照してください)、その領域がアクティブになります
(‘mouse-set-region’)。それに加えてリージョンのテキストがプライマリー選択
となります(*note Primary Selection::を参照してください)。

   変数‘mouse-drag-copy-region’を非‘nil’値に変更すると、テキストの周囲を
ドラッグすることにより、そのテキストをkillリングに追加します。デフォルト
は‘nil’です。

   ドラッグしている途中でマウスがウィンドウの上または下を超えた場合、マ
ウスがウィンドウ内に戻るまで、ウィンドウが一定の割合でスクロールします。
この方法により、スクリーン全体に収まらないリージョンを選択できます。1度
に何行スクロールするかは、マウスがウィンドウの縁からどれだけ離れたかに依
存します。変数‘mouse-scroll-min-lines’は、最小ステップサイズを指定します
。

   マウスの真ん中のボタン、‘Mouse-2’をクリックすると、クリックした位置に
ポイントを移動して、プライマリー選択の内容を挿入します
(‘mouse-yank-primary’)。*note Primary Selection::を参照してください。こ
の振る舞いは、他のXアプリケーションと一貫性があります。かわりに
‘Mouse-2’を、‘mouse-yank-at-click’にバインドできます。これはクリックした
位置にyankするコマンドです。

   変数‘mouse-yank-at-point’を非‘nil’値に変更すると、‘Mouse-2’はポイント
を移動しません。これはどこをクリックしたか、フレームのどのウィンドウをク
リックしたかに関係なく、ポイントのある位置にテキストを挿入します。この変
数は‘mouse-yank-primary’と‘mouse-yank-at-click’の両方に影響します。

   マウスの右ボタン、‘Mouse-3’をクリックすると、コマンド
‘mouse-save-then-kill’が実行されます。これはどこをクリックしたかと、リー
ジョンの状態に依存していくつかのアクションを処理します。

   • アクティブなリージョンがないときは、‘Mouse-3’のクリックにより、ポイ
     ントがあった位置にマークをセットし、クリックした位置にポイントを置
     いて、リージョンをアクティブにします。

   • リージョンがアクティブなときは、‘Mouse-3’のクリックにより、クリック
     した位置に近いリージョンの終端を、クリックした位置に調整します。調
     整されたリージョンのテキストは、killリングにコピーされます。元のリ
     ージョンのテキストがすでにkillリングにある場合は、それを置き換えま
     す。

   • 元のリージョンが‘Mouse-1’のダブルクリックまたはトリプルクリックで選
     択されたものである場合、リージョンは単語全体、または行全体にたいし
     て定義されているので(*note Word and Line Mouse::を参照してください
     )、‘Mouse-3’によるリージョンの調整も単語全体または行全体を単位とし
     て行われます。

   • 同じ場所で連続して2回‘Mouse-3’を使うことにより、すでに選択されてい
     るリージョンをkillできます。したがってマウスでテキストをkillする簡
     単な方法は、まずリージョンの始端を決めるため‘Mouse-1’をクリックして
     、もう一方の終端で‘Mouse-3’を2回クリックします。テキストを削除せず
     にkillリングにコピーするには、‘Mouse-3’を1回だけクリックするか、テ
     キスト範囲をドラッグします。その後は適当な場所でyankしてコピーでき
     ます。

   ‘mouse-save-then-kill’コマンドは、変数‘mouse-drag-copy-region’の値に
もしたがいます(上記参照)。変数の値が非‘nil’のときは、コマンドがアクティ
ブなリージョンをセットまたは調整したとき、常にリージョンのテキストは
killリングにも追加されます。一番最近のkillリングのエントリーが同じ方法で
追加されたものである場合、新しいエントリーを作成せず、そのエントリーを置
き換えます。

   上記で説明した任意のマウスコマンドを使ってセットしたリージョンは、シ
フト選択以外のマウス移動コマンド、および通常のマークを非アクティブ化する
方法により、マークが非アクティブになります。*note Shift Selection::を参
照してください。

   スクロールに使うことができる“ホイール”があるマウスもいくつかあります
。Emacsはデフォルトで、マウスホイールによるウィンドウのスクロールを、ほ
とんどのグラフィカルなディスプレーでサポートします。この機能を切り替える
には、‘M-x mouse-wheel-mode’を使います。変数‘mouse-wheel-follow-mouse’お
よび‘mouse-wheel-scroll-amount’は、(どこでホイールによるスクロール操作が
行われたかによる)スクロール対象の選択方法と、バッファーがスクロールされ
る量を決定します。変数‘mouse-wheel-progressive-speed’は、スクロールの早
さがホイールを移動した早さにリンクするかを決定します。


File: emacs-ja.info,  Node: Word and Line Mouse,  Next: Mouse References,  Prev: Mouse Commands,  Up: Frames

21.2 単語と行にたいするマウスコマンド
=====================================

以下の‘Mouse-1’の変種は、1度に単語全体または行全体を選択します。Emacsは
選択されたテキスト周辺のリージョンをアクティブにして、killリングにもコピ
ーされます。

‘Double-Mouse-1’
     クリックした単語周辺のテキストを選択します。

     “シンボル”の構文をもつ文字(C modeでのアンダースコアーなど)をダブル
     クリックすると、シンボルを取り囲むその文字を選択します。開きカッコ
     (または閉じカッコ)の構文をもつ文字をダブルクリックすると、そのカッ
     コで始まる(または終わる)グループを選択します。区切り文字の構文をも
     つ文字(Cのシングルクォーテーションやダブルクォーテーション)をダブル
     クリックすると、文字列定数を選択します(Emacsはその文字により開始す
     るのか(または終了するのか)を、発見的な手法を使って見つけ出します)。

‘Double-Drag-Mouse-1’
     単語全体の形式で、ドラッグした箇所のテキストを選択します。

‘Triple-Mouse-1’
     クリックした行を選択します。

‘Triple-Drag-Mouse-1’
     行全体の形式で、ドラッグした箇所のテキストを選択します。


File: emacs-ja.info,  Node: Mouse References,  Next: Menu Mouse Clicks,  Prev: Word and Line Mouse,  Up: Frames

21.3 マウスで参照をフォローする
===============================

Emacsのバッファーには“ボタン”や、アクティブ化(例えばクリック)したとき何
らかのアクション(例えば参照をフォローする)を行う、“ハイパーリンク”を含む
ものがあります。ボタンのテキストは通常、アンダーラインが引かれていたり、
周囲にボックスが描かれて、視覚的にハイライトされています。ボタンの上にマ
ウスを移動すると、マウスカーソルの形状が変化して、ボタンがライトアップさ
れます。変数‘mouse-highlight’を‘nil’に変更すると、Emacsはこのハイライト
機能を無効にします。

   ボタンをアクティブにするには、ポイントをそこに移動して<RET>をタイプす
るか、‘Mouse-1’または‘Mouse-2’でボタンをクリックします。たとえばDiredバ
ッファーでは、ファイル名がボタンです。これをアクティブにすることにより、
Emacsはそのファイルをvisitします(*note Dired::を参照してください)。
‘*Compilation*’バッファーでは、各エラーメッセージがボタンです。これをア
クティブにすることにより、そのエラーにたいするソースコードをvisitします
(*note Compilation::を参照してください)。

   ボタンを‘Mouse-1’でクリックすると、ボタンがアクティブになりますが、マ
ウスボタンを押してから離すまで一定時間(厳密に言うと450ミリ秒以上)が経過
すると、Emacsはボタンをアクティブにせず、ポイントをクリックした場所に移
動します。この方法によりボタンをアクティブにせずにポイントを移動するのに
、マウスを使用できます。マウスをボタンの上にドラッグすると、通常どおりリ
ージョンをセットして、ボタンはアクティブにしません。

   ボタンにたいして‘Mouse-1’がどのように適用されるかは、
‘mouse-1-click-follows-link’をカスタマイズすることにより変更できます。変
数の値が正の整数の場合、それはボタンのアクティブ化を取り消すのに、何ミリ
秒マウスボタンを押しつづける必要があるかを指定します。前のパラグラフで説
明したように、デフォルトは450です。値が‘nil’の場合、‘Mouse-1’は単にクリ
ックした場所にポイントを移動するだけで、ボタンをアクティブにしません。値
が‘double’の場合、シングルクリックでポイントのセット、ダブルクリックでボ
タンをアクティブにします。

   選択されていないウィンドウのボタンでも通常、‘Mouse-1’でクリックすれば
ボタンがアクティブになります。変数
‘mouse-1-click-in-non-selected-windows’を‘nil’に変更した場合、選択されて
いないウィンドウのボタンを‘Mouse-1’でクリックすると、クリックした位置に
ポイントを移動してウィンドウを選択しますが、ボタンはアクティブになりませ
ん。


File: emacs-ja.info,  Node: Menu Mouse Clicks,  Next: Mode Line Mouse,  Prev: Mouse References,  Up: Frames

21.4 メニューにたいするマウスクリック
=====================================

<CTRL>および<SHIFT>で修飾されたマウスクリックにより、メニューが表示され
るものがいくつかあります。

‘C-Mouse-1’
     このメニューはバッファーを選択するためのものです。

     MSB(“mouse select buffer”)グローバルマイナーモードは、このメニュー
     をスマートで、よりカスタマイズ可能なものにします。 *note Buffer
     Menus::を参照してください。

‘C-Mouse-2’
     このメニューには、フェイスや他のテキストプロパティーをテストしたり
     、それらを設定するものが含まれます(後者は主にEnriched textを編集す
     るのに便利です。*note Enriched Text::を参照してください)。

‘C-Mouse-3’
     このメニューは、モードに特有なメニューです。Menu-barモードがオンの
     場合、ほとんどのモードでは、このメニューに、そのモード特有なメニュ
     ーバーのメニューと同じアイテムを表示します。このボタンに異なるメニ
     ューを指定するモードもいくつかあります。Menu-barモードがオフの場合
     、このメニューにはモード特有のメニューだけでなく、本来メニューバー
     に含まれるべきすべてのアイテムが含まれるので、メニューバーを表示せ
     ずに、それらにアクセスすることができます。

‘S-Mouse-1’
     このメニューはそのウィンドウのバッファーの、デフォルトのフェイスを
     変更するためのものです。*note Text Scale::を参照してください。

   グラフィカルなアプリケーションには、‘Mouse-3’をモード特有なメニューに
使うものもいくつかあります。‘Mouse-3’で‘mouse-save-then-kill’コマンドを
実行するかわりに、Emacsにこのようなメニューを表示させるには、以下の行を
initファイルに追加して‘Mouse-3’をリバインドします(*note Init
Rebinding::を参照してください)。

     (global-set-key [mouse-3] 'mouse-popup-menubar-stuff)


File: emacs-ja.info,  Node: Mode Line Mouse,  Next: Creating Frames,  Prev: Menu Mouse Clicks,  Up: Frames

21.5 モードラインのマウスコマンド
=================================

ウィンドウのモードラインをマウスでクリックして、ウィンドウを選択したり操
作することができます。

   モードラインのいくつかの領域、たとえばバッファー名や、メジャーモード
およびマイナーモードは、独自のマウスバインディングをもっています。これら
の領域にマウスを移動すると、その領域がハイライトされ、特別なバインディン
グが表示されます(*note Tooltips::を参照してください)。このセクションのコ
マンドは、それらの領域には適用できません。

‘Mouse-1’
     モードラインを‘Mouse-1’でクリックすると、それが属するウィンドウを選
     択します。モードライン上で‘Mouse-1’でドラッグすることにより、それを
     移動することができるので、ウィンドウの高さを変更することができます
     。マウスでの高さの変更により、ウィンドウが削除されることはありませ
     ん。ウィンドウの高さが定められた最小値より小さくなる場合は、拒絶さ
     れます。

‘Mouse-2’
     モードラインを‘Mouse-2’でクリックすると、そのウィンドウがフレーム全
     体に表示されます。

‘Mouse-3’
     モードラインを‘Mouse-3’でクリックすると、それが属するウィンドウを削
     除します。フレームにウィンドウが1つしかないときは、何もしません。

‘C-Mouse-2’
     モードラインを‘C-Mouse-2’でクリックすると、クリックした位置でウィン
     ドウを左右に分割します(*note Split Window::を参照してください)。

   さらに、左右に並んだモードラインの間にある分割線を、‘Mouse-1’でクリッ
クしてドラッグすることにより、垂直の境界線を左右に移動できます。

   ウィンドウのサイズ変更は、‘window-resize-pixelwise’の値に影響されるこ
とに注意してください。詳細は*note Split Window::を参照してください。


File: emacs-ja.info,  Node: Creating Frames,  Next: Frame Commands,  Prev: Mode Line Mouse,  Up: Frames

21.6 フレームの作成
===================

プレフィクスキー‘C-x 5’は、‘C-x 4’に類似しています。‘C-x 4’コマンドが、
選択されたフレームの別ウィンドウにバッファーを表示するのにたいして、‘C-x
5’は異なるフレームを使います。可視またはアイコン化(“最小化”)されたフレー
ムで、すでに要求されたバッファーが表示されている場合、そのフレームを手前
に表示して非アイコン化(“最小化解除”)されます。それ以外の場合は、新しいフ
レームが現在の表示端末に作成されます。

   以下の‘C-x 5’コマンドは、選択するバッファーを検索したり作成する方法が
異なります。

‘C-x 5 2’
     新しいフレームを作成します(‘make-frame-command’)。
‘C-x 5 b BUFNAME <RET>’
     バッファーBUFNAMEを他のフレームで選択します。これは
     ‘switch-to-buffer-other-frame’を実行します。
‘C-x 5 f FILENAME <RET>’
     ファイルFILENAMEをvisitして、そのバッファーを他のフレームで選択しま
     す。これは‘find-file-other-frame’を実行します。*note Visiting::を参
     照してください。
‘C-x 5 d DIRECTORY <RET>’
     ディレクトリーDIRECTORYにたいするDiredバッファーを、他のフレームで
     選択します。これは‘dired-other-frame’を実行します。*note Dired::を
     参照してください。
‘C-x 5 m’
     他のフレームでメールメッセージの作成を開始します。これは
     ‘mail-other-frame’を実行します。これは‘C-x m’の異なるフレーム版です
     。*note Sending Mail::を参照してください。
‘C-x 5 .’
     他のフレームでカレントtagテーブルのtagを検索します。これは
     ‘find-tag-other-frame’を実行する、‘M-.’の複数フレーム版です。*note
     Tags::を参照してください。
‘C-x 5 r FILENAME <RET>’
     ファイルFILENAMEを読み取り専用でvisitして、そのバッファーを他のフレ
     ームで選択します。これは‘find-file-read-only-other-frame’を実行しま
     す。*note Visiting::を参照してください。

   “フレームパラメーター(frame parameters)”を指定することにより、新しく
作成されるフレームの外見と動作を制御できます。*note Frame Parameters::を
参照してください。


File: emacs-ja.info,  Node: Frame Commands,  Next: Fonts,  Prev: Creating Frames,  Up: Frames

21.7 フレームコマンド
=====================

以下のコマンドは、フレームを削除したり操作するために使われます:

‘C-x 5 0’
     選択されたフレームを削除します(‘delete-frame’)。1つしかフレームがな
     いときは、エラーをシグナルします。

‘C-z’
     選択されたEmacsフレームを最小化(またはアイコン化)します
     (‘suspend-frame’)。*note Exiting::を参照してください。

‘C-x 5 o’
     他のフレームを選択して手前に表示します。このコマンドを繰り返すと、
     端末のすべてのフレームを循環することができます。

‘C-x 5 1’
     現在の端末の、選択されたフレーム以外のすべてのフレームを削除します
     。

‘M-<F10>’
     カレントフレームの最大化を切り替えます。フレームが最大化されている
     ときはスクリーン全体に表示されます。

‘<F11>’
     カレントフレームのフルスクリーンモードを切り替えます(“フルスクリー
     ン”と“最大化”の違いは、前者がウィンドウマネージャーの装飾を隠すこと
     で、これによりEmacs自身のスクリーンスペースが若干増えます)。

   フレームを本当に“最大化”または“フルスクリーン”にするためには、変数
‘frame-resize-pixelwise’を非‘nil’値にカスタマイズする必要があるウィンド
ウマネージャーもいくつかあります。この変数を非‘nil’値にセットすると、一
般的にフレームのサイズ変更を行や列の整数倍ではなく、ピクセル単位で行うこ
とができます。

   ‘C-x 5 0’ (‘delete-frame’)コマンドは、選択されたフレームを削除します
。しかしEmacsセッションとの対話能力が失われるのを防ぐため、Emacsセッショ
ンの最後のフレームの削除は拒絶します。Emacsがデーモンとして実行されてい
るとき(*note Emacs Server::を参照してください)は、普通の対話的なフレーム
がすべて削除された後も、常に“仮想的なフレーム(virtual frame)”が残ります
。この場合、‘C-x 5 0’は最後の対話的なフレームを削除できます。Emacsセッシ
ョンに再接続するには、‘emacsclient’を使うことができます。

   ‘C-x 5 1’ (‘delete-other-frames’)コマンドは、現在の端末(端末にはグラ
フィカルなディスプレーとテキスト端末の両方が含まれます)の、カレントのフ
レーム以外のすべてのフレームを削除します。*note Non-Window Terminals::を
参照してください)。他のグラフィカルなディスプレー、またはテキスト端末で
開いたフレームをもっている場合、これらは削除されません。

   ‘C-x 5 o’ (‘other-frame’)コマンドは、現在の端末の次のフレームを選択し
ます。EmacsをXウィンドウシステム上のウィンドウマネージャーで使っていて、
どんなフレームだろうと、マウスカーソルが上にくるとそのフレームを選択(ま
たは“フォーカスを与える”)するようになっている場合、このコマンドが正常に
機能するために、変数‘focus-follows-mouse’を‘t’に変更する必要があります。
これは‘C-x 5 o’を呼び出し、マウスカーソルを選択されたフレームにワープさ
せます。


File: emacs-ja.info,  Node: Fonts,  Next: Speedbar,  Prev: Frame Commands,  Up: Frames

21.8 フォント
=============

デフォルトでは、Emacsはグラフィカルなディスプレーでテキストを表示するの
に、10ポイントのmonospaceフォントを使います。違うフォントを指定する異な
る方法がいくつかあります:

   • ‘Options’メニューの‘Set Default Font’をクリックします。これは既存の
     グラフィカルなフレームすべてのデフォルトを、選択したフォントにしま
     す。これを将来のセッションのために保存するには、‘Options’メニューの
     ‘Save Options’をクリックしてください。

   • 以下のように、‘font’パラメーターを指定するように、変数
     ‘default-frame-alist’を変更する行をinitファイルに追加します:

          (add-to-list 'default-frame-alist
                       '(font . "DejaVu Sans Mono-10"))

     これはこのinitファイルで再起動した後の、Emacsが作るすべてのグラフィ
     カルなフレームのデフォルトを、指定したフォントにします。

   • 以下のようにXリソースファイルに、Xリソースセッティング
     ‘emacs.font’を追加します:

          emacs.font: DejaVu Sans Mono-12

     Xリソースファイルが効果を表すには、Xを再起動するか‘xrdb’コマンドを
     使わなければなりません。*note Resources::を参照してください。Xリソ
     ースファイルでは、フォント名をクォートしないでください。

   • EmacsをGNOMEデスクトップで実行している場合、変数
     ‘font-use-system-font’を‘t’(デフォルトは‘nil’)にセットして、Emacsに
     デフォルトのシステムフォントを使うように指示できます。これが機能す
     るには、EmacsがGconfサポートつきでコンパイルされていなければなりま
     せん。

   • コマンドラインオプション‘-fn’(または‘--font’)を使います。*note Font
     X::を参照してください。

   現在使っているフォントをチェックするには、‘C-u C-x =’コマンドが有用で
す。これはポイント位置の文字の説明と、それを描画しているフォント名を表示
します。

   Xでは、“フォント名”を表現する異なる方法がいくつか存在します。1番目は
“Fontconfigパターン”を使う方法です。Fontconfigパターンは以下の形式をもち
ます:

     FONTNAME[-FONTSIZE][:NAME1=VALUES1][:NAME2=VALUES2]...

このフォーマットでは、大カッコ(braces)の中の要素は省略可能です。
FONTNAMEは、‘Monospace’や‘DejaVu Sans Mono’のような、フォントの“ファミリ
ー名”です。FONTSIZEは、フォントの“ポイントサイズ”(1“プリンターポイント
”はおよそ1/72インチです)で、エントリー‘NAME=VALUES’は、フォントのslantや
weightなどのセッティングを指定します。VALUESには1つの値か、カンマで区切
られた値のリストを指定します。それらに加えていくつかのプロパティー値は、
ある種のプロパティー名だけで有効なものがあり、それらについては‘NAME=’部
分を省略できます。

   以下は、一般的なフォントプロパティーの一覧です:

‘slant’
     ‘italic’、‘oblique’、‘roman’のうちの、どれか1つです。

‘weight’
     ‘light’、‘medium’、‘demibold’、‘bold’、‘black’のうちの、どれか1つで
     す。

‘style’
     slantとweightを組み合わせた、特別なstyleを定義するフォントがいくつ
     かあります。たとえば‘Dejavu Sans’は、‘book’ styleを定義し、これは
     slantおよびweightプロパティーをオーバーライドします。

‘width’
     ‘condensed’、‘normal’、‘expanded’のうちの、どれか1つです。

‘spacing’
     ‘monospace’、‘proportional’、‘dual-width’、‘charcell’のうちの、どれ
     か1つです。

以下はFontconfigパターンの例です:

     Monospace
     Monospace-12
     Monospace-12:bold
     DejaVu Sans Mono:bold:italic
     Monospace-12:weight=bold:slant=italic

   Fontconfigパターンの、より詳細な説明は、Fontconfigのマニュアルを参照
してください。これはFontconfigとともに配布されており、
<http://fontconfig.org/fontconfig-user.html>からオンラインで利用可能です
。

   フォントを指定する2番目の方法は、“GTKフォントパターン”を使う方法です
。これらは以下の構文を使います。

     FONTNAME [PROPERTIES] [FONTSIZE]

FONTNAMEはファミリー名、PROPERTIESはスペースで区切られたプロパティー値の
リストで、FONTSIZEはポイントサイズです。GTKフォントパターンで指定するプ
ロパティーは以下のようなものでしょう:

   • Slantプロパティー: ‘Italic’、‘Oblique’。省略したときはデフォルトの
     slant(roman)が暗に指定されます。
   • Weightプロパティー: ‘Bold’、‘Book’、‘Light’、‘Medium’、
     ‘Semi-bold’、‘Ultra-light’。省略したときは‘Medium’ weightが暗に指定
     されます。
   • Widthプロパティー: ‘Semi-Condensed’、‘Condensed’。省略したときはデ
     フォルトのwidthが使用されます。

以下にGTKフォントパターンの例をいくつか示します:

     Monospace 12
     Monospace Bold Italic 12

   フォントを指定する3番目の方法は、“XLFD”(“X Logical Font
Description”)を使う方法です。これはXでフォントを指定する際の伝統的な手法
です。以下のように、各XLFDは14の単語か数字をダッシュで区切ったものからな
ります:

     -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

XLFDでのワイルドカード文字(‘*’)は、任意の文字の並び(noneを含む)にマッチ
し、‘?’は任意の1文字にマッチします。しかしマッチングは実装依存で、長い名
前の中のダッシュにたいするワイルドカードのマッチが不正確なことがあります
。信頼できる結果を得るためには、14個すべてのダッシュを指定して、ワイルド
カードを1つのフィールドだけに使います。XLFDでは大文字小文字の違いは重要
ではありません。XLFDの構文は以下のとおりです:

     -MAKER-FAMILY-WEIGHT-SLANT-WIDTHTYPE-STYLE...
     ...-PIXELS-HEIGHT-HORIZ-VERT-SPACING-WIDTH-REGISTRY-ENCODING

エントリーは以下の意味をもちます:

MAKER
     フォントのmanufacturer(製造者名)です。
FAMILY
     フォントのファミリー名です(たとえば‘courier’)。
WEIGHT
     フォントのweightで、通常は‘bold’、‘medium’、‘light’のどれかです。他
     の値をサポートするフォント名もいくつかあります。
SLANT
     フォントのslantで、通常は‘r’(roman)、‘i’(italic)、‘o’(oblique)、
     ‘ri’(reverse italic)、‘ot’(other)のどれかです。他の値をサポートする
     フォント名もいくつかあります。
WIDTHTYPE
     フォントのwidthで、通常は‘normal’、‘condensed’、‘semicondensed’、
     ‘extended’のどれかです。他の値をサポートするフォント名もいくつかあ
     ります。
STYLE
     任意の補足的なstyle名です。通常は空で、ほとんどのXLFDでは、この場所
     に連続して2つのハイフンが記述されます。
PIXELS
     フォントのheightをピクセルで指定します。
HEIGHT
     プリンターのポイントの1/10を単位とした、スクリーン上のフォントの
     heightです。フォントのポイントサイズの10倍です。垂直解像度(vertical
     resolution)を与えれば、HEIGHTとPIXELSは比例します。したがって一方を
     指定して、もう一方に‘*’を指定するのが一般的です。
HORIZ
     フォントが意図するインチあたりのピクセル数で表した、水平解像度
     (horizontal resolution)です。
VERT
     フォントが意図するインチあたりのピクセル数で表した、垂直解像度
     (vertical resolution)です。通常、システムのフォント解像度は、スクリ
     ーンにたいして正しい値になっています。したがって、これとHORIZには
     ‘*’を指定するのが普通です。
SPACING
     これには‘m’(monospace)、‘p’(proportional)、‘c’(character cell)を指
     定します。
WIDTH
     ピクセル単位で表した文字の平均widthの10倍です。
REGISTRY
ENCODING
     フォントを描画するXフォント文字セット(X font character set)です(Xフ
     ォント文字セットはEmacs文字セットと同じではありませんが、似ています
     )。フォントの選択をチェックするのに、‘xfontsel’コマンドを使うことが
     できます。通常は、REGISTRYに‘iso8859’、ENCODINGに‘1’を使うべきです
     。

   フォントを指定する4番目の方法は、“フォントニックネーム(font
nickname)”を使う方法です。特定のフォントは通常のフォント指定のかわりに、
短いニックネームをもつものがあります。たとえば‘6x13’は以下と同じです

     -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

   X上でのEmacsは、2つのタイプのフォントを認識します。1つは“クライアント
サイド”のフォントで、これはXftおよびFontconfigライブラリーにより提供され
ます。もう1つは“サーバーサイド”のフォントで、これはXサーバー自身により提
供されます。ほとんどのクライアントサイドフォントは、アンチエイリアシング
(antialiasing)やサブピクセルンティング(subpixel hinting)などの、サーバー
サイドフォントにはない、進んだフォント機能をサポートします。Fontconfigと
GTKパターンは、クライアントサイドフォントだけにマッチします。

   すべての文字が同じ幅をもつ固定幅フォントを使いたいと思うでしょう。
XftおよびFontconfigフォントでは、‘fc-list’コマンドを使って、以下のように
して利用可能な固定幅フォントを一覧することができます。

     fc-list :spacing=mono
     fc-list :spacing=charcell

サーバーサイドのXフォントにたいしては、‘xlsfonts’プログラムを使って、以
下のようにして利用可能な固定幅フォントを一覧することができます。

     xlsfonts -fn '*x*' | egrep "^[0-9]+x[0-9]+"
     xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-m*'
     xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-c*'

XLFDのSPACINGフィールドが、‘m’または‘c’のフォントは固定幅フォントです。
特定のフォントの外見を見るには、以下のように‘xfd’コマンドを使います:

     xfd -fn 6x13

これはフォント‘6x13’の全体を表示します。

   Emacsを実行しているときは、特定の種類のテキスト(*note Faces::を参照し
てください)や、特定のフレーム(*note Frame Parameters::を参照してください
)のフォントをセットすることもできます。


File: emacs-ja.info,  Node: Speedbar,  Next: Multiple Displays,  Prev: Fonts,  Up: Frames

21.9 スピードバーフレーム
=========================

“スピードバー(speedbar)”は、簡単に他のフレームを操作したり処理するための
、特別なフレームです。スピードバーが存在するとき、それは常に“アタッチさ
れたフレーム(attached frame)”と呼ばれる、特定のフレームに対応しています
。すべてのスピードバー操作は、そのフレームにたいして処理されます。

   ‘M-x speedbar’とタイプすると、スピードバーを作成して、カレントフレー
ムに関連付けます。スピードバーを解除するには、再度‘M-x speedbar’とタイプ
するか、スピードバーを選択して‘q’とタイプします(他のEmacsフレームを削除
するのと同じ方法で、スピードバーフレームを削除することもできます)。スピ
ードバーを他のフレームに関連付けたいときは、一旦解除してから、そのフレー
ムで‘M-x speedbar’を呼び出します。

   スピードバーは、さまざまなモードを処理できます。デフォルトモードは
“File Display(ファイル表示)”モードで、これはアタッチされたフレームの、選
択されたウィンドウのカレントディレクトリーのファイルを、1行に1ファイルず
つ表示します。ファイル名をクリックすると、アタッチされたフレームの、選択
されたウィンドウでそのファイルをvisitし、ディレクトリー名をクリックする
と、スピードバーでそのディレクトリーを表示します(*note Mouse
References::を参照してください)。各行には‘[+]’や‘<+>’が記されたボックス
があり、それをクリックすると、そのアイテムの内容を“展開”します。ディレク
トリーを展開すると、ディレクトリーの内容を、ディレクトリー自身の行の下に
加えてスピードバー表示します。通常のファイルを展開すると、ファイルの中の
tagリストをスピードバー表示に加えます。tag名をクリックして、アタッチされ
たフレームの選択されたウィンドウで、tagにジャンプできます。ファイルまた
はディレクトリーが展開されているときは、‘[+]’が‘[-]’に変化します。ボック
スを再度クリックすると、アイテムを収納して、内容を隠すことができます。

   キーボードを使ってスピードバーを操作することもできます。スピードバー
でポイントのある行で<RET>をタイプするのは、そのアイテムをクリックするの
と等しく、<SPC>はアイテムを展開または収納します。‘U’は、カレントディレク
トリーの親ディレクトリーを表示します。カレント行のファイルをコピー、削除
、リネーム<するには、‘C’、‘D’、‘R’をタイプします。新しいディレクトリーを
作成するには、‘M’をタイプします。

   スピードバーのモードで、他に一般的な目的に使われるのは“Buffer
Display(バッファー表示)”モードです。このモードでは、スピードバーは
Emacsバッファーのリストを表示します。このモードに切り替えるにはスピード
バーで‘b’をタイプします。File Displayモードに戻るには、‘f’をタイプします
。スピードバーのウィンドウのどこかを‘mouse-3’でクリック(またはモードライ
ンを‘mouse-1’でクリック)して、ポップアップメニューの‘Displays’を選択して
も、表示モードを変更することができます。

   Rmailモード、Info、GUDを含むいくつかのメジャーモードは、スピードバー
に選択可能な便利なアイテムを配する、特別な方法をもっています。たとえば
Rmailモードでは、スピードバーはRmailファイルのリストを表示し、カレントメ
ッセージを他のRmailファイルに移動する場合は、それの‘<M>’ボックスをクリッ
クします。

   スピードバーの使い方とプログラミングに関する詳細は、*note Speedbar:
(speedbar)Top.を参照してください。


File: emacs-ja.info,  Node: Multiple Displays,  Next: Frame Parameters,  Prev: Speedbar,  Up: Frames

21.10 複数ディスプレー
======================

1つのEmacsが、1つ以上のXディスプレーと通信できます。最初、Emacsは環境変
数‘DISPLAY’、または‘--display’オプション(*note Initial Options::を参照し
てください)で指定された、ただ1つのディスプレーに表示されます。他のディス
プレーに接続するには、コマンド‘make-frame-on-display’を使います:

‘M-x make-frame-on-display <RET> DISPLAY <RET>’
     ディスプレーDISPLAYに新しいフレームを作成します。

   1つのXサーバーは、1つ以上のスクリーンを処理できます。1つのサーバーに
属する2つのスクリーンでフレームを開いた場合、Emacsはそれらが1つのキーボ
ードを共有するのを知っているので、これらのスクリーンから到着するすべての
コマンドを1つの入力ストリームとして扱います。

   異なるXサーバーでフレームを開いた場合、Emacsは各サーバーごとに別な入
力ストリームを作成します。各サーバーは、それぞれ選択されたフレームをもち
ます。特定のXサーバーで入力したコマンドは、そのサーバーの選択されたフレ
ームに適用されます。


File: emacs-ja.info,  Node: Frame Parameters,  Next: Scroll Bars,  Prev: Multiple Displays,  Up: Frames

21.11 フレームパラメーター
==========================

変数‘default-frame-alist’の中の、“フレームパラメーター(frame
parameters)”のデフォルトリストを指定することにより、すべてのフレームのデ
フォルトの外見と振る舞いを制御することができます。この値はエントリーのリ
ストで、各エントリーにはパラメーター名と、そのパラメーターの値を指定しま
す。これらのエントリーはEmacsが新しいフレームを作るとき(初期フレームを含
む)に効果を及ぼします。

   たとえば以下のファイルをinitファイル(*note Init File::を参照してくだ
さい)に追加することにより、デフォルトのフレーム幅が90列、デフォルトのフ
レーム高さが40行、デフォルトフォントに‘Monospace-10’を指定します。

     (add-to-list 'default-frame-alist '(width  . 90))
     (add-to-list 'default-frame-alist '(height . 40))
     (add-to-list 'default-frame-alist '(font . "Monospace-10"))

   フレームパラメーターのリストと、その効果については、*note
(elisp)Frame Parameters::を参照してください.

   変数‘initial-frame-alist’をカスタマイズすることにより、初期フレームだ
けに適用されるフレームパラメーターのリストを指定することもできます。

   EmacsがX ツールキットを使ってコンパイルされている場合、カラーとフォン
トを指定するフレームパラメーターは、メニューとメニューバーには影響を及ぼ
しません。なぜなら、それらはEmacsが直接描画しているのではなく、ツールキ
ットにより描画されているからです。


File: emacs-ja.info,  Node: Scroll Bars,  Next: Drag and Drop,  Prev: Frame Parameters,  Up: Frames

21.12 スクロールバー
====================

グラフィカルなディスプレーでは、Emacsウィンドの横に“スクロールバー”があ
ります。スクロールバーのupボタンまたはdownボタンを‘Mouse-1’でクリックす
ると、ウィンドウを1行ずつスクロールします。スクロールバー内部のボックス
の上または下を‘Mouse-1’でクリックすると、‘M-v’または‘C-v’と同様に、ほぼ
ウィンドウ全体の高さ分スクロールします(*note Moving Point::を参照してく
ださい)。スクロールバー内部のボックスをドラッグすると、連続してスクロー
ルします。

   EmacsがXウィンドウシステム上でXツールキットサポートなしでコンパイルさ
れている場合、スクロールバーは違った振る舞いをします。スクロールバーの任
意の箇所を‘Mouse-1’でクリックすると‘C-v’のように前方にスクロールし、
‘Mouse-3’でクリックすると‘M-v’のように後方にスクロールします。スクロール
バーで‘Mouse-2’をクリックすると、スクロールバー内部のボックスを上下にド
ラッグできます。

   スクロールバーの使用を切り替えるには、‘M-x scroll-bar-mode’とタイプし
ます。このコマンドは、まだ作成されていないフレームも含めて、すべてのフレ
ームに適用されます。選択されたフレームのスクロールバーだけ切り替えたい場
合は、コマンド‘M-x toggle-scroll-bar’を使用してください。

   起動時にスクロールバーの使用を制御するには、変数‘scroll-bar-mode’をカ
スタマイズします。この変数の値は、‘right’(ウィンドウの右にスクロールバー
を配します)、‘left’(ウィンドウの左にスクロールバーを配します)、‘nil’(ス
クロールバーを無効にします)のどれかです。EmacsがXウィンドウシステム上で
GTK+サポートつきでコンパイルされている、またはMS-Windows、Mac OSの場合、
デフォルトでは右にスクロールバーを配します。EmacsがXウィンドウシステム上
でGTK+サポートなしでコンパイルされている場合、(古いXアプリケーションの慣
例にしたがって)スクロールバーを左に配します。

   Xリソース‘verticalScrollBars’を使って、スクロールバーを有効または無効
にすることができます(*note Resources::を参照してください)。スクロールバ
ーの幅を制御するにはフレームパラメーター‘scroll-bar-width’を変更してくだ
さい(*note (elisp)Frame Parameters::を参照してください)。

   (GTK+またはMotifとともに)X上でEmacsを使っている場合、変数
‘scroll-bar-adjust-thumb-portion’をカスタマイズして、スクロールバーの“オ
ーバースクロール(overscrolling: たとえばバッファーの最後が表示されていて
もさらに下にスクロールします)”を制御できます。変数の値が非‘nil’の場合、
バッファーの最後が表示されていてもスクロールバーを下にドラッグできます。
‘nil’の場合、バッファーの最後が表示されたとき、内部のボックスはスクロー
ルバーの最下になります。バッファー全体が表示されているときは、オーバース
クロールできません。

   スクロールバーの視覚的な外見は、‘scroll-bar’フェイスにより制御されま
す。


File: emacs-ja.info,  Node: Drag and Drop,  Next: Menu Bars,  Prev: Scroll Bars,  Up: Frames

21.13 ドラッグアンドドロップ
============================

ほとんどのグラフィカルなデスクトップ環境で、Emacsは“ドラッグアンドドロッ
プ(drag and drop)”操作にたいする、基本的なサポートを提供します。たとえば
Emacsのフレームにテキストをドロップすると、ドロップされた箇所にテキスト
を挿入し、ファイルをドロップすると、Emacsフレームはそのファイルをvisitし
ます。特別なケースとしては、Diredバッファーにファイルをドロップすること
により、バッファーに表示されているディレクトリーにファイルを移動またはコ
ピーします(アプリケーションの慣例に基づきます)。

   ファイルをドロップすると、通常はドロップされたウィンドウでファイルを
visitします。そのような場合に、新しいウィンドウでファイルをvisitしたいと
きは、変数‘dnd-open-file-other-window’をカスタマイズします。

   現在のところ、XDNDおよびMotif drag and drop protocolsと、古いKDE 1.x
protocolがサポートされています。


File: emacs-ja.info,  Node: Menu Bars,  Next: Tool Bars,  Prev: Drag and Drop,  Up: Frames

21.14 メニューバー
==================

‘M-x menu-bar-mode’で、メニューバーの使用を切り替えることができます。引
数を指定しないと、このコマンドはグローバルマイナーモードのMenu Barを切り
替えます。引数を指定した場合、引数が正ならMenu Barモードをオンにして、負
ならオフにします。起動時にメニューバーの使用を制御するには、変数
‘menu-bar-mode’をカスタマイズしてください。

   熟練したユーザーは、テキストのために更なる行を得るために、メニューを
オフにしている場合がしばしばあります(特にテキスト端末時)。メニューバーが
オフでも、ポップアップメニューをサポートするディスプレーなら、
‘C-Mouse-3’でメニュー内容を含むポップアップメニューを表示できます。*note
Menu Mouse Clicks::を参照してください。

   メニューバーのコマンドを呼び出す方法については、*note Menu Bar::を参
照してください。メニューバーのメニューの視覚的な外見をカスタマイズする方
法は、*note X Resources::を参照してください。


File: emacs-ja.info,  Node: Tool Bars,  Next: Dialog Boxes,  Prev: Menu Bars,  Up: Frames

21.15 ツールバー
================

グラフィカルなディスプレーでは、Emacsはフレームのトップ、メニューバーの
直下に“ツールバー(tool bar)”を配します。これはマウスでクリックすることに
より、さまざまなコマンドを呼び出すことができるアイコンが1列に並んだもの
です。

   (デフォルトの)グローバルツールバーは、一般的なコマンドを含みます。自
身のツールバーを定義するメジャーモードもいくつか存在します。バッファーが
それらのメジャーモードの場合、モードのツールバーにより、グローバルツール
バーが置き換えられます。

   ツールバーの使用を切り替えるには、‘M-x tool-bar-mode’とタイプします。
このコマンドは、まだ作成されていないフレームを含むすべてのフレームに適用
されます。起動時にツールバーの使用を制御するには、変数‘tool-bar-mode’を
カスタマイズします。

   EmacsがGTK+サポートつきでコンパイルされている場合、ツールバーアイテム
には、イメージ、テキストラベル、またはそれら両方を含むことができます。デ
フォルトではEmacsはGnomeデスクトップの、ツールバースタイルセッティングに
したがいます。もし何も定義されていない場合、ツールバーのアイテムにはイメ
ージだけが表示されます。特定のツールバースタイルを強要するには、変数
‘tool-bar-style’をカスタマイズしてください。

   フレームパラメーター‘tool-bar-position’で、GTK+ツールバーのためのツー
ルバーの配置を制御することもできます。*note (elisp)Frame Parameters::を
参照してください。


File: emacs-ja.info,  Node: Dialog Boxes,  Next: Tooltips,  Prev: Tool Bars,  Up: Frames

21.16 ダイアログボックスの使用
==============================

ダイアログボックスとは、yes-or-noの質問(はい／いいえで応える問いかけ)を
したり、他の何か特別な質問を問いかけるための、特別な種類のメニューです。
コマンドを呼び出すためにマウスを使い、それがユーザーへの質問を要するよう
な操作の場合、多くのEmacsコマンドはyes-or-noを問うために、ダイアログボッ
クスを使います。

   ダイアログボックスの使用を無効にするには、変数‘use-dialog-box’を
‘nil’に変更します。この場合、Emacsはエコーエリアとキーボード入力を使って
yes-or-noプロンプトを処理します。この変数はファイル選択ウィンドウの使用
も制御します(しかしこれらはすべてのプラットフォームでサポートされている
わけではありません)。

   ファイル選択ウィンドウはファイル名を問うための、特別な種類のダイアロ
グボックスです。変数‘use-file-dialog’をカスタマイズすれば、他の種類のダ
イアログボックスの使用して、ファイル選択ウィンドウを使用しないようにでき
ます。変数‘use-dialog-box’ですべてのダイアログボックスを使用しないように
している場合、この変数は効果がありません。

   EmacsがGTK+サポートつきでコンパイルされている場合、EmacsはGTK+の“ファ
イル選択”ダイアログを使います。Emacsは非表示のファイル(名前がドットで始
まるファイル)の表示の有効・無効を切り替えるボタンを、ダイアログボックス
に追加します。この切り替えをデフォルトで有効にしたい場合、変数
‘x-gtk-show-hidden-files’を‘t’に変更します。さらにEmacsは、GTK+ファイル
選択ダイアログにヘルプテキストを追加します。このヘルプテキストを無効にす
るには、変数‘x-gtk-file-dialog-help-text’を‘nil’に変更してください。


File: emacs-ja.info,  Node: Tooltips,  Next: Mouse Avoidance,  Prev: Dialog Boxes,  Up: Frames

21.17 ツールチップ
==================

“ツールチップ”は、小さなウィンドウに現在のマウス位置のテキスト情報を表示
します。ツールチップはウィンドウの重要なテキストの上や、ツールバーのボタ
ンやメニューアイテムのような、Emacsフレームの他の部分の上でマウスを停止
させたときにアクティブになります。

   ツールチップの使用は、コマンド‘M-x tooltip-mode’で切り替えることがで
きます。Tooltipモードが無効な場合、ヘルプテキストは、かわりにエコーエリ
アに表示されます。ツールチップの使用を起動時に制御するには、変数
‘tooltip-mode’をカスタマイズしてください。

   変数‘tooltip-delay’は、ツールチップを表示するまでEmacsがどれだけ待つ
べきかを指定します。ツールチップの表示についての追加のカスタマイズオプシ
ョンは、‘M-x customize-group <RET> tooltip <RET>’を使います。

   EmacsがGTK+サポートつきでビルドされている場合、ツールチップはGTK+を通
じて、GTK+のツールチップのデフォルトの外見を使います。これを無効にするに
は、変数‘x-gtk-use-system-tooltips’を‘nil’に変更します。これを行うか、
EmacsがGTK+サポートなしでビルドされた場合は、ツールチップテキストのほと
んどの属性は‘tooltip’フェイスとXリソース(*note X Resources::を参照してく
ださい)により指定されます。

   “GUDツールチップ”は、プログラムをGUDでデバッグしているときに変数の値
を表示する、特別なツールチップです。*note Debugger Operation::を参照して
ください。


File: emacs-ja.info,  Node: Mouse Avoidance,  Next: Non-Window Terminals,  Prev: Tooltips,  Up: Frames

21.18 マウスの回避
==================

グラフィカルな端末では、マウスポインターがEmacsフレームのテキストを隠し
てしまうことがありえます。この問題を避けるために、Emacsは2つの方法を提供
します。

   1番目の方法は、ユーザーが自己挿入文字をタイプしたとき、Emacsがマウス
ポインターを非表示にして、マウスポインターを動かしたときに、ポインターが
Emacsフレームの内側にあるときは、再びポインターを表示する方法です。この
機能を無効にするには、変数‘make-pointer-invisible’を‘nil’にセットしてく
ださい。

   2番目の方法はMouse Avoidance(マウス回避)モードを使って、マウスポイン
ターをポイントから遠ざける方法です。Mouse Avoidanceモードを使うには、変
数‘mouse-avoidance-mode’をカスタマイズします。この変数にさまざまな値をセ
ットすることにより、マウスを遠ざけるいくつかの方法を選択できます。

‘banish’
     キーが押されたらポインターをフレームの隅に移動します。ポインターを
     どこに遠ざけるかは、変数‘mouse-avoidance-banish-position’でカスタマ
     イズできます。
‘exile’
     カーソルがポインターに近づきすぎたときだけポインターを遠ざけて、カ
     ーソルが離れたらポインターを元に戻します。
‘jump’
     カーソルがポインターに近づきすぎたら、ランダムな方向と距離にポイン
     ターを移動します。
‘animate’
     ‘jump’と同様ですが、移動モーションをアニメ化します。
‘cat-and-mouse’
     ‘animate’と同じです。
‘proteus’
     ‘animate’と同様ですが、マウスポインターの外見も変更します。

   コマンド‘M-x mouse-avoidance-mode’を使って、このモードを有効にするこ
ともできます。Mouse Avoidanceモードがマウスを移動したときは、常にそのフ
レームを前に表示します。


File: emacs-ja.info,  Node: Non-Window Terminals,  Next: Text-Only Mouse,  Prev: Mouse Avoidance,  Up: Frames

21.19 非ウィンドウ端末
======================

テキスト端末では、Emacsは1度に1つのEmacsフレームしか表示できません。それ
でも複数のEmacsフレームを作成して、それらを切り替えることができます。こ
れらの端末でフレームを切り替えるのは、異なるウィンドウの設定を切り替える
のによく似ています。

   ‘C-x 5 2’を使うと新しいフレームを作成してそれに切り替えます。‘C-x 5
o’を使うと既存のフレームを巡回します。‘C-x 5 0’を使うと、カレントフレー
ムを削除します。

   各フレームには区別するための番号があります。端末が1度に1つのフレーム
しか表示できない場合、選択されたフレームの番号Nが、モードラインの先頭に
近い位置に、‘FN’という形式で表示されます。

   ‘FN’は、フレームの実際の初期名称です。フレームにもっと意味のある名前
を与えて、その名前でフレームを選択できます。コマンド‘M-x set-frame-name
<RET> NAME <RET>’を使うと、選択されたフレームに新しい名前を指定し、‘M-x
select-frame-by-name <RET> NAME <RET>’を使うとその名前に一致するフレーム
を選択します。指定した名前は、そのフレームが選択されたときに、モードライ
ンに表示されます。


File: emacs-ja.info,  Node: Text-Only Mouse,  Prev: Non-Window Terminals,  Up: Frames

21.20 テキスト端末でのマウスの使用
==================================

端末ウィンドウでのマウスクリックをサポートするテキスト端末がいくつかあり
ます。

   ‘xterm’と互換性のある端末エミュレーターでは、‘M-x xterm-mouse-mode’を
使って、Emacsに簡単なマウスの使用 — 基本的には修飾なしのシングルクリック
だけがサポートされます — を制御させることができます。そのようなクリック
にたいする通常の‘xterm’のマウス機能は、マウスボタンを押すときに‘SHIFT’キ
ーを押すことにより、利用できます。Xterm Mouseモードはグローバルマイナー
モードです(*note Minor Modes::を参照してください)。コマンドを繰り返すと
、このモードを再びオフにします。

   GNU/Linuxのコンソールでは、‘M-x gpm-mouse-mode’を使ってマウスサポート
を有効にできます。これが機能するためにはgpmサーバーがインストールされて
いて、システムで実行されていなければなりません。

   MS-DOSでのマウスサポートに関する情報は、*note MS-DOS Mouse::を参照し
てください 。


File: emacs-ja.info,  Node: International,  Next: Modes,  Prev: Frames,  Up: Top

22 国際化文字セットのサポート
*****************************

Emacsは、広範囲な国際化文字セット(international character sets)をサポー
トします。それらには、ラテンアルファベットの変種であるEuropeanと
Vietnamese、同様にArabic scripts、(Bengali、Hindi、Thaiのような言語にた
いする)Brahmic scripts 、Cyrillic、Ethiopic、Georgian、Greek、(Chineseと
Japaneseにたいする)Han、(Koreanにたいする)Hangul、Hebrew、IPAが含まれま
す。Emacsは他の国際化されたソフトウェアー(ワープロやメーラー)などで使わ
れる、それらの文字にたいするさまざまなエンコーディングもサポートします。

   Emacsは関連するアクティビティーのすべてをサポートすることにより、国際
化文字セットの編集を可能にします:

   • 非ASCII文字のファイルをvisitしたり、非ASCIIのテキストを保存したり、
     非ASCIIのテキストを、EmacsとEmacsが呼び出すプログラム(コンパイラー
     、スペルチェッカー、メーラーなど)に引き渡すことができます。言語環境
     のセッティングとは、コーディングシステムのセッティングと、その他の
     言語に特有な文化のためのオプションを処理することです。かわりに各コ
     マンドにエンコードあるいはデコードする方法を指定できます。*note
     Text Coding::を参照してください.

   • さまざまなスクリプトでエンコードされた、非ASCII文字を表示することが
     できます。これはグラフィカルなディスプレー上で適切なフォントを使う
     こと(*note Defining Fontsets::を参照してください)、そしてテキスト表
     示のために特別なコードを送信すること(*note Terminal Coding::を参照
     してください)により機能します。正しく表示できない文字があるときは、
     *note Undisplayable Characters::を参照してください。これには考えら
     れる原因と、解決方法が記述されています。

   • 本来、右から左に記述されるスクリプトの文字は、表示のために再配置さ
     れます。これらのスクリプトにはArabic、Hebrew、Syriac、Thaana、それ
     以外にもいくつか存在します。

   • 非ASCII文字を挿入したり検索することができます。これを行うために、言
     語にあったインプットメソッド(IM: input method。*note Select Input
     Method::を参照してください)を指定するか、言語環境を選択したときにセ
     ットアップされた、デフォルトのインプットメソッドを使うことができま
     す。キーボードが非ASCII文字を生成できる場合、適切なキーボードコーデ
     ィングシステムを選択できます。Emacsはそれらの文字を受け入れることが
     できるでしょう。Latin-1文字は、‘C-x 8’プレフィクスを使って入力する
     こともできます。*note Unibyte Mode::を参照してください.

     Xウィンドウシステムでは、Emacsがキーボード入力を正しく解釈するため
     に、localeに適切な値をセットする必要があります。*note locales:
     Language Environments.を参照してください。

   このチャプターの残りの部分では、これらの問題について詳細を説明します
。

* Menu:

* International Chars::      マルチバイト文字の基本的な概念。
* Language Environments::    使用する言語のためのセットアップ事項。
* Input Methods::            キーボードにないテキスト文字の入力。
* Select Input Method::      インプットメソッド選択を指定する。
* Coding Systems::           ファイルを読み書きしたりするときの文字セット変換。
* Recognize Coding::         どの変換を使用するかをEmacsが解決する方法。
* Specify Coding::           ファイルのコーディングシステムの明示的な指定。
* Output Coding::            出力のためのコーディングシステムの選択について。
* Text Coding::              ファイルのテキストに使う変換の選択。
* Communication Coding::     プロセス間通信のためのコーディングシステム。
* File Name Coding::         _ファイル名_のコーディングシステム。
* Terminal Coding::          端末の入出力の変換のためのコーディングシステムの指定。
* Fontsets::                 フォントセット、それは文字の全範囲をカバーするフォントのコレクション。
* Defining Fontsets::        新しいフォントセットの定義。
* Modifying Fontsets::       既存のフォントセットの修正。
* Undisplayable Characters::  文字が表示されないとき。
* Unibyte Mode::             マルチバイト文字を使わずに1つの英文字セットを選択する。
* Charsets::                 Emacsが内部の文字コードをグループ化する方法。
* Bidirectional Editing::    右から左に記述する言語のサポート。


File: emacs-ja.info,  Node: International Chars,  Next: Language Environments,  Up: International

22.1 国際化文字セットのイントロダクション
=========================================

国際化文字セットとスクリプトのユーザーは、ファイルを保存するために、多少
の差はありますが、標準化された多くのコーディングシステムを確立しています
。これらのコーディングシステムは通常は“マルチバイト(multibyte)”で、これ
は1つの非ASCII文字を表すのに、2つ以上のバイトシーケンスを対応させること
を意味します。

   Emacsは、内部的には“Unicode”標準のスーパーセットである、マルチバイト
文字エンコーディングを使用します。この内部的なエンコーディングは、ほとん
どすべての既知のスクリプトを、1つのバッファーまたは文字列に混成すること
を可能にします。Emacsはファイルを読み書きしたり、サブプロセスとデータを
やりとりするとき、このマルチバイト文字エンコーディングと、他のさまざまな
コーディングシステムをコード変換します。

   コマンド‘C-h h’ (‘view-hello-file’)は、ファイル‘etc/HELLO’を表示しま
す。これは、多くの異なる言語で、“hello”をどのように記述するかを、さまざ
まな文字で例示するファイルです。もしもある文字が端末で表示できないときは
、それらの文字は‘?’か、中抜きのボックスで表示されます。

   これらの文字セットを使う国のキーボードでも、一般的にはすべての文字に
対応するキーはもっていません。キーボードがサポートしない文字は、‘C-q’
(‘quoted-insert’)、または‘C-x 8 <RET>’ (‘insert-char’)を使って挿入するこ
とができます。*note Inserting Text::を参照してください。Emacsはさまざま
な“インプットメソッド(IM: input methods)”をサポートします。これはある字
体の文字をタイプするのを簡単にするもので、通常1つの字体または言語に1つで
す。*note Input Methods::を参照してください。

   プレフィクスキー‘C-x <RET>’は、マルチバイト文字、コーディングシステム
、インプットメソッドに属するコマンドにたいして使用されます。

   コマンド‘C-x =’ (‘what-cursor-position’)は、ポイント位置にある文字の
情報を表示します。文字の位置に加えて、*note Position Info::で説明したよ
うに、このコマンドはその文字がどのようにエンコードされているかを表示しま
す。たとえば、このコマンドは文字‘c’に大して、以下のような行をエコーエリ
アに表示します:

     Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

   ‘Char:’の後ろの4つの値は、ポイント位置の文字を説明するためのもので、
1つ目はその文字自身、その後ろに文字コードを10進(decimal)、8進(octal)、
16進(hex)で表示します。非ASCIIのマルチバイト文字の場合、バッファーのコー
ディングシステムでその文字を安全に1バイトでエンコードできる場合は、
‘file’とそのバッファーのコーディングシステムで表した文字コードの16進表記
が続きます。その文字のエンコーディングが1バイトより長い場合、Emacsは
‘file ...’と表示します。

   特別なケースとして、文字コードが128(8進の0200)から159(8進の0237)の範
囲の場合、それは“raw(生)”のバイトを表し、それに対応する表示可能な文字は
ありません。そのような“文字”は‘eight-bit-control’文字セットに属し、エス
ケープされた8進表記で表示されます。このような場合、‘C-x =’は‘file’のかわ
りに、‘part of display ...’と表示します。

   プレフィクス引数を指定した(‘C-u C-x =’)では、その文字の詳細な情報をウ
ィンドウに表示します:

   • 文字セット名(character set name)と、文字セットでその文字が識別され
     るコード。ASCII文字の場合、‘ascii’文字セットに属すると識別されます
     。

   • その文字のスクリプト(script)、構文(syntax)、カテゴリー
     (categories)。

   • 現在のインプットメソッドで(もしその文字をサポートしていれば)、その
     文字を入力するためにタイプするキー。

   • その文字のエンコード。バッファー内部のエンコードと、ファイルに保存
     したときの外部のエンコードの両方。

   • グラフィカルなディスプレーでEmacsを実行しているときはフォント名と、
     その文字にたいするグリフコード(glyph code)。Emacsをテキスト端末で実
     行している場合、端末に送るコード。

   • その文字のテキストプロパティー(*note (elisp)Text Properties::を参照
     してください)。これにはその文字を表示するのに使われるデフォルト以外
     のフェイスと、それを含むオーバーレイ(overlays)が含まれます(*note
     (elisp)Overlays::を参照してください)。

   以下は例です(マニュアルに収まるように折り返している行もあります):

                  position: 1 of 1 (0%), column: 0
                 character: ê (displayed as ê) (codepoint 234, #o352, #xea)
         preferred charset: unicode (Unicode (ISO10646))
     code point in charset: 0xEA
                    script: latin
                    syntax: w        which means: word
                  category: .:Base, L:Left-to-right (strong), c:Chinese,
                            j:Japanese, l:Latin, v:Viet
                  to input: type "C-x 8 RET HEX-CODEPOINT" or "C-x 8 RET NAME"
               buffer code: #xC3 #xAA
                 file code: #xC3 #xAA (encoded by coding system utf-8-unix)
                   display: by this font (glyph code)
         xft:-unknown-DejaVu Sans Mono-normal-normal-
             normal-*-15-*-*-*-m-0-iso10646-1 (#xAC)

     Character code properties: customize what to show
       name: LATIN SMALL LETTER E WITH CIRCUMFLEX
       old-name: LATIN SMALL LETTER E CIRCUMFLEX
       general-category: Ll (Letter, Lowercase)
       decomposition: (101 770) ('e' '^')


File: emacs-ja.info,  Node: Language Environments,  Next: Input Methods,  Prev: International Chars,  Up: International

22.2 言語環境
=============

サポートされているすべての文字セットは、マルチバイト文字が利用可能なとき
は、Emacsバッファーの中でサポートされます。その文字を表示するために、特
定の言語を選択する必要はありません。しかしさまざまなデフォルト値をセット
するために、“言語環境(language environment)”を選択することは重要です。大
まかに言うと、言語環境とは、言語の選択というよりも、好ましいスクリプト選
択の提示です。

   言語環境は、テキストを読み込むとき、それを認識するコーディングシステ
ムを制御します(*note Recognize Coding::を参照してください)。これはファイ
ル、到着メール、その他のEmacsで読む任意のテキストに適用されます。これは
新しくファイルを作成するときに使う、デフォルトのコーディングシステムも指
定します。それぞれの言語環境は、デフォルトのインプットメソッドも指定しま
す。

   言語環境を選択するには、‘current-language-environment’をカスタマイズ
するか、コマンド‘M-x set-language-environment’を使います。このコマンドを
使うとき、どのバッファーがカレントかで違いは生じません。なぜなら、その効
果はEmacsセッションにグローバルで適用されるからです。サポートされている
言語環境の一覧は、変数‘language-info-alist’を参照してください。コマンド
‘C-h L LANG-ENV <RET>’ (‘describe-language-environment’)を使うと、言語環
境LANG-ENVの、より詳細な情報が参照できます。サポートされる言語環境には、
以下が含まれます:

     ASCII、Arabic、 Belarusian、Bengali、 Brazilian Portuguese、
     Bulgarian、 Burmese、Cham、 Chinese-BIG5、Chinese-CNS、
     Chinese-EUC-TW、Chinese-GB、Chinese-GB18030、Chinese-GBK、
     Croatian、Cyrillic-ALT、Cyrillic-ISO、Cyrillic-KOI8、 Czech、
     Devanagari、 Dutch、English、 Esperanto、Ethiopic、 French、
     Georgian、 German、Greek、Gujarati、 Hebrew、IPA、 Italian、
     Japanese、Kannada、 Khmer、Korean、Lao、 Latin-1、Latin-2、
     Latin-3、Latin-4、Latin-5、Latin-6、Latin-7、Latin-8、Latin-9、
     Latvian、Lithuanian、 Malayalam、Oriya、 Persian、Polish、 Punjabi、
     Romanian、 Russian、Sinhala、 Slovak、Slovenian、Spanish、 Swedish、
     TaiViet、 Tajik、Tamil、 Telugu、Thai、 Tibetan、Turkish、 UTF-8、
     Ukrainian、 Vietnamese、Welsh、 Windows-1255

   グラフィカルなディスプレーでは、使用されている言語環境で使われている
スクリプトを表示するために、適切なフォントをもっている必要があります。フ
ォントのセットアップについては、*note Fontsets::を参照してください。

   環境変数‘LC_ALL’、‘LC_CTYPE’、‘LANG’をセットすることにより、使用する
文字セットのlocaleを指定するオペレーティングシステムがいくつかあります
(もしこれらの１つ以上がセットされている場合、特に1番目のものが空でない場
合、それは正にこの目的のためにlocaleを指定しています)。起動の間、Emacsは
文字セットのlocale名を、システムのlocaleエイリアステーブルから探して、そ
の正規化された名前(canonical name)を、変数
‘locale-charset-language-names’および‘locale-language-names’(前者は後者
をオーバーライドします)のエントリーにたいしてマッチし、マッチが見つかっ
たら対応する言語環境を選択します。これはディスプレーテーブルと端末のコー
ディングシステム、localeコーディングシステム、localeに必要な好ましいコー
ディングシステム — そして最後に重要なのは — Emacsがキーボードから送られ
た非ASCII文字をデコードする方法を調整します。

   Emacs実行中に、(‘M-x setenv’を使って)環境変数‘LC_ALL’、‘LC_CTYPE’、
‘LANG’を変更した場合、新しいlocaleにたいする言語環境を再調整するために、
後で‘set-locale-environment’関数を呼び出したいと思うかもしれません。

   ‘set-locale-environment’関数は通常、システムメッセージをデコードする
ために、言語環境により確立された、優先されるコーディングシステムを使用し
ます。しかしlocaleが変数‘locale-preferred-coding-systems’のエントリーに
マッチした場合、Emacsはかわりに対応するコーディングシステムを使用します
。たとえばlocaleの‘ja_JP.PCK’が、‘locale-preferred-coding-systems’の
‘japanese-shift-jis’にマッチした場合、Emacsは通常なら
‘japanese-iso-8bit’が使われるような場合でも、エンコーディングにそのコー
ディングシステムを使用します。

   initファイルで明示的にコマンド‘set-language-environment’を使うか、
‘current-language-environment’をカスタマイズすることにより、起動時に選択
された言語環境をオーバーライドできます。

   特定の言語環境LANG-ENVの効果に関する情報を表示するには、コマンド‘C-h
L LANG-ENV <RET>’ (‘describe-language-environment’)を使います。これはこ
の言語環境に有効な言語、文字セットのリスト、コーディングシステム、インプ
ットメソッドを表示します。これはこの言語環境で使われるスクリプトを例示す
る、サンプルテキストも表示します。LANG-ENVに空の入力を与えると、このコマ
ンドは選択されている言語環境を説明します。

   ノーマルフック‘set-language-environment-hook’により、任意の言語環境を
カスタマイズできます。コマンド‘set-language-environment’は、新しい言語環
境をセットアップした後に、このフックを実行します。フック関数は変数
‘current-language-environment’をチェックすることにより、特定の言語環境を
テストできます。このフックはキーボード入力にたいするコーディングシステム
や端末出力、デフォルトのインプットメソッドなど、特定の言語環境にたいして
非デフォルトのセッティングが必要な場所に設定します

   新しい言語環境のセットアップを開始する前に、
‘set-language-environment’はまずフック‘exit-language-environment-hook’を
実行します。このフックは‘set-language-environment-hook’によるカスタマイ
ズを取り消すのに便利です。たとえば、特定の言語環境にたいして
‘set-language-environment-hook’を使って特別なキーバインドをセットアップ
した場合は、‘exit-language-environment-hook’で通常のキーバインドに復元す
るべきです。


File: emacs-ja.info,  Node: Input Methods,  Next: Select Input Method,  Prev: Language Environments,  Up: International

22.3 インプットメソッド
=======================

“インプットメソッド(IM: input method)”は、対話的入力のために具体的にデザ
インされた、一種の文字変換です。Emacsでは、各言語はそれ自身のインプット
メソッドをもっています。同じ文字を使う複数の言語で、1つのインプットメソ
ッドを共有できます。複数のインプットメソッドをサポートする言語もあります
。

   一番簡単な種類のインプットメソッドは、ASCII文字を他のアルファベットに
マッピングすることにより機能します。これによりASCIIのかわりに他のアルフ
ァベットを使うことが可能になります。GreekとRussianのインプットメソッドは
この方式で機能します。

   より強力なテクニックがコンポジション(composition: 複合)です。これは文
字のシーケンスを1つの文字に変換します。Europeanのインプットメソッドの多
くが、アクセント文字を後(または前)に続けた文字シーケンスから、1つの非
ASCII文字を生成するためにコンポジションを使います。たとえば、インプット
メソッドのいくつかは、‘o ^’のシーケンスを1つのアクセントつき文字に変換し
ます。これらのインプットメソッドは、それら自身では特別なコマンドをもちま
せん。これらすべてが行うのは、文字シーケンスを複合して、プリント文字にす
ることです。

   音節記号(syllabic scripts)のためのインプットメソッドは通常、マッピン
グと、それに続けてコンポジションを使います。ThaiとKoreanのためのインプッ
トメソッドは、この方式で機能します。最初に複数の文字が、特定の音や口調の
ためのシンボルにマッピングされます。次にこれらシンボルのシーケンスから音
節全体を作り、それを1つの音節記号にマッピングします。

   ChineseとJapaneseには、さらに複雑な方式が必要です。Chineseのインプッ
トメソッドでは、最初にChineseの単語の音声スペルを入力するか(特にインプッ
トメソッド‘chinese-py’)、文字の一部をシーケンスとして入力します(インプッ
トメソッド‘chinese-4corner’、‘chinese-sw’など)。通常1つの入力シーケンス
は、多くのChinese文字に対応します。‘C-f’、‘C-b’、‘C-n’、‘C-p’(または矢印
キー)、またはこの状況では特別な意味をもつ数字を指定することにより、意図
するものを選択します。

   文字の候補は、概念的には複数の行にアレンジされ、各行は10個の候補をも
ちます。通常Emacsは1度に1行をエコーエリアに表示します。行頭に‘(I/J)’が表
示され、これはトータルJ行中、I番目の行かを示します。‘C-n’または‘C-p’をタ
イプすると、次または前の行を表示します。

   ‘C-f’または‘C-b’をタイプすると、カレント行の候補の間を前方または後方
に移動します。これを行うとき、Emacsはカレント候補を特別な色でハイライト
します。‘C-<SPC>’とタイプすると、カレント候補を選択して、それを入力に使
用します。各行の候補には番号も付けられています。この番号は各候補の前に表
示されます。番号をタイプすると、カレント行の番号に関連付けられた候補を選
択し、それを入力に使用します。

   これらChineseのインプットメソッドでは、<TAB>はすべての文字候補をバッ
ファーに表示します。候補の1つを‘Mouse-2’でクリックすることにより選択しま
す。‘C-f’、‘C-b’、‘C-n’、‘C-p’、および数字キーは通常どおり機能しますが、
それらはエコーエリアではなく、文字候補を表示したバッファーをハイライトし
ます。

   Japaneseのインプットメソッドでは、最初に音声スペルを使って単語全体を
入力します。つぎに単語がバッファーに入った後で、より大きな辞書を使って
Emacsがそれを1つ以上の文字に変換します。1つの音声スペルは、いくつかの
Japaneseの単語に対応します。これらの1つを選択するには、‘C-n’または
‘C-p’を使って候補を巡回します。

   インプットメソッドをオフにして、入力した文字シーケンスが複合されない
ようにするのが便利なときがあります。たとえばインプットメソッド
‘latin-1-postfix’では、シーケンス‘o ^’は、アクセントつきの‘o’に複合され
ます。これらの文字を個別に入力したいときはどうすればよいでしょう?

   1つは、アクセントを2度タイプする方法です。これは文字とアクセントを個
別に入力するための特別な機能です。たとえば‘o ^ ^’により、2つの文字‘o^’が
得られます。他の方法としては‘o’の後に別の文字 — 複合されない何か別の文字
— を入力してすぐにそれを削除する方法です。たとえば‘o o <DEL> ^’とタイプ
することにより、‘o’と‘^’を個別に得ることができます。

   他の方法としては、もっと一般的ですがタイプしにくい方法です。これは2つ
の文字の間に‘C-\ C-\’を使って、それらの文字が複合されるのを止める方法で
す。これはコマンド‘C-\’ (‘toggle-input-method’)を2回使っています。 *note
Select Input Method::を参照してください。

   ‘C-\ C-\’は、インクリメンタル検索の中で使うのが特に便利です。なぜなら
これは複合される文字が入力されるのを待つのを止めて、それまでに入力した文
字で検索を開始するからです。

   現在のインプットメソッドを使って、ポイント位置の後ろの文字を入力する
方法を探すには、‘C-u C-x =’をタイプします。*note Position Info::を参照し
てください。

   変数‘input-method-highlight-flag’および‘input-method-verbose-flag’は
、インプットメソッドで何が起きているかを告げる方法を制御します。
‘input-method-highlight-flag’が非‘nil’の場合、部分的な入力シーケンスがバ
ッファーでハイライトされます(この機能を無効にしているインプットメソッド
もあります)。‘input-method-verbose-flag’が非‘nil’の場合、次にタイプでき
る文字の一覧をエコーエリア(ただしミニバッファーにいるときは除く)に表示し
ます。

   キーボードにない文字をタイプする他の方法は、‘C-x 8 <RET>’
(‘insert-char’)を使って、Unicode名またはコードポイント(code-point)にもと
づいて1つの文字を挿入する方法です。*note Inserting Text::を参照してくだ
さい。


File: emacs-ja.info,  Node: Select Input Method,  Next: Coding Systems,  Prev: Input Methods,  Up: International

22.4 インプットメソッドの選択
=============================

‘C-\’
     選択されたインプットメソッドを有効または無効にします
     (‘toggle-input-method’)。

‘C-x <RET> C-\ METHOD <RET>’
     カレントバッファーにたいして、新しいインプットメソッドを選択します
     (‘set-input-method’)。

‘C-h I METHOD <RET>’
‘C-h C-\ METHOD <RET>’
     インプットメソッドMETHODの説明を表示します
     (‘describe-input-method’)。デフォルトでは、(もしあれば)カレントのイ
     ンプットメソッドを説明します。これは特定のインプットメソッドの使い
     方に関する、すべての詳細説明を表示します。

‘M-x list-input-methods’
     サポートされている、すべてのインプットメソッドのリストを表示します
     。

   カレントバッファーにたいするインプットメソッドを選択するには、‘C-x
<RET> C-\’ (‘set-input-method’)を使います。このコマンドはミニバッファー
からインプットメソッドの名前を読み取ります。この名前は通常、それが使われ
ることを意図した言語環境で開始されます。変数‘current-input-method’は選択
されたインプットメソッドを記録します。

   インプットメソッドは非ASCII文字を表すために、さまざまなASCII文字のシ
ーケンスを使います。インプットメソッドを一時的にオフにできると便利なとき
もあります。そのようなときは‘C-\’ (‘toggle-input-method’)をタイプします
。インプットメソッドを再度有効にするには、もう1度‘C-\’をタイプします。

   ‘C-\’をタイプしたときに、まだインプットメソッドが選択されていない場合
、インプットメソッドを指定するように求めます。これはインプットメソッドを
指定する‘C-x <RET> C-\’を使ったときと同じ効果です。

   ‘C-u C-\’のようにプレフィクス引数を指定した場合、
‘toggle-input-method’は常にインプットメソッドを尋ねます。このときデフォ
ルトとして提案されるのは、もっとも最近選択されたインプットメソッドです。

   言語環境の選択により、さまざまなバッファーで使用するデフォルトのイン
プットメソッドが指定されます。デフォルトのインプットメソッドがある場合、
‘C-\’とタイプしてカレントバッファーでそれを選択できます。変数
‘default-input-method’はデフォルトのインプットメソッドを指定します
(‘nil’は、それが存在しないことを意味します)。

   複数の異なるインプットメソッドをサポートする言語環境では、
‘set-language-environment’で選択されるデフォルトとは違うインプットメソッ
ドを使いたいときもあるでしょう。‘set-language-environment-hook’を使って
、特定の言語環境にたいして異なるデフォルトのインプットメソッドを使うよう
Emacsに指示できます(*note set-language-environment-hook: Language
Environments.を参照してください)。たとえば:

     (defun my-chinese-setup ()
       "Set up my private Chinese environment."
       (if (equal current-language-environment "Chinese-GB")
           (setq default-input-method "chinese-tonepy")))
     (add-hook 'set-language-environment-hook 'my-chinese-setup)

これは言語環境をChinese-GB languageに選択したときは、常にデフォルトのイ
ンプットメソッドを‘chinese-tonepy’にセットします。

   特定のインプットメソッドを自動的にアクティブにするようEmacsに指示でき
ます。たとえば:

     (add-hook 'text-mode-hook
       (lambda () (set-input-method "german-prefix")))

これはTextモードで自動的にインプットメソッド“german-prefix”をアクティブ
にします。

   英文字スクリプトのためのいくつかのインプットメソッドは、それらのスク
リプトで一般的に使用されているさまざまなキーボードエミュレートするために
、(実質的には)他のアルファベットに再マッピングすることにより機能します。
この再マッピングがどのように正しく行われるかは、実際のキーボードレイアウ
トに依存します。キーボードがどのレイアウトなのかを指定するには、コマンド
‘M-x quail-set-keyboard-layout’を使います。

   コマンド‘M-x quail-show-key’を使って、ポイントの後ろにある文字を入力
するために、選択されたキーボードレイアウトの、どのキー(またはキーシーケ
ンス)をタイプすればよいのか表示できます。コマンド‘C-u C-x =’もこの情報と
、それに加えてその文字に関する他の情報を表示します。

   ‘M-x list-input-methods’は、サポートされているすべてのインプットメソ
ッドを一覧します。この一覧は各インプットメソッドの情報と、モードラインに
表示される文字列を表示します。


File: emacs-ja.info,  Node: Coding Systems,  Next: Recognize Coding,  Prev: Select Input Method,  Up: International

22.5 コーディングシステム
=========================

さまざまな言語のユーザーは、多少の差はあれ、それらを表示するための標準の
コーディングシステムを確立しています。Emacsはこれらのコーディングシステ
ムを、内部的に使用しません。データを読み込むときは、さまざまなコーディン
グシステムからEmacs独自のコーディングシステムに変換し、データを書き込む
ときには、内部コーディングシステムから他のコーディングシステムに変換しま
す。ファイルの読み書き、端末とのやりとり、サブプロセスとのデータ交換にお
いて、変換が可能です。

   Emacsは各コーディングシステムに名前を割り当てます。ほとんどのコーディ
ングシステムは、1つの言語で使用され、コーディングシステムの名前は、言語
の名前で始まります。複数の言語で使用されるコーディングシステムもあります
。これらのコーディングシステムの名前は、通常‘iso’で始まります。
‘no-conversion’、‘raw-text’、‘emacs-internal’のような特別なコーディング
システムもあります。

   まとめて“コードページ(codepages)”として知られる、特別なクラスのコーデ
ィングシステムは、MS-WindowsおよびMS-DOSのソフトウェアーによりエンコード
されたテキストをサポートするためにデザインされています。これらのコーディ
ングシステムの名前は‘cpNNNN’という形式で、NNNNは3桁から4桁のコードページ
番号です。これらのコーディングもほかのコーディングシステムと同様に使うこ
とができます。たとえばコードページ850でエンコードされたファイルをvisitす
るには、‘C-x <RET> c cp850 <RET> C-x C-f FILENAME <RET>’とタイプします。

   非ASCII文字のさまざまな表現の変換に加えて、コーディングシステムは行末
変換(end-of-line conversion)も行います。Emacsは、ファイル内の行の区切り
方として、3つの異なる変換を扱います。つまり、改行(“unix”)、復帰改行
(“dos”)、復帰(“mac”)です。

‘C-h C CODING <RET>’
     コーディングシステムCODINGの説明を表示します
     (‘describe-coding-system’)。

‘C-h C <RET>’
     現在使われているコーディングシステムの説明を表示します。

‘M-x list-coding-systems’
     サポートされているすべてのコーディングシステムのリストを表示します
     。

   コマンド‘C-h C’ (‘describe-coding-system’)は、特定のコーディングシス
テムについて、それらのコーディングシステムで規定されている、行末変換も含
めた情報を表示します。引数にコーディングシステム名を指定できます。引数が
空のときには、さまざまな目的のために選択されている、現在のコーディングシ
ステムの、カレントバッファにたいするものとデフォルトの両方について表示す
るとともに、コーディングシステムを認識するための優先順位表を表示します
(*note Recognize Coding::を参照してください)。

   サポートされているすべてのコーディングシステムのリストを表示するには
、‘M-x list-coding-systems’とタイプします。表示されるリストは、モードラ
インに表示される文字も含めて、各コーディングシステムの情報を提供します。

   リストに表示される各コーディングシステム — ただし何の変換も行わない
‘no-conversion’は除く — は、プリントする文字をどのように変換するか、しな
いかを指定しますが、改行変換については、各ファイル内容にもどづいて決定す
るので選択をしません。たとえばファイルが行区切りに改行復帰文字を使ってい
るように見えるときは、DOSの改行変換を使います。

   リストされた各コーディングシステムは、改行変換を厳密に指定する3つの変
種があります。

‘...-unix’
     何の改行変換も行いません。ファイルは行区切りに改行文字を使っている
     と仮定します(これは通常Unix、GNUシステム、Mac OS Xで使われている慣
     習です)。

‘...-dos’
     ファイルが行区切りに改行復帰文字を使っていると仮定し、適切な変換を
     行います(これは通常Microsoftシステムで使われている慣習です(1))。

‘...-mac’
     ファイルが行区切りに復帰文字を使っていると仮定し、適切な変換を行い
     ます(これはOS Xより前のMacintoshシステムで使われている慣習です)。

   これらのコーディングシステムの変種は、それらが完全に予測可能なため、
簡略化のために‘list-coding-systems’の表示からは省略されています。たとえ
ばコーディングシステム‘iso-latin-1’は‘iso-latin-1-unix’、
‘iso-latin-1-dos’、‘iso-latin-1-mac’という変種をもちます。

   コーディングシステム‘unix’、‘dos’、‘mac’は、それぞれ
‘undecided-unix’、‘undecided-dos’、‘undecided-mac’の別名です。これらのコ
ーディングシステムは改行変換だけを指定し、文字コード変換はテキスト字体か
ら推論されるよう残します

   コーディングシステム‘raw-text’は、主にASCIIテキストのファイルに適して
いますが、ファイルには、非ASCII文字の符号を意味しない127を越えるバイト値
が含まれるかもしれません。‘raw-text’では、 Emacsはそれらのバイト値を変更
せずにコピーし、カレントバッファーの‘enable-multibyte-characters’を
‘nil’にセットして、それらは適切に解釈されるます。‘raw-text’は、出会った
データに基づく通常の方法で行末変換を処理し、使用する行末変換を指定する変
種も3つもちます。

   対照的に、コーディングシステム‘no-conversion’は、いかなる文字コード変
換 — 非ASCIIバイト値や行末にたいしても — を行いません。これは、バイナリ
ーファイル、tarファイル、 そのまま処理する必要があるその他のファイルを読
み書きするのに便利です。これも‘enable-multibyte-characters’を‘nil’にセッ
トします。

   いかなる種類の変換もしないでファイルを編集するもっとも簡単な方法は、
‘M-x find-file-literally’コマンドを使うことです。このコマンドは、
‘no-conversion’を使い、ファイルを見る前にファイルの内容を変換するかもし
れない、Emacsのその他の機能を抑制します。*note Visiting::を参照してくだ
さい。

   コーディングシステム‘emacs-internal’(または‘utf-8-emacs’)は、Emacs内
部エンコーディングのままで格納された、非ASCII文字を含むファイルであるこ
とを意味します。これは出会ったデータに基づいて行末変換を処理し、行末変換
の種類を指定する通常の3つの変種を持ちます。

   ---------- Footnotes ----------

   (1) これはMIMEの‘text/*’の本体、および他のネットワーク転送のコンテキ
ストでも指定されています。これはEmacsが直接サポートしないSGMLリファレン
ス構文のrecord-start/record-endとは異なります。


File: emacs-ja.info,  Node: Recognize Coding,  Next: Specify Coding,  Prev: Coding Systems,  Up: International

22.6 コーディングシステムの認識
===============================

Emacsはテキストを読み込むとき、どのコーディングシステムが使われているか
認識しようと試みます。これはファイルの読み込み、サブプロセスからの出力、
X選択からのテキストなど、さまざまです。Emacsは大抵の場合 — 自分の好みを
1度指定しておけば、自動的に正しいコーディングシステムを選択できます。

   データにどのバイトシーケンスが出現するかにより、認識あるいは識別され
るコーディングシステムもいくつかあります。しかし識別される可能性さえない
コーディングシステムもあります。たとえばLatin-1とLatin-2を識別する方法は
ありません。これらは同じバイト値を異なる意味で使用します。

   Emacsはこのようなシチュエーションを、コーディングシステムの優先リスト
により処理します。Emacsがファイルを読み込むときは常に、それに使用するコ
ーディングシステムを指定しなければ、Emacsはデータを各コーディングシステ
ムに照らしてチェックし、それを優先順位の上から順に、データに適合するコー
ディングシステムが見つかるまで続けます。そして、そのコーディングシステム
で、ファイル内容が表示できると仮定して変換を行います。

   コーディングシステムの優先リストは、選択されている言語環境に依存しま
す(*note Language Environments::を参照してください)。たとえばFrenchを使
うのなら、おそらくEmacsにはLatin-2よりLatin-1を選んでほしいでしょう。
Czechを使うなら、おそらくLatin-2のほうがよいでしょう。これが言語環境を指
定する理由の1つです。

   しかし、コマンド‘M-x prefer-coding-system’を使って、優先リストの詳細
を変更できます。このコマンドはミニバッファーからコーディングシステムの名
前を読み取り、それを優先リストの先頭に追加して、他のすべてのものより優先
するようにします。このコマンドを数回使うと、使用するごとに優先リストの先
頭に1つの要素が追加されます。

   ‘iso-8859-1-dos’のような、行末変換を指定したコーディングシステムを使
うと、‘iso-8859-1’を優先して認識を試み、その際DOSの行末変換を使うことを
Emacsに指示することになります。

   ファイルにたいして使用するコーディングシステムをファイル名が示してい
ることがあります。変数‘file-coding-system-alist’は、この対応関係を指定し
ます。このリストに要素を追加する特別な関数は、
‘modify-coding-system-alist’です。たとえば、すべての‘.txt’の読み書きに、
コーディングシステム‘chinese-iso-8bit’を使用したいなら、つぎのLisp式を実
行します:

     (modify-coding-system-alist 'file "\\.txt\\'" 'chinese-iso-8bit)

1つ目の引数は‘file’、2番目の引数はこれを適用するファイルを決定する正規表
現、3番目の引数は、これらのファイルに対して使用するコーディングシステム
です。

   Emacsはファイルの内容にもとづいて、使用する行末変換の種類を認識します
。復帰のみ、あるいは復帰改行のシーケンスだけであれば、対応する行末変換を
選択します。変数‘inhibit-eol-conversion’を非‘nil’にセットすることにより
、行末変換の自動的な使用を抑止できます。これを行うとDOSスタイルのファイ
ルは、バッファー内に可視の‘^M’という文字を表示します。モードラインの左端
に目立たないように表示される改行タイプ指示‘(DOS)’より、こちらのほうを好
む人もいます。

   デフォルトでは、コーディングシステムの自動検知はエスケープシーケンス
を検出します。文字シーケンスがエスケープ文字で開始されていて、そのシーケ
ンスが有効なISO-2022であれば、それはEmacsにファイルをデコードするエンコ
ーディングに、ISO-2022を使うことを告げています。

   しかし、ファイルの中のエスケープシーケンスを、そのまま読み取りたい場
合もあるでしょう。そのような場合、変数‘inhibit-iso-escape-detection’を非
‘nil’にセットします。これにより、コード検知はエスケープシーケンスを無視
するようになり、ISO-2022エンコーディングは使用されません。この結果として
、すべてのエスケープシーケンスがバッファー内で可視になります。

   変数‘inhibit-iso-escape-detection’のデフォルト値は‘nil’です。わたした
ちは特別な操作を除いて、これを変更しないことを推奨します。なぜなら、
EmacsディストリビューションのEmacs Lispソースファイルのいくつかは、コー
ディングシステム‘iso-2022-7bit’でエンコードされた非ASCII文字を含んでおり
、エスケープシーケンス検知を抑止しているときにこれらのファイルをvisitす
ると、正しくデコードされないからです。

   変数‘auto-coding-alist’および‘auto-coding-regexp-alist’は、それぞれフ
ァイル名に含まれる特定パターン、およびファイルに含まれる特定パターンによ
りコーディングシステムを指定する一番強い方法です。これらの変数は、ファイ
ル自身に含まれる‘-*-coding:-*-’タグさえオーバーライドします。たとえば、
Emacsはtarおよびアーカイブファイルに、‘auto-coding-alist’を使います。こ
れはアーカイブのメンバーファイルに‘-*-coding:-*-’が含まれている場合、
Emacsが混乱してそれをファイル全体に適用するのを防ぎます。

   コーディングシステムを指定する他の方法は、変数
‘auto-coding-functions’を使う方法です。たとえばビルトインの1つ
‘auto-coding-functions’は、XMLファイルにたいするエンコーディングを検知し
ます。前の2つと異なり、この変数は‘-*-coding:-*-’タグをオーバーライドしま
せん.


File: emacs-ja.info,  Node: Specify Coding,  Next: Output Coding,  Prev: Recognize Coding,  Up: International

22.7 ファイルのコーディングシステムの指定
=========================================

Emacsがファイルのエンコーディングを正しく認識しなかった場合、‘C-x <RET>
r’ (‘revert-buffer-with-coding-system’)で、正しいコーディングシステムで
ファイルを再読み込みできます。このコマンドは、使用するコーディングシステ
ムの入力を求めます。ファイルのデコードに実際に使われているコーディングシ
ステムを見るには、モードラインの左端の近くのコーディングシステムのニーモ
ニック文字を見るか、‘C-h C’ (‘describe-coding-system’)をタイプします。

   特定のファイルのコーディングシステムを指定するのに、そのファイル自身
の最初に‘-*-...-*-’構成を指定するか、ファイルの最後にローカル変数リスト
(*note File Variables::を参照してください)を使用できます。これは
‘coding’という名前の“変数”に、値を定義することにより行われます。Emacsは
実際には変数‘coding’をもっていません。かわりに変数をセットして、特定のフ
ァイルにたいしてコーディングシステムを指定するのにこれを使います。たとえ
ば‘-*-mode: C; coding: latin-1;-*-’は、Latin-1コーディングシステム、同様
にCモードを指定することを指示します。ファイルの中でコーディングを明示的
に指定した場合、これは‘file-coding-system-alist’をオーバーライドします。


File: emacs-ja.info,  Node: Output Coding,  Next: Text Coding,  Prev: Specify Coding,  Up: International

22.8 出力のためのコーディングシステムの選択
===========================================

Emacsがバッファーにたいして1度コーディングシステムを選択すると、そのコー
ディングシステムは、‘buffer-file-coding-system’に記録されます。これによ
り‘save-buffer’や‘write-region’などの、バッファーからファイルに書き込む
際のデフォルトに、それを使用するようになります。
‘set-buffer-file-coding-system’を使って、バッファーのコーディングシステ
ムとは異なるコーディングシステムで、ファイルに書き込むよう指定できます
(*note Text Coding::を参照してください)。

   Emacsがサポートする任意の文字を、任意のEmacsバッファーに挿入できます
が、ほとんどのコーディングシステムは、それらの文字のサブセットしか処理す
ることができません。したがって挿入した文字は、そのバッファーを保存するの
に使われるコーディングシステムではエンコードできないかもしれません。たと
えば、‘iso-8859-2’でエンコードされたPolishのファイルをvisitして、それに
Russianの単語を追加することは可能です。このバッファーを保存するとき、
Emacsは‘buffer-file-coding-system’の現在の値を使用できません。なぜなら追
加された文字が、そのコーディングシステムではエンコードできないからです。

   これが発生した場合、Emacsは(‘M-x prefer-coding-system’または‘M-x
set-language-environment’によりセットされた)もっとも適したコーディングシ
ステムを試します。そのコーディングシステムがバッファーのすべての文字をエ
ンコードできたら、Emacsはそれを使って、その値を
‘buffer-file-coding-system’に格納します。そうでなければEmacsはバッファー
内容をエンコードするのに適したコーディングシステムのリストを表示して、そ
れらのコーディングシステムを1つ選ぶよう求めます。

   メールメッセージに適さない文字を入力した場合、Emacsの振る舞いは若干異
なります。この場合、追加でMIMEメッセージに推奨されたもっとも適したコーデ
ィングシステムかをチェックします。もしそうでなければ、この事実を知らせ、
他のコーディングシステムの入力を求めます。これにより、メール受信者のメー
ルソフトがデコードするのが困難なエンコードで、無意識にメッセージを送るよ
うなことがなくなります(入力をもとめられたときに、適さないコーディングシ
ステムを選ぶ、という選択肢もまだ残っています)。

   メールメッセージを送信するとき、Emacsはメッセージテキストのエンコーデ
ィングに使うコーディングシステムを決定する、4つの異なる方法をもっていま
す。最初にバッファー自身の‘buffer-file-coding-system’が非‘nil’なら、それ
を使います。次に‘sendmail-coding-system’が非‘nil’なら、それを使います。
3番目は言語環境の選択により制御されるデフォルトのコーディングシステムが
非‘nil’なら、それを使います。上述した値のすべてが‘nil’の場合、送信メール
をLatin-1コーディングシステムを使ってエンコードします。


File: emacs-ja.info,  Node: Text Coding,  Next: Communication Coding,  Prev: Output Coding,  Up: International

22.9 ファイルのテキストにたいするコーディングシステムの指定
===========================================================

Emacsがファイル内容にたいして、自動的に正しいコーディングシステムを選択
しない場合、コーディングシステムを指定するために、以下のコマンドを使用で
きます。

‘C-x <RET> f CODING <RET>’
     カレントバッファーのファイルを、コーディングシステムCODINGを使って
     保存または再visitします(‘set-buffer-file-coding-system’)。

‘C-x <RET> c CODING <RET>’
     直後に続くコマンドのコーディングシステムにCODINGを指定します
     (‘universal-coding-system-argument’).

‘C-x <RET> r CODING <RET>’
     コーディングシステムCODINGを使って、現在のファイルを再visitします
     (‘revert-buffer-with-coding-system’)。

‘M-x recode-region <RET> RIGHT <RET> WRONG <RET>’
     コーディングシステムWRONGを使ってデコードされたリージョンを、かわり
     にコーディングシステムRIGHTを使ってデコードします。

   コマンド‘C-x <RET> f’ (‘set-buffer-file-coding-system’)は、カレントバ
ッファーのファイルのコーディングシステムをセットします(たとえばファイル
を保存またはリバートするときに使うコーディングシステム)。これはミニバッ
ファーを使ってコーディングシステムを指定します。モードラインのコーディン
グシステムインディケーターを‘Mouse-3’でクリックしても、このコマンドを呼
び出すことができます。

   バッファーのすべての文字を処理できないコーディングシステムを指定した
場合、Emacsは問題となる文字について警告します。そしてそのバッファーを保
存するときのコーディングシステムの選択を求めます。

   このコマンドを、カレントバッファーのエンコーディングの際の改行変換の
指示に使うこともできます(*note end-of-line conversion: Coding Systems.を
参照してください)。たとえば‘C-x <RET> f dos <RET>’は、カレントバッファー
を、DOSスタイル(行末が改行復帰文字)で保存します。

   ファイルにたいしてコーディングシステムを指定する他の方法は、ファイル
をvisitするときに指定する方法です。最初にコマンド‘C-x <RET> c’
(‘universal-coding-system-argument’)を使います。このコマンドはミニバッフ
ァーを使ってコーディングシステムを読み取ります。ミニバッファーを抜けた後
、_その直後に続くコマンド_に、指定したコーディングシステムが使用されます
。

   たとえば直後に続くコマンドが‘C-x C-f’の場合、そのコーディングシステム
を使ってファイルを読み込みます(そして後で保存するときのために、そのコー
ディングシステムを記録します)。直後に続くコマンドが‘C-x C-w’の場合、その
コーディングシステムを使ってファイルを書き込みます。‘C-x <RET> f’のかわ
りに、この方法で保存するときのコーディングシステムを指定した場合、バッフ
ァーにそのコーディングシステムが処理できない文字が含まれていても警告はさ
れません。

   ‘C-x i’や‘C-x C-v’、同様に‘C-x C-f’の別ウィンドウ版‘C-x <RET> c’など
、その他のファイルコマンドも指定されたコーディングシステムに影響されます
。そして‘M-x shell’ (*note Shell::を参照してください)を含む、サブプロセ
スを開始するコマンドも影響を受けます。直後に続くコマンドがコーディングシ
ステムを使用しない場合、‘C-x <RET> c’は何の影響も与えません。

   変換をせずにファイルをvisitする簡単な方法は、‘M-x
find-file-literally’コマンドです。*note Visiting::を参照してください。

   変数‘buffer-file-coding-system’のデフォルト値は、新しいファイルを作成
するときに選択されるコーディングシステムを指定します。これは新しいファイ
ルを作成するときや、バッファーを作成してそれをファイルに保存するときに適
用されます。言語環境の選択は、この変数を言語環境にたいして適した、デフォ
ルトのコーディングシステムにセットします。

   間違ったコーディングシステムでファイルをvisitしたときは、‘C-x <RET>
r’ (‘revert-buffer-with-coding-system’)でこれを正すことができます。これ
は指定したコーディングシステムを使って、現在のファイルを再visitします。

   テキストの一部が、すでに間違ったコーディングシステムでバッファーに挿
入されてしまった場合、‘M-x recode-region’を使ってデコードしなおすことが
できます。これは正しいコーディングシステムと、実際に使われた間違ったコー
ディングシステムの入力を求め、変換を行います。最初にリージョンを間違った
コーディングシステムでエンコードして、その後で正しいコーディングシステム
でデコードします。


File: emacs-ja.info,  Node: Communication Coding,  Next: File Name Coding,  Prev: Text Coding,  Up: International

22.10 プロセス間通信にたいするコーディングシステム
==================================================

このセクションでは、他のプロセスと通信するときに使うコーディングシステム
を指定する方法を説明します。

‘C-x <RET> x CODING <RET>’
     選択したテキストを、他のグラフィカルなアプリケーションと送受信する
     ために、コーディングシステムCODINGを使用します
     (‘set-selection-coding-system’)。

‘C-x <RET> X CODING <RET>’
     次回に選択するテキストを、他のグラフィカルなアプリケーションと送受
     信するために、コーディングシステムCODINGを使用します
     (‘set-next-selection-coding-system’)。

‘C-x <RET> p INPUT-CODING <RET> OUTPUT-CODING <RET>’
     カレントバッファーでのサブプロセスの入出力に、コーディングシステム
     INPUT-CODINGとOUTPUT-CODINGを使用します
     (‘set-buffer-process-coding-system’)。

   コマンド‘C-x <RET> x’ (‘set-selection-coding-system’)は、選択したテキ
ストを他のウィンドウアプリケーションに送信するとき、および他のアプリケー
ションで選択されたテキストを受信するときのコーディングシステムを指定しま
す。このコマンドは、このコマンドを再度使って設定をオーバーライドするまで
、以降のすべての選択に適用されます。コマンド‘C-x <RET> X’
(‘set-next-selection-coding-system’)は、Emacsで次に選択されるテキスト、
または次に読み取られるテキストのためのコーディングシステムを指定します。

   変数‘x-select-request-type’は、Xウィンドウシステムからのリクエストに
より、他のアプリケーションで選択されたテキストを受信する際のデータタイプ
を指定します。値が‘nil’(デフォルト)の場合、Emacsは‘UTF8_STRING’、
‘COMPOUND_TEXT’の順に試み、さらにさまざまな経験則を用いて、2つの結果から
より適したものを選択します。どちらも成功しなかったとき、Emacsは
‘STRING’にフォールバックします。‘x-select-request-type’の値が、
‘COMPOUND_TEXT’、‘UTF8_STRING’、‘STRING’、‘TEXT’のうちのどれかであった場
合、Emacsはリクエストされたタイプだけを使用します。値がこれらのシンボル
のリストだった場合、Emacsはリストのリクエストタイプを順に試行し、どれか
が成功するか、すべてを試みるまで続けます。

   コマンド‘C-x <RET> p’ (‘set-buffer-process-coding-system’)は、サブプ
ロセスの入出力のコーディングシステムを指定します。このコマンドはカレント
バッファーに適用されます。サブプロセスは通常、それぞれ自身のバッファーを
もっています。したがってサブプロセスに対応するバッファーでこのコマンドを
実行することにより、特定のサブプロセスとの送受信に使用するコーディングシ
ステムを指定できます。

   サブプロセスを開始するコマンドの直前に‘C-x <RET> c’
(‘universal-coding-system-argument’)を使うことにより、そのプロセスとの通
信で使用するコーディングシステムを指定することもできます。*note Text
Coding::を参照してください。

   デフォルトでは、プロセス通信の入出力は現在の言語環境に依存します。

   変数‘locale-coding-system’は、システムのエラーメッセージや、
‘format-time-string’のフォーマットやタイムスタンプなどの、システム文字列
のエンコードおよびデコードで使用するコーディングシステムを指定します。こ
のコーディングシステムは、Xウィンドウシステムでの非ASCIIキーボードによる
入力のデコードにも使用されます。通常は環境変数‘LC_ALL’、‘LC_CTYPE’、
‘LANG’のうちの1つで指定される、背景にあるシステムのテキスト表現(text
representation)と互換性のあるコーディングシステムを選択するべきです(上記
の順番で最初の環境変数の値が空でない場合、それはテキスト表現を決定します
)。


File: emacs-ja.info,  Node: File Name Coding,  Next: Terminal Coding,  Prev: Communication Coding,  Up: International

22.11 ファイル名にたいするコーディングシステム
==============================================

‘C-x <RET> F CODING <RET>’
     ファイル名のエンコードおよびデコードに、コーディングシステム
     CODINGを使用します(‘set-file-name-coding-system’)。

   コマンド‘C-x <RET> F’ (‘set-file-name-coding-system’)は、ファイルの
_名前_に使用するコーディングシステムを指定します。ファイルの_内容_の読み
込みと書き込みには影響がありません。

   実際にこのコマンドが行うのは、変数‘file-name-coding-system’に値をセッ
トすることだけです。変数にコーディングシステムの名前(Lispシンボルか文字
列)をセットすると、Emacsはすべてのファイル操作において、ファイル名のエン
コードにそのコーディングシステムを使用します。これによりファイル名に非
ASCII文字 — または少なくとも指定されたコーディングシステムではエンコード
できる非ASCII文字 — を使うことが可能になります。

   ‘file-name-coding-system’が‘nil’の場合、Emacsは言語環境により選択され
、変数‘default-file-name-coding-system’に格納される、デフォルトのコーデ
ィングシステムを使用します。デフォルトの言語環境では、ファイル名の非
ASCII文字は特別にエンコードはされません。これらはEmacsの内部表現を使って
、ファイルシステム上に表示されます。

   Emacsが、MS-WindowsのNTファミリーの子孫(Windows 2000、XP、Vista、
Windows 7、Windows 8)にあたるバージョンで実行されている場合、
‘file-name-coding-system’の値は大部分が無視されます。これはEmacsがデフォ
ルトでUnicodeファイル名を直接渡せるAPIを使用するからです。一方、Windows
9Xでは、ファイル名は変数‘file-name-coding-system’を使ってエンコードされ
ており、この変数にはカレントのシステムロケールにたいして適切なコードペー
ジ(*note codepage: Coding Systems.を参照してください)がセットされている
必要があります。変数‘w32-unicode-filenames’の値は、Emacsがファイル名を引
数とするOS関数を呼び出すUnicode APIを使うかどうかを制御します。この変数
はスタートアップコードにより、Windows 9Xでは‘nil’、新しいバージョンの
MS-Windowsでは‘t’にセットされます。

   *警告: *Emacsセッションの途中で‘file-name-coding-system’(または言語環
境)を変更した場合、すでにvisitしているファイルの名前が、古いコーディング
システムを使えばエンコードできるが、新しいコーディングシステムではエンコ
ードされない(または違ってエンコードされる)という問題が発生します。このよ
うなバッファーをvisitしたファイル名で保存を試みると、間違ったファイル名
で保存するか、エラーが発生します。このような問題が発生したときは‘C-x
C-w’を使って、そのバッファーにたいして新しいファイル名を指定してください
。

   ファイル名をエンコードするとき間違いが発生した場合、コマンド‘M-x
recode-file-name’を使って、ファイル名のコーディングシステムを変更します
。このコマンドは古いコーディングシステムでの既存のファイル名と、変換した
いコーディングシステムの入力を求めます。


File: emacs-ja.info,  Node: Terminal Coding,  Next: Fontsets,  Prev: File Name Coding,  Up: International

22.12 端末入出力にたいするコーディングシステム
==============================================

‘C-x <RET> t CODING <RET>’
     端末の出力に、コーディングシステムCODINGを使用します
     (‘set-terminal-coding-system’)。

‘C-x <RET> k CODING <RET>’
     キーボード入力に、コーディングシステムCODINGを使用します
     (‘set-keyboard-coding-system’)。

   コマンド‘C-x <RET> t’ (‘set-terminal-coding-system’)は、端末出力のた
めのコーディングシステムを指定します。端末出力の文字コードを指定した場合
、端末へのすべての文字出力は、指定したコーディングシステムに変換されます
。

   この機能は、特定の言語または文字セットをサポートするようビルドされた
、特定の文字端末で有用です — たとえばEuropean端末は、ISO Latin文字セット
の1つをサポートします。マルチバイトテキストを使う場合は、端末のコーディ
ングシステムを指定する必要があります。これにより、Emacsは端末が実際にど
の文字を処理できるのか知ることができます。

   デフォルトでは、Emacsが端末タイプまたはlocale指定により、正しいコーデ
ィングシステムを推論できない場合、端末への出力は変換されません。

   コマンド‘C-x <RET> k’ (‘set-keyboard-coding-system’)、または変数
‘keyboard-coding-system’は、キーボード入力のためのコーディングシステムを
指定します。キーボード入力の文字コード変換は、非ASCIIのグラフィック文字
を送信するキーをもつ端末で有用です — たとえば、いくつかの端末はISO
Latin-1、またはそれのサブセットのためにデザインされています。

   デフォルトでは、キーボード入力はシステムのlocale設定にもとづいて変換
されます。端末がlocaleにより暗に指定されるエンコードを実際にはサポートし
ない場合(たとえば、‘M-i’をタイプしたときに非ASCII文字が挿入されるのに気
づいたとき)、エンコーディングをオフにするために
‘keyboard-coding-system’を‘nil’にセットする必要があるでしょう。これは、

     (set-keyboard-coding-system nil)

をinitファイルに記述することにより、行うことができます。

   キーボード入力にたいするコーディングシステムを使用した変換と、インプ
ットメソッドの使用は似通った点があります。これらは両方ともキーボード入力
シーケンスを1つの文字に変換します。しかし、インプットメソッドは人間によ
り対話的に使用されることが便利なようにデザインされており、通常はASCIIの
プリント文字のシーケンスが、変換されたシーケンスになります。通常、コーデ
ィングシステムは非グラフィック文字のシーケンスを変換します。


File: emacs-ja.info,  Node: Fontsets,  Next: Defining Fontsets,  Prev: Terminal Coding,  Up: International

22.13 フォントセット
====================

フォントは通常、1つのアルファベットまたはスクリプトの形状を定義します。
したがってEmacsがサポートするスクリプトの全範囲を表示するには、多くのフ
ォントのコレクションが要求されます。Emacsではこのようなコレクションのこ
とを“フォントセット(fontset)”と呼びます。フォントセットはフォント仕様の
リストとして定義され、それぞれが文字コードのある範囲を処理し、指定された
フォントでカバーしない文字にたいしては他のフォントセットにフォールバック
します。

   それぞれのフォントセットは、フォントと同様に名前をもちます。しかしフ
ォントはシステムに格納されていて、利用可能なフォント名はシステムで定義さ
れていますが、フォントセットはEmacs自身で定義されます。1度フォントセット
を定義したら、1つのフォントを使える場所ならどこでも、フォントセットを名
前で指定して使用することができます。もちろんEmacsのフォントセットに使用
できるのは、システムがサポートするフォントだけです。もしある文字がスクリ
ーン上で空のボックスや16進コードで表示される場合、それは使用しているフォ
ントセットがその文字にたいするフォントをもっていないことを意味します。こ
のような場合や、文字は表示されるが、それが意図したものとは異なる場合、多
分追加のフォントをインストールする必要があるでしょう。オペレーティングシ
ステムにはインストールできるオプションのフォントがあるはずです。またはサ
ポートされたスクリプトのほとんどのフォントを含むGNU Intlfontsパッケージ
をインストールすることもできます。(1)

   Emacsは3つのフォントセットを自動的に作成します。それは“スタンダードフ
ォントセット(standard fontset)”、“スタートアップフォントセット(startup
fontset)”、“デフォルトフォントセット(default fontset)”の3つです。デフォ
ルトフォントセットは、さまざまな非ASCII文字のフォントをもち、他の2つのフ
ォントセットのデフォルトのフォールバック先です(デフォルトフォントをセッ
トしたときは、デフォルトフォントセットではなくデフォルトフォント)。しか
しこれはフォントのファミリー名を指定しないので、これを直接使うと、結果は
少しランダムに思えるかもしれません。Emacsを‘-fn’オプションで実行すること
により、特定のフォントセットを使用するように指示できます。たとえば、

     emacs -fn fontset-standard

‘Font’でフォントセットを指定することもできます(*note X Resources::を参照
してください)。

   使用するフォントセットが何も指定されていない場合、EmacsはASCIIフォン
トを使用し、そのフォントがカバーしない文字にたいするフォールバックに
‘fontset-default’を使用します。名前とは裏腹にスタンダードフォントセット
は、明示的に要求されたときだけ使用されます。

   フォントセットは、すべての文字コードにたいしてフォントを指定する必要
はありません。フォントセットが特定の文字にたいしてフォントを指定していな
い、または指定したフォントがシステムに存在しない場合、フォントセットは文
字を正しく表示できません。この場合、その文字は16進コード、細いスペース、
または空のボックスがかわりに表示されます(詳細は、*note glyphless
characters: Text Display.を参照してください)。

   ---------- Footnotes ----------

   (1) EmacsをXで実行している場合、以下のようにして新しくインストールし
たフォントの場所を、X serverに指示する必要があるでしょう:
     xset fp+ /usr/local/share/emacs/fonts
     xset fp rehash


File: emacs-ja.info,  Node: Defining Fontsets,  Next: Modifying Fontsets,  Prev: Fontsets,  Up: International

22.14 フォントセットの定義
==========================

XでEmacsを実行している場合、Emacsは‘standard-fontset-spec’の値により、ス
タンダードフォントセットを作成します。このフォントセットの名前は、

     -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

または単に短く‘fontset-standard’です。

   GNUstep、およびMac OS Xではスタンダードフォントセットは、
‘ns-standard-fontset-spec’の値を使って作成され、MS Windowsでは
‘w32-standard-fontset-spec’の値を使って作成されます。

   スタンダードフォントセットのボールド、イタリック、ボールドイタリック
などの変種も自動的に作成されます。これらの変種の名前には‘medium’のかわり
に‘bold’、または‘r’のかわりに‘i’、またはその両方が使われます。

   Emacsは‘Font’リソース、または‘-fn’引数で指定した任意のデフォルト
ASCIIフォント、またはEmacsが起動時に見つけたデフォルトフォントにもとづい
て、フォントセットを自動的に作成します。これが“スタートアップフォントセ
ット(startup fontset)”で、名前は‘fontset-startup’です。これは
CHARSET_REGISTRYフィールドを‘fontset’、CHARSET_ENCODINGフィールドを
‘startup’で置き換えたもので、その置き換えた文字列をフォントセットの指定
に用います。

   たとえば以下の形式でEmacsを起動した場合、

     emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"

Emacsは以下のフォントセットを生成して、それをXウィンドウの初期フレームに
使用します:

     -*-courier-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

   スタートアップフォントセットは、そのフォントでサポートされているすべ
ての文字にたいして指定したフォントか、異なるregistryまたはencodingのフォ
ントを使用し、それ以外の文字は‘fontset-default’にフォールバックして表示
するでしょう。

   Xリソースの‘Emacs.Font’では、フォントセット名を実際のフォント名のよう
に指定できます。しかし‘Emacs*Font’のようなワイルドカードを使ったリソース
にフォントセット名を指定しないように注意してください — ワイルドカードを
使った指定は、メニューのようなフォントセットを処理できないものも含めて、
他のさまざまな目的にも適用されます。*note X Resources::を参照してくださ
い。

   ‘Fontset-N’という名前のXリソースを使って、追加のフォントセットを指定
できます。ここでNは0から始まる整数です。リソースの値はつぎのような形式で
す:

     FONTPATTERN, [CHARSET:FONT]...

FONTPATTERNは、最後の2つのフィールドを除いて、標準のXフォント名の形式で
す(前のfontset-startupの例を参照)。最後の2つのフィールドは、
‘fontset-ALIAS’の形式をもつべきです。

   フォントセットには2つの名前、長い名前と短い名前があります。長い名前は
FONTPATTERNです。短い名前は‘fontset-ALIAS’です。どちらの名前でもフォント
セットを参照できます。

   ‘CHARSET:FONT’という構成は、ある文字セットにたいして、(このフォントセ
ットでは)どのフォントを使用するかを指定します。ここでCHARSETは、文字セッ
トの名前で、FONTはその文字セットに使用するフォントです。1つのフォントセ
ットの定義の中で、この構成を何度でも使用できます。

   他の文字セットにたいしては、EmacsはFONTPATTERNにもとづいて選択します
。これは文字セットを記述する値で‘fontset-ALIAS’を置き換えます。ASCII文字
フォントにたいしては、‘fontset-ALIAS’を‘ISO8859-1’で置き換えます。

   これに加えて、複数の連続するフィールドがワイルドカードの場合、Emacsは
それらを1つのワイルドカードにまとめます。これは、オートスケールされたフ
ォントの使用を避けるためです。大きいフォントをスケーリングしたフォントは
編集に適しておらず、小さいフォントをスケーリングしたフォントも同様です。
なぜならEmacsがそうするように、もともと小さなフォントを使うほうがよいか
らです。

   したがって、FONTPATTERNが以下の場合、

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCII文字にたいするフォント指定は、以下のようになるでしょう:

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

そしてChinese GB2312文字にたいするフォント指定は、以下のようになるでしょ
う:

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

   上記のフォント指定に一致するChineseフォントがないかもしれません。ほと
んどのXディストリビューションには、FAMILYフィールドが‘song ti’か
‘fangsong ti’のChineseフォントだけが含まれています。そのような場合、
‘Fontset-N’をつぎのように指定します:

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

そうするとChinese GB2312の文字を除くフォント指定では、FAMILYフィールドが
‘fixed’となり、Chinese GB2312の文字に対するフォント指定では、FAMILYフィ
ールドが‘*’となります。

   フォントセットのリソース値を処理してフォントセットを作る関数は、
‘create-fontset-from-fontset-spec’と呼ばれます。フォントセットを作るため
に、この関数を明示的に呼ぶこともできます。

   フォントの命名についての詳細は、*note Fonts::を参照してください。


This is emacs.info, produced by makeinfo version 6.1 from emacs.texi.

This is the ‘GNU Emacs Manual’, updated for Emacs version 24.5.

   Copyright © 2015–2016 Ayanokoji Takesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).            拡張可能なセルフドキュメント形式のテキストエディター。
END-INFO-DIR-ENTRY


File: emacs.info,  Node: Top,  Next: Distrib,  Up: (dir)

The Emacs Editor
****************

Emacsは、拡張可能で、カスタマイズ可能な、セルフドキュメント方式のリアル
タイム画面エディターです。このinfoファイルでは、Emacsでの編集方法や
Emacsのカスタマイズ方法について説明します。GNU Emacs 24.5に対応します。

   これをEmacsで読んでいる場合、Infoドキュメントシステムの基本的な手引き
を読むには、‘h’とタイプします。

   Emacsの拡張に関しては、*note Emacs Lisp: (elisp)Top.を参照してくださ
い。

   This is the ‘GNU Emacs Manual’, updated for Emacs version 24.5.

   Copyright © 2015–2016 Ayanokoji Takesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”

* Menu:

* Distrib::                  最新のEmacsディストリビューションを入手する方法。
* Intro::                    Emacsの概念についてのイントロダクション

重要な一般的概念
* Screen::                   スクリーンで目にするものの使い方。
* User Input::               さまざまな入力イベント（文字、ボタン、ファンクションキー）
* Keys::                     キーシーケンス:
                               編集アクションをリクエストするための入力。
* Commands::                 編集を行うキーシーケンスにより実行される名前付きの関数。
* Entering Emacs::           シェルからのEmacsの起動。
* Exiting::                  Emacsの停止と終了。

基本的な編集コマンド
* Basic::                    もっとも基本的な編集コマンド。
* Minibuffer::               入力プロンプトにたいして引数を入力する。
* M-x::                      コマンドを名前で呼び出す。
* Help::                     コマンドについてEmacsに尋ねるコマンド。

テキストを変更する重要コマンド
* Mark::                     mark:
                               どうやってテキストの"region"を区切るか。
* Killing::                  テキストのkill(切り取り)とyank(コピー)。
* Registers::                バッファーのテキストや位置の保存。
* Display::                  テキストの表示の制御。
* Search::                   文字列の検索と置換。
* Fixit::                    タイプミスを訂正するのに特に有用なコマンド。
* Keyboard Macros::          再生するためにキーストロークのシーケンスを記録する。

Emacsの主要な構造
* Files::                    ファイルの処理に関するすべて。
* Buffers::                  複数バッファー —
                               1度に複数のファイルを編集する。
* Windows::                  1つのフレームでの複数のテキスト片の閲覧。
* Frames::                   ディスプレーで複数のウィンドウを使用する。
* International::            非ASCII文字セットの使用。

上級の機能
* Modes::                    Emacsの基本動作を変更するメジャーモードとマイナーモード。
* Indentation::              行の先頭にある空白スペースの編集。
* Text::                     人間の言語のためのコマンドとモード。
* Programs::                 プログラム編集のためのコマンドとモード。
* Building::                 プログラムのコンパイル、実行、デバッグ。
* Maintaining::              大きなプログラムを保守するための機能。
* Abbrevs::                  タイプ量を減らすための略語の定義。
* Dired::                    ディレクトリー・ファイルマネージャー。
* Calendar/Diary::           カレンダーおよびダイアリー機能。
* Sending Mail::             Emacsでのメールの送信。
* Rmail::                    Emacsでのメールの閲覧。
* Gnus::                     柔軟なメール・ニュースリーダー。
* Document View::            PDF、PS、DVIファイルの閲覧。
* EWW::                      Emacsのウェブブラウザー。
* Shell::                    Emacsからのシェルコマンドの実行。
* Emacs Server::             Emacsを編集サーバーとして使用する。
* Printing::                 バッファーまたはリージョンのハードコピーの印刷。
* Sorting::                  Emacsでの行、パラグラフ、ページのソート。
* Picture Mode:: テキスト文字で作られたピクチャーの編集。
* Editing Binary Files::     Hexlモードでのバイナリーファイルの編集。
* Saving Emacs Sessions::    あるセッションから次のセッションへ、Emacsの状態を保存する。
* Recursive Edit::           他のコマンドを実行中に編集を行なう。
* Hyperlinking::             バッファー内のリンクをフォローする。
* Amusements::               さまざまなゲームとhack。
* Packages::                 追加機能のインストール。
* Customization::            Emacsの動作を変更する。

問題からのリカバリー
* Quitting::                 中止(quit)と中断(abort)。
* Lossage::                  Emacsがハングしたり誤動作するとき何を行なうか。
* Bugs::                     バグを報告すべきとき、そしてその方法について。
* Contributing::             Emacsの改良に貢献する方法。
* Service::                  あなた独自のEmacsのニーズにたいして助けを得る方法。

Appendices
* Copying::                  GNU General Public
                               Licenseは特定の条件に置いてGNUEmacsを再配布する許可をあなたに与えます。そして保証がないことも説明します。
* GNU Free Documentation License::  このドキュメントのライセンス。
* Emacs Invocation::         hairy(身の毛もよだつ、恐ろしい、困難な、難しい、危険な、やばい)な開始オプション。
* X Resources::              EmacsをカスタマイズするためのXリソース。
* Antinews::                 Emacsバージョン23についての情報。
* Mac OS / GNUstep::         Mac OSおよびGNUstepでのEmacsの使用。
* Microsoft Windows::        Microsoft
                               WindowsおよびMS-DOSでのEmacsの使用。
* Manifesto::                What’s GNU? Gnu’s Not Unix! —
                               GNUとはなんだ? => Gnu’s Not
                               Unix!(GNUはUnixではない!)。

* Glossary::                 このマニュアルで使用されている用語。
* Acknowledgments:: GNU Emacsの主要な貢献者。


インデックス(各インデックスは大きなメニューを含みます)
* Key Index::                標準的なEmacsキーシーケンス。
* Option Index::             コマンドラインオプション。
* Command Index::            コマンド名。
* Variable Index::           ドキュメントされた変数。
* Concept Index::            概念。



 — 詳細なボード一覧 — ——————————————-



以下は実際にはすでにリストされたノードのサブノードです。それらをここで記述するので、1ステップで移動できます:



スクリーンの構成



* Point::                    テキスト内で編集コマンドが作用する場所
* Echo Area::                スクリーンのいちばん下で、短いメッセージが表示されます
* Mode Line::                モードを説明するライン
* Menu Bar::                 メニューバーの使い方

基本的な編集コマンド。



* Inserting Text::           単純に入力してテキストを挿入する。
* Moving Point::             何か修正したい場所にカーソルを移動する。
* Erasing::                  テキストの削除とkill。
* Basic Undo::               テキストの最近の変更を取り消す。
* Basic Files::              ファイルの読み込み、作成、保存。
* Basic Help::               文字が何を行うか尋ねる。
* Blank Lines::              空行の作成と削除
* Continuation Lines::       Emacsがスクリーンに収まりきれない行を表示する方法。
* Position Info::            ポイントのある場所の行と列は何か?
* Arguments::                コマンドをN回繰り返すための数引数。
* Repeating::                素早く前のコマンドを繰り返す。

ミニバッファー



* Basic Minibuffer::         ミニバッファーの基本的な使い方。
* Minibuffer File::          ミニバッファーでファイル名を入力する。
* Minibuffer Edit::          ミニバッファーで編集する方法。
* Completion::               ミニバッファーでの入力のための略記機能。
* Minibuffer History::       最近のミニバッファー引数の再使用。
* Repetition::               ミニバッファーを使ったコマンドの再実行。
* Passwords::                エコーエリアでパスワードを入力する。
* Yes or No Prompts::        エコーエリアでyes/noにこたえる。

Completion



* Completion Example::       補完の使い方の例。
* Completion Commands::      補完コマンドの一覧。
* Completion Exit::          補完とミニバッファーでのテキストのsubmit。
* Completion Styles::        補完の一致が選ばれる方法。
* Completion Options::       補完のオプション。

Help



* Help Summary::             すべてのヘルプコマンドの要約リスト。
* Key Help::                 Emacsでキーが何を行うか尋ねる。
* Name Help::                コマンド、変数、関数名を尋ねる。
* Apropos::                  与えられたトピックに関係があるものを尋ねる。
* Help Mode::                へルポモードとヘルプバッファーの特別な機能。
* Package Keywords::         キーワード(トピック)でLispライブラリーを探す。
* Language Help::            国際的な言語サポートに関するヘルプ。
* Misc Help::                その他のヘルプコマンド。
* Help Files::               追加のヘルプファイルを表示するコマンド。
* Help Echo::                アクティブなテキストのヘルプとツールチップ("バルーンヘルプ")。

マークとリージョン



* Setting Mark::             マークをセットするコマンド。
* Marking Objects::          テキスト的な単位の周辺にリージョンをセットするコマンド。
* Using Region::             リージョンの内容を操作する方法の要約。
* Mark Ring::                後で戻れるように保存された以前のマーク位置。
* Global Mark Ring::         さまざまなバッファーの以前のマーク位置。
* Shift Selection::          シフトを押してカーソル移動キーを使う。
* Disabled Transient Mark::  デフォルトでリージョンをハイライトせずにおく。

テキストのkillと移動



* Deletion and Killing::     テキストを除去するコマンド。
* Yanking::                  テキストを挿入するコマンド。
* Cut and Paste::            グラフィカルなディスプレーにおけるクリップボードと選択。
* Accumulating Text::        バッファーにテキストを追加する他の手法。
* Rectangles::               矩形領域のテキストの操作。
* CUA Bindings::             killとyankで‘C-x’/‘C-c’/‘C-v’を使う。

Deletion and Killing



* Deletion::                 少量のテキストや空の領域を削除するコマンド。
* Killing by Lines::         テキスト行を一度にkillする方法。
* Other Kill Commands::      大きなリージョンや単語やセンテンスのような構文単位をkillするコマンド。
* Kill Options::             killに影響のあるオプション。

Yanking



* Kill Ring::                killされたテキストが格納される場所。
* Earlier Kills::            もっと前にkillしたものをyankする。
* Appending Kills::          数回のkillを一緒にまとめてyankする。

グラフィカルなディスプレーでのカットアンドペースト操作



* Clipboard::                Emacsがシステムクリップボードを使う方法。
* Primary Selection::        一時的に選択されたテキストの選択。
* Secondary Selection::      ポイントとマークを変化させずに切り取る。

Registers



* Position Registers::       位置をレジスターに保存する。
* Text Registers::           テキストをレジスターに保存する。
* Rectangle Registers::      矩形領域をレジスターに保存する。
* Configuration Registers::  ウィンドウの設定をレジスターに保存する。
* Number Registers::         レジスターの中の数字。
* File Registers::           レジスターの中のファイル名。
* Keyboard Macro Registers::  レジスターの中のキーボードマクロ。
* Bookmarks::                ブックマーク、レジスターと似ているが永続性がある。

ディスプレーの制御



* Scrolling::                ウィンドウのテキストを上下に移動させるコマンド。
* Recentering::              現在行を中央するスクロールコマンド。
* Auto Scrolling::           必要なときテキストをスクロールして再表示する。
* Horizontal Scrolling::     ウィンドウの左右にテキストを移動させる。
* Narrowing::                表示を制限してバッファーの一部を編集する。
* View Mode::                読み取り専用バッファーの表示。
* Follow Mode::              Follow
                               modeで2つのウィンドウを1つとしてスクロールさせる。
* Faces::                    フェイスを使って表示スタイルを変更する方法。
* Colors::                   フェイスのカラーを指定する。
* Standard Faces::           主要な既定のフェイス。
* Text Scale::               バッファーのテキストサイズの拡大と縮小。
* Font Lock::                フェイスを使って文法をハイライトするマイナーモード。
* Highlight Interactively::  Emacsにハイライトするテキストを指示する。
* Fringes::                  ウィンドウフリンジの有効と無効。
* Displaying Boundaries::    バッファーの先頭と最後を表示する。
* Useless Whitespace::       不要な行末の空白文字の表示。
* Selective Display::        大きなインデントの行を隠す。
* Optional Mode Line::       モードラインの表示機能のオプション。
* Text Display::             テキスト文字が通常表示される方法。
* Cursor Display::           カーソル表示の機能。
* Line Truncation::          複数のスクリーン行で継続表示させずにスクリーン幅に行を切り詰める。
* Visual Line Mode::         単語の折り返しとスクリーン行にもとづく編集。
* Display Custom::           ディスプレーをカスタマイズする変数の情報。

検索と置換



* Incremental Search::       文字列をタイプすることにより始まる検索。
* Nonincremental Search::    文字列全体を指定してから検索する。
* Word Search::              単語の並びを検索する。
* Symbol Search::            ソースコードのシンボルを検索する。
* Regexp Search::            正規表現にマッチする検索。
* Regexps::                  正規表現の文法。
* Regexp Backslash::         ‘\’で開始される正規表現の構築。
* Regexp Example::           複雑な正規表現の解説。
* Search Case::              検索で大文字小文字を無視または区別するには。
* Replace::                  一部またはすべてのマッチを検索または置換する。
* Other Repeating Search::   いくつかの正規表現にマッチするすべてを処理する。

Incremental Search



* Basic Isearch::            基本的なインクリメンタル検索コマンド。
* Repeat Isearch::           同じ文字列を再度検索する。
* Error in Isearch::         文字列が見つからなかったとき。
* Special Isearch::          インクリメンタル検索での特別な入力。
* Isearch Yank::             検索文字列にテキストを取り込んだり、検索文字列を編集するコマンド。
* Not Exiting Isearch::      プレフィクス引数とスクロールコマンド。
* Isearch Minibuffer::       ミニバッファー履歴のインクリメンタル検索。

置換コマンド



* Unconditional Replace::    マッチする文字列をすべて置換する。
* Regexp Replace::           regexpにマッチするすべてを置換する。
* Replacement and Case::     置換が大文字小文字を保持する方法。
* Query Replace::            問い合わせを使う方法。

タイプミス訂正のためのコマンド



* Undo::                     Undoコマンド。
* Transpose::                2つの文字、単語、行、リスト、...の交換。
* Fixing Case::              最後に入力した文字の大文字小文字を訂正する。
* Spelling::                 単語またはファイル全体へのスペルチェッカーの適用。

Keyboard Macros



* Basic Keyboard Macro::     キーボードマクロの定義と実行。
* Keyboard Macro Ring::      以前のキーボードマクロが保存される場所。
* Keyboard Macro Counter::   マクロに増加する番号を挿入する。
* Keyboard Macro Query::     毎回違うことを行うマクロの作成。
* Save Keyboard Macro::      キーボードマクロの命名とファイルへの保存。
* Edit Keyboard Macro::      キーボードマクロを編集するには。
* Keyboard Macro Step-Edit::  キーボードマクロの対話的な実行と編集。

ファイル処理



* File Names::               ファイル名引数をタイプ、編集する方法。
* Visiting::                 ファイルをvisitしてEmacsが編集する準備をする。
* Saving::                   保存して変更を永続化する。
* Reverting::                保存されていないすべての変更を取り消して前の状態に戻す。
* Autorevert:: 非ファイルバッファーの自動リバートについて。
* Auto Save::                定期的な自動保存によりデータを失うことから守る。
* File Aliases::             1つのファイルにたいする複数の名前を処理する。
* Directories::              ファイルディレクトリーの削除、作成、一覧。
* Comparing Files::          2つのファイルの異なる部分を探す。
* Diff Mode::                ファイルの異なる部分を編集するモード。
* Misc File Ops::            ファイルにたいして行うその他のコマンド。
* Compressed Files::         圧縮されたファイルへのアクセス。
* File Archives::            tar、zip、jar、...などのアーカイブファイルにたいする操作。
* Remote Files::             他のマシンにあるファイルへのアクセス。
* Quoted File Names::        ファイル名に含まれる特別な文字のクォート。
* File Name Cache::          補完のための、ときどき使うファイルの一覧。
* File Conveniences::        ファイルを探すための便利な機能。
* Filesets::                 複数ファイルの処理。

Saving Files



* Save Commands::            ファイルを保存するコマンドについて。
* Backup::                   Emacsがファイルの古いバージョンを保存する方法。
* Customize Save::           ファイルの保存のカスタマイズ。
* Interlocking::             Emacsが2人のユーザーによる1つのファイルへの同時編集から保護する方法。
* File Shadowing::           ファイルを自動的に"shadows"コピーする。
* Time Stamps::              Emacsによる保存されたファイルのタイムスタンプの更新。

バックアップファイル



* Backup Names::             バックアップファイルの命名方法。
* Backup Deletion::          Emacsによる余分な番号つきバックアップの削除。
* Backup Copying::           コピーとリネームによるバックアップの作成。

非ファイルバッファーの自動リバート

* Auto Reverting the Buffer Menu:: バッファーメニューの自動リバート。


自動保存 — 災害にたいする保護



* Auto Save Files::          ファイルを保存するまでの間、自動保存された変更が実際に保存されるファイル。
* Auto Save Control::        自動保存をいつ、どのような間隔で行うかの制御。
* Recover::                  auto-saveファイルからのテキストの復旧。

複数バッファーの使用



* Select Buffer::            新しいバッファーの作成と既存のバッファーの再選択。
* List Buffers::             既存のバッファーリストの取得。
* Misc Buffer::              リネーム、読み取り専用属性の変更、テキストのコピー。
* Kill Buffer::              不必要なバッファーのkill。
* Several Buffers::          すべてのバッファーリストの操作と、それらへのさまざまな操作。
* Indirect Buffers::         他のバッファーのテキストを共有するインダイレクトバッファー。
* Buffer Convenience::       バッファー操作のための便利な機能とカスタマイズ。

バッファー処理の便利な機能とカスタマイズ



* Uniquify::                 ディレクトリー部分でバッファー名を一意にする。
* Icomplete::                素早いミニバッファーの選択について。
* Buffer Menus::             バッファーメニューの設定。

複数ウィンドウ



* Basic Window::             Emacsウィンドウの紹介。
* Split Window::             既存のウィンドウを分割して新しいウィンドウを作る。
* Other Window::             他のウィンドウへの移動と操作。
* Pop Up Window::            他のウィンドウのファイルまたはバッファーの検索。
* Change Window::            ウィンドウの削除とサイズ変更。
* Displaying Buffers::       Emacsがバッファーを表示するためにウィンドウを選択する方法。
* Window Convenience::       ウィンドウ処理の便利な機能。

ウィンドウでのバッファーの表示



* Window Choice::            ‘display-buffer’が機能する方法

フレームとグラフィカルなディスプレー



* Mouse Commands::           マウスによる移動、切り取り、貼り付け。
* Word and Line Mouse::      単語または凝然体を選択するマウスコマンド。
* Mouse References::         リストからアイテムを選択するのにマウスを使う。
* Menu Mouse Clicks::        メニューを表示させるマウスクリック。
* Mode Line Mouse::          モードライン上でのマウスクリック。
* Creating Frames::          さまざまな内容とともに追加のEmacsフレームを作成する。
* Frame Commands::           フレームのアイコン化とフレームの切り替え。
* Fonts::                    フレームフォントの変更。
* Speedbar::                 スピードバーフレームの作り方と使い方。
* Multiple Displays::        1つのEmacsインスタンスが複数ディスプレーと通信する方法。
* Frame Parameters::         フレームの色や他のモードの変更。
* Scroll Bars::              スクロールバーの有効と無効、および使い方。
* Drag and Drop::            ファイルを開いたりテキストを挿入するのにドラッグアンドドロップを使う。
* Menu Bars::                メニューバーの有効と無効。
* Tool Bars::                ツールバーの有効と無効。
* Dialog Boxes::             ダイアログボックス使用の制御。
* Tooltips::                 マウスの現在位置の情報の表示。
* Mouse Avoidance::          マウスポインターがテキストを隠すのを防ぐ。
* Non-Window Terminals::     フレームを1つだけ表示する端末での複数フレーム。
* Text-Only Mouse::          テキスト端末でのマウスの使用について。

国際化文字セットのサポート



* International Chars::      マルチバイト文字の基本的な概念。
* Language Environments::    使用する言語のためのセットアップ事項。
* Input Methods::            キーボード似ないテキスト文字の入力。
* Select Input Method::      インプットメソッドの選択を指定する。
* Coding Systems::           ファイルを読み書きしたりするときの文字セット変換。
* Recognize Coding::         どの変換が使われたのかEmacsが解決する方法。
* Specify Coding::           ファイルのコーディングシステムの明示的な指定。
* Output Coding::            出力のためのコーディングシステムの選択について。
* Text Coding::              ファイルのテキストに使う変換の選択。
* Communication Coding::     プロセス間通信のためのコーディングシステム。
* File Name Coding::         _ファイル名_のコーディングシステム。
* Terminal Coding::          端末の入出力の変換のためのコーディングシステムの指定。
* Fontsets::                 フォントセット、それは文字の全範囲をカバーするフォントのコレクション。
* Defining Fontsets::        新しいフォントセットの定義。
* Modifying Fontsets::       既存のフォントセットの修正。
* Undisplayable Characters::文字が表示されないとき。
* Unibyte Mode::             マルチバイト文字を使わずに1つの英文字セットを選択する。
* Charsets::                 Emacsが内部の文字コードをグループ化する方法。
* Bidirectional Editing::    右から左に記述する言語のサポート。

メジャーモードとマイナーモード



* Major Modes::              Textモード vs. Lispモード
                               vs. Cモード...
* Minor Modes::              マイナーモードは他と独立して有効にできる機能です。
* Choosing Modes::           ファイルをvisitしたときにモードが選択される方法。

Indentation



* Indentation Commands::     インデントを処理するほかのコマンド。
* Tab Stops::                Textモードのインデントのストップポイント。
* Just Spaces::              インデントにスペース文字だけを使用する。
* Indent Convenience::       インデントのオプション機能。

人間の言語にたいするコマンド



* Words::                    単語単位の移動とkill。
* Sentences::                センテンス単位の移動とkill。
* Paragraphs::               パラグラフ単位の移動。
* Pages::                    ページ単位の移動。
* Filling::                  テキストのフィルと調整。
* Case::                     テキストの大文字小文字の変更。
* Text Mode::                テキストファイルを編集するためのメジャーモード。
* Outline Mode::             アウトラインの編集。
* Org Mode::                 Emacsオーガナイザー。
* TeX Mode::                 TeXおよびLaTeXファイルの編集。
* HTML Mode::                HTMLおよびSGMLファイルの編集。
* Nroff Mode::               nroffフォーマッターへの入力の編集。
* Enriched Text::            フォント、色などでenrichedテキストを編集する。
* Text Based Tables::        テキストベースのテーブルを編集するためのコマンド。
* Two-Column::               テキスト列を分割して別のウィンドウに表示する。

テキストのフィル



* Auto Fill::                Auto
                               Fillモードは長い行を自動的に分割します。
* Fill Commands::            パラグラフの再フィルと行の中央揃えコマンド。
* Fill Prefix::              インデントされていたり、コメントであるパラグラフのフィル。
* Adaptive Fill::            Emacsがフィルプレフィクスを自動的に決定する方法。

Outline Mode



* Outline Format::           アウトラインのテキストがどのように見えるか。
* Outline Motion::           アウトラインを移動するための特別なコマンド。
* Outline Visibility::       なにを表示するか制御するコマンド。
* Outline Views::            アウトラインと複数ビュー。
* Foldout::                  アウトラインをズームする折り畳み。

Org Mode



* Org Organizer::            TODOリストとアジェンダの管理。
* Org Authoring::            Orgバッファーをさまざまなフォーマットでエクスポートする。

TeXモード



* TeX Editing::              TeXモードで編集するための特別なコマンド。
* LaTeX Editing::            LaTeX入力ファイルのための追加のコマンド。
* TeX Print::                ファイルの一部をTeXで印刷するコマンド。
* TeX Misc::                 TeXモードのカスタマイズと関連する機能。

Enriched Text



* Enriched Mode::            Enrichedモードの開始と終了。
* Hard and Soft Newlines::   改行には2つの種類があります。
* Editing Format Info::      テキストプロパティーの編集方法。
* Enriched Faces::           太字、斜体、下線、など。
* Enriched Indentation::     左余白と右余白の変更。
* Enriched Justification::   テキストの中央揃え、左揃え、右揃え、など。
* Enriched Properties::      特別なテキストプロパティーサブメニュー。



テキストベースの表の編集



* Table Definition::         テキストベースのテーブルとは何か。
* Table Creation::           テーブルを作成する方法。
* Table Recognition::        テーブルをアクティブまたは非アクティブにする方法。
* Cell Commands::            テーブルのセル指向のコマンド。
* Cell Justification::       セル内容の位置調整。
* Table Rows and Columns::   行と列の追加と削除。
* Table Conversion::         プレーンテキストとテーブルの変換について。
* Table Misc::               テーブル、その他について。

プログラムの編集



* Program Modes::            プログラムを編集するためのメジャーモード。
* Defuns::                   プログラムの主要なトップレベル要素を操作するためのコマンド。
* Program Indent::           ネスティングを示すためのインデントの調整。
* Parentheses::              カッコを操作するコマンド。
* Comments::                 コメントの挿入、kill、位置揃え。
* Documentation::            関数ドキュメントの取得。
* Hideshow::                 ブロックの選択的な表示。
* Symbol Completion::        プログラムまたは言語でのシンボルの補完。
* MixedCase Words::          identifiersLikeThisのような識別子の処理。
* Semantic::                 ソースコードのパースにもとづいた編集ツール。
* Misc for Programs::        その他、プログラムを編集するための便利なEmacs機能。
* C Modes::                  C、C++、Objective-C、Java、IDL、Pike、AWKモードの特別なコマンド。
* Asm Mode::                 Asmモードと特別な機能。
* Fortran:: Fortranモードと特別な機能。


トップレベルの定義とdefun



* Left Margin Paren::        開きカッコまたは同様の開始を意味する区切りは、それが左端にある場合はdefunの開始です。
* Moving by Defuns::         主要な定義を移動したりマークするコマンド。
* Imenu::                    バッファーのインデックスをメニューにする。
* Which Function::           Which
                               Functionモードはどの関数にいるか表示します。

プログラムのインデント



* Basic Indent::             1行のインデント。
* Multi-line Indent::        複数行を一度に再インデントするコマンド。
* Lisp Indent::              Lisp関数がどのようにインデントされるべきか指定する。
* C Indent::                 Cおよび関連するモードのインデントのための追加機能。
* Custom C Indent::          Cおよび関連するモードのインデントスタイルの制御。

カッコの編集にたいするコマンド



* Expressions::              対応が取れたカッコの式。
* Moving by Parens::         カッコ構造を上、下、横断して移動するコマンド。
* Matching::                 終了区切りの挿入による、マッチする開始区切りのフラッシュ表示。

コメントの操作



* Comment Commands::         コメントの挿入、kill、位置揃え。
* Multi-Line Comments::      複数行のコメントを追加・編集するコマンド。
* Options for Comments::コメント機能のカスタマイズ。



ドキュメントのルックアップ



* Info Lookup::              Infoファイルからライブラリー関数やコマンドを探す。
* Man Page::                 manからライブラリー関数やコマンドを探す。
* Lisp Doc::                 Emacs関数を探す、その他。

Cモードと関連するモード



* Motion in C::              Cステートメント単位での移動など。
* Electric C::               コロンおよび他の文字による自動的な再インデント。
* Hungry Delete::            より強力なDELコマンド。
* Other C Commands::         コメントのフィル、マクロ展開の閲覧、その他のクールな機能。

Fortranモード

* Fortran Motion:: 命令文またはサブプログラムごとにポイントを移動する。
* Fortran Indent:: Fortranのためのインデントコマンド。
* Fortran Comments:: コメントの挿入と位置揃え。
* Fortran Autofill:: FortranをサポートするAuto Fill。
* Fortran Columns:: 有効なFortranのための列の計算。
* Fortran Abbrev:: Fortranキーワードのためのビルトインのabbrevs。

Fortranのインデント

* ForIndent Commands:: Fortranをインデントおよびフィルするコマンド。
* ForIndent Cont:: 継続行がインデントされる方法。
* ForIndent Num:: 行番号が自動インデントされる方法。
* ForIndent Conv:: トラブル防止のためにしたがわなければならない慣習。
* ForIndent Vars:: Fortranのインデントスタイルを制御する変数。


プログラムのコンパイルとテスト



* Compilation::              Lisp以外の言語(C、Pascal、など)のプログラムのコンパイル。
* Compilation Mode::         コンパイラーエラーをvisitするモード。
* Compilation Shell::        compilationバッファーで使えるようにシェルを適切にカスタマイズする。
* Grep Searching::           grepでの検索。
* Flymake::                  オンザフライでの構文エラーの検索。
* Debuggers::                非Lispプログラムのためのシンボルデバッガーの実行。
* Executing Lisp::           Lispプログラムを編集するためのさまざまなモードと、Lispプログラムを実行する異なる機能。
* Lisp Libraries::           LispプログラムがEmacsにロードされる方法。
* Lisp Eval::                Emacsでの1つのLisp式の実行。
* Lisp Interaction::         EmacsバッファーでのLispの実行。
* External Lisp::            Emacsを通じた別のLispとの対話。

Emacsの下でデバッガーを実行する



* Starting GUD::             デバッガーサブプロセスを開始する方法。
* Debugger Operation::       デバッガーとソースバッファーの関係。
* Commands of GUD::          一般的なコマンドのキーバインディング。
* GUD Customization::        GUDにたいして独自のコマンドを定義する。
* GDB Graphical Interface::  GDB機能を使用してグラフィカルなデバッグ環境を実装する拡張モード。

GDB Graphical Interface



* GDB User Interface Layout::  複数表示されたバッファーの制御。
* Source Buffers::           プログラムを制御するためにフリンジ・余白でマウスを使う。
* Breakpoints Buffer::       ブレークポイントのコントロールパネル。
* Threads Buffer::           スレッドの表示。
* Stack Buffer::             callスタックからのフレームの選択。
* Other GDB Buffers::        GDBの状態を制御するその他のバッファー。
* Watch Expressions::        speedbarで変数の値をモニターする。
* Multithreaded Debugging::  複数スレッドのプログラムのデバッグ。

大きなプログラムの保守



* Version Control::          バージョンコントロールシステムの使用。
* Change Log::               プログラムの変更履歴をメンテナンスする。
* Tags::                     1つのコマンドでプログラムの任意の関数に直接移動する。Tagsはそれがどのファイルにあるか記憶する。
* EDE::                      Emacsのための統合開発環境。
* Emerge:: 2つのバージョンのプログラムをマージする便利な方法。


Version Control



* Introduction to VC::       一般的にバージョンコントロールが機能する方法。
* VC Mode Line::             モードラインがバージョンコントロールの状態を表示する方法。
* Basic VC Editing::         バージョンコントロール下のファイルの編集方法。
* Log Buffer::               logエントリーバッファーで利用可能な機能。
* Registering::              バージョンコントロール下にファイルを置く。
* Old Revisions::            古いバージョンの調査と比較。
* VC Change Log::            VC Change Logの閲覧。
* VC Undo::                  コミット前後の変更の取り消し。
* VC Ignore::                バージョンコントロール下のファイルの無視。
* VC Directory Mode::        バージョンコントロールで管理されたファイルの一覧。
* Branches::                 開発における複数行。
* Miscellaneous VC:: その他のVCのさまざまなコマンドと機能。
* Customizing VC:: VCの動作を変更する変数。


バージョンコントロールの紹介



* Why Version Control?::     問題が示すところを理解するには。
* Version Control Systems::  バックエンドシステムとしてサポートされるバージョンコントロール。
* VCS Concepts::             バージョンコントロールに関連する単語と概念。
* VCS Merging::              ファイルの衝突を処理する方法。
* VCS Changesets::           変更がグループ化される方法。
* VCS Repositories::         バージョンコントロールのリポジトリーが格納される場所。
* Types of Log File::        VCS logとChangeLogの違い。

バージョンコントロール下での基本的な編集



* VC With A Merging VCS::    ロックしない:
                               CVSのデフォルトモード。
* VC With A Locking VCS::    RCSのデフォルトモード、SCCS、オプションでCVS。
* Advanced C-x v v::         プレフィクス引数で利用可能な上級機能。

VC Directory Mode



* VC Directory Buffer::      バッファーの外観と意味。
* VC Directory Commands::    VC
                               directoryバッファーで使用するコマンド。

ブランチのバージョンコントロール



* Switching Branches::       既存のブランチを取得する方法。
* VC Pull::                  ブランチの内容の更新。
* Merging::                  ブランチ間での変更の転送。
* Creating Branches::        新しいブランチを開始する方法。

VCのその他の機能とコマンド

* Change Logs and VC:: logエントリーからChangeLogファイルを生成する。
* VC Delete/Rename:: バージョンコントロールされたファイルの削除とリネームとは
* Revision Tags:: リビジョンにたいするシンボリック名。
* Version Headers:: 作業ファイルへのバージョンコントロールヘッダーの挿入。

VCのカスタマイズ

* General VC Options:: 複数のバックエンドに適用されるオプション。
* RCS and SCCS:: RCSとSCCSのためのオプションについて。
* CVS Options:: CVSにたいするオプションについて。


変更ログ(ChangeLog)



* Change Log Commands::      変更ログファイルを編集するためのコマンド。
* Format of ChangeLog::      変更ログファイルがどのように見えるか。

Tagsテーブル



* Tag Syntax::               さまざまなタイプのコードおよびテキストファイルにたいするタグ構文。
* Create Tags Table::        ‘etags’によるタグテーブルの作成。
* Etags Regexps::            正規表現を使用した不定タグの作成。
* Select Tags Table::        タグテーブルをvisitする方法。
* Find Tag::                 特定のタグの定義を見つけるコマンド。
* Tags Search::              検索と置換にたいしてタグテーブルを使う。
* List Tags::                補完および補完候補の一覧にタグを使う。

Emergeでのファイルのマージ

* Overview of Emerge:: Emergeを開始する方法と基本的な概念。
* Submodes of Emerge:: Fastモード vs. Editモード。Skip PrefersモードとAuto Advanceモード。
* State of Difference:: 各相違にたいしてAまたはBの状態を指定することによりマージを行う。
* Merge Commands:: 相違を選択したり相違の状態を変更するコマンドなど。
* Exiting Emerge:: マージを終えた後に行うこと。
* Combining in Emerge:: 相違にたいする両方の候補を維持する方法。
* Fine Points of Emerge:: その他の問題。


Abbrevs



* Abbrev Concepts::          定義されたabbrevsの基本。
* Defining Abbrevs::         abbrevを定義することによりタイプしたとき展開されるようになります。
* Expanding Abbrevs::        展開の制御 —
                               プレフィクス、展開の取り消し。
* Editing Abbrevs::          定義されたabbrevsのリスト全体の閲覧と編集。
* Saving Abbrevs::           他のセッションのためにabbrevsのリスト全体を保存する。
* Dynamic Abbrevs::          すでにバッファーにある単語にたいする略語。
* Dabbrev Customization::    動的abbrevsのための単語とは何か。ケースごとの処理。

ピクチャーの編集

* Basic Picture:: Pictureモードの基本概念と簡単なコマンド。
* Insert in Picture:: 自己挿入文字の後のカーソル移動方向の制御。
* Tabs in Picture:: タブストップとインデントにたいするさまざまな機能。
* Rectangles in Picture:: 矩形領域のクリアーと重ね合わせ。


ディレクトリーエディターDired



* Dired Enter::              Diredの呼び出し方。
* Dired Navigation::         Diredバッファーでの特別な移動コマンド。
* Dired Deletion::           Diredでのファイルの削除。
* Flagging Many Files::      ファイル名にもとづくファイルへのフラグ付け。
* Dired Visiting::           Diredによるその他のファイル操作。
* Marks vs Flags::           削除のためのフラグとマーク。
* Operating on Files::       1つまたは複数ファイルにたいするコピー、リネーム、プリント、圧縮など。
* Shell Commands in Dired::  マークしたファイルにたいするシェルコマンドの実行。
* Transforming File Names::  複数ファイルのリネームにパターンを使う。
* Comparison in Dired::      Diredのやり方で‘diff’を実行する。
* Subdirectories in Dired::  Diredバッファーにたいするサブディレクトリーの追加。
* Subdir Switches:: Diredでのサブディレクトリースイッチ
* Subdirectory Motion::      サブディレクトリー間の移動、上下への移動。
* Hiding Subdirectories::    サブディレクトリーの表示・非表示。
* Dired Updating::           重要でないファイル行の削除。
* Dired and Find::           Diredでファイルを選択するために‘find’を使う。
* Wdired::                   Diredバッファーの編集によりファイルを操作する。
* Image-Dired::              Diredでのイメージサムネイルの閲覧。
* Misc Dired Features::      その他のさまざまな機能。

カレンダーとダイアリー



* Calendar Motion::          カレンダー内の移動、日付の選択。
* Scroll Calendar::          過去または将来の月をスクリーンに表示する。
* Counting Days::            2つの日付の間の日数は?
* General Calendar::         カレンダーの終了と再計算。
* Writing Calendar Files::   さまざまなフォーマットでカレンダーをファイルに記述する。
* Holidays::                 休日の日付を表示する。
* Sunrise/Sunset::           日の出と日の入りの時間を地方時間で表示する。
* Lunar Phases::             月の位相の表示。
* Other Calendars::          他のカレンダーシステムへの日付の変換。
* Diary::                    ダイアリーからイベントを表示する。
* Appointments::             何かを行なう時刻のためのリマインダー。
* Importing Diary::          ダイアリーのイベントと他のフォーマットの変換。
* Daylight Saving::          夏時間がアクティブなときを指定する方法。
* Time Intervals::           時間間隔の追跡。
* Advanced Calendar/Diary Usage:: カレンダーとダイアリーの上級のカスタマイズ。


カレンダー内での移動



* Calendar Unit Motion::     日、週、月、年単位での移動。
* Move to Beginning or End::  週、月、年の開始と終了への移動。
* Specified Dates::          今日の日付や、特定の日付への移動。

他のカレンダーへ/からの変換



* Calendar Systems::         (グレゴリオ歴以外の)Emacsが理解するカレンだ。
* To Other Calendar::        選択された日付をさまざまなカレンダーに変換する。
* From Other Calendar::      他のカレンダーで指定された日付に移動する。

ダイアリー



* Displaying the Diary::     ダイアリーのエントリーと、それに関連するカレンダーの日付を閲覧する。
* Format of Diary File::     ダイアリーにイベントを入力する。
* Date Formats::             日付を指定するさまざまな方法。
* Adding to Diary::          ダイアリーのエントリーを作成するコマンド。
* Special Diary Entries::    記念日、日付ブロック、周期的なエントリーなど。

カレンダーとダイアリーのさらに上級の機能

* Calendar Customizing:: カレンダーのレイアウトとフック。
* Holiday Customizing:: 独自の休日を定義する。
* Mayan Calendar:: マヤ暦で指定された日付への移動。
* Date Display Format:: フォーマットの変更。
* Time Display Format:: フォーマットの変更。
* Diary Customizing:: セットできるデフォルト。
* Non-Gregorian Diary:: 他のカレンダーにもとづくダイアリーエントリー。
* Diary Display:: ダイアリーを表示する方法の選択。
* Fancy Diary Display:: インクルードされたダイアリーファイルを使ったダイアリーエントリーのソート。
* Sexp Diary Entries:: より柔軟なダイアリーエントリー。


Sending Mail



* Mail Format::              メールメッセージのフォーマット。
* Mail Headers::             いくつかの標準的なメールヘッダーフィールドの詳細。
* Mail Aliases::             メールアドレスの短縮とグループ化。
* Mail Commands::            作成するメールを編集するための特別なコマンド。
* Mail Signature::           各メッセージに署名を追加する。
* Mail Amusements::          NSAを混乱させるキーワードや、fortuneのメッセージを累加する。
* Mail Methods::             他のメール作成方法を使用する。

Mail Commands



* Mail Sending::             メッセージを送信するコマンド。
* Header Editing::           ヘッダーフィールドに移動して編集するコマンド。
* Citing Mail::              返信するメッセージのクォート。
* Mail Misc::                ファイル添付、スペルチェックなど。

Rmailでメールを読む



* Rmail Basics::             Rmailの基本的な概念と簡単な使い方。
* Rmail Scrolling::          メッセージをスクロールする。
* Rmail Motion::             他のメッセージへの移動。
* Rmail Deletion::           メッセージの削除と完全な削除。
* Rmail Inbox::              メールがRmailファイルに取り込まれる方法。
* Rmail Files::              複数のRmailファイルの使用。
* Rmail Output::             メッセージを外部ファイルにコピーする。
* Rmail Labels::             メッセージにラベルをつけて分類する。
* Rmail Attributes::         属性と呼ばれる標準的なラベル。
* Rmail Reply::              閲覧しているメッセージにたいして返信する。
* Rmail Summary::            多くのメッセージの簡単な情報の要約。
* Rmail Sorting::            Rmailでのメッセージのソート。
* Rmail Display::            Rmailがメッセージを表示する方法とカスタマイズ。
* Rmail Coding::             Rmailがデコードされた文字セットを扱う方法。
* Rmail Editing::            Rmailでのメッセージのテキストとヘッダーの編集。
* Rmail Digest::             メッセージのダイジェストからメッセージを抽出する。
* Rmail Rot13::              rot13コードでエンコードされたメッセージの閲覧。
* Movemail::                 新たなメールのフェッチに関する詳細。
* Remote Mailboxes::         リモートmailboxからのメールの取得について。
* Other Mailbox Formats::    さまざまなフォーマットのローカルmailboxからのメールの取得。

Rmailのサマリー



* Rmail Make Summary::       さまざまな種類のサマリーの作成。
* Rmail Summary Edit::       サマリーからのメッセージの操作。

Gnus



* Buffers of Gnus::          グループ、サマリー、アーティクルバッファー。
* Gnus Startup::             Gnusの開始するにあたって知っておくべきこと。
* Gnus Group Buffer::        Gnusグループコマンドの短い説明。
* Gnus Summary Buffer::      Gnusサマリーコマンドの短い説明。

ドキュメントの閲覧



* DocView Navigation::       DocViewバッファーの操作。
* DocView Searching::        ドキュメント内の検索。
* DocView Slicing::          ページのどの部分を表示するか指定する。
* DocView Conversion::       変換に影響を与えたり、それを誘因するもの。

Emacsからシェルコマンドを実行する



* Single Shell::             シェルコマンドを実行して戻る方法。
* Interactive Shell::        Emacsを通じて入力を行なう永続的なシェル。
* Shell Mode::               永続的なシェルで使用される特別なEmacsコマンド。
* Shell Prompts::            シェルプロンプトを認識する2つの方法。
* Shell History::            シェルバッファーで前のコマンドを繰り返す。
* Directory Tracking::       サブシェルでのディレクトリーの変更の追跡。
* Shell Options::            Shellモードをカスタマイズするオプション。
* Terminal emulator::        端末エミュレーターとしてのEmacsウィンドウ。
* Term Mode::                Termモードで使用される特別なEmacsコマンド。
* Remote Host::              他のコンピューターへの接続。
* Serial Terminal::          シリアルポートへの接続。

シェルコマンドヒストリー



* Shell Ring::               ヒストリーリストからコマンドを取り出す。
* Shell History Copying::コマンドに移動してそれをコピーする。
* History References::       ‘!’スタイルのヒストリー参照の展開。

サーバーとしてのEmacsの使用



* Invoking emacsclient::     Emacsサーバーでの接続。
* emacsclient Options::      Emacsクライアントの開始オプション。

ハードコピーの印刷



* PostScript::               バッファーまたはリージョンをPostScriptとして印刷する。
* PostScript Variables::     PostScript印刷コマンドのカスタマイズ。
* Printing Package::         オプションの上級向け印刷インターフェース。

ハイパーリンクとナビゲーション機能



* Browse-URL::               URLを辿るには。
* Goto Address mode::        URLのアクティブ化について。
* FFAP::                     ポイント位置のファイルを探す、など。

Emacs Lispパッケージ



* Package Menu::             パッケージを閲覧・管理するためのバッファー。
* Package Installation::     パッケージのインストールにたいするオプション。
* Package Files::            パッケージがインストールされる場所。

Customization



* Easy Customization::       設定を閲覧したり変更する便利な方法。
* Variables::                多くのEmacsコマンドは何を行なうか決定するためにEmacs変数を調べるので、変数をセットすることによりこれらの機能を制御できます。
* Key Bindings::             keymapには各キーが実行するコマンドが記述されています。それを変更することによりキーを再定義できます。
* Init File::                初期化ファイルで一般的なカスタマイズを記述する方法。

Easy Customizationインターフェース



* Customization Groups::     セッティングがクラス化される方法。
* Browsing Custom::          セッティングのブラウズとサーチ。
* Changing a Variable::      オプション値の編集、およびオプションをセットする方法。
* Saving Customizations::    将来のEmacsセッションのためにカスタマイズを保存する。
* Face Customization::       フェイスの属性を編集する方法。
* Specific Customization::   グループの特定のセッティングのカスタマイズ。
* Custom Themes::            カスタマイズセッティングのコレクション。
* Creating Custom Themes::   新しいカスタムテーマを作成する方法。

Variables



* Examining::                変数の値の検証とセッティング。
* Hooks::                    フック変数によりEmacsの一部にたいして特定の機会に実行するプログラムを指定できます。
* Locals::                   変数のバッファーごとの値。
* File Variables::           ファイルが変数の値を指定する方法。
* Directory Variables::      ディレクトリーにより変数の値を指定する方法。

ファイル内のローカル変数



* Specifying File Variables::  ファイルローカル変数の指定。
* Safe File Variables::      ファイルローカル変数が安全であることを確認する。

キーバインドのカスタマイズ



* Keymaps::                  一般的な考え方。グローバルキーマップ。
* Prefix Keymaps::           プレフィクスキーにたいするキーマップ。
* Local Keymaps::            キーマップをもつメジャーモードとマイナーモード。
* Minibuffer Maps::          ミニバッファーが使用する独自のキーマップ。
* Rebinding::                あるキー意味を再定義する便利な方法。
* Init Rebinding::           初期化ファイルでのキーのリバインド。
* Modifier Keys::            キーバインドでの修飾キーの使用。
* Function Keys::            端末のファンクションキーのリバインド。
* Named ASCII Chars::        <TAB>と‘C-i’などを区別する方法。
* Mouse Buttons::            Emacsでのマウスボタンのリバインド。
* Disabling::                コマンドを無効にするとは、それを実行出きるようにする前に確認が要求されることを意味します。これはビギナーを戸惑わせないようにするために行なわれます。

Emacsの初期化ファイル



* Init Syntax::              Emacs Lispでの定数の構文。
* Init Examples::            initファイルで何かを行なう方法。
* Terminal Init::            端末タイプごとのinitファイル。
* Find Init::                Emacsがinitファイルを探す方法。
* Init Non-ASCII::           initファイルでの非ASCII文字の使用。

Emacsでトラブルに対処する



* DEL Does Not Delete::      <DEL>で削除できないとき何を行なうか。
* Stuck Recursive::          モードラインのカッコの周囲の‘[...]’。
* Screen Garbled::           画面上のゴミ。
* Text Garbled::             テキスト内のゴミ。
* Memory Full::              メモリー不足に対処する方法。
* Crashing::                 クラッシュ時にEmacsが何を行なうか。
* After a Crash::            クラッシュしたEmacsセッションの編集のリカバリー。
* Emergency Escape::         Emacsが応答しなくなったとき何を行なうか。

バグの報告



* Known Problems::           既知の問題とバグについて読む方法。
* Bug Criteria::             本当にバグを見つけたのか?
* Understanding Bug Reporting::  バグを報告する効果的な方法。
* Checklist::                良いバグレポートのためにしたがうべきステップ。
* Sending Patches::          GNU Emacsにパッチを送る方法。

Emacs呼び出しにたいするコマンドライン引数



* Action Arguments::         ファイルのvisit、ライブラリーのロード、関数を呼び出す引数。
* Initial Options::          Emacsの開始に影響する引数。
* Command Example::          コマンドライン引数の使用例。
* Environment::              Emacsが使用する環境変数。
* Display X::                デフォルトディスプレーの変更と、リモートログインの使用。
* Font X::                   Xでのテキストのフォント選択。
* Colors X::                 ディスプレーカラーの選択。
* Window Size X::            Xでのスタートアップウィンドウのサイズ。
* Borders X::                Xでの内枠ボーダーと外枠ボーダー。
* Title X::                  初期フレームのタイトルの指定。
* Icons X::                  Xで使用するアイコンの選択。
* Misc X::                   その他のディスプレーオプション。

環境変数



* General Variables::        すべてのバージョンのEmacsが使用する環境変数。
* Misc Variables::           システム固有の変数。
* MS-Windows Registry::      MS-Windowsでの環境の代用。

Xオプションとリソース



* Resources::                EmacsでXリソースを使用する(一般論として)。
* Table of Resources::       Emacsに影響する特定のXリソースの表。
* Lucid Resources::          LucidメニューにたいするXリソース。
* Motif Resources::          MotifおよびLessTifメニューにたいするXリソース。
* GTK resources::            GTKウィジェットにたいするリソース。

GTK resources



* GTK Resource Basics::      GTK+リソースの基本的な使い方。
* GTK Widget Names::         GTK+ウィジェットの命名方法。
* GTK Names in Emacs::       Emacsが使用するGTK+ウィジェット。
* GTK styles::               GTK+ウィジェットの何がカスタマイズできるか。

EmacsとMac OS、GNUstep



* Mac / GNUstep Basics::     GNUstepまたはMac
                               OSでのEmacsの基本的な使用方法。
* Mac / GNUstep Customization::  GNUstepまたはMac
                                   OSでのカスタマイズ。
* Mac / GNUstep Events::     ウィンドウシステムイベントが処理される方法。
* GNUstep Support::          GNUstepサポート状態の詳細。

EmacsとMicrosoft Windows/MS-DOS



* Windows Startup::          WindowsでEmacsを開始する方法。
* Text and Binary::          行末にCRLFを使用するテキストファイル。
* Windows Files::            Windowsのファイル名の慣習。
* ls in Lisp::               Diredにたいする‘ls’のエミュレーション。
* Windows HOME::             開始時にEmacsが‘.emacs’を探す場所。
* Windows Keyboard::         Windows特有のキーボード機能。
* Windows Mouse::            Windows特有のマウス機能。
* Windows Processes::        Windowsでのサブプロセスの実行。
* Windows Printing::         MS-Windowsでプリンターを指定する方法。
* Windows Fonts::            MS-Windowsでのフォントの指定。
* Windows Misc::             その他のWindowsの機能。
* MS-DOS:: MS-DOSでのEmacsの使用。

EmacsとMS-DOS

* MS-DOS Keyboard:: MS-DOSでのキーボードの慣習。
* MS-DOS Mouse:: MS-DOSでのマウスの慣習。
* MS-DOS Display:: MS-DOSでのフォント、フレーム、ディスプレーのサイズ。
* MS-DOS File Names:: MS-DOSでのファイル名の慣習。
* MS-DOS Printing:: MS-DOSでの印刷の特性。
* MS-DOS and MULE:: MS-DOSでの国際化のサポート。
* MS-DOS Processes:: MS-DOSでのサブプロセスの実行。




File: emacs.info,  Node: Distrib,  Next: Intro,  Prev: Top,  Up: Top

ディストリビューション
**********************

GNU Emacsは“free software(フリーソフトウェアー、自由なソフトウェアー)”で
す。これはすべての人が自由に使用でき、特定の条件の元に自由に再配布できる
ことを意味します。GNU Emacsはパブリックドメイン(public domain: 特許権の
消滅状態)ではありません。copyright(版権)されており、配布については制限が
あります。しかし、それらの制限は良き共同的な市民(good cooperating
citizen)が行ないたいと欲するであろう、すべてのことを許すようデザインされ
ています。なにが許されていないか、それはあなたから取得するかもしれない
GNU Emacsの任意のバージョンの更なる共有を妨げる試みです。これの正確な条
件はEmacsのGNU General Public Licenseで見ることができ、このマニュアルに
も記載されています(1)。 *note Copying::を参照してください。

   GNU Emacsのコピーを入手する1つの方法は、それを所有する他の誰かから入
手する方法です。これを行なうための許可を求めたり、他の誰かに告げる必要は
ありません。ただコピーするだけです。インターネットへアクセスできるなら、
匿名FTPからGNU NEmacsの最新のディストリビューションバージョンを入手でき
ます。わたしたちのウェブサイトについての詳細は、
<http://www.gnu.org/software/emacs>を参照してください。

   コンピューターを購入したときに、GNU Emacsを入手するかもしれません。コ
ンピューター業者は、他のすべての人に適用されるのと同じ条件で、コピーを自
由に配布できます。これらの条件は、コンピューター業者がソースにたいして行
なった変更を含む完全なソースをあなたに与えることと、General Public
Licenseの通常の条件の下に、入手したGNU Emacsをあなたが再配布できることを
要求します。言い換えると、そのプログラムはあなたが入手したときはフリーで
なければならず、業者にとっては単にフリーという訳ではありません。

   GNU Emacsが有用だと思ったら、わたしたちの作業をサポートするために、ど
うかFree Software Foundationに*寄付を送ってください*。合衆国ではFree
Software Foundationへの寄付は、税金が控除されます。職場でGNU Emacsを使用
している場合は、どうかその企業に寄付を行なうよう提案してください。寄付を
するには、<https://my.fsf.org/donate/>を参照してください。あなたが手助け
できる他の方法については、<http://www.gnu.org/help/help.html>を参照して
ください。

   わたしたちは、このマニュアルと、Robert J. Chassellによる‘An
Introduction to Programming in Emacs Lisp’のハードコピーも販売しています
。あなたは、わたしたちのオンラインショップ<http://shop.fsf.org/>を訪れる
ことができます。販売による収益は、Free Software Foundationの目的 — すな
わち新しいソフトウェアーの開発、GNU Emacsを含む既存のプログラムの改良を
サポートします。

   Free Software Foundationに連絡する必要がある場合は、
<http://www.fsf.org/about/contact/>を参照するか、下記に手紙を送ってくだ
さい

     Free Software Foundation
     51 Franklin Street, Fifth Floor
     Boston, MA 02110-1301
     USA

   ---------- Footnotes ----------

   (1) このマニュアル自身はGNU Free Documentation Licenseにより保護され
ています。このライセンスの精神はGeneral Public Licenseと同様ですが、より
ドキュメントに適したものです。*note GNU Free Documentation License::を参
照してください。


File: emacs.info,  Node: Intro,  Next: Screen,  Prev: Distrib,  Up: Top

イントロダクション
******************

あなたはEmacsのマニュアル読んでいるところです。Emacsは、セルフドキュメン
ト方式で、カスタマイズ可能で、拡張可能エディターであり、GNUの先進性を具
現化したものです( GNU (GNU’s Not Unix) の‘G’は発音します)。

   Emacsは“先進的(advanced)”であるというのは、単純な挿入と削除だけでなく
、プロセスの制御、プログラムのインデントの自動化、複数ファイルの同時表示
、整形済みテキストの編集、文字、単語、行、文、段落、ページを扱うのと同様
に、異なるプログラミム言語の式やコメントを扱う機能なども提供するからです
。

   “セルフドキュメント方式(Self-documenting)”とは、いつでも“ヘルプコマン
ド”として知られる、特別なコマンドを使うことができることです。これはどの
ようなオプションがあるのか、コマンドが何をするのかを見つけたり、与えられ
たトピックと関連するすべてのコマンドを見つけることができるコマンドです。
*note Help::を参照してください。

   “カスタマイズ可能(Customizable)”とは、シンプルな方法でEmacsコマンドの
動作を簡単に変更できるということです。たとえば、‘<**’で始まり‘**>’で終わ
るようなコメントのプログラム言語を使っている場合は、Emacsのコメント操作
コマンドに、これらの文字列を使うように指示できます(*note Comments::を参
照してください)。別の例としては、カーソル動作(上下左右)を再編成して使い
やすくカスタマイズできます。*note Customization::を参照してください。

   “拡張可能(Extensible)”とは、単純なカスタマイズではなく、まったく新し
いコマンドを作成できるということです。新しいコマンドは、Emacs自身の
Lisp処理系で動作する、Lisp言語でプログラムを記述されます。既存のコマンド
は、編集を行なっている最中でさえ、Emacsを再起動することなく再定義できま
す。Emacsのほとんどの編集コマンドはLispで記述されています。Lispで記述す
ることも可能ですが、効率のためにCで記述されているものもあります。拡張機
能の記述はプログラミングですが、プログラマーでない人も後でそれを使うこと
ができます。もしあなたがEmacs Lispを学びたければ、*note Emacs Lisp
Intro: (eintr)Top.を参照してください。


File: emacs.info,  Node: Screen,  Next: User Input,  Prev: Intro,  Up: Top

1 画面の構成
************

Xウィンドウシステムを使うGNU/Linuxのようなグラフィカルなディスプレーの場
合、Emacsは“グラフィカルなウィンドウ”に表示されます。テキスト端末の場合
、Emacsは端末スクリーン全体を表示領域として使います。Emacsが占有する画面
スクリーンや、グラフィカルなウィンドウを指して、“フレーム(frame)”という
用語を使用します。Emacsの振る舞いは、どちらのフレームでも同じです。通常
は1個のフレームだけで始まりますが、必要ならば新たにフレームを作れます
(*note Frames::を参照してください)。

   それぞれのフレームにはいくつかの領域が含まれています。いちばん上のフ
レームは“メニューバー(menu bar)”で、メニューにある一連のコマンドにアクセ
スできます。グラフィカルなディスプレーでは、メニューバーのすぐ下に“ツー
ルバー(tool bar)”があり、アイコンをクリックすることにより編集コマンドを
実行できます。いちばん下のフレームは“エコーエリア(echo area)”で、メッセ
ージが表示されたり、Emacsが入力を求める際に使用されます。

   (もしあれば)ツールバーの下とエコーエリアの間の、フレームの主要な領域
の部分を、“ウィンドウ(the window)”といいます。このマニュアルでは“ウィン
ドウ”という言葉を、上記のような場合に使います。グラフィカルなディスプレ
ーのシステムでは、“ウィンドウ”という言葉を違う意味で用いますが、上述した
とおり、そのような“グラフィカルなウィンドウ”のことは、“フレーム”と呼ぶこ
とにします。

   Emacsのウィンドウには、“バッファー(buffer)” — 編集中のテキスト — が表
示されます。グラフィカルなディスプレーでは、ウィンドウの片側に“スクロー
ルバー(scroll bar)”あり、これを使ってバッファー内をスクロールできます。
ウィンドウのいちばん下の行は、“モードライン(mode line)”です。これには保
存されてない変更や、使用されている編集モード、現在のライン番号など、バッ
ファーについての様々な情報が表示されます。

   Emacsを起動すると、通常フレームには1つのウィンドウが表示されます。し
かしこのウィンドウを水平方向、または垂直方向に分割して複数のウィンドウを
作成し、それぞれ異なるバッファーを表示することもできます(*note
Windows::を参照してください)。

   どんな時でも、1つのウィンドウが“選択されたウィンドウ(selected
window)”となります。グラフィカルなディスプレーでは、選択されたウィンドウ
には目立つカーソル(通常は塗りつぶされて点滅している)が表示され、他のウィ
ンドウには目立たないカーソル(通常はぬりつぶされていない四角)が表示されま
す。テキスト端末では、選択されたウィンドウのカーソルだけが表示されます。
選択されたウィンドウ上に表示されているバッファーを、“カレントバッファー
(current buffer)”と呼び、それが編集が行われているバッファーとなります。
多くのEmacsコマンドはカレントバッファーに暗黙に適用され、選択されてない
ウィンドウに表示されているテキストは参照用に使用します。もしグラフィカル
なディスプレーで複数のフレームを使っている場合、特定のフレームを選択する
と、そのフレームのウィンドウが選択されます。

* Menu:

* Point::                    テキスト内で編集コマンドが作用する場所
* Echo Area::                スクリーンのいちばん下で、短いメッセージが表示されます
* Mode Line::                モードを説明するライン
* Menu Bar::                 メニューバーの使い方


File: emacs.info,  Node: Point,  Next: Echo Area,  Up: Screen

1.1 ポイント
============

カーソルは、選択されたウィンドウで多くの編集コマンドが作用する場所を示し
、その場所を“ポイント(point)”(1)と呼びます。多くのEmacsコマンドはポイン
トをテキスト中で移動し、テキスト中のさまざまな箇所で編集できるようにしま
す。マウスのボタン1(通常は左ボタン)をクリックしても、ポイントを移動でき
ます。

   デフォルトでは、選択されたウィンドウ上にある、塗りつぶされたボックス
のカーソルは文字の_上_に表示されますが、ポイントは2つの文字の_間_にある
と考える必要があります。つまりポイントは、カーソルが重なっている文字の
_前_にあります。たとえば、‘frob’というテキストで、‘b’にカーソルがある場
合、ポイントは‘o’と‘b’の間にあります。その位置に‘!’という文字を挿入する
と、‘fro!b’という結果になり、ポイントは‘!’と‘b’の間にあります。つまりカ
ーソルは‘b’の上にあり、実行前と同じです。

   Emacsでいくつかのファイルを編集して、各ファイルがそれぞれ専用のバッフ
ァーにある場合、各バッファには独自のポイント位置があります。バッファーが
表示されていなくても、後で表示されるときに備えて、ポイント位置を記録して
います。1つのフレームに複数のウィンドウがある場合、各ウィンドウには独自
のポイント位置があります。

   Emacsがカーソルをどのように表示するか制御する方法については、*note
Cursor Display::を参照してください。

   ---------- Footnotes ----------

   (1) “point”という用語は、文字‘.’に由来します。この文字は、現在ポイン
トと呼んでいる値を参照するためのTECO(オリジナルのEmacsを記述していた言語
)のコマンドです。


File: emacs.info,  Node: Echo Area,  Next: Mode Line,  Prev: Point,  Up: Screen

1.2 エコーアリア
================

フレームの1番下の行は、“エコーエリア(echo area)”です。ここは、いろいろな
目的向けの短いテキスト表示に使われます。

   エコーエリアという名前は、あなたが打った文字が“エコーされる”ことが由
来で、これは複数の文字からなるコマンドが表示されることを意味します。1文
字のコマンドをエコーすることはありません。複数の文字からなるコマンド
(*note Keys::を参照してください)の途中で、入力中に1秒以上間を置くとエコ
ーされます。Emacsはそれまでに入力されたコマンドの文字を表示し、ユーザー
に残りの文字の入力を促します。いったんエコーが始まると、コマンドの残りは
、打つと同時にただちにエコーされます。これは、タイプに自信のあるユーザー
には速い応答を提供する一方で、自信のないユーザーには最大限のフィードバッ
クを与えるための機能です。

   エコーエリアは、コマンドを実行できなかったときに、“エラーメッセージ
(error message)”を表示するためにも使用されます。エラーメッセージと共に、
ビープ音が鳴ったり、画面が点滅する場合もあります。

   エコーエリアに有用なメッセージを表示するコマンドもあります。これらの
“有用”なメッセージは、エラーメッセージによく似ていますが、ビープ音を伴わ
ず点滅もしません。たとえば、コマンド‘C-x =’(<Ctrl>を押したまま‘x’をタイ
プし、<Ctrl>を離してから‘=’をタイプします)は、テキスト中のポイントの文字
位置と、ウィンドウの現在の列位置を示すメッセージを表示します。処理に時間
のかかるコマンドでは、実行中に‘...’(どの程度進行したかをパーセント表示で
示す場合もあります)で終わるメッセージをエコーエリアに表示し、完了時には
‘done’を最後に付け加えることがよくあります。

   エコーエリアに表示される有益なメッセージは、‘*Messages*’と呼ばれる特
別なバッファーに保存されます(まだバッファーについては説明していませんが
、詳細は*note Buffers::を参照してください)。画面上に短時間しか表示されな
いメッセージを見逃してしまった場合には、‘*Messages*’バッファーに切り替え
て、もう一度そのメッセージを見ることができます。‘*Messages*’のサイズは、
ある行数に制限されています。変数‘message-log-max’は、その行数を指定しま
す(まだ変数については説明していませんが、詳細は*note Variables::を参照し
てください)。いったんバッファーがこの行数を超えると、最後に1行加わるごと
に先頭の1行を削除します。

   Emacsがエコーエリアをどのように使用するか制御するオプションについては
、*note Display Custom::を参照してください。

   エコーエリアは“ミニバッファー(minibuffer)”の表示にも使われます。これ
は、編集しようとするファイル名のような、コマンドへの引数を読むのに使われ
るウィンドウです。ミニバッファーが使用されているとき、エコーエリアには
“プロンプト文字列(prompt string)”で始まるテキストが表示され、エコーエリ
アが一時的に選択されたウィンドウとなり、カーソルもその行に表示されます。
‘C-g’を打つと、いつでもミニバッファーから抜けられます。*note
Minibuffer::を参照してください。


File: emacs.info,  Node: Mode Line,  Next: Menu Bar,  Prev: Echo Area,  Up: Screen

1.3 モードライン
================

ウィンドウの最後の行は“モードライン(mode line)”で、そのウィンドウで何が
進行しているか表示します。ウィンドウが1つしかない場合、モードラインはエ
コーエリアのすぐ上に表示されます。フレームでは最後から2番目の行になりま
す。グラフィカルなディスプレーでは、モードラインは立体的に描画されます。
通常、Emacsは目立つように選択されたウィンドウのモードラインを、選択され
ていないウィンドウと異なるカラーで描画します。

   モードラインに表示されるテキストは以下の書式です:

      CS:CH-FR  BUF      POS LINE   (MAJOR MINOR)

テキスト端末では、上記テキストの後ろからウィンドウの右端まで一連のダッシ
ュ表示されます。これらのダッシュはグラフィカルなディスプレーでは省略され
ます。

   CSとその後ろのコロンは、カレントバッファーのキャラクターセットと改行
の規則を説明しています。通常Emacsはこれらの設定を自動的に処理しますが、
このメッセージが便利なときもあります。

   CSはバッファーのキャラクターセットを説明します(*note Coding
Systems::を参照してください)。もしこれがダッシュ(‘-’)の場合、特定のキャ
ラクターセットの処理が行われていないことを意味します(例外として、以降で
説明する行末規則があります)。‘=’の場合は、変換が行われていないことを意味
し、通常はテキストに非テキストデータが含まれているときに使用されます。他
の文字はさまざまな“コーディングシステム(coding systems)” — たとえば‘1’は
ISO Latin-1を表します。

   テキスト端末ではCSの前に追加で2つの文字が表示され、それによりキーボー
ド入力と端末出力のコーディングシステムが示されます。さらに何らかの入力メ
ソッドを使用している場合は、CSの前に入力メソッドを識別する文字列が表示さ
れます(*note Input Methods::を参照してください)。

   CSの後ろの文字は、通常コロンです。もし違う文字が表示されている場合、
それはファイルのエンコーディングに特別な行末規則が使われていることを意味
します。通常ファイル内のテキストの各行は“改行文字(newline characters)”で
区切られていますが、他の2つの規則が使われる場合もあります。MS-DOSのファ
イルを編集する場合には“キャリッジリターン(carriage-return)”と“ラインフィ
ード(linefeed)”が使われ、コロンではなくバックスラッシュ(‘\’)または
‘(DOS)’(オペレーティングシステムに依存する)が表示されます。古いマッキン
トッシュシステムのファイルでは、改行文字の代わりに“キャリッジリターン
(carriage-return)”が使われ、そのような場合コロンではなくスラッシュ
(‘/’)または‘(Mac)’が表示されます。いくつかのシステムでは行の区切りとして
改行文字を使う場合、コロンではなく‘(Unix)’と表示されます。

   モードラインの次の要素はCHで示される文字列です。2つのダッシュ(‘--’)が
表示されている場合、ウィンドウに表示されているバッファーとディスク上のフ
ァイルの内容が同じことを意味し、たとえばバッファーが“未変更
(unmodified)”の場合です。バッファーが変更されている場合には2つの星印
(‘**’)が表示されます。読み出し専用のバッファーの場合には、バッファーが編
集されている場合には‘%*’になり、バッファーが編集されていない場合には
‘%%’となります。

   通常、CHの後ろの文字はダッシュ(‘-’)です。しかしカレントバッファーのデ
フォルトディレクトリーがリモートマシン上にある場合、かわりに‘@’が表示さ
れます(*note File Names::を参照してください)。

   FRは選択されているフレームの名前です(*note Frames::を参照してください
)。これはテキスト端末でだけ表示されます。フレーム名の初期値は‘F1’です。

   BUFは、ウィンドウに表示されているバッファーの名前です。通常は編集中の
ファイル名と同じです。*note Buffers::を参照してください。

   POSはウィンドウの上またはウィンドウの下に、まだテキストがあるかを知ら
せます。もしバッファーが小さくてウィンドウに全体が表示されている場合、
POSには‘All’が表示されます。そうではなくバッファーの一部が表示されている
ときには、バッファーの先頭が表示されている場合には‘Top’、バッファーの最
後が表示されている場合には‘Bot’、‘NN%’と表示されている場合、NNはウィンド
ウの上部がバッファーのどこかをパーセント表示したものです。Size
Indication(サイズ表示)モードでは、バッファー全体のサイズを表示できます。

   LINEは、‘L’のあとに現在ポイントがある行の番号が続いたものです(Column
Number(列番号)モードをオンにすると、現在の列番号も表示できます。*note
Optional Mode Line::を参照してください)。

   majorは、そのバッファの“メジャーモード(major mode)”の名前です。メジャ
ーモードはバッファーを編集する際の主要なモードで、Textモード、Lispモード
、Cモードなどがあります。*note Major Modes::を参照してください。メジャー
モード名の後ろに追加の情報を表示するメジャーモードもあります。たとえば
Compilation buffer(コンパイルバッファー)やShell buffer(Shellバッファー
)などは、サブプロセスの状態を表示します。

   MINORは有効になっている“マイナーモード(minor modes)”の一覧で、上位の
メジャーモードに追加の機能を提供するための編集モードです。*note Minor
Modes::を参照してください。

   いくつかの機能は、それらが本当はマイナーモードではなくても、有効にな
っていればマイナーモードの一覧とともに表示されます。‘Narrow’は、表示中の
バッファーが、そのテキストの一部のみを編集するように制限されていることを
示します(*note Narrowing::を参照してください)。‘Def’は、キーボードマクロ
を定義中であることを示します(*note Keyboard Macros::を参照してください
)。

   さらにEmacsがリカーシブエディットにあるときには、モードを囲んでいるカ
ッコの周りに角カッコ(‘[...]’)が現れます。リカーシブエディット中も別のリ
カーシブエディットに入ると、角カッコは2重になります。リカーシブエディッ
トは、特定のバッファにだけ関係するものではなく、Emacs全体に影響するので
、角カッコはすべてのウィンドウのモード行に表示されるか、まったく表示され
ないのどちらかです。*note Recursive Edit::を参照してください。

   モードラインの外観は、その内容の書式と同様、変更できます。*note
Optional Mode Line::を参照してください。さらにモードラインはマウスに反応
します。モードラインの違う部分をクリックすることでさまざまなコマンドを実
行できます。*note Mode Line Mouse::を参照してください。


File: emacs.info,  Node: Menu Bar,  Prev: Mode Line,  Up: Screen

1.4 メニューバー
================

各Emacsフレームには通常、最上部に“メニューバー(menu bar)”があり、よく使
われる操作を実行するために使用できます。これはあなた自身で簡単に確かめら
れますから、ここではそれらを列挙する必要はないでしょう。

   マウスをサポートするディスプレー上では、マウスを使ってメニューバーか
らコマンドを選ぶことができます。メニューアイテムの後にある右矢印は、その
アイテムにサブメニューがあることを示します。アイテムの最後に‘...’がある
場合は、コマンドを実際に実行する前に、そのコマンドがキーボードから引数を
読み取ることを意味します。

   メニューのコマンドの中には、他のコマンドと同様、キーが割り当てられて
いるものもあります。そのような場合、メニューのアイテムの後ろのカッコ内に
キーバインディングが表示されます。メニューアイテムの完全なコマンド名や説
明文を見るには、‘C-h k’とタイプしてから、通常どおりにマウスでメニューバ
ーを選択してください(*note Key Help::を参照してください)。

   マウスを使う代わりに<F10>(コマンド‘menu-bar-open’を実行します)を押せ
ば、メニューバーの最初のアイテムを呼び出すことができます。その後は矢印キ
ーでメニュー操作できます。選択されたメニューアイテムを起動するときは
<RET>、メニュー操作をキャンセルするときは‘C-g’か‘<ESC> <ESC> <ESC>’を押
します。

   テキスト端末では、エコーエリアからメニューバーのメニューにアクセスす
ることもできます。これを行うには、変数‘tty-menu-open-use-tmm’をカスタマ
イズして、非‘nil’値にします。その後は<F10>をタイプするとメニューをドロッ
プダウンせずに、コマンド‘tmm-menubar’が実行されます(‘M-`’は常に
‘tmm-menubar’を呼び出します)。‘tmm-menubar’では、キーボードでメニューア
イテムを選択できます。暫定的な候補がエコーエリアに表示されるので、上矢印
か下矢印でメニューの異なるアイテムを表示し、<RET>を押せばアイテムを選択
できます。各メニューアイテムを文字か数字で指定することもできます(通常メ
ニューアイテム名のイニシャル)。この文字または数字とアイテム名は‘==>’で区
切られています。アイテムの文字または数字を押せばアイテムを選択することが
できます。


File: emacs.info,  Node: User Input,  Next: Keys,  Prev: Screen,  Up: Top

2 ユーザーインプットの種類
**************************

GNU Emacsは、主にキーボードを使うようにデザインされています。マウスを使
ってメニューバーやツールバーの編集コマンドを実行することはできますが、キ
ーボードを使う場合に比べて効率的ではありません。したがって、このマニュア
ルには主にキーボードで編集する方法を記します。

   Emacsにたいするキーボード入力は、ASCIIを大きく拡張したバージョンが基
本となっています。‘a’、‘B’、‘3’、‘=’や空白文字(<SPC>)と表記します)などの
単純な文字は、それぞれに対応するキーをタイプして入力します。<RET>、
<TAB>、<DEL>、<ESC>、<F1>、<Home>、<LEFT>などの制御文字なども、この方法
で入力できますし、非英語キーボードの特定の文字も同様です(*note
International::を参照してください)。

   Emacsは“修飾キー(modifier keys)”を用いて入力された制御文字も認識しま
す。よく使用される修飾キーは、<Control>(通常<Ctrl>)というラベル)と、
<META>(通常<Alt>(1)というラベル)の2つです。たとえば、‘Control-a’は
<Ctrl>を押したままで‘a’を押して入力しますが、これを短く‘C-a’と記します。
同様に、‘<META>-a’または短く‘M-a’は、<Alt>を押したまま‘a’を押すことです
。修飾キーは英数文字以外のキーにも適用できます。例: ‘C-<F1>’、‘M-<LEFT>’

   <ESC>で始まる2文字キーシーケンスを使って、Meta文字を入力することもで
きます。したがって‘M-a’を‘<ESC> a’と入力することができます。‘C-M-a’は
‘<ESC> C-a’と入力できます。<META>と違い、<ESC>は切り離された文字です。次
の文字を押すとき<ESC>を押しっぱなしにするのではなく、<ESC>を押して離して
から次の文字を入力します。この機能は<META>キーをあてにできない、一部のテ
キスト端末で有用です。

   グラフィカルなディスプレーでは、ウィンドウマネージャーが‘M-<TAB>’、
‘M-<SPC>’、‘C-M-d’、‘C-M-l’などのキーボード入力をブロックするかもしれま
せん。このような問題がある場合、ウィンドウマネージャーがこれらのキーをブ
ロックしないようにカスタマイズしたり、影響を受けるEmacsのコマンドを“リバ
インド(rebind)”したりできます(*note Customization::を参照してください)。

   単純な文字や制御文字、同様にマウスのクリックなどの非キーボード入力は
、総じて“入力イベント(input events)”と呼ばれます。Emacsが内部で入力イベ
ントをどのように処理するかについての詳細は、*note (elisp)Input Events::を
参照してください.

   ---------- Footnotes ----------

   (1) 歴史的な理由により、<Alt>のことを<META>という名前で参照します。


File: emacs.info,  Node: Keys,  Next: Commands,  Prev: User Input,  Up: Top

3 キー
******

Emacsコマンドには、ただ1つの入力イベントで呼び出されるものが、いくつかあ
ります。たとえば‘C-f’はバッファーを1文字前方に移動します。他のコマンドは
、‘C-x C-f’や‘C-x 4 C-f’のように、2つ以上の入力イベントにより呼び出され
ます。

   “キーシーケンス(key sequence)”、短く書くと“キー(key)”は、1つの単位と
して考えることのできる、1つまたはそれ以上の一連の入力イベントの集まりの
ことです。もし、あるキーシーケンスがコマンドを呼び出すような場合、それを
“コンプリートキー(complete key)”と呼ぶことにします。たとえば‘C-f’、‘C-x
C-f’、‘C-x 4 C-f’などはコンプリートキーです。もし、あるキーシーケンスが
コマンドを呼び出すほど十分長くないとき、それを“プレフィクスキー(prefix
key)”と呼ぶことにします。たとえば前の例でいうと、‘C-x’や‘C-x 4’はプレフ
ィクスキーです。すべてのキーシーケンスは、コンプリートキーかプレフィクス
キーのどちらかになります。

   プレフィクスキーは、その後の入力イベントと組み合わせて、もっと長いキ
ーシーケンスを作るためのものです。たとえば‘C-x’ はプレフィクスキーなので
、‘C-x’と入力しただけではコマンドは呼び出されません。かわりにEmacsは更な
る入力を待ちます(もし１秒以上入力がない場合、入力を促すために‘C-x’がエコ
ーされます。*note Echo Area::を参照してください)。‘C-x’は、それに続く次
の入力イベントと組み合わされる、2イベントのキーシーケンスで、それはプレ
フィクスキー(‘C-x 4’)など)のときもあれば、コンプリートキー(‘C-x C-f’など
)のときもあります。キーシーケンスの長さに制限はありませんが、実際に3つ、
4つ以上の入力イベントの場合は、ほとんどありません。

   コンプリートキーに入力イベントを付け加えることはできません。たとえば
、‘C-f’はコンプリートキーなので、2イベントのシーケンス‘C-f C-k’は、1つで
はなく2つのキーシーケンスです。

   デフォルトではEmacsのプレフィクスキーは‘C-c’、‘C-h’、‘C-x’、‘C-x
<RET>’、‘C-x @’、‘C-x a’、‘C-x n’、‘C-x r’、‘C-x v’、‘C-x 4’、‘C-x 5’、
‘C-x 6’、<ESC>、‘M-g’、‘M-o’です(<F1>と<F2>は、‘C-h’と‘C-x 6’のエイリア
スです)。このリストは不変のものではありません。Emacsをカスタマイズすれば
、新しいプレフィクスキーを作ることができます。標準のプレフィクスキーを無
効にすることさえできますが、これはほとんどのユーザーにたいして推奨はでき
ません。たとえばプレフィクス定義‘C-x 4’を削除すると、‘C-x 4 C-f’は無効な
キーシーケンスになります。*note Key Bindings::を参照してください。

   プレフィックスキーのあとにヘルプ文字(‘C-h’や<F1>)を押すと、そのプレフ
ィックスで始まるコマンド一覧を表示できます。唯一の例外は<ESC>です。
‘<ESC> C-h’は‘C-M-h’と同じで、これは何かまったく別のことを行うコマンドで
す。しかし<F1>ならば、<ESC>で始まるコマンドの一覧を表示できます。


File: emacs.info,  Node: Commands,  Next: Entering Emacs,  Prev: Keys,  Up: Top

4 キーとコマンド
****************

このマニュアルは、特定のキーが何を行うかを説明するページばかりです。しか
し、Emacsは直接キーに意味を与えてはいません。そのかわりに、Emacsは名前を
付けた“コマンド(commands)”に意味を持たせ、キーとコマンドを“バインディン
グ(binding)”することによって、キーに意味を与えています。

   すべてのコマンドには、プログラマーが選んだ名前が付いています。名前は
、たとえば‘next-line’、‘forward-word’のように、いくつかの英単語をダッシ
ュで区切って作られます。内部的には、それぞれのコマンドはLispの“関数
(function)”の特別な型で、コマンドに関連付けられたアクションは、関数を実
行することによって機能します。*note What Is a Function: (elisp)What Is a
Function.を参照してください。

   キーとコマンドの間のバインディングは、“keymaps”というテーブルに記憶さ
れます。*note Keymaps::を参照してください。

   “‘C-n’は下に1行動きます”という言い方は、通常の使用では関係ないが、
Emacsをカスタマイズする上では重要になる点を隠蔽しています。1行下に移動す
るコマンドは‘next-line’です。‘C-n’が‘next-line’にバインドされているから
効果があるのです。もし‘C-n’をコマンド‘forward-word’にリバインドしたら、
‘C-n’で1語前方に動くことになります。

   厳密に言えばキーはコマンドにバインドされているだけですが、このマニュ
アルでは‘C-n’をコマンドであるかのような言い回しをするときがあります。そ
のようなときは、処理を実行させるキーの後ろに、本当に処理を行うコマンドの
名前をカッコ内に記します。たとえば、“コマンド‘C-n’ (‘next-line’)は、ポイ
ントを垂直下方に移動します”というときは、コマンド‘next-line’がポイントを
垂直下方に移動し、それは通常‘C-n’にバインドされている、ということを意味
します。

   カスタマイズについて議論したので、“変数(variables)”にもふれておくべき
でしょう。コマンドの説明で、“これを変更する場合、変数 ‘mumble-foo’をセッ
トしてください”というときがあります。変数とは、値を保存するときに使用す
る名前のことです。このマニュアルに記載されている変数は、ほとんどがカスタ
マイズに関するものです。いくつかのコマンド、およびEmacsのある部分は、変
数調べてその変数にセットされた値により、動作がかわります。カスタマイズに
興味がでるまでは、、変数に関する情報は無視してかまいません。その後で変数
(*note Variables::を参照してください)の基本を読めば、特定の変数について
の情報に合点がいくでしょう。


File: emacs.info,  Node: Entering Emacs,  Next: Exiting,  Prev: Commands,  Up: Top

5 Emacsの起動
*************

Emacsを呼び出す通常の方法は、シェルコマンド‘emacs’です。Xウィンドウシス
テムで実行される端末ウィンドウからは、‘emacs &’によりEmacsをバックグラウ
ンドで実行できます。この方法だとEmacsが端末ウィンドウに結びつけられない
ため、他のシェルコマンドを実行できます。

   Emacsを起動すると、初期フレームは‘*GNU Emacs*’という名前の特別なバッ
ファーを表示します。この“スタートアップ画面(startup screen)”には、
Emacsについての情報と、初心者にとって便利な一般的タスクへのリンクが含ま
れています。たとえば‘Emacs Tutorial’というリンクはEmacsのチュートリアル
を開きます。これはコマンド‘C-h t’ (‘help-with-tutorial’)と同じです。リン
クをアクティブにするには、ポイントをそこに動かして‘<RET>’をタイプするか
、‘mouse-1’(マウスの左ボタン)をクリックしてください。

   コマンドライン引数を使うと、Emacsが起動直後に1つ以上のファイルをアク
セスするよう指示できます。たとえば‘emacs foo.txt’は、‘foo.txt’の内容を表
示するバッファーとともにEmacsを起動します。これは他のエディターとの互換
性により存在する機能で、シェルから短い編集セッションを始めるときのために
デザインされています。Emacsをこの方法で呼び出すと、初期フレームは2つのウ
ィンドウに分割されます。1つは指定されたファイルで、もう1つはスタートアッ
プ画面です。*note Windows::を参照してください。

   一般的に、ファイルを編集するたびに新たにEmacsを起動するのは不必要で無
駄です。Emacsを使うときの推奨方法は、Emacsを1度だけ起動する方法で、ログ
インしたら起動して、同じEmacsセッションですべての編集作業を行うのです。
1つ以上のファイルをアクセスする方法は、*note Files::を参照してください。
この方法でEmacsを使うと、Emacsのセッションはキルリング(kill ring)、レジ
スター(registers)、アンドゥヒストリー(undo history)、マークリング(mark
ring)などの、値をもつコンテキストを蓄積するので、これを共有すれば編集が
より快適になります。これらの機能については、このマニュアルの後で説明しま
す。

   Emacsを実行中に、他のプログラムからファイルを編集する場合、既存の
Emacsセッションのファイルを開くために、‘emacsclient’というヘルパープログ
ラムを使うことができます。*note Emacs Server::を参照してください。

   コマンドライン引数を使って、EmacsにLispファイルをロードして初期フレー
ムに適用させたりできます。*note Emacs Invocation::を参照してください。

   変数‘inhibit-startup-screen’が非‘nil’の場合、Emacsはスタートアップ画
面を表示しません。この場合、コマンドラインに1つ以上のファイルが指定され
ていれば、Emacsは単にそれらのファイルを表示し、指定されていないときは
Lispの式を対話的に評価できる、‘*scratch*’という名前のバッファーを表示し
ます。*note Lisp Interaction::を参照してください。変数
‘inhibit-startup-screen’のセットは、Emacsのカスタマイズ機能(*note Easy
Customization::を参照してください)を使うか、初期設定ファイル(*note Init
File::を参照してください)を編集して行うことができます。(1)

   変数‘initial-buffer-choice’にファイルやディレクトリーの名前をセットす
ることにより、Emacsのスタートアップ時にファイルやディレクトリーを表示さ
せることもできます。‘initial-buffer-choice’の値に、その後に表示するバッ
ファーを戻す関数(引数なし)をセットすることもできます。
‘initial-buffer-choice’が非‘nil’の場合、コマンドラインにファイルを指定し
ても、それらのファイルは表示されますが、初期画面としては表示されません。

   ---------- Footnotes ----------

   (1) ‘site-start.el’の中で‘inhibit-startup-screen’をセットしても機能し
ません。なぜならスタートアップ画面は‘site-start.el’が読み込まれる前にセ
ットアップされるからです。‘site-start.el’についての情報は、*note Init
File::を参照してください。


File: emacs.info,  Node: Exiting,  Next: Basic,  Prev: Entering Emacs,  Up: Top

6 Emacsの終了
*************

‘C-x C-c’
     Emacsをkill(終了)します。(‘save-buffers-kill-terminal’)。
‘C-z’
     テキスト端末ではEmacsをサスペンドします。グラフィカルなディスプレー
     では選択されたフレームを“最小化”します。(‘suspend-emacs’)。

   Emacsを“Kill”するというのは、Emacsプログラムを終了するという意味です
。これを行うには、‘C-x C-c’ (‘save-buffers-kill-terminal’)とタイプします
。2文字キーシーケンスが使われているのは、アクシデントにより間違ってタイ
プしづらくするためです。もし変更されたファイルがある場合、‘C-x C-c’をタ
イプすると、Emacsとそれらのバッファーを巡回して、バッファーを保存するか
問い合わせます。それらすべてを保存しない場合、未保存の変更が失われてしま
う前に、もう一度問い合わせます。サブプロセスがまだ実行中の場合にも、
Emacsをkillするとサブプロセスもkillされるので、問い合わせを行います
(*note Shell::を参照してください)。

   もしEmacsをサーバーとして使っている場合、‘C-x C-c’は特別に振る舞いま
す。もし“クライアントフレーム”からタイプした場合は、クライアントのコネク
ションをクローズします。*note Emacs Server::を参照してください。

   Emacsはオプションで、killしたときに表示していたファイルなどの、セッシ
ョン情報を記録することができます。この情報は次回Emacsを起動するとき利用
可能です。*note Saving Emacs Sessions::を参照してください。

   変数‘confirm-kill-emacs’の値が非‘nil’の場合、‘C-x C-c’はその値が関数
だとみなして、その関数を呼び出します。その関数呼び出しの結果が非‘nil’の
場合、セッションはkillされ、そうでない場合、Emacsは実行を続けます。
‘confirm-kill-emacs’の値として使うのに適した関数の1つが、‘yes-or-no-p’で
す。‘confirm-kill-emacs’のデフォルト値は‘nil’です。

   保存の問い合わせを行わずにEmacsをkillするときは、‘M-x kill-emacs’とタ
イプします。

   ‘C-z’は、コマンド‘suspend-frame’を実行します。グラフィカルなディスプ
レーでは、このコマンドは選択されたEmacsのフレームを後で戻れるように、“最
小化”(または“アイコン化”)して隠します(どのように隠されるかはウィンドウシ
ステムに依存します)。テキスト端末では、‘C-z’はEmacsを“サスペンド(休止
)”します。プログラムは一時的に停止し、制御は親プロセス(通常はシェル)に戻
ります。ほとんどのシェルではシェルのコマンド‘%emacs’で、サスペンド中の
Emacsを再開できます。

   テキスト端末は、通常、実行中のプログラムをkillしたりサスペンドする、
特定の特殊文字を監視しています。この端末の機能は、Emacsではオフになって
います。Emacsでの‘C-z’や‘C-x C-c’のキーの意味は、いくつかのオペレーティ
ングシステムでプログラムを休止させたり終了させたりするために用いる文字、
‘C-z’と‘C-c’にヒントを得たものですが、オペレーティングシステムとの関係は
それだけです。これらのキーは、他のコマンドを実行するようにカスタマイズで
きます(*note Keymaps::を参照してください)。


File: emacs.info,  Node: Basic,  Next: Minibuffer,  Prev: Exiting,  Up: Top

7 基本的な編集コマンド
**********************

ここではテキストの入力、修正、ファイルへの保存といった基本操作について説
明します。これらに接するのが初めてなら、learn-by-doing(行ってみることで
学ぶ)形式のチュートリアルをやってみることを提案します。チュートリアルを
行うには‘C-h t’ (‘help-with-tutorial’)とタイプしてください。

* Menu:



* Inserting Text::           単純に入力してテキストを挿入する。
* Moving Point::             何か修正したい場所にカーソルを移動する。
* Erasing::                  テキストの削除とkill。
* Basic Undo::               テキストの最近の変更を取り消す。
* Files: Basic Files.        ファイルの読み込み、作成、保存。
* Help: Basic Help.          文字が何を行うか尋ねる。
* Blank Lines::              空行の作成と削除
* Continuation Lines::       Emacsがスクリーンに収まりきれない行を表示する方法。
* Position Info::            ポイントのある場所の行と列は何か?
* Arguments::                コマンドをN回繰り返すための数引数。
* Repeating::                素早く前のコマンドを繰り返す。


File: emacs.info,  Node: Inserting Text,  Next: Moving Point,  Up: Basic

7.1 テキストの挿入
==================

普通の“グラフィック文字(graphic character)”(例 ‘a’、‘B’、‘3’、‘=’)は、対
応するキーをタイプして挿入することができます。これによりバッファーのポイ
ント位置に文字が追加されます。挿入によりポイントは前方に移動するので、ポ
イントは挿入された文字の直後になります。*note Point::を参照してください
。

   行を終了して新しい行を開始するには<RET>(‘newline’)を入力します(キーボ
ードで<RET>キーは、<Return>や<Enter>というラベルがついているかもしれませ
んが、このマニュアルでは<RET>と呼ぶことにします)。このコマンドは改行文字
をバッファーに挿入してから、メジャーモードに基づきインデント(*note
Indentation::を参照してください)を行います。ポイントが行末にある場合には
、新しく空行を作成してから新しい行をインデントします。もしポイントが行の
途中にある場合、行はその位置で分割されます。自動インデントをオフにするに
は、Electric Indentモード(*note Indent Convenience::を参照してください
)を無効にするか、自動インデントを行わず改行だけを挿入する‘C-j’を入力しま
す。

   マニュアルの後ろで説明しますが、“マイナーモード(minor modes)”を利用す
ることにより、Emacsが挿入を処理する方法を変更できます。たとえばAuto
Fillモードというマイナーモードは行が長くなりすぎたとき自動的に行を分割し
ます(*note Filling::)。Overwrite modeというマイナーモードは、既存の文字
を右方に押しやるかわりに、既存の文字を置き換え(上書き)ます。*note Minor
Modes::を参照してください。

   対応するキーを押して挿入できるのはグラフィック文字だけです。他のキー
は編集コマンドとして動作し、文字自体の挿入はしません。たとえば、デフォル
トでは<DEL>は、コマンド‘delete-backward-char’を実行します(違うコマンドに
バインドされているモードもあります)。このキーはリテラルの‘DEL’(ASCIIの文
字コード127)を入力する訳ではありません。

   非グラフィック文字や、キーボードがサポートしていない文字を挿入するに
は、最初に‘C-q’ (‘quoted-insert’)で文字を“クォート(quote)”します。
‘C-q’の使い方は2つあります:

   • ‘C-q’に続けて非グラフィック文字(‘C-g’でさえも)をタイプすると、その
     文字が挿入されます。たとえば‘C-q <DEL>’は、リテラルの‘DEL’文字を挿
     入します。

   • ‘C-q’に続けて8進文字のシーケンスを入力すると、8進の文字コードに対応
     する文字が挿入されます。任意の8進数字を使うことができます。非8進数
     字により入力は終了します。もし終了文字が<RET>の場合、<RET>は入力の
     終了だけに用いられます。他の非8進文字は入力を終了させてから、通常の
     入力として扱われます。つまり‘C-q 1 0 1 B’は‘AB’を挿入します。

     8進数字での入力は、通常の非バイナリーのOverwriteモードでは無効にな
     っています。それにより上書きすることなく数字を挿入する便利な方法が
     提供されます。

8進のかわりに10進や16進を使うには、変数‘read-quoted-char-radix’に、10や
16をセットします。もし基数が16の場合、‘a’から‘f’は文字コードの一部として
扱われます。大文字小文字は区別されません。

   かわりにコマンド‘C-x 8 <RET>’ (‘insert-char’)を使うこともできます。こ
れはミニバッファーを使って、Unicode名かコードポイント(code-point)の入力
を求めます。もし名前を入力する時、コマンドが補完機能を提供します(*note
Completion::を参照してください)。コードポイントを入力する場合、それは
16進(Unicodeの規約による)、または指定した基数の数字(例 ‘#o23072’
(octal); *note (elisp)Integer Basics::を参照してください)であるべきです
。このコマンドは対応する文字をバッファーに挿入します。たとえば以下の2つ
はどちらも無限記号(infinity sign: Unicode code-point ‘U+221E’)を挿入しま
す。

     C-x 8 <RET> infinity <RET>
     C-x 8 <RET> 221e <RET>

   ‘C-q’または‘C-x 8 <RET>’への数引数は、文字のコピーを何個挿入するかを
指定します(*note Arguments::を参照してください)。


File: emacs.info,  Node: Moving Point,  Next: Erasing,  Prev: Inserting Text,  Up: Basic

7.2 ポイント位置の変更
======================

文字の挿入以上のことを行うには、ポイントを移動する方法について知る必要が
あります(*note Point::を参照してください)。キーボードのコマンド‘C-f’、
‘C-b’、‘C-n’、‘C-p’は、それぞれ右・左・下・上にポイントを移動します。ほ
とんどのキーボードにある矢印キー — <RIGHT>、<LEFT>、<DOWN>、<UP>でもポイ
ントを移動できます。しかし多くのEmacsユーザーは矢印キーより、コントロー
ルキーのほうが速いと考えています。なぜなら矢印キーを押すためにそれらが配
置されている領域に手を動かす必要があるからです。

   ポイントを移動したい場所でマウスの左ボタンをクリックしてもポイントを
移動できます。Emacsは、さらに洗練された方法でポイントを移動する、さまざ
まなキーボードコマンドを提供します。

‘C-f’
     1文字前方(forward)に移動します (‘forward-char’)。

‘<RIGHT>’
     このコマンド(‘right-char’)は、‘C-f’と同じように振る舞いますが1つ例
     外があります。もしアラビア語のようにright-to-left(右から左に記述す
     る)な文書を編集する場合、現在のパラグラフが右から左で記述するパラグ
     ラフなら、_後方_に移動することになるのです。*note Bidirectional
     Editing::を参照してください。もし‘visual-order-cursor-movement’が非
     ‘nil’の場合、このコマンドは現在のスクリーン位置の右の文字に移動し、
     前または次のスクリーン行に適切に移動します。これはその場所の双方向
     コンテキストに依存するので、多くのバッファーのポイントがあいまいに
     なる可能性があることに注意してください。

‘C-b’
     1文字後方(backward)に移動します (‘backward-char’)。

‘<LEFT>’
     このコマンド(‘left-char’)は、‘C-b’と同じように振る舞いますが1つ例外
     があります。もしアラビア語のようにright-to-leftの文書を編集する場合
     、現在のパラグラフが右から左で記述するパラグラフなら、_前方_に移動
     することになるのです。*note Bidirectional Editing::を参照してくださ
     い。もし‘visual-order-cursor-movement’が非‘nil’の場合、このコマンド
     は現在のスクリーン位置の左の文字に移動し、前または次のスクリーン行
     に適切に移動します。

‘C-n’
‘<DOWN>’
     スクリーンに表示された行で1行下に移動します(‘next-line’)。このコマ
     ンドは横方向の位置を変更しないよう試みます。そのため行の途中でコマ
     ンドを開始すると、次の行の途中に移動することになります。

‘C-p’
‘<UP>’
     スクリーンに表示された行で1行上に移動します(‘previous-line’)。この
     コマンドは‘C-n’と同様、行内の位置を保ちます。

‘C-a’
‘<Home>’
     行の先頭に移動します(‘move-beginning-of-line’)。

‘C-e’
‘<End>’
     行の最後に移動します(‘move-end-of-line’)。

‘M-f’
     1単語前方に移動します(‘forward-word’)。

‘C-<RIGHT>’
‘M-<RIGHT>’
     このコマンド(‘right-word’)は‘M-f’と同様に振る舞います。例外は現在の
     パラグラフがright-to-leftの場合、1語_後方_に移動することになります
     。*note Bidirectional Editing::を参照してください。

‘M-b’
     1単語後方に移動します(‘backward-word’)。

‘C-<LEFT>’
‘M-<LEFT>’
     このコマンド(‘left-word’)は‘M-b’と同様に振る舞います。例外は現在の
     パラグラフがright-to-leftの場合、1語_前方_に移動することになります
     。*note Bidirectional Editing::を参照してください。

‘M-r’
     スクリーン上のテキストを移動させることなく、ポイントの位置をウィン
     ドウ上で中央にもっとも近いテキスト行の左端に移動します。連続して呼
     び出すと、最上行の左端、最下行の左端へと循環的にポイントを移動しま
     す(‘move-to-window-line-top-bottom’)。

     数引数はスクリーンの行の何行目にポイントを移動するか指定します。数
     値はウィンドウの最上行から数えた行数です(0は最上行を意味します)。負
     の引数は最下行から数えた行数です(−1は最下行を意味します。数引数につ
     いては詳細は、*note Arguments::を参照してください。

‘M-<’
     バッファーの先頭に移動します(‘beginning-of-buffer’)。数引数Nが与え
     られた場合、最上行からN/10に移動します。

‘M->’
     バッファーの最後に移動します(‘end-of-buffer’)。

‘C-v’
‘<PageDown>’
‘<next>’
     画面を1画面前方にスクロールします。もし必要ならポイントをスクリーン
     上の位置に移動します(‘scroll-up-command’)。*note Scrolling::を参照
     してください。

‘M-v’
‘<PageUp>’
‘<prior>’
     画面を1画面後方にスクロールします。もし必要ならポイントをスクリーン
     上の位置に移動します(‘scroll-down-command’)。*note Scrolling::を参
     照してください。

‘M-g c’
     数値Nを読み取り、ポイントをバッファー位置Nに移動します。1を指定する
     とバッファーの先頭に移動します。

‘M-g M-g’
‘M-g g’
     数値Nを読み、ポイントをバッファーの先頭からN行目に移動します。行に
     1を指定するとバッファーの先頭に移動します。もしポイントがバッファー
     の数字の上または直後にある場合、その数がNのデフォルトになります。ミ
     ニバッファーで単に<RET>を押すと、その数が使われます。数値のプレフィ
     クス引数でNを指定して‘M-g M-g’に与えることもできます。単にプレフィ
     クス引数を与えた場合の‘M-g M-g’の動作については、*note Select
     Buffer::を参照してください。

‘M-g <TAB>’
     数値Nを読み取り、現在行のN列目に移動します。列0は最左列です。プレフ
     ィクス引数とともに呼び出された場合、引数で指定された数の列に移動し
     ます。

‘C-x C-n’
     現在ポイントがある列を‘C-n’や‘C-p’の“半恒久的な目標列(semipermanent
     goal column)”として使用します。目標列が有効な場合、これらのコマンド
     で垂直に移動すると、その列もしくはできる限り近い列に移動しようと試
     みます。目標列はキャンセルされるまで有効です。

‘C-u C-x C-n’
     目標列をキャンセルします。それ以降の‘C-n’や‘C-p’は通常どおり水平位
     置を保とうと試みます。

   バッファーのテキストがウィンドウの幅より長い場合、通常Emacsは2行以上
の“スクリーン行(screen lines)”で表示します。便宜上、‘C-n’と‘C-p’そして
‘<down>’と‘<up>’も、同様にスクリーン行にしたがってポイントを移動します。
これらのコマンドを“論理行(logical lines)”(たとえばバッファーのテキスト行
)にしたがって移動させるには、‘line-move-visual’に‘nil’をセットします。そ
うすると論理行が複数のスクリーン行となるような場合、カーソルは追加された
スクリーン行をスキップします。詳細は*note Continuation Lines::を参照して
ください。‘line-move-visual’などの変数をセットする方法については、*note
Variables::を参照してください。

   ‘C-n’や‘C-p’と異なり、ほとんどのEmacsコマンドは_論理的_な行に作用しま
す。たとえば‘C-a’ (‘move-beginning-of-line’)や‘C-e’
(‘move-end-of-line’)は、論理行の先頭もしくは最後に移動します。‘C-n’や
‘C-p’のようにスクリーン行に作用するコマンドの場合、わたしたちはそれを示
すようにします。

   ‘line-move-visual’が‘nil’の場合、変数‘track-eol’にも非‘nil’値をセット
できます。そうすると論理行の行末で‘C-n’や‘C-p’を開始すると、次の論理行の
行末に移動します。通常‘track-eol’は‘nil’です。

   通常‘C-n’をバッファーの最後の行で使用した場合、バッファーの最後でスト
ップします。しかし変数‘next-line-add-newlines’に非‘nil’値をセットした場
合、バッファーの最後の行で‘C-n’を押すと、行を追加してその行に移動します
。


File: emacs.info,  Node: Erasing,  Next: Basic Undo,  Prev: Moving Point,  Up: Basic

7.3 テキストの消去
==================

‘<DEL>’
‘<BACKSPACE>’
     ポイントの前の文字、またはリージョンがアクティブのときはリージョン
     を削除します(‘delete-backward-char’)。

‘<Delete>’
     ポイントの後の文字、またはリージョンがアクティブのときはリージョン
     を削除します(‘delete-forward-char’)。

‘C-d’
     ポイントの後ろの文字を削除します(‘delete-char’)。

‘C-k’
     行末までkillします(‘kill-line’)。
‘M-d’
     次の単語(word)の末尾までを前方にkillします(‘kill-word’)。
‘M-<DEL>’
     前の単語の先頭までを後方にkillします(‘backward-kill-word’)。

   コマンド‘<DEL>’ (‘delete-backward-char’)は、ポイントの前の文字を削除
して、カーソルと後ろの文字を後方に移動します。ポイントが行の先頭にある場
合、前の改行を削除して、その行を前の行と連結します。

   しかしリージョンがアクティブのとき、‘<DEL>’はリージョンのテキストを削
除します。リージョンの説明は、*note Mark::を参照してください。

   ほとんどのキーボードでは、<DEL>には<BACKSPACE>というラベルがついてい
ますが、このマニュアルでは<DEL>と呼ぶことにします(<DEL>を<Delete>と混同
しないでください。<Delete>についてはこの後で議論します)。いくつかのテキ
スト端末では、Emacsは<DEL>を正しく認識しません。もしこの問題に遭遇したと
きには、*note DEL Does Not Delete::を参照してください。

   コマンド<Delete> (‘delete-forward-char’)は、“反対方向”に削除します。
これはポイントの後ろの文字、たとえばカーソルの下の文字を削除します。ポイ
ントが行末にある場合は、その行を次の行と連結します。‘<DEL>’と同様、リー
ジョンがアクティブのときはリージョンのテキストを削除します(*note Mark::を
参照してください)。

   ‘C-d’ (‘delete-char’)は、<Delete>と同じようにポイントの後ろの文字を削
除しますが、リージョンがアクティブかどうかは関係ありません。

   上述した削除コマンドについての詳細な情報は、*note Deletion::を参照し
てください。

   ‘C-k’ (‘kill-line’)は行を一度に消去(kill)します。もし行頭または行の途
中で‘C-k’とタイプすると、行末までのすべてのテキストをkillします。行末で
‘C-k’とタイプすると、その行を次の行と連結します。

   ‘C-k’と関連するコマンドについては、*note Killing::を参照してください
。


File: emacs.info,  Node: Basic Undo,  Next: Basic Files,  Prev: Erasing,  Up: Basic

7.4 変更のアンドゥ
==================

‘C-/’
     undoレコードにあるエントリーをundoします。通常1つのコマンドを元に戻
     す(‘undo’)ことに相当します。

‘C-x u’
‘C-_’
     同じです。

   Emacsはバッファー内のテキストに行われた変更のリストを記録しているので
、最近の変更はundoできます。これは‘C-/’(および‘C-x u’と‘C-_’)にバインド
されているコマンド‘undo’を使って行われます。通常このコマンドは最後の変更
をundoして、ポイントを変更前の位置に移動します。undoコマンドはバッファー
への変更のみに適用されるので、カーソルの動きをundoすることはできません。

   個々の編集コマンドは、通常undoレコードの個別のエントリーとなりますが
、とても単純なコマンドはグループ化される場合があります。1つのエントリー
が、実は複雑なコマンドのほんの一部の場合もあります。

   もし‘C-/’(またはそれの別名コマンド)を繰り返すと、undoされた箇所はさら
にundoされ、初期の変更もundoされ、ついには利用可能なundo情報の限界に達し
ます。もし記録された変更がすべてundoされている場合、undoコマンドはエラー
メッセージを表示して、何も行いません。

   ‘undo’コマンドについてさらに学ぶには、*note Undo::を参照してください
。


File: emacs.info,  Node: Basic Files,  Next: Basic Help,  Prev: Basic Undo,  Up: Basic

7.5 ファイル
============

Emacsのバッファーに挿入したテキストは、Emacsのセッションの間だけ存在しま
す。テキストを永続化させるためには、それを“ファイル(file)”に保存しなけれ
ばなりません。

   ホームディレクトリーに、‘test.emacs’という名前のファイルがあるとしま
しょう。このファイルをEmacsで編集するには、以下を入力します

     C-x C-f test.emacs <RET>

ここでファイル名は、コマンド‘C-x C-f’ (‘find-file’)に与えられる、“引数
(argument)”です。このコマンドは引数を読み取るために“ミニバッファー
(minibuffer)”を使い、<RET>は引数を終端させます(*note Minibuffer::を参照
してください)。

   このコマンドに従うために、Emacsはそのファイルを“visit(訪問)”します: す
なわちバッファーを作成し、ファイル内容をバッファーにコピーし、編集のため
にバッファーを表示します。テキストを変更したら、‘C-x C-s’
(‘save-buffer’)と入力することにより、ファイルを“保存(save)”できます。こ
れにより変更されたバッファー内容は、‘test.emacs’に書き戻され永続化されま
す。保存するまでは、テキストへの変更はEmacs内部にだけ存在し、ファイル
‘test.emacs’は変更されません。

   ファイルを作成するには、すでにファイルが存在するかのように‘C-x C-f’で
ファイルをvisitするだけです。これはファイルに書き込みたいテキストを入力
できる、空のバッファーを作成します。最初にこのバッファーを‘C-x C-s’で保
存するとき、Emacsは実際にファイルを作成します。

   Emacsでファイルを使うことについてさらに学ぶには、*note Files::を参照
してください。


File: emacs.info,  Node: Basic Help,  Next: Blank Lines,  Prev: Basic Files,  Up: Basic

7.6 ヘルプ
==========

もしキーが何をするか忘れた場合、‘C-h k’ (‘describe-key’)と入力して、それ
に続けて関心のあるキーを入力します。たとえば‘C-h k C-n’は、‘C-n’が何をす
るか表示します。

   プレフィクスキー‘C-h’は“ヘルプ(help)”が由来です。<F1>キーは‘C-h’の別
名です。‘C-h k’以外にも、異なる種類のヘルプを提供する多くのヘルプコマン
ドがあります。

   詳細については、*note Help::を参照してください。


File: emacs.info,  Node: Blank Lines,  Next: Continuation Lines,  Prev: Basic Help,  Up: Basic

7.7 空行
========

空行を挿入したり削除するための、特別なコマンドとテクニックがあります。

‘C-o’
     カーソルの後ろに空行を挿入します(‘open-line’)。
‘C-x C-o’
     連続する空行を、1行残してすべて削除します(‘delete-blank-lines’)。

   これまで‘<RET>’ (‘newline’)が、どうやってテキストの新しい行を開始する
のか見てきました。しかし最初に空行を作ってからテキストを挿入するほうが、
何を行っているのかわかりやすいでしょう。これはキー‘C-o’ (‘open-line’)を
使えば、簡単に行うことができます。これはポイントの後ろに改行を挿入し、ポ
イントを改行の前に維持します。‘C-o’の後に新しい行のためのテキストを入力
します。

   複数の空行は‘C-o’を数回入力するか、何個の空行を作るのかを数引数で与え
れば作れます。方法については、*note Arguments::を参照してください。もし
フィルプレフィクスがあって、行頭で‘C-o’が入力された場合、新しい行にフィ
ルプレフィクスを挿入します。*note Fill Prefix::を参照してください。

   余分な空行を取り除く簡単な方法は、‘C-x C-o’ (‘delete-blank-lines’)で
す。連続する空行の中にポイントがあるとき、‘C-x C-o’は1行残してすべての空
行を削除します。ポイントが単独の空行にある場合、‘C-x C-o’はその空行を削
除します。ポイントが空でない行にある場合、‘C-x C-o’は、後続する空行があ
れば、それらすべてを削除します。


File: emacs.info,  Node: Continuation Lines,  Next: Position Info,  Prev: Blank Lines,  Up: Basic

7.8 継続行
==========

バッファー内のテキストの行 — “論理行(logical line)” — がウィンドウに収ま
らないほど長い場合、Emacsがそれを2行以上の“スクリーン行(screen lines)”で
表示するときがあります。これは“行の折り返し(line wrapping)”または“継続
(continuation)”と呼ばれ、論理行は“継続された行(continued line)”と呼ばれ
ます。グラフィカルなディスプレーでは、Emacsは行の折り返しをウィンドウの
左右のフリンジ(fringes、縁)の小さな曲矢印で示します。テキスト端末では、
Emacsは右の余白に‘\’を表示して行の折り返しを示します。

   ほとんどのコマンドは、スクリーン行ではなく論理行にたいして作用します
。たとえば‘C-k’は論理行をkillします。前に説明したように、‘C-n’
(‘next-line’)と‘C-p’ (‘previous-line’)は特別な例外です。これらはスクリー
ン行にたいしてポイントを上下に移動させます(*note Moving Point::を参照し
てください)。

   Emacsはオプションで長い論理行を継続するかわりに、“切り詰める
(truncate)”ことができます。これは論理行が1つのスクリーン行を占めることを
意味します。もし論理行がウィンドウ幅より長い場合、行の残りは表示されませ
ん。グラフィカルなディスプレーでは切り詰められた行は、右フリンジの小さな
直矢印で示されます。テキスト端末では右余白の‘$’で示されます。*note Line
Truncation::を参照してください。

   デフォルトでは継続行はウィンドウの右端で折り返されます。折り返しが単
語の途中で発生すると、継続された行は読むのが難しくなります。普通の解決策
は、行が長くなりすぎる前に改行を挿入することです。もしお好みなら、行が長
くなりすぎたときにEmacsが自動的に改行を挿入するように、Auto Fillモードを
使うことができます。*note Filling::を参照してください。

   多くの長い論理行を含むファイルを編集する必要があり、それらすべてを改
行で分割するのが実用的でない場合があります。そのようなケースでは“単語折
り返し(word wrapping)”が有効なVisual Lineモードを使うことができます。こ
れは長い行を正確にウィンドウの右端で折り返すのではなく、ウィンドウの右端
に一番近い単語境界(スペースやタブなど)で折り返します。Visual Lineモード
では、‘C-a’、‘C-n’、‘C-k’などの編集コマンドも、論理行ではなくスクリーン
行を処理するように再定義されます。*note Visual Line Mode::を参照してくだ
さい。


File: emacs.info,  Node: Position Info,  Next: Arguments,  Prev: Continuation Lines,  Up: Basic

7.9 カーソル位置の情報
======================

バッファーのある部分にたいしてサイズや位置、単語数や行数についての情報を
得るためのコマンドがあります。

‘M-x what-line’
     ポイントの行番号を表示します。
‘M-x line-number-mode’
‘M-x column-number-mode’
     現在の行番号および列番号の自動表示を切り替えます。*note Optional
     Mode Line::を参照してください。

‘M-=’
     現在のリージョンの行数、単語数、文字数を表示します
     (‘count-words-region’)。リージョンについては、*note Mark::を参照し
     てください。

‘M-x count-words’
     現在のバッファーの行数、単語数、文字数を表示します。リージョン
     (*note Mark::を参照してください)がアクティブのときは、かわりにリー
     ジョンの数字を表示します。

‘C-x =’
     ポイントの後ろの文字の文字コード、ポイントの文字位置、ポイントの列
     位置を表示します(‘what-cursor-position’)。
‘M-x hl-line-mode’
     現在行のハイライト表示を有効または無効にします。*note Cursor
     Display::を参照してください。
‘M-x size-indication-mode’
     バッファーのサイズの自動表示を切り替えます。*note Optional Mode
     Line::を参照してください。

   ‘M-x what-line’は、エコーエリアに現在の行番号を表示します。通常このコ
マンドは不必要です。なぜならモードラインに現在の行番号が、すでに表示され
ているからです (*note Mode Line::を参照してください)。しかしバッファーが
ナロー(narrow: 制限)されている場合、モードラインはアクセスできる範囲につ
いての行番号しか表示しません(*note Narrowing::を参照してください)。それ
にくらべて‘what-line’は、制限されたリージョンとバッファー全体、両方の行
番号を表示します。

   ‘M-=’ (‘count-words-region’)はリージョン内の行数、単語数、文字数を報
告するメッセージを表示します(リージョンについての説明は、*note Mark::を
参照してください)。プレフィクス引数‘C-u M-=’を指定すると、このコマンドは
バッファー全体の数字を表示します。

   ‘M-x count-words’は同じことを行いますが、呼び出し規約が異なります。も
しリージョンがアクティブの場合はリージョン、そうでない場合はバッファーの
数字を表示します。

   コマンド‘C-x =’ (‘what-cursor-position’)は現在のカーソル位置と、その
位置にあるバッファー内容についての情報を表示します。エコーエリアには、以
下のような行が表示されます:

     Char: c (99, #o143, #x63) point=28062 of 36168 (78%) column=53

   ‘Char:’には、バッファー中のそのポイントにある文字が表示されます。カッ
コ内にはその文字に対応する文字コードが10進、8進、16進で表示されます。
‘C-x =’が文字の情報について表示する方法については、*note International
Chars::を参照してください。‘point=’はポイント位置を文字数(バッファーの最
初の文字は1、次の文字は2、...)で表示します。その後ろの数字ではバッファー
内の文字数の合計が表示され、カッコ内にはその位置が全体から見て何パーセン
トの位置なのかが表示されます。‘column=’にはポイントの水平位置、すなわち
ウィンドウの左端から数えて何番目の列かが表示されます。

   もしバッファーがナローされている場合、最初と最後の部分のテキストが一
時的にアクセス不能になります。‘C-x =’は現在アクセス可能な範囲についての
追加説明を表示します。たとえば以下のように表示します:

     Char: C (67, #o103, #x43) point=252 of 889 (28%) <231-599> column=0

ここで、新たに追加された2つの数字が、ポイントを設定できる文字位置の下限
と上限を示します。これら2つの位置のあいだの文字が参照可能な文字です。
*note Narrowing::を参照してください。


File: emacs.info,  Node: Arguments,  Next: Repeating,  Prev: Position Info,  Up: Basic

7.10 数引数
===========

数学や計算機の用語では、引数(argument)という単語は、“関数や操作に与える
データ”を意味します。Emacsのコマンドには、数引数(numeric argument)(プレ
フィクス引数(prefix argument)とも呼ぶ)を指定できるものがあります。引数を
反復回数として解釈するコマンドもあります。たとえば、引数10を‘C-f’に指定
すると、カーソルを通常の1文字ではなく、10文字分前向きに移動します。これ
らのコマンドでは、引数を指定しないと引数1を指定したのと同等になります。
この種のコマンドの多くでは、負の引数を指定すると、逆向きの移動や逆の操作
を指示することになります。

   数引数を指定するもっとも簡単な方法は、<META>キーを押しながら数字また
はマイナス記号(と数字)を入力する方法です。以下はその例です:

     M-5 C-n

これは５行下に移動します。キー‘M-1’、‘M-2’、...、同様に‘M--’は、次のコマ
ンドへの引数をセットアップするコマンド、(‘digit-argument’と
‘negative-argument’)にバインドされています。数字をともなわない‘M--’は、
通常−1を意味します。

   2桁以上の数字を入力したい場合、2文字目以降の数字を入力するときに
<META>を押しつづける必要はありません。つまり50行下に移動するときは、以下
のように入力します:

     M-5 0 C-n

これは、(あなたが期待するように)‘0’を5つコピーして挿入してから1行下がる
のでは_ない_ことに注意してください。‘0’はプレフィクス引数の一部として扱
われます。

   (‘0’を5つコピーして挿入するときは、‘M-5 C-u 0’と入力します。ここで
‘C-u’はプレフィクス引数を“終端させる”ので、次のキー入力はあなたが実行し
たいコマンドです。ここでの‘C-u’の意味はこのケースだけに適用される使い方
です。‘C-u’の通常の役割については以下を参照してください。)

   数引数を指定する別の方法として、‘M-1’、‘M-2’、...と入力するかわりに、
‘C-u’ (‘universal-argument’)のあとに数字(負の引数の場合はマイナス記号と
数字)を入力する方法があります。通常、数字をともなわないマイナス記号は
−1を意味します。

   単独の‘C-u’は、“4倍”という特別な意味をもち、次のコマンドの引数を4倍に
します。‘C-u C-u’は16倍です。つまり‘C-u C-u C-f’は16文字前方に移動します
。その他に便利な使い方としては‘C-u C-n’、‘C-u C-u C-n’(適当な割り合いで
画面を下に移動する)や、‘C-u C-u C-o’(空行を“たくさん”作る)、‘C-u C-k’(4行
削除する)、などがあります。

   自分自身を挿入する文字の前に数引数を使えば、指定した分のコピーを挿入
できます。これは挿入したい文字が数字でないときは簡単です。たとえば‘C-u 6
4 a’は、‘a’を64個コピーして挿入します。しかし数字を挿入したいときは、こ
れではうまくいきません。‘C-u 6 4 1’は引数に641を指定することになってしま
います。このようなときは引数と挿入したい数字を分けるために、他の‘C-u’を
使うことができます。たとえば‘C-u 6 4 C-u 1’とすれば、これは‘1’を64個コピ
ーして挿入します。

   引数の有無は確認しても、その値は無視するコマンドもあります。たとえば
コマンド‘M-q’ (‘fill-paragraph’)は、1行に収まるようできるだけテキストを
フィルしますが、引数をともなうと、余分なスペースを挿入してテキストが正確
に1行の最大幅を使うよう均等に割り付けてフィルします(‘M-q’については、
*note Filling::を参照してください)。このようなコマンドは、引数として単に
‘C-u’を指定するだけで充分です。

   引数の値を繰り返しの回数として使いますが、引数がないときは特別な処理
を行うコマンドもあります。たとえばコマンド‘C-k’ (‘kill-line’)に引数Nを指
定すると、これは行末の改行も含めてN行をkillします。しかし引数を指定しな
いで‘C-k’した場合、ポイントから改行までのテキストをkillするか、ポイント
が行末にある場合は改行をkillします。つまりコマンド‘C-k’を引数なしで2回呼
び出すと、‘C-k’に引数1を指定したのと同様、空でない行をkillできます
(‘C-k’についての情報は、*note Killing::を参照してください)。

   いくつかのコマンドは、‘C-u’だけの引数を通常の引数とは異なるものとして
扱います。また、マイナス記号のみの引数を、−1とは区別するコマンドもありま
す。これらの例外については、必要になったときに説明します。これらの例外は
、それぞれのコマンドを使いやすくするためにあり、コマンドのドキュメント文
字列に記載されています。

   コマンドの前に引数を入力するという点を強調するために、そしてコマンド
が呼び出されてから入力されるミニバッファー引数(*note Minibuffer::を参照
してください)と区別するために、わたしたちは“プレフィクス引数(prefix
argument)”という言葉を使います。


File: emacs.info,  Node: Repeating,  Prev: Arguments,  Up: Basic

7.11 コマンドの繰り返し
=======================

単純なキーで呼び出されるものや、‘M-x COMMAND-NAME <RET>’で実行できるよう
な多くのコマンドは、数引数で繰り返し回数(*note Arguments::を参照してくだ
さい)を与えることで、その回数だけ繰り返すことができます。しかし、入力を
求めるものや数引数を別の目的に使うコマンドでは、この方法はうまくいきませ
ん。

   コマンド‘C-x z’ (‘repeat’)は、Emacsコマンドを何回も反復する別の方法で
す。このコマンドは、直前のEmacsコマンドが何であっても、それを繰り返しま
す。繰り返されるコマンドは、まえと同じ引数を使います。毎回新たに引数を読
み取ることはしません。

   コマンドを2回以上繰り返すには‘z’を追加して入力します。1つの‘z’でコマ
ンドを1回繰り返します。‘z’以外の文字を入力するか、マウスボタンを押すと繰
り返しを終了します。

   たとえば、20文字削除するために‘C-u 2 0 C-d’と入力したとしましょう。
‘C-x z z z’と入力すれば、(引数を含めて)削除コマンドをさらに3回繰り返し、
全部で80文字削除できます。始めの‘C-x z’でコマンドを1回繰り返し、そのあと
のそれぞれの‘z’で1回ずつ繰り返します。


File: emacs.info,  Node: Minibuffer,  Next: M-x,  Prev: Basic,  Up: Top

8 ミニバッファー
****************

“ミニバッファー(minibuffer)”とは、Emacsのコマンドがファイル名、バッファ
ー名、Emacsコマンド名、Lisp式といった、複雑な引数を読み取るための場所で
す。なぜ“ミニバッファー”と呼ぶかというと、それがスクリーン上の小領域を占
める、特別な目的のためのバッファーだからです。ミニバッファーで引数テキス
トを編集するために、通常のEmacs編集コマンドを使うことができます。

* Menu:

* Basic Minibuffer::         ミニバッファーの基本的な使い方。
* Minibuffer File::          ミニバッファーでファイル名を入力する。
* Minibuffer Edit::          ミニバッファーで編集する方法。
* Completion::               ミニバッファーでの入力のための略語機能。
* Minibuffer History::       最近のミニバッファー引数の再使用。
* Repetition::               ミニバッファーを使ったコマンドの再実行。
* Passwords::                エコーエリアでパスワードを入力する。
* Yes or No Prompts::        エコーエリアでyes/noにこたえる。


File: emacs.info,  Node: Basic Minibuffer,  Next: Minibuffer File,  Up: Minibuffer

8.1 ミニバッファーを使う
========================

ミニバッファーを使用中、ミニバッファーはエコーエリアにカーソルとともに表
示されます。ミニバッファーは通常、コロンが最後についた“プロンプト
(prompt)”から開始されます。プロンプトはどのような入力が期待されるか、そ
してそれがどのように使われるのかを示します。プロンプトは、フェイス
‘minibuffer-prompt’を使ってハイライトされます。

   ミニバッファーで入力するもっとも簡単な方法は、テキストを入力してから
<RET>で引数入力を完了してミニバッファーを終了する方法です。かわりに
‘C-g’を入力して引数を求めているコマンドをキャンセルし、ミニバッファーを
終了することもできます(*note Quitting::を参照してください)。

   コロンの前のカッコ内に“デフォルト引数(default argument)”を表示するプ
ロンプトもあります。このデフォルト値は、<RET>だけを入力したときに、引数
として使用されます。たとえばバッファー名を読み取るコマンドは、通常デフォ
ルト値としてバッファー名を表示します。<RET>を入力することでデフォルトの
バッファーにたいして処理を行うことができます。

   Minibuffer Electric Defaultモードというグローバルマイナーモードを有効
にしている場合、ミニバッファーの内容の変更を開始すると、Emacsはデフォル
ト引数を非表示にします。ミニバッファーのテキストを元に戻せば、ふたたびプ
ロンプトにデフォルト値が表示されます。さらに変数
‘minibuffer-eldef-shorten-default’を非‘nil’値に変更すると、スクリーンの
スペースを節約するために、‘(default DEFAULT)’のかわりに‘[DEFAULT]’の形式
でデフォルト値を表示します。このマイナーモードを有効にするには、‘M-x
minibuffer-electric-default-mode’とタイプしてください。

   エコーエリアにミニバッファーが表示されると、他のエコーエリアの使用と
競合するかもしれません。ミニバッファーがアクティブなとき、エラーメッセー
ジや情報メッセージは一時的な表示となります。メッセージは数秒ミニバッファ
ーを隠すように表示されるか、なにかタイプするまでのあいだ表示され、その後
ミニバッファーに戻ります。ミニバッファーの使用中、キーストロークはエコー
されません。


File: emacs.info,  Node: Minibuffer File,  Next: Minibuffer Edit,  Prev: Basic Minibuffer,  Up: Minibuffer

8.2 ミニバッファーでのファイル名
================================

‘C-x C-f’ (‘find-file’)のようなコマンドは、ミニバッファーを使ってファイ
ル名引数を読み取ります。ファイル名を読み取るためにミニバッファーを使用し
ているとき、通常は最後にスラッシュがついたテキストで開始されています。こ
れは“デフォルトディレクトリー(default directory)”です。たとえば以下のよ
うに開始されていたとします:

     Find file: /u2/emacs/src/

ここで‘Find file: ’はプロンプト、‘/u2/emacs/src/’はデフォルトディレクト
リーです。ここで‘buffer.c’を入力すると‘/u2/emacs/src/buffer.c’を指定した
ことになります。デフォルトディレクトリーについての情報は、*note File
Names::を参照してください。

   ‘..’で親ディレクトリーを指定できます。つまり‘/a/b/../foo.el’は
‘/a/foo.el’と同じです。‘M-<DEL>’を使えば、ディレクトリー名を後方にkillで
きます(*note Words::を参照してください)。

   デフォルトディレクトリーとは無関係のファイルを指定する場合、デフォル
ト値全部を‘C-a C-k’でkillできます。かわりにデフォルト値を無視することも
できます。これはスラッシュで始まる絶対パスのファイル名か、チルダで始まる
ファイル名をデフォルトディレクトリーに続けて入力します。たとえば以下のよ
うにして‘/etc/termcap’を指定できます:

     Find file: /u2/emacs/src//etc/termcap

Emacsはダブルスラッシュを、“2番目のスラッシュより前のすべてを無視する”と
解釈します。上の例では‘/u2/emacs/src/’は無視されるので、引数は
‘/etc/termcap’となります。無視される部分のファイル名は、端末に可能なら目
立たないような表示になります(これを無効にするには、コマンド‘M-x
file-name-shadow-mode’でFile Name Shadowモードをオフにしてください)。

   Emacsは‘~/’をホームディレクトリーと解釈します。‘~/foo/bar.txt’はホー
ムディレクトリーにある、‘foo’というディレクトリーの、‘bar.txt’という名前
のファイルを指定します。さらに‘~USER-ID/’はログイン名がUSER-IDというユー
ザーの、ホームディレクトリーを意味します。‘~’の前のディレクトリー名は無
視されるので、‘/u2/emacs/~/foo/bar.txt’は‘~/foo/bar.txt’と同じです。

   MS-WindowsとMS-DOSでは、ユーザーは常にホームディレクトリーを持つとは
限らないので、Emacsはいくつかの代替ディレクトリーを使います。
MS-Windowsについては*note Windows HOME::、MS-DOSについては *note MS-DOS
File Names::を参照してください。 これらのシステムでは‘~USER-ID/’は現在の
ユーザーの場合だけ、つまりUSER-IDが現在のユーザーのログイン名のときだけ
がサポートされます。

   Emacsがファイル名を読みとるとき、デフォルトディレクトリーを挿入しない
ようにするには、変数‘insert-default-directory’を‘nil’に変更します。この
場合、ミニバッファーは空で開始されます。それでも相対パスでのファイル名引
数は、同じデフォルトディレクトリーにもとづいて解釈されます。

   ミニバッファーにリモートファイル名を入力することもできます。 *note
Remote Files::を参照してください。


File: emacs.info,  Node: Minibuffer Edit,  Next: Completion,  Prev: Minibuffer File,  Up: Minibuffer

8.3 ミニバッファーでの編集
==========================

ミニバッファーは一風変わっていますがEmacsのバッファーなので、引数テキス
トを編集するための、通常のEmacsコマンドが利用可能です(しかしプロンプトは
“読み取り専用(read-only)”なので変更できません)。

   ミニバッファーでの<RET>は引数を完了させるので、これを使って改行を挿入
することはできません。‘C-q C-j’を使えば制御文字‘C-j’(改行文字と等しい)を
挿入できます(*note Inserting Text::を参照してください)。かわりに‘C-o’
(‘open-line’)を使うこともできます(*note Blank Lines::を参照してください
)。

   ミニバッファーの中では<TAB>、<SPC>、‘?’は“補完コマンド(completion
commands)”にバインドされている場合があります。これによりテキスト全部を入
力せずに、入力したいテキストを簡単に入力できます。*note Completion::を参
照してください。<RET>のときと同様、‘C-q’を使って<TAB>、<SPC>、‘?’のよう
な文字を入力できます。

   便宜上ミニバッファーでの‘C-a’ (‘move-beginning-of-line’)は、プロンプ
トの先頭ではなく引数テキストの先頭にポイントを移動します。これにより、た
とえば‘C-a C-k’で引数全体をkillことができます。

   ミニバッファーがアクティブのとき、エコーエリアは通常のEmacsウィンドウ
のように扱われます。たとえば(‘C-x o’で)他のウィンドウに切り替えて、そこ
でテキストを編集して、またミニバッファーのウィンドウにもどって引数の入力
を完了できます。ほかのウィンドウでテキストをkillしてからミニバッファーの
ウィンドウにもどり、引数にテキストをyankすることさえ可能です。しかしミニ
バッファーのウィンドウは分割(split)できないなどの制限もあります。*note
Windows::を参照してください。

   通常ミニバッファーのウィンドウは、スクリーン行で1行を占めます。しかし
2行以上のテキストをミニバッファーに追加すると、そのテキストに対応して自
動的に拡張されます。変数‘resize-mini-windows’は、ミニバッファーのサイズ
調整を制御します。デフォルト値は‘grow-only’で、これは今説明したとおりの
振る舞いを意味します。もし値が‘t’の場合、ミニバッファーから行を削除する
と。ミニバッファーのウィンドウは自動的に縮小されて、スクリーン行で1行ま
で小さくなります。値が‘nil’の場合、ミニバッファーのウィンドウは自動的に
サイズを変更しません。しかし通常のウィンドウのサイズ調整コマンドは使用で
きます(*note Windows::を参照してください)。

   変数‘max-mini-window-height’は、ミニバッファーのウィンドウのサイズ変
更するときの、最大高さを制御します。浮動少数を指定した場合は、フレームの
高さにたいする比になります。整数を指定した場合は最大行数になります。
‘nil’を指定すると、ミニバッファーのウィンドウの自動サイズ調整は行われま
せん。デフォルト値は0.25です。

   ミニバッファーでの‘C-M-v’コマンドは、他のウィンドウに表示されたコマン
ドのヘルプテキストをスクロールします。‘M-<prior>’や‘M-<next>’(または
‘M-<PageUp>’や‘M-<PageDown>’)でも、ヘルプテキストをスクロールできます。
これは長い補完候補のリストを選ぶときなどに便利です。*note Other
Window::を参照してください。

   通常Emacsはミニバッファーがアクティブのときは、ミニバッファーにたいし
て多くのコマンドを使用できないようにしています。ミニバッファーでこれらの
コマンドを使えるようにするには、変数‘enable-recursive-minibuffers’に
‘t’をセットしてください。

   アクティブでないとき、ミニバッファーは‘minibuffer-inactive-mode’にな
っており、‘Mouse-1’をクリックすると、‘*Messages*’バッファーを表示します
。ミニバッファー専用のフレームを使用している場合、Emacsはそこでのキー入
力も認識します。たとえば‘n’は新しいフレームを作成します。


File: emacs.info,  Node: Completion,  Next: Minibuffer History,  Prev: Minibuffer Edit,  Up: Minibuffer

8.4 補完
========

引数を入力する助けとなる、“補完(completion)”という機能が使えるときがあり
ます。これは引数の一部を入力すると、それまでに何を入力したかにもとづいて
、Emacsが残りあるいは残りの一部を補完してくれることを意味します。

   補完が利用可能なとき、特定のキー(通常は<TAB>、<RET>、<SPC>)が、ミニバ
ッファーの特別な補完コマンド(*note Completion Commands::を参照してくださ
い)にリバインドされています。これらのコマンドは、ミニバッファーのテキス
トを完了させようと試みます。これは引数を要求したコマンドが提供する、“補
完候補(completion alternatives)”にもとづいています。通常‘?’を入力すると
、補完候補のリストを見ることができます。

   補完は通常ミニバッファー内で行われますが、通常のバッファーないでもこ
の機能を利用可能なときがあります。*note Symbol Completion::を参照してく
ださい。

* Menu:

* Completion Example::       補完の使い方の例。
* Completion Commands::      補完コマンドのリスト。
* Completion Exit::          補完とミニバッファーでのテキストの確定。
* Completion Styles::        補完のマッチが選ばれる方法。
* Completion Options::       補完のオプション。


File: emacs.info,  Node: Completion Example,  Next: Completion Commands,  Up: Completion

8.4.1 補完の例
--------------

ここでは簡単な例が理解しやすいでしょう。‘M-x’は、コマンド名を読み取るた
めにミニバッファーを使います。補完はミニバッファーのテキストと、既存の
Emacsコマンドの名前のマッチによって機能します。コマンドを
‘auto-fill-mode’を実行したいとします。‘M-x auto-fill-mode <RET>’をタイプ
すればよいのですが、補完を使えばもっと簡単になります。

   ‘M-x a u <TAB>’とタイプすると、<TAB>は‘au’で始まる補完候補(この例では
コマンド名)を探します。‘auto-fill-mode’、‘autoconf-mode’などの候補がいく
つかありますが、候補はすべて‘auto’で始まるので、ミニバッファーの‘au’は
‘auto’に補完されます(あなたのEmacsのセッションには、もっと多くのコマンド
が定義されているかもしれません。たとえば‘authorize-me’というコマンドが定
義されている場合には、Emacsが補完できるのは‘aut’までです)。

   もう一度<TAB>をタイプしても、次の文字は‘-’、‘a’、‘c’のどれなのか決定
できません。そのため文字は追加されず、かわりに<TAB>は可能性のある補完候
補の一覧を別のウィンドウに表示します。

   次に‘-f’と入力します。ミニバッファーには‘auto-f’が入力されました。こ
の文字で始まるコマンド名は、‘auto-fill-mode’だけです。ここで<TAB>を入力
すると、残りの部分が補完されて、ミニバッファーの引数は‘auto-fill-mode’に
なります。

   したがって‘a u <TAB> - f <TAB>’と入力するだけで、‘auto-fill-mode’と入
力できるのです。


File: emacs.info,  Node: Completion Commands,  Next: Completion Exit,  Prev: Completion Example,  Up: Completion

8.4.2 補完コマンド
------------------

以下は補完が使えるときに、ミニバッファーで定義されている補完コマンドの一
覧です。

‘<TAB>’
     可能な限りミニバッファーのテキストを補完します。補完できないときは
     、可能性のある補完候補のリストを表示します(‘minibuffer-complete’)。
‘<SPC>’
     ミニバッファーのテキストを単語単位で補完します
     (‘minibuffer-complete-word’)。このコマンドは、引数にスペースが含ま
     れる可能性のあるファイル名などでは利用できません。
‘<RET>’
     最初に可能な限り補完した後で、ミニバッファーのテキストを引数として
     確定します。*note Completion Exit::を参照してください。
‘?’
     補完候補の一覧を表示します(‘minibuffer-completion-help’)。

   <TAB> (‘minibuffer-complete’)は、もっとも基本的な補完コマンドです。こ
れはミニバッファーのテキストとマッチする可能性のある、すべての補完候補を
検索して、できるかぎりの補完を試みます。補完候補が選択される方法について
は、*note Completion Styles::を参照してください。

   <SPC> (‘minibuffer-complete-word’)は、<TAB>と同じように補完をおこない
ますが、次のハイフンまたは空白までしか補完しません。ミニバッファーが
‘auto-f’の場合、‘auto-fill-mode’まで補完できますが、‘ill-’しか挿入しない
ので‘auto-fill-’となります。次に<SPC>を入力すると‘auto-fill-mode’が補完
されます。

   <TAB>や<SPC>が補完できない場合、マッチする補完候補のリスト(複数ある場
合)を、別のウィンドウに表示します。同じリストは‘?’
(‘minibuffer-completion-help’)でも表示できます。以下は補完一覧で使うこと
ができるコマンドです:

‘Mouse-1’
‘Mouse-2’
     マウスのボタン1もしくはボタン2で補完候補を選択します
     (‘mouse-choose-completion’)。

‘M-v’
‘<PageUp>’
‘<prior>’
     ミニバッファーで‘M-v’を入力すると、候補リストを表示しているウィンド
     ウを選択します(‘switch-to-completions’)。以下のコマンドを使うには、
     この方法がよいでしょう。<PageUp>と<prior>は同じことをおこないます。
     他の方法でもウィンドウを選択できます(*note Windows::を参照してくだ
     さい)。

‘<RET>’
     補完候補リストのバッファー内では、ポイント位置の補完候補を選択しま
     す(‘choose-completion’)。

‘<RIGHT>’
     補完候補リストのバッファー内では、次の補完候補にポイントを移動しま
     す(‘next-completion’)。

‘<LEFT>’
     補完候補リストのバッファー内では、前の補完候補にポイントを移動しま
     す(‘previous-completion’)。


File: emacs.info,  Node: Completion Exit,  Next: Completion Styles,  Prev: Completion Commands,  Up: Completion

8.4.3 補完の終了
----------------

コマンドがミニバッファーの補完を使って引数を読みとる場合、引数を確定する
ために<RET> (‘minibuffer-complete-and-exit’)をタイプしたときに、何が起こ
るかも制御します。これには4種類の動作があります:

   • “強い補完(Strict completion)”は、正確にマッチする補完のみを許します
     。<RET>でミニバッファーを抜けるのは、ミニバッファーのテキストが正確
     にマッチしているか、1つに補完された場合だけです。それ以外の場合、
     Emacsはミニバッファーからのexit(入力を完了してミニバッファーから抜
     け出す)を拒絶します。かわりに補完を試み、補完できなかったときは、ミ
     ニバッファーのテキストの後ろに数秒‘[No match]’と表示します(‘C-g’を
     使えばミニバッファーを離れることができます)。

     この動作をおこなうコマンドの例は‘M-x’で、それは存在しないコマンド名
     を受けとるのは無意味だからです。

   • “慎重な補完(Cautious completion)”は強い補完と似ていますが、テキスト
     がすでに正確にマッチしているときだけexitできる点が異なります。テキ
     ストが正確なマッチに補完できるとき、<RET>は補完を行いますが、まだ
     exitしません。exitするには、もう一度<RET>を入力しなければなりません
     。

     慎重な補完は、たとえば存在しなければならないファイル名を読みとると
     きに使用されます。

   • “寛大な補完(Permissive completion)”は、任意の入力を許容します。補完
     候補はあくまでも提案です。<RET>では補完は行われず、単に入力された引
     数を確定します。

   • “確認付きの寛大な補完(Permissive completion with confirmation)”は、
     寛大な補完と似ていますが例外があります。<TAB>を入力して、テキストが
     ある中間的な状態まで補完されたとき(たとえばまだ正確なマッチに至らな
     いとき)、次に<RET>を入力しても引数は確定されません。かわりにEmacsは
     テキストの後ろに‘[Confirm]’を数秒表示して、確認を求めます。その次の
     <RET>は確認とみなされテキストが確定されます。これにより<TAB>により
     希望するマッチまで補完されたと勘違いして、<RET>を押してしまうなどの
     一般的な間違いを捕らえることができます。

     変数‘confirm-nonexistent-file-or-buffer’をカスタマイズして、確認動
     作を微調整できます。デフォルト値の‘after-completion’は、まさに説明
     したとおりに動作します。これを‘nil’に変更すると、Emacsは確認を求め
     なくなり、寛大な補完にフォールバックします。他の非‘nil’値に変更した
     場合、その前のコマンドが<TAB>かどうかにかかわらず、Emacsは確認を求
     めます。

     この動作はファイル名を読みとる‘C-x C-f’や、バッファー名を読み取る
     ‘C-x b’など、多くのコマンドで使われています。


File: emacs.info,  Node: Completion Styles,  Next: Completion Options,  Prev: Completion Exit,  Up: Completion

8.4.4 補完候補が選択される方法
------------------------------

補完コマンドは、たくさんの可能性のある補完候補を、ミニバッファーに入力し
たものと“マッチ(match)”する、より少ないサブセットへと絞り込むことにより
機能します。*note Completion Example::では、そのようなマッチングの簡単な
例を紹介しました。どのような構成が“マッチ”なのかを決定する手続きはとても
複雑です。Emacsは多くの状況下でもっとも妥当と思われる補完を試みます。

   Emacsは1つ以上の“補完スタイル(completion styles)”を使って補完をおこな
います。これはミニバッファーのテキストを補完候補とマッチングするための条
件のセットです。補完を行うとき、Emacsは補完スタイルを順番に試します。も
しあるスタイルが1つ以上のマッチを獲得した場合、それらは補完候補リストの
ために使用されます。もしあるスタイルがマッチを獲得できなかった場合、
Emacsは次のスタイルにフォールバックします。

   リスト変数‘completion-styles’は、使用する補完スタイルを定義します。そ
れぞれのリスト要素(list element)は、補完スタイルの名前(Lispシンボル)です
。デフォルトの補完スタイルは、リスト変数に以下の名前の要素が順番に並んで
います。

‘basic’
     ミニバッファーのポイントより前のテキストと、補完候補の先頭が同じで
     なければなりません。さらにミニバッファーのポイントより後ろのテキス
     トがある場合、補完候補の残りそれが含まれていなければなりません。

‘partial-completion’
     このアグレッシブな補完スタイルは、ミニバッファーのテキストをハイフ
     ンまたは空白で区切り、各単語ごとに補完をおこないます(たとえばコマン
     ド名を補完する場合、‘em-l-m’は、‘emacs-lisp-mode’に補完されます)。

     さらにミニバッファーのテキスト中の‘*’は、“ワイルドカード
     (wildcard)”として扱われます。これは補完候補の対応する位置にある、任
     意の文字とマッチします。

‘emacs22’
     この補完スタイルは‘basic’とにていますが、ミニバッファーのポイントよ
     り後のテキストを無視します。この名前は補完の動作がEmacs 22と同じだ
     からです。

以下の追加の補完スタイルが定義されており、‘completion-styles’に追加する
こともできます(*note Customization::を参照してください)。

‘substring’
     補完候補は、ミニバッファーのポイントより前のテキストと、ポイントよ
     り後のテキストが同じ順番で含まれていなければなりません。

     したがって、ミニバッファーのテキストが‘foobar’で、ポイントが‘foo’と
     ‘bar’の間にある場合、‘AfooBbarC’にマッチします。この場合A、B、Cは空
     文字列を含む任意の文字列です。

‘initials’
     このとてもアグレッシブな補完スタイルは、頭文字とイニシャルで補完を
     試みます。たとえばコマンド名の補完をする場合、‘lch’は
     ‘list-command-history’とマッチします。

‘emacs21’と呼ばれる、とてもシンプルな補完スタイルもあります。このスタイ
ルでは、ミニバッファーのテキストが‘foobar’の場合、‘foobar’で始まるものだ
けにマッチします。

   変数‘completion-category-overrides’を設定することにより、状況に応じて
異なる補完スタイルを使うことができます。たとえばバッファー名を補完すると
きは、デフォルトで‘basic’と‘substring’だけを使うよう指定できます。


File: emacs.info,  Node: Completion Options,  Prev: Completion Styles,  Up: Completion

8.4.5 補完オプション
--------------------

大文字小文字の違いは、コマンド名のように大文字小文字を区別する
(case-sensitive)引数では重要です。たとえばコマンド名の補完では、‘AU’では
‘auto-fill-mode’に補完されません。大文字小文字の違いは、それが問題になら
ない引数の補完では無視されます。

   ファイル名を補完するとき、変数
‘read-file-name-completion-ignore-case’が非‘nil’なら、大文字小文字の違い
は無視されます。GNU/Linuxのように、ファイル名の大文字と小文字を区別する
システムでは、デフォルト値は‘nil’です。Microsoft Windowsのように、ファイ
ル名の大文字と小文字を区別しないシステムでは、非‘nil’です。バッファー名
を補完するとき、‘read-buffer-completion-ignore-case’が非‘nil’なら、大文
字小文字の違いは無視されます。デフォルトは‘nil’です。

   通常Emacsはファイル名を補完するとき、選ばれるべきではないと思われる、
特定の候補を無視します。これはリスト変数
‘completion-ignored-extensions’により決定されます。リストの要素はに文字
列を指定します。それらの文字列で終わるファイル名は、補完候補としては無視
されます。スラッシュ(‘/’)で終わる要素は、ディレクトリー名を表します。
‘completion-ignored-extensions’の標準的な値は‘".o"’、‘".elc"’、‘"~"’を含
むいくつかの要素です。たとえばディレクトリーに‘foo.c’、‘foo.elc’があると
き、‘foo’は‘foo.c’に補完されます。しかし_すべて_の補完候補が“無視すべき
”文字列で終わるとき、これらの候補は無視されません。前の例でいうと
‘foo.e’は‘foo.elc’に補完されます。Emacsは補完候補リストで補完候補を表示
するとき、‘completion-ignored-extensions’を無視します。

   Shellでの補完は、ファイル名補完の拡張されたバージョンです。*note
Shell Options::を参照してください。

   ‘completion-auto-help’に‘nil’がセットされていると、補完コマンドは補完
リストバッファーを表示しません。表示するには‘?’を入力しなければなりませ
ん。値が‘lazy’の場合、Emacsは2度目の補完を試みたときだけ、補完リストバッ
ファーを表示します。もし補完すべきものがない場合、1度目の<TAB>は‘Next
char not unique’と表示し、2度目の<TAB>で補完リストバッファーが表示されま
す。

   ‘completion-cycle-threshold’が非‘nil’のとき、補完コマンドは補完候補を
“循環(cycle)”できます。通常ミニバッファーのテキストで１つ以上の補完候補
がある場合、補完コマンドは補完できた文字までを表示します。
‘completion-cycle-threshold’を‘t’に変更すると、補完コマンドは補完候補の
中から最初の候補を表示します。それ以降の補完コマンドの呼び出しでは、その
次の補完候補を循環的に表示します。‘completion-cycle-threshold’を数値Nに
すると、補完候補がN以下のときだけ循環表示の動作をします。


File: emacs.info,  Node: Minibuffer History,  Next: Repetition,  Prev: Completion,  Up: Minibuffer

8.5 ミニバッファーヒストリー
============================

ミニバッファーで入力したすべての引数は、“ミニバッファーヒストリーリスト
(minibuffer history list)”に保存されているので、簡単に後でまた使うことが
できます。以下のコマンドにより、前の引数をすばやく探してミニバッファーに
呼び出すことができます:

‘M-p’
‘<UP>’
     ミニバッファーヒストリーの前のアイテム、つまり以前のアイテムに移動
     します(‘previous-history-element’)。
‘M-n’
‘<DOWN>’
     ミニバッファーヒストリーの次のアイテムに移動します
     (‘next-history-element’)。
‘M-r REGEXP <RET>’
     REGEXPにマッチする、ミニバッファーヒストリーの以前のアイテムに移動
     します(‘previous-matching-history-element’)。
‘M-s REGEXP <RET>’
     REGEXPにマッチする、ミニバッファーヒストリーの以降のアイテムに移動
     します(‘next-matching-history-element’)。

   ミニバッファーでの‘M-p’または<UP> (‘previous-history-element’)は、ミ
ニバッファーのヒストリーリストのアイテムを1つずつ移動します。‘M-p’はヒス
トリーリストの以前のアイテムを取り出して、ミニバッファーの既存の内容を置
き換えます。‘M-n’または<DOWN> (‘next-history-element’)は、ミニバッファー
のヒストリーリストを反対方向、つまり以降のエントリーを取り出してミニバッ
ファーの既存の内容を置き換えます。

   ミニバッファーヒストリーに以降のエントリーがないとき(たとえば前に1回
も‘M-p’を入力していないとき)、Emacsはデフォルト引数のリストから、あなた
が入力するだろうと思われる値を取り出します。これは“未来のヒストリー”を移
動すると考えることもできます。

   ミニバッファーコマンドの‘M-p’または‘M-n’で挿入されたテキストを編集し
ても、ヒストリーリストのエントリーは変更されません。かわりに編集された引
数が確定されたとき、ヒストリーリストの最後に追加されます。

   ‘M-r’ (‘previous-matching-history-element’)でヒストリーリストの古い要
素を、‘M-s’ (‘next-matching-history-element’)で新しいエントリーを探すこ
とができます。これらのコマンドはどちらも引数として“正規表現(regular
expression)”を要求し、それにマッチした最初のエントリーをミニバッファーに
取り出します。正規表現についての説明は、*note Regexps::を参照してくださ
い。数引数Nを指定すると、それはN番目に一致したエントリーを取り出すことを
意味します。これらのコマンドはミニバッファーから呼び出されたとはいえ、ミ
ニバッファーを使って正規表現を読みとるという点では、変わったコマンドです
。正規表現に大文字が含まれていると、大文字小文字を区別する検索(*note
Search Case::を参照してください)となります。

   ヒストリーをインクリメンタルサーチすることもできます。*note Isearch
Minibuffer::を参照してください。

   Emacsは引数の種類ごとに個別のリストを保持します。たとえばファイル名の
リストは、ファイル名を読みとるすべてのコマンドで使われたファイル名、とい
った具合です。ほかのヒストリーリストとしてはバッファー名やコマンド名
(‘M-x’で使われたもの)、コマンド引数(‘query-replace’のような引数で使われ
たもの)があります。

   変数‘history-length’には、ミニバッファーのヒストリーリストの最大の長
さを指定します。リストが長くなりすぎたときは、一番古い要素を削除して新し
い要素を追加します。‘t’を指定したときは、長さは無制限になります。

   変数‘history-delete-duplicates’には、重複したヒストリーを削除するかを
指定します。非‘nil’の場合、新しい要素が追加されるとリストからそれと同じ
要素がすべて削除されます。デフォルトは‘nil’です。


File: emacs.info,  Node: Repetition,  Next: Passwords,  Prev: Minibuffer History,  Up: Minibuffer

8.6 ミニバッファーでのコマンドの繰り返し
========================================

ミニバッファーを使用したコマンドはすべて、“コマンドヒストリー(command
history)”という特別なヒストリーリストに記録されます。これにはコマンドの
引数の値も記録されるので、コマンド全体を再実行できます。特に‘M-x’はコマ
ンド名を読みとるので、‘M-x’を使用したものはすべてそこに記録されます。

‘C-x <ESC> <ESC>’
     コマンドヒストリーから最近のミニバッファーのコマンドを再実行します
     (‘repeat-complex-command’)。
‘M-x list-command-history’
     コマンドヒストリー全体を表示します。表示されたすべてのコマンドは
     ‘C-x <ESC> <ESC>’で再実行できます。一番最近のものが先頭に表示されま
     す。

   ‘C-x <ESC> <ESC>’は、ミニバッファーを使った最近のコマンドを再実行しま
す。引数を与えないと、一番最近のコマンドを実行します。数引数で再実行した
いコマンドを指定します。1は一番最近のコマンド、2はその前、といった具合で
す。

   ‘C-x <ESC> <ESC>’は、前のコマンドをLisp式に変換して、その式でミニバッ
ファーのテキストを初期化します。Lispを知らなくても、何のコマンドが再実行
用に表示されているか明白でしょう。単に<RET>を入力すると、コマンドを変更
せずに再実行します。実行する前にLisp式を編集して、コマンドを変更できます
。実行されたコマンドは、一番最近のコマンドと等しくなければ、コマンドヒス
トリーの一番先頭に追加されます。

   ‘C-x <ESC> <ESC>’で一度ミニバッファーの中に入れば、通常のミニバッファ
ーのヒストリーコマンド(*note Minibuffer History::を参照してください)を使
って、ヒストリーリスト中を移動できます。以前に実行したコマンドが見つけた
ら、式を編集して<RET>により実行できます。

   厳密に言うとインクリメンタルサーチはミニバッファーを使いません。これ
が複雑なコマンドのように振る舞うとしても、通常は‘C-x <ESC> <ESC>’で表示
されるヒストリーリストに含まれません。ヒストリーにインクリメンタルサーチ
コマンドを表示させるには、‘isearch-resume-in-command-history’に非‘nil’を
セットしてください。*note Incremental Search::を参照してください。

   ミニバッファーを使用した以前のコマンドのリストは、Lispのリスト値とし
て‘command-history’に格納されています。Lisp式の各要素は、1つのコマンドと
その引数をあらわしています。Lispプログラムは‘eval’に‘command-history’の
要素を使って呼び出すことで、コマンドを再実行できます。


File: emacs.info,  Node: Passwords,  Next: Yes or No Prompts,  Prev: Repetition,  Up: Minibuffer

8.7 パスワードの入力
====================

Emacsでパスワードを入力したい場合があります。たとえばEmacsにFTPのような
ネットワークプロトコルを介して他のマシンのファイルをvisitし、マシンへの
アクセスのためにパスワードを与える場合などです(*note Remote Files::を参
照してください)。

   パスワードの入力はミニバッファーの使用と似ています。Emacsは
(‘Password: ’のような)プロンプトをエコーエリアに表示します。要求されたパ
スワードを入力した後、それを確定するために<RET>を押します。他の人がパス
ワードを見るのを防ぐために、入力した文字は通常の形式ではなく、ドット
(‘.’)で表示されます。

   ミニバッファーに関連付けられた多くの機能およびコマンドは、パスワード
入力では使用_できません_。ヒストリーや補完はできず、ウィンドウの変更や
Emacsでの他の処理も、パスワードをsubmitするまでは行うことができません。

   パスワードのタイプ中は、<DEL>を押して後方に、すなわち最後に入力した文
字から削除できます。‘C-u’で入力したすべての文字を削除できます。‘C-g’はパ
スワードプロンプトを閉じます(*note Quitting::を参照してください)。
‘C-y’は現在のkillリングからパスワードを挿入します(*note Killing::)。パス
ワードを確定するには、<RET>または<ESC>を入力します。他の自己挿入文字は、
対応する文字をパスワードに入力します.それ以外の入力は無視されます。


File: emacs.info,  Node: Yes or No Prompts,  Prev: Passwords,  Up: Minibuffer

8.8 Yes or No プロンプト
========================

Emacsのコマンドが実行の過程で、“yes or no(はい/いいえ)”形式で質問して答
えを求めるかもしれません。これらの質問は大きく2つにわけることができます
。

   1番目の“yes or no”形式の質問は、‘(y or n)’で終わるプロンプトのもので
す。このような質問は、実際のところミニバッファーを使用しません。プロンプ
トがエコーエリアに表示され、答えを‘y’または‘n’で入力すると、ただちにそれ
が答えとなります。たとえばバッファーの保存で‘C-x C-w’ (‘write-file’)を入
力して既存のファイル名を入力すると、Emacsは以下のようなプロンプトを表示
します:

     File `foo.el' exists; overwrite? (y or n)

この質問はミニバッファーを使用しないので、通常のミニバッファー編集コマン
ドは使えません。しかしいくつかのウィンドウをスクロールする操作は行えます
。‘C-l’による選択されたウィンドウの再センタリング、‘M-v’(または
<PageDown>か<next>)による前方へのスクロール、‘C-v’(または<PageUp>か
<prior>)による後方へのスクロール、‘C-M-v’による次のウィンドウの前方への
スクロール、‘C-M-S-v’による次のウィンドウの後方へのスクロールができます
。‘C-g’は質問を打ちきり、質問を発したコマンドを終了します(*note
Quitting::を参照してください)。

   2番目の“yes or no”形式の質問は、間違った答えが深刻な事態を招くような
場合に使用されます。これはミニバッファーを使い、‘(yes or no)’で終わるプ
ロンプトという特徴があります。たとえば変更が保存されていないファイルを
visitしているバッファーで、‘C-x k’ (‘kill-buffer’)を呼び出すと、Emacsは
ミニバッファーをアクティブにして以下のようなプロンプトを表示します:

     Buffer foo.el modified; kill anyway? (yes or no)

これに答えるには、ミニバッファーに‘yes’または‘no’と入力してから、<RET>を
押さなければなりません。ミニバッファーは前のセクションで説明したように動
作します。‘C-x o’による他のウィンドウへのスイッチ、ヒストリーコマンドの
‘M-p’や‘M-f’などが使用できます。‘C-g’でミニバッファーを閉じて、質問を発
したコマンドを終了できます。


File: emacs.info,  Node: M-x,  Next: Help,  Prev: Minibuffer,  Up: Top

9 名前を指定してコマンドを実行する
**********************************

すべてのEmacsコマンドは、それを使えば実行できるような名前を持っています
。使いやすいようにキーバインディングされているコマンドも、たくさんありま
す。これらのコマンドはキーまたは名前で実行できます。キーがバインドされて
いないコマンドもたくさんあり、そのようなコマンドは名前でしか実行できませ
ん(キーバインドをセットアップする方法については、*note Key Bindings::を
参照してください)。

   慣例によりコマンド名は‘auto-fill-mode’や‘manual-entry’のように、ハイ
フンで区切られた、1つ以上の単語となっています。コマンド名は覚えやすいよ
うに、略されていない英単語が主に使われます。

   コマンドを名前で実行するには、最初に‘M-x’をタイプしてから、コマンド名
をタイプして<RET>で実行します。‘M-x’はミニバッファーを使ってコマンド名を
読みとります。ミニバッファーの先頭には、実行のために名前の入力が必要なこ
とを気付かせるため、‘M-x’という文字が“プロンプト”として表示されます。
<RET>でミニバッファーを抜けだしコマンドを実行します。ミニバッファーにつ
いての詳細は、*note Minibuffer::を参照してください。

   コマンド名の入力には補完が使用できます。たとえば‘forward-char’を呼び
出すには以下のように入力できます

     M-x forward-char <RET>

または

     M-x forw <TAB> c <RET>

‘forward-char’は、キー‘C-f’で呼び出されるのと同じコマンドであることに注
意してください。キーバインドの存在は、名前によるコマンドの実行を妨げませ
ん。

   ‘M-x’とコマンドの実行をキャンセルするには、コマンド名の入力のかわりに
‘C-g’を入力します。これによりコマンドを呼び出したレベルまで戻ります。

   ‘M-x’で呼び出すコマンドに数引数を渡すには、‘M-x’の前に数引数を指定し
ます。引数の値はコマンド名が読みとられるときにプロンプトとして表示され、
最終的に‘M-x’は引数をコマンドに渡します。

   ‘M-x’で実行するコマンドがキーバインディングを持つ場合、Emacsはコマン
ド実行後にその旨をエコーエリアに表示します。たとえば‘M-x forward-word’と
入力すると、同じコマンドを‘M-f’で実行できるというメッセージが表示されま
す。このメッセージは変数‘suggest-key-bindings’に‘nil’にセットすればオフ
にできます。

   このマニュアルではコマンドを名前で実行するとき、名前を終了させるため
の<RET>を省くことがあります。つまり‘M-x auto-fill-mode <RET>’ではなく
‘M-x auto-fill-mode’と表記します。<RET>はコマンドに引数がある場合に強調
させる意味で使用します。

   ‘M-x’は‘execute-extended-command’を実行します。これは他のコマンドの名
前を読み取って実行するコマンドです。


File: emacs.info,  Node: Help,  Next: Mark,  Prev: M-x,  Up: Top

10 ヘルプ
*********

Emacsはバラエティに富んだヘルプコマンドを提供しており、それらにはプレフ
ィクスキー‘C-h’(ファンクションキー<F1>でも可)からアクセスできます。以下
のセクションではこれらのコマンドについて説明します。‘C-h C-h’
(‘help-for-help’)と入力すれば、ヘルプコマンドの一覧を見ることもできます
。この一覧は<SPC>と<DEL>でスクロールでき、それから見たいヘルプコマンドを
入力するか、‘C-g’でキャンセルできます。

   多くのヘルプコマンドは、“ヘルプバッファー(help buffer)”という特別なバ
ッファーに情報を表示します。このバッファーでは<SPC>と<DEL>によりスクロー
ルし、<RET>でハイパーリンクをフォローすることができます。*note Help
Mode::を参照してください。

   特定の機能を探しているが、それが何と呼ばれているかわからない、どこを
見ればよいのかわからないときには、次の3つの方法を推奨します。まず最初に
aproposコマンドを試してください。次にマニュアルのインデックスを探してく
ださい。そしてFAQとパッケージのキーワードを探してください。

‘C-h a TOPICS <RET>’
     引数TOPICSと名前が一致するコマンドを検索します。引数にはキーワード
     、キーワードのリスト、正規表現(*note Regexps::を参照してください)を
     指定できます。*note Apropos::を参照してください。

‘C-h i d m emacs <RET> i TOPIC <RET>’
     Emacsのinfoマニュアルのインデックスから、TOPICを検索して最初にマッ
     チしたものを標示します。‘,’を押すと次にマッチしたものを標示します。
     TOPICには正規表現を指定できます。

‘C-h i d m emacs <RET> s TOPIC <RET>’
     同様ですが、インデックスではなくマニュアル本文の_テキスト_を検索し
     ます。

‘C-h C-f’
     Infoを使ってEmacs FAQを標示します。

‘C-h p’
     キーワードに基づいて、利用可能なEmacsパッケージを表示します。*note
     Package Keywords::を参照してください。

   他のさまざまなコンテキストでも、‘C-h’や<F1>は“ヘルプ”を意味します。た
とえばプレフィクスキーの後にこれらのキーを入力すると、プレフィクスキーに
続けて入力できるキーの一覧を表示することができます(このコンテキストでは
‘?’も使用できます。いくつかのプレフィクスキーは‘C-h’や‘?’に別の意味を持
たせているものがあるので使えませんが、それらのものでも<F1>はサポートされ
ています)。

* Menu:

* Help Summary::             すべてのヘルプコマンドの要約リスト。
* Key Help::                 Emacsでキーが何を行うか尋ねる。
* Name Help::                コマンド、変数、関数名を尋ねる。
* Apropos::                  与えられたトピックに関係があるものを尋ねる。
* Help Mode::                へルポモードとヘルプバッファーの特別な機能。
* Package Keywords::         キーワード(トピック)でLispライブラリーを探す。
* Language Help::            国際的な言語サポートに関するヘルプ。
* Misc Help::                その他のヘルプコマンドについて。
* Help Files::               追加のヘルプファイルを表示するコマンド。
* Help Echo::                アクティブなテキストのヘルプとツールチップ("バルーンヘルプ")。


File: emacs.info,  Node: Help Summary,  Next: Key Help,  Up: Help

10.1 ヘルプの概要
=================

ここではビルトインのドキュメントにアクセスする、ヘルプコマンドの要約を記
します。これらの大部分については、以下のセクションで詳細を説明します。

‘C-h a TOPICS <RET>’
     名前がTOPICSにマッチするコマンドの一覧を表示します
     (‘apropos-command’)。
‘C-h b’
     有効なキーバインディングをすべて表示します。最初はマイナーモード、
     次にメジャーモード、それからグローバルのバインディングを表示します
     (‘describe-bindings’)。
‘C-h c KEY’
     キーシーケンスKEYがバインドされているコマンドの名前を表示します
     (‘describe-key-briefly’)。‘c’は“character”からきています。KEYについ
     てさらに詳しい情報を得るには、‘C-h k’を使います。
‘C-h d TOPICS <RET>’
     TOPICSにマッチするドキュメントをもつ、コマンドまたは変数を表示しま
     す(‘apropos-documentation’)。
‘C-h e’
     バッファー‘*Messages*’を表示します(‘view-echo-area-messages’)。
‘C-h f FUNCTION <RET>’
     FUNCTIONという名前の、Lisp関数のドキュメントを表示します
     (‘describe-function’)。コマンドもLisp関数なので、これはコマンドにも
     使用できます。
‘C-h h’
     ファイル‘HELLO’を表示します。このファイルは様々な文字セットの例です
     。
‘C-h i’
     GNUドキュメントブラウザー(‘info’)を実行します。Emacsのマニュアルは
     infoで利用できます。
‘C-h k KEY’
     KEYで実行されるコマンドの名前と、ドキュメントを表示します
     (‘describe-key’)。
‘C-h l’
     最近のキーストローク300回分のの説明を表示します(‘view-lossage’)。
‘C-h m’
     現在のメジャーモードのドキュメントを表示します(‘describe-mode’)。
‘C-h n’
     最近のEmacsの変更に関するニュースを表示します(‘view-emacs-news’)。
‘C-h p’
     トピックのキーワードでパッケージを見つけます(‘finder-by-keyword’)。
     これはパッケージメニューバッファーを使ってパッケージを一覧します。
     *note Packages::を参照してください。
‘C-h P PACKAGE <RET>’
     指定したパッケージのドキュメントを表示します(‘describe-package’)。
‘C-h r’
     Emacsのマニュアルをinfoで表示します(‘info-emacs-manual’)。
‘C-h s’
     現在の“構文テーブル(syntax table)”を表示します(‘describe-syntax’)。
     構文テーブルは、どの文字が開始デリミッターで、その文字が単語の一部
     なのかを定義します。詳細については、*note Syntax Tables:
     (elisp)Syntax Tables.を参照してください。
‘C-h t’
     Emacsの対話的なチュートリアルを開始します(‘help-with-tutorial’)。
‘C-h v VAR <RET>’
     Lisp変数VARのドキュメントを表示します(‘describe-variable’)。
‘C-h w COMMAND <RET>’
     COMMANDという名前のコマンドを実行するキーを表示します(‘where-is’)。
‘C-h C CODING <RET>’
     コーディングシステムCODINGを説明します(‘describe-coding-system’)。
‘C-h C <RET>’
     現在使用されているコーディングシステムを説明します。
‘C-h F COMMAND <RET>’
     infoを開始して、EmacsコマンドCOMMANDのドキュメントのノードに移動し
     ます(‘Info-goto-emacs-command-node’)。
‘C-h I METHOD <RET>’
     インプットメソッドMETHODを説明します(‘describe-input-method’)。
‘C-h K KEY’
     infoを開始して、キーシーケンスKEYのドキュメントのノードに移動します
     (‘Info-goto-emacs-key-command-node’)。
‘C-h L LANGUAGE-ENV <RET>’
     言語環境(language environment)LANGUAGE-ENVで使用される文字セット、
     コーディングシステム、インプットメソッドに関する情報を表示します。
‘C-h S SYMBOL <RET>’
     編集中のプログラム言語に基づいて、シンボルSYMBOLのinfoドキュメント
     を表示します(‘info-lookup-symbol’)。
‘C-h .’
     ポイントが特別なテキスト領域のとき(これには、たとえば‘*Help*’のリン
     クなどが含まれます)、ヘルプメッセージを表示します
     (‘display-local-help’)。


File: emacs.info,  Node: Key Help,  Next: Name Help,  Prev: Help Summary,  Up: Help

10.2 キーのドキュメント
=======================

キーシーケンスに関する情報を得るためのヘルプコマンドは、‘C-h c’
(‘describe-key-briefly’)と‘C-h k’ (‘describe-key’)です。

   ‘C-h c KEY’は、KEYにバインドされているコマンドの名前を、エコーエリア
に表示します。たとえば‘C-h c C-f’は、‘forward-char’と表示します。

   ‘C-h k KEY’も同様ですが、さらに多くの情報が得られます。これはコマンド
が何をするかが正確に説明する、“ドキュメント文字列(documentation
string)”を含むヘルプバッファーを表示します。

   ‘C-h K KEY’は、KEYに対応するコマンドが説明されている、Emacsマニュアル
のセクションを表示します。

   ‘C-h c’、‘C-h k’、‘C-h K’はファンクションキー、メニュー、マウスイベン
トを含む、任意のキーシーケンスにたいして動作します。たとえば‘C-h k’の後
で、メニューバーからメニューアイテムを選択すれば、それにより実行されるコ
マンドのドキュメントが表示されます。

   ‘C-h w COMMAND <RET>’は、COMMANDがバインドされているキーをリストしま
す。リストはエコーエリアに表示されます。コマンドがキーにバインドされてい
ないとき、それは‘M-x’を使って実行しなければならないことを意味します。
‘C-h w’はコマンド‘where-is’を実行します。


File: emacs.info,  Node: Name Help,  Next: Apropos,  Prev: Key Help,  Up: Help

10.3 コマンドと変数名のヘルプ
=============================

‘C-h f FUNCTION <RET>’ (‘describe-function’)は、Lisp関数FUNCTIONのドキュ
メントをウィンドウに表示します。コマンドもLisp関数なので、この方法を使え
ば、名前を知っている任意のコマンドのドキュメントを閲覧できます。たとえば

     C-h f auto-fill-mode <RET>

は‘auto-fill-mode’のドキュメントを表示します。これはキーにバインドされて
いないコマンド(通常‘M-x’で実行する)のドキュメントを閲覧する、唯一の方法
です。

   ‘C-h f’は、LispプログラムからLisp関数を使うときも便利です。たとえば式
‘(make-vector len)’を書いたとしましょう。正しく‘(make-vector len)’を使っ
ているかチェックしたいときは、‘C-h f make-vector <RET>’と入力します。
‘C-h f’はコマンド名だけでなくすべての関数名を許容するので、‘M-x’では機能
するいつもの補完による短縮形が、‘C-h f’では機能しないと気付くかもしれま
せん。コマンド名では省略形が一意であっても、すべての関数名を含めたら一意
ではないかもしれないからです。

   ‘C-h f <RET>’を入力すると、バッファーのポイントがある位置の、一番内側
のLisp式で呼び出されている関数の名前が有効で、Lisp関数として定義されてい
れば、その関数の説明が表示されます(引数を入力するときデフォルトとして関
数名が表示されます)。たとえばポイントが‘(make-vector (car x)’の後ろにあ
るとき、ポイントを含む一番内側のリストは‘(make-vector’で始まっているので
、‘C-h f <RET>’により関数‘make-vector’の説明が表示されます。

   ‘C-h f’は、関数名を正しく記述しているか確かめたいときも便利です。‘C-h
f’のミニバッファーのプロンプトで、編集中のバッファーの関数名がデフォルト
として表示されるなら、それは定義されたLisp関数であることを意味します。本
当にドキュメントを見たい訳でなければ、‘C-g’を押してコマンド‘C-h f’をキャ
ンセルできます。

   ‘C-h v’ (‘describe-variable’)は、‘C-h f’と似ていますがLisp関数ではな
く、Lisp関数の説明を表示します。ポイントの周囲または前にあるLispシンボル
が、定義されたLisp変数名のときはそれがデフォルトとなります。*note
Variables::を参照してください。

   通常Emacsの変数または関数を説明するヘルプバッファーには、ソースファイ
ルがインストールされていれば、対応するソースコードへのハイパーリンクが含
まれています(*note Hyperlinking::を参照してください)。

   マニュアルからコマンドのドキュメントを探すには、‘C-h F’
(‘Info-goto-emacs-command-node’)を使います。これはEmacsのマニュアルだけ
でなく、さまざまなマニュアルを認識するので、正しいものを見つけられるでし
ょう。


File: emacs.info,  Node: Apropos,  Next: Help Mode,  Prev: Name Help,  Up: Help

10.4 Apropos
============

“apropos(折よい、適切な)”コマンドは、“What are the commands for working
with files?(ファイルを処理するコマンドは?)”のような質問に答えるものです
。より正確に言うと単語、単語のリスト、正規表現によって、“aproposパターン
”を指定します。

   以下の各aproposコマンドは、ミニバッファーでaproposパターンを読み取り
、パターンにマッチするアイテムを検索して、結果を別のウィンドウに表示しま
す。

‘C-h a’
     コマンドを検索します(‘apropos-command’)。プレフィクス引数を指定する
     と、非インタラクティブな関数も検索します。

‘M-x apropos’
     関数と変数を検索します。これを使えばインタラクティブな関数(コマンド
     )と非インタラクティブな関数の両方を検索できます。

‘M-x apropos-user-option’
     ユーザーがカスタマイズできる関数を検索します。プレフィクス引数を指
     定すると、カスタマイズできない変数も検索します。

‘M-x apropos-variable’
     変数を検索します。プレフィクス引数を指定すると、カスタマイズできる
     変数だけを検索します。

‘M-x apropos-value’
     指定したパターンにマッチする値の変数を検索します。プレフィクス引数
     を指定すると、定義がパターンにマッチする関数と、プロパティーリスト
     がパターンにマッチする、Lispシンボルも検索します。

‘C-h d’
     指定されたパターンにマッチするドキュメント文字列の関数、または変数
     を検索します(‘apropos-documentation’)。

   最も簡単な種類のaproposパターンは単語です。その単語が含まれていれば、
パターンにマッチします。ファイルを処理するコマンドを探すには、‘C-h a
file <RET>’と入力します。これは‘copy-file’、‘find-file’などの、名前に
‘file’を含むすべてのコマンドの一覧を表示します。各コマンド名には簡単な説
明と、それを呼び出すためのキーの一覧が一緒に表示されます。この例だと、
‘find-file’は‘C-x C-f’で呼び出せることがわかります。

   aproposバッファーの関数定義、変数、シンボルの属性についてもっと情報が
欲しいときは、‘Mouse-1’または‘Mouse-2’でクリックするか、そこに移動して
<RET>を押してください。

   2つ以上の単語をaproposパターンに指定したときは、マッチするために少な
くとも名前に2つの単語が含まれていなければなりません。たとえばポイントの
前のテキストをkillするコマンドを探すときは、‘C-h a kill back backward
behind before <RET>’などと試みることができます。これは実際のコマンド名
‘kill-backward’にマッチするでしょう。もし‘kill-text-before’というコマン
ドがあったなら、これも指定した単語を2つ含んでいるのでマッチします。

   より一層フレキシビリティを高めるために、正規表現(*note Regexps::)を指
定できます。aproposパターンに正規表現の特殊文字‘^$*+?.\[’が含まれている
と、それは正規表現として扱われます。

   Emacsコマンド命名の慣習に従うと、aproposパターンとして便利な単語がい
くつかあります。これらを‘C-h a’で使うことにより、命名の慣習の必要性を感
じることができるでしょう。

     char、line、word、sentence、paragraph、region、page、sexp、list、
     defun、rect、buffer、frame、window、face、file、dir、register、
     mode、beginning、end、forward、backward、next、previous、up、down、
     search、goto、kill、delete、mark、insert、yank、fill、indent、
     case、change、set、what、list、find、view、describe、default

   変数‘apropos-do-all’が非‘nil’の場合、aproposコマンドは常にプレフィク
ス引数が指定されたものとして振る舞います。

   デフォルトでは、‘apropos-documentation’を除くすべてのaproposコマンド
は、結果をアルファベット順に一覧します。変数‘apropos-sort-by-scores’が非
‘nil’のときは、かわりに結果の関連度を推測して、一番関連度が高いと思われ
るものを最初に表示します。‘apropos-documentation’コマンドは、デフォルト
で結果を関連度順で一覧します。これをアルファベット順にするには、変数
‘apropos-documentation-sort-by-scores’を‘nil’に変更してください。


File: emacs.info,  Node: Help Mode,  Next: Package Keywords,  Prev: Apropos,  Up: Help

10.5 ヘルプモードのコマンド
===========================

ヘルプバッファーはViewモード(*note View Mode::を参照してください)と同じ
コマンドを提供します。たとえば前方へのスクロールは<SPC>、後方へのスクロ
ールは<DEL>か‘S-<SPC>’です。他にも特別なコマンドをいくつか提供します:

‘<RET>’
     ポイント位置のクロスリファレンス先をフォローします(‘help-follow’)。
‘<TAB>’
     ポイントを次のハイパーリンクへ進めます(‘forward-button’)。
‘S-<TAB>’
     ポイントを前のハイパーリンクへ戻します(‘backward-button’)。
‘Mouse-1’
‘Mouse-2’
     クリックしたハイパーリンク先をフォローします。
‘C-c C-c’
     ポイント位置のシンボルに関する、すべてのドキュメントを表示します
     (‘help-follow-symbol’)。
‘C-c C-b’
     前のヘルプトピックに戻ります(‘help-go-back’)。

   もし関数名、変数名、フェイス名(*note Faces::を参照してください)がヘル
プバッファーのドキュメントにあると、通常はアンダーラインされた“ハイパー
リンク(hyperlink)”として表示されます。関連するドキュメントを閲覧するには
、ポイントをそこに移動して<RET> (‘help-follow’)をタイプするか、ハイパー
リンクを‘Mouse-1’または‘Mouse-2’でクリックします。するとヘルプバッファー
の内容が入れ替わりますが、‘C-c C-b’ (‘help-go-back’)で元に戻すことができ
ます。

   ヘルプバッファーには、infoマニュアル、ソースコード定義、URL(ウェブペ
ージ)へのハイパーリンクを含むこともできます。最初の2つはEmacs上で表示さ
れ、3番目のURLはコマンド‘browse-url’により、ウェブブラウザーを使って表示
されます。

   ヘルプバッファーでは、<TAB> (‘forward-button’)はポイントを次のハイパ
ーリンクへ進め、‘S-<TAB>’ (‘backward-button’)は前のハイパーリンクへ戻し
ます。これらのコマンドは循環的です。たとえば最後のハイパーリンクで
<TAB>をタイプすると、最初のハイパーリンクに戻ります。

   テキスト中のシンボルに関するすべてのドキュメントを閲覧するには、ポイ
ントをそこに移動して‘C-c C-c’ (‘help-follow-symbol’)とタイプします。これ
はシンボル(変数、関数、フェイス)に関する、すべての利用可能なドキュメント
を表示します。


File: emacs.info,  Node: Package Keywords,  Next: Language Help,  Prev: Help Mode,  Up: Help

10.6 パッケージのキーワード検索
===============================

Emacsのたいていのオプション機能は、“パッケージ(packages)”にグループ化さ
れています。Emacsには数百のビルトインパッケージが含まれており、ネットワ
ークを通じて他のパッケージのインストールもできます(*note Packages::を参
照してください)。

   あるトピックに関連するパッケージを探すのを簡単にするため、ほとんどの
パッケージは、それが何をするかにもとづき、1つ以上の“キーワード
(keywords)”に関連付けられています。‘C-h p’ (‘finder-by-keyword’)とタイプ
すると、パッケージキーワードとキーワードの意味を説明するリストが表示され
ます。キーワードに属するパッケージのリストを表示するには、そのキーワード
の行で<RET>をタイプします。これによりパッケージメニューバッファー(*note
Package Menu::を参照してください)で、パッケージの一覧が表示されます。

   ‘C-h P’ (‘describe-package’)はパッケージ名の入力を求めて、パッケージ
の属性と、それが実装する機能をヘルプバッファーで表示します。このバッファ
ーは、ボタン形式で関連するパッケージのキーワードを一覧します。ボタンをク
リックすると、そのキーワードに関連する他のパッケージを見ることができます
。


File: emacs.info,  Node: Language Help,  Next: Misc Help,  Prev: Package Keywords,  Up: Help

10.7 国際化言語のサポートに関するヘルプ
=======================================

特定の言語環境(language environment: *note Language Environments::を参照
してください)の情報を得るには、‘C-h L’とタイプします。これはヘルプバッフ
ァーを開いて、言語環境でサポートされる言語の説明と、関連する文字セット、
コーディングシステム、インプットメソッド、およびその言語環境のサンプルテ
キストを表示します。

   コマンド‘C-h h’ (‘view-hello-file’)は、ファイル‘etc/HELLO’を表示しま
す。このファイルはさまざまな言語で“hello”をどのように言うのかを、いろい
ろな文字セットで表示するデモンストレーションです。

   コマンド‘C-h I’ (‘describe-input-method’)は、指定されたインプットメソ
ッド、または現在使われているインプットメソッド(デフォルト)の説明します。
*note Input Methods::を参照してください。

   コマンド‘C-h C’ (‘describe-coding-system’)は、指定されたコーディング
システム、または現在使われているものを説明します。*note Coding
Systems::を参照してください。


File: emacs.info,  Node: Misc Help,  Next: Help Files,  Prev: Language Help,  Up: Help

10.8 その他のヘルプコマンド
===========================

‘C-h i’ (‘info’)は、infoプログラムを実行します。infoは構造化されたドキュ
メントファイルを閲覧するものです。Emacsマニュアル全体は、GNUシステムのた
めの他のマニュアルとともに、infoで利用可能です。infoを開始した後、‘h’を
タイプすると、infoの使い方のチュートリアルが実行されます。

   数引数Nを指定すると、‘C-h i’はinfoバッファー‘*info*<N>’を選択します。
これは同時に複数のinfoマニュアルを閲覧するとき便利です。プレフィクス引数
‘C-u’だけを指定した場合、‘C-h i’はドキュメントのファイル名を尋ねるので、
infoメニューのトップレベルにエントリーがないファイルでも閲覧できます。

   上記で説明しているヘルプコマンド‘C-h F FUNCTION <RET>’と‘C-h K KEY’は
、infoを実行して関数(FUNCTION)またはキー(KEY)に関するドキュメントを直接
開きます。

   プログラムを編集しているとき、そのプログラム言語のinfo版のマニュアル
を持っていれば、‘C-h S’ (‘info-lookup-symbol’)を使ってシンボル(キーワー
ド、関数、変数)のエントリーを、適切なマニュアルから探すことができます。
コマンドがどのように動作するかの詳細は、メジャーモードに依存します。

   何か予期しないことが起こって、何をタイプしたかわからなくなったときは
、‘C-h l’ (‘view-lossage’)を使います。‘C-h l’は最近の300回分のキーストロ
ークを表示します。身に覚えのないキー入力を見つけたら、‘C-h c’を使えばそ
のキーが何を行うか調べることができます。

   最近のエコーアリアのメッセージを調べるには、‘C-h e’
(‘view-echo-area-messages’)を使います。これはそれらのメッセージを保持す
るバッファー、‘*Messages*’を表示します。

   Emacsの各メジャーモードでは、一般的にいくつかのキーが再定義されていて
、編集動作も異なります。‘C-h m’ (‘describe-mode’)は、現在のメジャーモー
ドのドキュメントを表示します。これには通常このモードで変更されているコマ
ンドや、機能が説明されています。

   ‘C-h b’ (‘describe-bindings’)と‘C-h s’ (‘describe-syntax’)は、現在の
Emacs環境に関する、それ以外の情報を表示します。最初は現在のマイナーモー
ドのローカルバインディング、次に現在のメジャーモードで定義されているロー
カルバインディング、最後にグローバルバインディングが表示されます。‘C-h
s’は各文字の構文の説明とともに、構文テーブルの内容を表示します(*note
Syntax Tables: (elisp)Syntax Tables.を参照してください)。

   プレフィクスキーの後に‘C-h’、‘?’、<F1>をタイプすることにより、特定の
プレフィクスキーにたいする、サブコマンドのリストを得ることができます(こ
の方法が機能しないプレフィクスキーもあります。たとえば<ESC>です。‘<ESC>
C-h’は実際には‘C-M-h’と解釈され、これはdefunをマークするコマンドです。こ
のような場合でも‘<ESC> <F1>’や‘<ESC> ?’はうまく機能します)。


File: emacs.info,  Node: Help Files,  Next: Help Echo,  Prev: Misc Help,  Up: Help

10.9 ヘルプファイル
===================

ビルトインのドキュメントとマニュアル以外にも、Emacsにはコピー条件
(copying conditions)、リリースノート(release notes)、デバッグ説明書
(instructions for debugging)、バグ報告(reporting bugs)などのトピックを説
明する、いくつかのファイルが含まれています。これらのファイルは、以下のコ
マンドで閲覧することができます。‘C-h g’をのぞき、これらはすべて、‘C-h
C-CHAR’という形式になっています。

‘C-h C-c’
     Emacsをコピー、再頒布する場合の規則を表示します
     (‘describe-copying’)。
‘C-h C-d’
     Emacsをデバッグするためのヘルプを表示します
     (‘view-emacs-debugging’)。
‘C-h C-e’
     外部のパッケージをどこで入手するかについての情報を表示します
     (‘view-external-packages’)。
‘C-h C-f’
     EmacsのFAQ(frequently-answered-questions: 頻繁に答えられる質問)のリ
     ストを表示します(‘view-emacs-FAQ’)。
‘C-h g’
     GNUプロジェクトに関する情報を表示します(‘describe-gnu-project’)。
‘C-h C-m’
     Emacsマニュアルの印刷されたコピーの注文に関する情報を表示します
     (‘view-order-manuals’)。
‘C-h C-n’
     このバージョンの新しい機能の一覧が含まれる“news”ファイルを表示しま
     す(‘view-emacs-news’)。
‘C-h C-o’
     Emacsおよび他のGNUソフトウェアーの最新バージョンを、注文またはダウ
     ンロードする方法を表示します(‘describe-distribution’)。
‘C-h C-p’
     Emacsの既知の問題(それにどう対処するかの提案がある場合もあります)を
     表示します(‘view-emacs-problems’)。
‘C-h C-t’
     EmacsのTODOリストを表示します(‘view-emacs-todo’)。
‘C-h C-w’
     GNU Emacsが完全に無保証なことにたいする、すべての詳細を表示します
     (‘describe-no-warranty’)。


File: emacs.info,  Node: Help Echo,  Prev: Help Files,  Up: Help

10.10 アクティブテキストのヘルプとツールチップ
==============================================

Emacsでは拡大解釈される“アクティブテキスト(active text: マウスのクリック
や<RET>に特別な反応をするテキスト)”は、しばしばヘルプテキストに関連付け
られています。これにはEmacsのバッファーのハイパーリンク、同様にモードラ
インの一部が含まれます。グラフィカルなディスプレー、同様にいくつかのテキ
スト端末は、マウストラッキングをサポートしており、アクティブテキストの上
をマウスが通過することにより、ヘルプテキストを“ツールチップ(tooltip)”で
表示します。*note Tooltips::を参照してください。

   マウストラッキングをサポートしない端末では、バッファーのアクティブテ
キストにポイントを移動して、‘C-h .’ (‘display-local-help’)をタイプすれば
、ヘルプテキストを表示できます。これはヘルプテキストをエコーエリアに表示
します。ポイントがある場所のヘルプテキストが利用可能な場合に、常に表示さ
せるには、変数‘help-at-pt-display-when-idle’に‘t’をセットしてください。


File: emacs.info,  Node: Mark,  Next: Killing,  Prev: Help,  Up: Top

11 マークとリージョン
*********************

Emacsのコマンドには、現在のバッファー内の、任意の連続する領域(region)を
操作するものがたくさんあります。そのようなコマンドが操作するテキストを指
定するには、領域の一方の端に“マーク(mark)”をセットし、もう一方の端にポイ
ントを移動します。ポイントとマークの間のテキストを、“リージョン
(region)”と呼びます。リージョンは常にポイントとマークの間で拡張され、そ
れは一方がテキストの先頭にある場合も変わりません。ポイントを移動すれば、
常にリージョンは変化します。

   テキストのある位置にマークをセットすると、マークは“アクティブ
(active)”になります。マークがアクティブのときは、リージョンもアクティブ
になります。Emacsはアクティブなリージョンの中にあるテキストを、フェイス
‘region’でハイライト表示します(*note Face Customization::を参照してくだ
さい)。

   バッファーのテキストを変更するコマンドを含む、特定の非移動系コマンド
(non-motion commands)の後で、Emacsは自動的にマークを“非アクティブ
(deactivates)”にし、これによりハイライトも解除されます。‘C-g’をタイプす
れば、いつでも明示的に非アクティブにすることができます(*note Quitting::を
参照してください)。

   上記のデフォルト動作は、Transient Markモード(暫定マークモード)という
名で知られています。Transient Markモードを無効にすると、Emacsは通常では
リージョンをハイライトしなくなります。*note Disabled Transient Mark::を
参照してください。

   あるバッファーでマークをセットしても、他のバッファーのマークは影響を
受けません。アクティブなマークがあるバッファーに戻ったとき、マークは以前
と同じ場所にあります。複数のウィンドウで同じバッファーを表示しているとき
、これらのウィンドウはそれぞれのポイント位置をもっているので、リージョン
も異なります。しかしこれらのウィンドウでは、マークの位置は共通です。
*note Windows::を参照してください。通常、選択されたウィンドウのリージョ
ンだけがハイライトされます。しかし変数‘highlight-nonselected-windows’が
非‘nil’の場合、各ウィンドウのリージョンがハイライトされます。

   “rectangular region(矩形リージョン)”という、違う種類のリージョンもあ
ります。*note Rectangles::を参照してください。

* Menu:

* Setting Mark::             マークをセットするコマンド。
* Marking Objects::          テキスト単位の周辺にリージョンをセットするコマンド。
* Using Region::             リージョンの内容を操作する方法の要約。
* Mark Ring::                後で戻れるように保存された以前のマーク位置。
* Global Mark Ring::         さまざまなバッファーの以前のマーク位置。
* Shift Selection::          シフトを押してカーソル移動キーを使う。
* Disabled Transient Mark::  デフォルトでリージョンをハイライトせずにおく。


File: emacs.info,  Node: Setting Mark,  Next: Marking Objects,  Up: Mark

11.1 マークのセット
===================

マークをセットするためのコマンドがいくつかあります:

‘C-<SPC>’
     ポイント位置にマークをセットしてアクティブにします
     (‘set-mark-command’)。
‘C-@’
     同じです。
‘C-x C-x’
     ポイント位置にマークをセットしてアクティブにしてから、以前のマーク
     があった位置にポイントを移動します(‘exchange-point-and-mark’)。
‘Drag-Mouse-1’
     ドラッグしたテキストの周りにポイントとマークをセットします。
‘Mouse-3’
     ポイント位置にマークをセットしてから、クリックした場所にポイントを
     移動します(‘mouse-save-then-kill’)。
‘‘シフトを押したカーソル移動キー’’
     マークが非アクティブなら、ポイント位置にマークをセットしてポイント
     を移動します。*note Shift Selection::を参照してください。

   マークをセットするもっとも一般的な方法は、‘C-<SPC>’
(‘set-mark-command’)です(1)。これはポイントがある位置にマークをセットし
てから、アクティブにします。その後、マークをそこに残したままポイントを移
動できます。

   たとえばバッファーの一部を大文字に変換したいとします。これを行うには
対象のテキストの一方の端に移動して、‘C-<SPC>’をタイプし、対象のテキスト
がハイライトされるまでポイントを移動します。そして‘C-x C-u’
(‘upcase-region’)をタイプすると、リージョンのテキストが大文字に変換され
て、マークが非アクティブになります。

   マークがアクティブなときに非アクティブにしたいときは、‘C-g’をタイプし
ます(*note Quitting::を参照してください)。リージョンにたいして操作を行う
ほとんどのコマンドは、上記の例の‘C-x C-u’のように、自動的にマークを非ア
クティブにします。

   リージョンにたいしての操作は行わず、バッファーの位置を“覚えておく”た
めにマークをセット(‘C-<SPC> C-<SPC>’とタイプ)して、後でそこに戻る(‘C-u
C-<SPC>’とタイプ)こともできます。詳細については、*note Mark Ring::を参照
してください。

   コマンド‘C-x C-x’ (‘exchange-point-and-mark’)は、ポイントとマークの位
置を交換します。ポイントの位置に問題はないが、リージョンのもう一方の端に
ポイントを移動したいとき‘C-x C-x’は便利です。2回目の‘C-x C-x’で、マーク
を新しいポイント位置にマークをセットしてから、ポイントを元の位置に戻すこ
とができます。このコマンドはマークが非アクティブのとき、最初にマークをア
クティブにします。これはマークが最後にどこにセットされたかを明確にするた
めに、リージョンをハイライトするためです。しかしプレフィクス引数とともに
呼び出せば、マークは非アクティブのままでリージョンもハイライトされません
。これを使えば‘C-u C-<SPC>’と同様の方法で、マークの位置にジャンプできま
す。

   マウスでマークをセットすることもできます。マウスの左ボタン
(‘down-mouse-1’)をクリックしてから、テキスト範囲をドラッグすると、最初に
マウスボタンを押した位置にマークがセットされ、マウスボタンを話した位置に
ポイントが置かれます。かわりにマウスの右ボタン(‘mouse-3’)をクリックすれ
ば、ポイントのある位置にマークがセットされ、クリックした位置にポイントが
移動します。これらのマウスコマンドに関する詳細な説明は、*note Mouse
Commands::を参照してください。

   最後にシフトキーを押しながらカーソルを移動するコマンド(‘S-<RIGHT>’、
‘S-C-f’、‘S-C-n’など)でマークをセットできます。これは“シフト選択
(shift-selection)”と呼ばれ、(シフト選択するときにアクティブなマークがな
いときに限り)ポイントを移動する前の位置にマークをセットします。マウスコ
マンドやシフト選択によるマークのセットは、通常のマークとは少し異なります
。続けてシフトを押さないカーソル移動コマンドを実行するにより、マークは自
動的に非アクティブになります。詳細は、*note Shift Selection::を参照して
ください。

   ‘C-y’ (‘yank’)のようなテキストを挿入するコマンドの多くは、挿入された
テキストの先頭に、非アクティブなマークをセットします。これにより簡単にそ
の位置に戻ることができます(*note Mark Ring::を参照してください)。コマン
ドがこれを行っていることは、エコーエリアに‘Mark set’が表示されることで見
分けることができます。

   Xではアクティブなリージョンが変化するたびに、Emacsはリージョンのテキ
ストを“プライマリー選択(primary selection)”に保存します。これにより
‘mouse-2’をクリックして、他のXアプリケーションへテキストを挿入することが
できるようになります。*note Primary Selection::を参照してください。

   ---------- Footnotes ----------

   (1) ASCIIには、文字‘C-<SPC>’はありません。テキスト端末で‘C-<SPC>’をタ
イプすると、通常は文字‘C-@’が与えられます。このキーも
‘set-mark-command’にバインドされているので、もし異なる挙動を示すテキスト
端末の場合は、‘C-<SPC>’のかわりに‘C-@’を使うことを考えるのがよいかもしれ
ません。


File: emacs.info,  Node: Marking Objects,  Next: Using Region,  Prev: Setting Mark,  Up: Mark

11.2 テキストオブジェクトをマークするコマンド
=============================================

単語(word)、リスト(list)、パラグラフ(paragraph: 段落)、ページ(page)など
のテキストオブジェクトの周辺に、ポイントを配置してマークするコマンドがあ
ります:

‘M-@’
     次の単語の末尾の後にマークをセットします(‘mark-word’)。ポイントは移
     動しません。
‘C-M-@’
     次の対応のとれた式の後にマークをセットします(‘mark-sexp’)。ポイント
     は移動しません。
‘M-h’
     ポイントを現在のパラグラフの先頭に移動して、パラグラフの最後にマー
     クをセットします(‘mark-paragraph’)。
‘C-M-h’
     ポイントを現在のdefunの先頭に移動して、defunの最後にマークをセット
     します(‘mark-defun’)。
‘C-x C-p’
     ポイントを現在のページの先頭に移動して、ページの最後にマークをセッ
     トします(‘mark-page’)。
‘C-x h’
     ポイントを現在のバッファーの先頭に移動して、バッファーの最後にマー
     クをセットします(‘mark-whole-buffer’)。

   ‘M-@’ (‘mark-word’)は、次の単語の最後にマークをセットします(単語につ
いての情報は、*note Words::を参照してください)。繰り返し呼び出されると、
マークを1度に1単語進めてリージョンを拡張します。例外として、マークがアク
ティブでポイントの前にある場合、‘M-@’はマークを現在の位置から1単語後方に
移動します。

   このコマンドに数引数Nを指定することにより、N単語進めてマークするよう
指定できます。負の引数はN単語後方にマークを移動します。

   同様に‘C-M-@’ (‘mark-sexp’)は、対応のとれた式の最後にマークをセットし
ます(*note Expressions::を参照してください)。繰り返し呼び出すことにより
、後続の式にリージョンを拡張します。正または負の数引数を指定するとその数
に応じて前方または後方にマークを移動します。

   上記のリストの他のコマンドは、ポイントとマークの両方をセットするので
、バッファー内のオブジェクトを区切るコマンドです。‘M-h’
(‘mark-paragraph’)はパラグラフ(*note Paragraphs::を参照してください)、
‘C-M-h’ (‘mark-defun’)はトップレベルの関数定義(*note Moving by Defuns::を
参照してください)、‘C-x C-p’ (‘mark-page’)はページ(*note Pages::を参照し
てください)をマークします。繰り返して呼び出すと、同種の連続するオブジェ
クトへと、リージョンを拡張します。数引数も同様で、マークを移動したいオブ
ジェクトの数を指定します。

   ‘C-x h’ (‘mark-whole-buffer’)はポイントをバッファーの先頭、マークを最
後にセットすることによりバッファー全体をリージョンとします。


File: emacs.info,  Node: Using Region,  Next: Mark Ring,  Prev: Marking Objects,  Up: Mark

11.3 リージョンを操作する
=========================

一度リージョンを設定すると、それを処理するいくつかの方法があります:

   • ‘C-w’ (*note Killing::)でkillします。
   • ‘M-w’ でkillリングにコピーします(*note Yanking::を参照してください
     )。
   • ‘C-x C-l’または‘C-x C-u’で、大文字小文字を変換します(*note Case::を
     参照してください)。
   • ‘C-u C-/’で変更をアンドゥ(undo)します(*note Undo::を参照してくださ
     い)。
   • ‘M-%’でリージョンの中のテキストを置換します(*note Query Replace::を
     参照してください)。
   • ‘C-x <TAB>’または‘C-M-\’でインデントします(*note Indentation::を参
     照してください)。
   • ‘M-x fill-region’でテキストとしてフィルします(*note Filling::を参照
     してください)。
   • ‘M-$’で単語のスペルをチェックします(*note Spelling::を参照してくだ
     さい)。
   • ‘M-x eval-region’でLispコードとして評価します(*note Lisp Eval::を参
     照してください)。
   • ‘C-x r s’でレジスターに保存します(*note Registers::を参照してくださ
     い)。
   • バッファーまたはファイルに保存します(*note Accumulating Text::を参
     照してください)。

   マークが非アクティブのときにはデフォルトの動作をするが、マークがアク
ティブのときはリージョンを処理するコマンドがいくつかあります。たとえば
‘M-$’ (‘ispell-word’)は、通常はポイントのある単語のスペルをチェックしま
すが、マークがアクティブのときはリージョンの中のテキストをチェックします
(*note Spelling::を参照してください)。通常そのようなコマンドはリージョン
が空のとき(たとえばマークとポイントが同じ位置のとき)は、デフォルトの動作
をします。空のリージョンにたいして処理を行いたいときは、変数
‘use-empty-active-region’を‘t’に変更してください。

   *note Erasing::で説明したように、<DEL> (‘backward-delete-char’)と
<delete> (‘delete-forward-char’)もこの方法で動作します。マークがアクティ
ブのときはリージョンのテキストを削除します(例外として数引数Nに1以外が指
定されたとき、これらのコマンドはマークがアクティブか関係なく、N文字を削
除します)。変数‘delete-active-region’を‘nil’に変更すると、これらのコマン
ドはマークがアクティブのとき異なる動作をしなくなります。これを‘kill’に変
更するとリージョンを削除するかわりに、“kill”するようになります(*note
Killing::を参照してください)。

   その他のコマンドにはデフォルトの動作はなく、常にリージョンを処理しま
す。通常このようなコマンドには、‘C-w’ (‘kill-region’)や‘C-x C-u’
(‘upcase-region’)のように、名前に‘region’がついています。マークが非アク
ティブのときは“非アクティブなリージョン”、すなわちポイントと最後にマーク
をセットした位置の間にあるテキストにたいして処理を行います(*note Mark
Ring::を参照してください)。この動作を無効にするには、変数
‘mark-even-if-inactive’を‘nil’に変更してください。そうするとこれらのコマ
ンドはマークが非アクティブのときエラーをシグナルします。

   デフォルトでは、マークがアクティブでもテキストの挿入は普通に行われま
す。たとえば‘a’をタイプすると、‘a’が挿入されてからマークが非アクティブに
なります。マイナーモードのDelete Selectionモードを有効にしていると、マー
クがアクティブなときは、最初にリージョンのテキストを削除してから、テキス
トが挿入されます。Delete Selectionモードをオフにするには、‘M-x
delete-selection-mode’とタイプしてください。


File: emacs.info,  Node: Mark Ring,  Next: Global Mark Ring,  Prev: Using Region,  Up: Mark

11.4 マークリング
=================

各バッファーは、“マークリング(mark ring)”の中に、以前のマークの位置を記
録しています。マークをセットするコマンドは、古いマークをこのリングに
pushします。マークリングの1つの使い方として、後で戻りたい場所を記録させ
る使い方があります。

‘C-<SPC> C-<SPC>’
     マークをアクティブにせずにマークをセットしてから、マークリングに
     pushします。
‘C-u C-<SPC>’
     マークがあった場所にポイントを移動し、マークリングから1つ前のマーク
     を復元します。

   コマンド‘C-<SPC> C-<SPC>’は、後で戻ってきたい位置をマークするときに便
利です。これは現在の位置をマークを(Emacsがリージョンをハイライト表示して
しまう)アクティブにすることなく、マークリングにpushします。実際にこれは
‘C-<SPC>’ (‘set-mark-command’)を連続して2回呼び出しています。最初の
‘C-<SPC>’はマークをセットし、2回目の‘C-<SPC>’はそれを非アクティブにして
います(Transient Markモードがオフの場合、‘C-<SPC> C-<SPC>’は一時的に
Transient Markモードを有効にします。*note Disabled Transient Mark::を参
照してください)。

   マークした位置に戻るには、‘C-u C-<SPC>’のようにプレフィクス引数を指定
して、‘set-mark-command’を使います。これはマークがあった場所にポイントを
移動して、もしマークがアクティブのときは非アクティブにします。‘C-u
C-<SPC>’を連続して呼び出すと、マークリングに保存された前の位置へジャンプ
していきます。この方法で移動した位置の情報は失われません。それらはリング
の最後に移動します。

   ‘set-mark-command-repeat-pop’を非‘nil’にセットすると、‘C-u C-<SPC>’の
後に続けて、‘C-u C-<SPC>’ではなく、‘C-<SPC>’でマークリングを巡回できます
。デフォルトでは‘set-mark-command-repeat-pop’は‘nil’です。

   各バッファーは自身のマークリングを持ちます。すべての編集コマンドは現
在のバッファーのマークリングを使います。特に‘C-u C-<SPC>’は常に同じバッ
ファーに留まります。

   変数‘mark-ring-max’は、マークリングに保持する最大のエントリー数を指定
します。デフォルトは16エントリーです。もしエントリー数が最大の場合、他の
エントリーをpushするとリストの一番古いものが捨てられます。‘C-u C-<SPC>’を
繰り返すと、リングの現在位置を巡回します。

   もし何度も同じ場所に戻りたいときは、マークリングでは不十分でしょう。
そのような場合は後で使うために、その位置をレジスターに記録できます(*note
Position Registers::を参照してください)。


File: emacs.info,  Node: Global Mark Ring,  Next: Shift Selection,  Prev: Mark Ring,  Up: Mark

11.5 グローバルマークリング
===========================

各バッファーに属する普通のマークリングに加えて、Emacsには“グローバルマー
クリング(global mark ring)”が1つあります。以前マークをセットしてからバッ
ファーを切り替えた場合、マークをセットすると、マークはカレントバッファー
のマークリングに加えて、グローバルマークリングにも記録されます。その結果
、グローバルマークリングには訪れていたバッファーの系列が記録され、各バッ
ファーではマークを設定した箇所が記録されます。グローバルマークリングの長
さは、‘global-mark-ring-max’で制御され、デフォルトは16です。

   コマンド‘C-x C-<SPC>’ (‘pop-global-mark’)は、グローバルリングの最新の
バッファー位置にジャンプします。これもリングを巡回するので、連続して‘C-x
C-<SPC>’を使うことにより、古いバッファーのマーク位置に移動します。


File: emacs.info,  Node: Shift Selection,  Next: Disabled Transient Mark,  Prev: Global Mark Ring,  Up: Mark

11.6 シフト選択
===============

シフトキーを押しながらカーソル移動コマンドをタイプすると、ポイントを移動
する前の位置にマークをセットするので、リージョンが元のポイント位置から新
しいポイント位置に拡張されます。この機能は“シフト選択
(shift-selection)”と呼ばれます。これは他のエディターでテキストを選択する
方法と似ています。

   シフト選択によるマークのセットは、これまでの説明とは少し異なる振る舞
いをします。最初に、マークを非アクティブにする通常の方法(バッファーのテ
キストを変更したり‘C-g’をタイプするなど)に加え、_シフトキーを押さない
(unshifted)_カーソル移動コマンドでも、マークが非アクティブになります。次
に、連続する_シフトキーを押した(shifted)_カーソル移動コマンドでは、マー
クの更新はされません。つまりシフトキーを押しながらカーソル移動コマンドを
繰り返すと、リージョンは継続的に変更されます。

   シフト選択は、シフトキーを押したカーソル移動キーが、別のコマンドにバ
インドされていない場合のみ動作します(*note Customization::を参照してくだ
さい)。たとえば‘S-C-f’を他のコマンドにバインドしていると、‘S-C-f’はシフ
ト選択バージョンの‘C-f’ (‘forward-char’)ではなく、バインドされたコマンド
を実行します。

   マウスコマンドによるマークのセットも、シフト選択によるマークのセット
と同様です(*note Setting Mark::を参照してください)。たとえばマウスをドラ
ッグしてリージョンを指定すると、シフトキーを押したカーソル移動コマンドを
使って、そのリージョンの拡張を続けることができます。どちらのケースも、シ
フトキーを押さないカーソル移動コマンドで、マークが非アクティブになります
。

   シフト選択をオフにするには、‘shift-select-mode’を‘nil’にセットしてく
ださい。これをセットしても、マウスコマンドによるマークのセッティングは無
効になりません。


File: emacs.info,  Node: Disabled Transient Mark,  Prev: Shift Selection,  Up: Mark

11.7 Transient Markモードを無効にする
=====================================

マークとリージョンのデフォルト動作では、マークをアクティブにセットすると
、リージョンがハイライトされます。これはTransient Markモードと呼ばれます
。これはデフォルトで有効になっているマイナーモードです。‘M-x
transient-mark-mode’、または‘Options’メニューの‘Active Region
Highlighting’で切り替えることができます。オフにすることによりEmacsの操作
モードは変更されます。

   • ‘C-<SPC>’や‘C-x C-x’のようなコマンドでマークをセットしても、リージ
     ョンはハイライトされません。そのためマークがどこにあるか見分けるこ
     とができないので、覚えている必要があります。

     マークをセットしたらどこにセットしたか忘れる前にすぐ使うというのが
     、この問題にたいする通常の解決策です。ポイントとマークの位置を交換
     する‘C-x C-x’で、マークがどこかチェックすることもできます。

   • 通常マークがアクティブのときリージョンにたいして処理を行ういくつか
     のコマンドは、そのような振る舞いをしなくなります。たとえば普通‘M-%’
     (‘query-replace’)は、マークがアクティブのときはリージョンにたいして
     置換を行います。Transient Markがオフだと、常にポイントからバッファ
     ーの最後までを処理します。このような方法で動作するコマンドは、コマ
     ンド自身のドキュメントにより識別できます。

   Transient Markモードがオフのときは、‘C-<SPC> C-<SPC>’または‘C-u C-x
C-x’を使って一時的にアクティブにすることができます。

‘C-<SPC> C-<SPC>’
     ポイント位置にマークをセット(普通の‘C-<SPC>’と同様)して、マークが非
     アクティブになるまでの間、1度だけTransient Markモードを有効にします
     (実際にはこれは独立したコマンドではなく‘C-<SPC>’コマンドを2回行って
     います)。

‘C-u C-x C-x’
     ポイントとマークを交換してからマークをアクティブにして、次にマーク
     が非アクティブになるまでの間、Transient Markモードを一時的に有効に
     します(これはプレフィクス引数を指定した‘C-x C-x’
     (‘exchange-point-and-mark’)コマンドです)。

   これらのコマンドはマークをセットまたはアクティブにして、マークが非ア
クティブになるまでの間Transient Markモードを有効にします。これらを使う
1つの理由は、いくつかのコマンドはTransient Markモードがオフのとき、リー
ジョンにたいしてではなくバッファー全体を処理するからです。Transient
Markモードを一時的に有効にできれば、これらのコマンドをリージョンにたいし
て処理させることができます。

   リージョンをマウス(*note Setting Mark::を参照してください)、またはシ
フト選択(*note Shift Selection::を参照してください)で指定したときも、一
時的にTransient Markモードが有効になり、リージョンがハイライトされます。


File: emacs.info,  Node: Killing,  Next: Registers,  Prev: Mark,  Up: Top

12 テキストのkillと移動
***********************

Emacsで“kill”とはテキストを消去して、“killリング”にコピーすることを意味
します。“yank”とは、killリングからテキストを取り出して、バッファーに戻す
ことを意味します(“cut(カット、切り取り)”と“paste(ペースト、貼り付け)”と
いう用語を使うアプリケーションもあります)。これはテキストブロックのセッ
トが、循環的にアクセスできるリングに格納されているイメージから、killリン
グと名付けられました。*note Kill Ring::を参照してください。

   killとyankは、Emacsでテキストを移動したりコピーするための、もっとも一
般的な方法です。これは用途が広いコマンドです。なぜなら、多くの異なる種類
の構文単位をkillするためのコマンドが存在するからです。

* Menu:

* Deletion and Killing::     テキストを削除するコマンド。
* Yanking::                  テキストを挿入するコマンド。
* Cut and Paste::            グラフィカルなディスプレーにおけるクリップボードと選択。
* Accumulating Text::        バッファーにテキストを追加する他の方法。
* Rectangles::               矩形領域のテキストの操作。
* CUA Bindings::             killとyankで‘C-x’/‘C-c’/‘C-v’を使う。


File: emacs.info,  Node: Deletion and Killing,  Next: Yanking,  Up: Killing

12.1 削除とkill
===============

バッファーからテキストを消去するコマンドの多くは、それをkillリングに保存
します。これらは“kill”コマンドとして知られており、通常名前に‘kill’が含ま
れます(例 ‘kill-line’)。killリングには、最近killしたものが、1つだけでは
なくいくつか格納されているので、killはとても安全な操作と言えます。なぜな
ら、以前にkillしたテキストが失われる心配をする必要がないからです。killリ
ングは、すべてのバッファーで共有されているので、あるバッファーでkillした
テキストを、別のバッファーにyankすることができます。

   ‘C-/’ (‘undo’)を使うと、killコマンドはアンドゥ(*note Undo::を参照して
ください)されるので、killしたテキストはバッファーに戻されますが、killリ
ングからは削除されません。

   グラフィカルなディスプレーでは、テキストをkillすると、それはシステム
のクリップボードにもコピーされます。 *note Cut and Paste::を参照してくだ
さい。

   テキストを消去してkillリングに保存しないコマンドは、“削除(delete)”コ
マンドとして知られており、名前に‘delete’が含まれています。これらは‘C-d’
(‘delete-char’)や<DEL> (‘delete-backward-char’)のように、一度に1文字削除
するものや、スペースや改行だけを削除するものが含まれます。重要なデータの
有意な量を消去するコマンドには、一般的にkill操作が用いられます。

   killとyankでマウスを使うこともできます。*note Cut and Paste::を参照し
てください。

* Menu:

* Deletion::                 少量のテキストや空の領域を削除するコマンド。
* Killing by Lines::         テキスト行を一度にkillする方法。
* Other Kill Commands::      大きなリージョン、および単語やセンテンスのような構文単位をkillするコマンド。
* Kill Options::             killに影響を与えるオプション。


File: emacs.info,  Node: Deletion,  Next: Killing by Lines,  Up: Deletion and Killing

12.1.1 削除
-----------

削除とは、テキストを消去してkillリングに保存しないという意味です。テキス
トを削除するたいていのEmacsコマンドは、1文字または空白文字しか消去しませ
ん。

‘<DEL>’
‘<BACKSPACE>’
     前の文字を削除します。リージョンがアクティブのときは、リージョンの
     テキストを削除します(‘delete-backward-char’)。

‘<Delete>’
     次の文字を削除します。リージョンがアクティブのときは、リージョンの
     テキストを削除します(‘delete-forward-char’)。

‘C-d’
     次の文字を削除します(‘delete-char’)。

‘M-\’
     ポイントの周囲のスペースとタブを削除します
     (‘delete-horizontal-space’)。
‘M-<SPC>’
     スペースを1つ残して、ポイントの周囲のスペースとタブを削除します
     (‘just-one-space’)。
‘C-x C-o’
     現在行の周囲の空行を削除します(‘delete-blank-lines’)。
‘M-^’
     行間にある改行をインデントと共に削除して2行を1行にします
     (‘delete-indentation’)。

   基本的な削除コマンド<DEL> (‘delete-backward-char’)、<delete>
(‘delete-forward-char’)、‘C-d’ (‘delete-char’)については既に説明しました
。*note Erasing::を参照してください。数引数を指定すると、指定した数の文
字を削除します。リージョンがアクティブのとき、数引数に1を指定するか省略
した場合は、リージョンのすべてのテキストを削除します。

   他の削除コマンドは、空白文字(スペース、タブ、改行)だけを削除するもの
です。‘M-\’ (‘delete-horizontal-space’)は、ポイントの前後にあるすべての
スペースとタブを削除します。プレフィクス引数を指定すると、ポイントの前に
あるスペースとタブだけを削除します。‘M-<SPC>’ (‘just-one-space’)も同様で
すが、前にスペースが何個あるかに関係なく、ポイントの前に1つのスペースを
残します。数引数Nを指定すると、Nが正のときはポイントの前に、N個のスペー
スを残します。Nが負の場合は、スペースとタブに加えて改行も削除し、ポイン
トの前に-N個のスペースを残します。コマンド‘cycle-spacing’は、
‘just-one-space’のようなコマンドで、よりフレキシブルな動作をします。これ
は連続で呼び出すと異なる処理を行います。1番目の呼び出しでは
‘just-one-space’と同様の処理をし、2番目の呼び出しではすべての空白文字を
削除し、3番目の呼び出しでは元の空白文字を復元します。

   ‘C-x C-o’ (‘delete-blank-lines’)は、現在行の下にあるすべての空行を削
除します。現在行が空行のときは、現在行の上にあるすべての空行も削除します
(空行を1つ、つまり現在行は残します)。単独の空行で実行するとその行を削除
します。

   ‘M-^’ (‘delete-indentation’)は、改行と周囲のスペース(通常1つのスペー
スを残す)を削除することにより、現在行とその上の行を結合します。*note
M-^: Indentation.を参照してください。

   コマンド‘delete-duplicate-lines’は、リージョン内の重複した行を検索し
て、それぞれ1行を残して削除します。通常は重複した行の最初の行を残します
が、プレフィクス引数‘C-u’を指定すると、最後の行を残します。プレフィクス
引数‘C-u C-u’を指定すると、隣接した重複行だけを検索します。これは行がソ
ート済みのとき効果的です。プレフィクス引数‘C-u C-u C-u’を指定すると、連
続する空行は残します。


File: emacs.info,  Node: Killing by Lines,  Next: Other Kill Commands,  Prev: Deletion,  Up: Deletion and Killing

12.1.2 行のkill
---------------

‘C-k’
     行の残り、または1行以上をkillします(‘kill-line’)。
‘C-S-backspace’
     1度に行全体を削除します(‘kill-whole-line’)。

   もっとも簡単なkillコマンドは、‘C-k’ (‘kill-line’)です。これを行末で使
うと、その行を終端している改行をkillして、現在行と次の行を継げます(空行
なら削除します)。そうでない場合、‘C-k’はポイントから行末までを削除します
。ポイントの元の位置が行頭の場合は、空行が残ります。

   どちらのケースを適用するか決める際には、行末のスペースとタブは無視さ
れます。ポイントが行の一番最後の可視の文字の後ろにあるとき、‘C-k’は改行
をkillすることに注意してください。空でない行全体をkillするときは、行頭で
‘C-k’を2回タイプしてください。

   このコンテキストで“行”とは、スクリーン行ではなく論理行を意味します
(*note Continuation Lines::を参照してください)。

   ‘C-k’に正の数値Nを与えると、N行とそれに続く改行をkillします(現在行の
ポイントの前にあるテキストはkillされません)。負の引数−Nを与えると、現在
行のポイントの前にあるテキストと、前のN行をkillします。‘C-k’に0を指定す
ると、現在行のポイントの前にあるテキストをkillします。

   変数‘kill-whole-line’が非‘nil’のときは、行頭での‘C-k’により行末の改行
も含めて行全体がkillされます。この変数は通常‘nil’です。

   ‘C-S-backspace’ (‘kill-whole-line’)は行中のポイントの位置に関わらず、
改行を含めた行全体をkillします。キーシーケンス‘C-S-backspace’をタイプで
きないテキスト端末がたくさんあることに注意してください。


File: emacs.info,  Node: Other Kill Commands,  Next: Kill Options,  Prev: Killing by Lines,  Up: Deletion and Killing

12.1.3 その他のkillコマンド
---------------------------

‘C-w’
     リージョンをkillします(‘kill-region’)。
‘M-w’
     リージョンをkillリングにコピーします(‘kill-ring-save’)。
‘M-d’
     次の単語をkillします(‘kill-word’)。*note Words::を参照してください
     。
‘M-<DEL>’
     後方に1単語killします(‘backward-kill-word’)。
‘C-x <DEL>’
     センテンスの先頭までを後方にkillします(‘backward-kill-sentence’)。
     *note Sentences::を参照してください。
‘M-k’
     文の末尾までをkillします(‘kill-sentence’)。
‘C-M-k’
     後に続く対応のとれた式(balanced expressions)をkillします
     (‘kill-sexp’)。*note Expressions::を参照してください。
‘M-z CHAR’
     次のCHARまでをkillします(‘zap-to-char’)。

   一般によく使われるkillコマンドは‘C-w’ (‘kill-region’)で、これはリージ
ョンのテキストをkillします(*note Mark::を参照してください)。同様に‘M-w’
(‘kill-ring-save’)は、バッファーからテキストを消去せずに、リージョンのテ
キストをkillリングにコピーします。‘C-w’または‘M-w’をタイプしたとき、マー
クが非アクティブの場合、これらのコマンドはポイントと最後にセットしたマー
クの間にあるテキストにたいして処理を行います(*note Using Region::を参照
してください)。

   Emacsは特定の構文単位にたいするkillコマンドを提供します。単語
(words)にたいしては‘M-<DEL>’と‘M-d’(*note Words::を参照してください)、対
応のとれた式(balanced expressions)にたいしては‘C-M-k’(*note
Expressions::を参照してください)、センテンス(sentences: 文)にたいしては
‘C-x <DEL>’‘M-k’(*note Sentences::を参照してください)です。

   コマンド‘M-z’ (‘zap-to-char’)は、killと検索が組み合わされています。こ
れは文字を読み取り、ポイントからバッファー内の次にその文字が現れる場所ま
でをkillします。数引数は繰り返し回数です。負の引数の場合は後方に検索する
ことを意味し、ポイントの前のテキストをkillします。


File: emacs.info,  Node: Kill Options,  Prev: Other Kill Commands,  Up: Deletion and Killing

12.1.4 killのオプション
-----------------------

いくつかの特別なバッファーは、“読み取り専用(read-only)のテキスト”を含ん
でいて、それらは変更できないのでkillもできません。killコマンドは読み取り
専用のバッファーにたいして特別な動作をします。バッファーから実際にテキス
トを削除せずに、killリングにコピーします。通常はビープ音をならし、その旨
のエラーメッセージを表示します。しかし変数‘kill-read-only-ok’を非‘nil’に
セットすると、なぜテキストが消去されないのかをエコーエリアにメッセージ表
示します。

   変数‘kill-do-not-save-duplicates’を非‘nil’に変更すると、同じものにた
いするkillは重複なくkillリングの1つのエントリーとなります。


File: emacs.info,  Node: Yanking,  Next: Cut and Paste,  Prev: Deletion and Killing,  Up: Killing

12.2 yank
=========

“yank”するとは、以前killしたテキストを再び挿入するという意味です。テキス
トを移動またはコピーする通常の方法は、それをkillしてからどこかにyankする
方法です。

‘C-y’
     最後にkillしたものをポイント位置にyankします(‘yank’)。
‘M-y’
     yankしたテキストを、それより前にkillしたテキストに置き換えます
     (‘yank-pop’)。*note Earlier Kills::を参照してください。
‘C-M-w’
     次のコマンドがkillコマンドのときは、killしたものを、以前にkillした
     ものに追加します(‘append-next-kill’)。*note Appending Kills::を参照
     してください。

   基本的なyankコマンドは、‘C-y’ (‘yank’)です。これはもっとも最近killさ
れたものを挿入し、カーソルを挿入されたテキストの最後に移動します。また挿
入されたテキストの先頭にマークをセットして、それを非アクティブにします。
これにより‘C-u C-<SPC>’で簡単にその位置にジャンプできます(*note Mark
Ring::を参照してください)。

   ‘C-u C-y’のようにプレフィクス引数を指定すると、カーソルを挿入されたテ
キストの前に移動して、マークをテキストの最後にセットします。他のプレフィ
クス引数は、何回前のkillかを指定します。たとえば‘C-u 4 C-y’は、もっとも
最近killされたものから4番目に古いものを挿入します。

   グラフィカルなディスプレーでは、‘C-y’はまず最後にEmacsがkillした後に
、他のアプリケーションがシステムのクリップボードに、何らかのテキストをコ
ピーしていないか調べます。もしコピーしていたなら、かわりにクリップボード
のテキストを挿入します。このようにEmacsは効果的に“カット(cut)”や“コピー
(copy)”などの、他のアプリケーションで処理されたクリップボード操作を、
Emacsのkillのように扱います(ただしkillリングには記録されません)。詳細に
ついては、*note Cut and Paste::を参照してください。

* Menu:

* Kill Ring::                killされたテキストが格納される場所。
* Earlier Kills::            もっと前にkillしたものをyankする。
* Appending Kills::          数回のkillを一緒にまとめてyankする。


File: emacs.info,  Node: Kill Ring,  Next: Earlier Kills,  Up: Yanking

12.2.1 killリング
-----------------

“killリング(kill ring)”とは、以前にkillされたテキストブロックからなるリ
ストです。すべてのバッファーにたいして、killリングは1つしかないので、あ
るバッファーでkillしたテキストを、他のバッファーにyankすることができます
。これはバッファーから他のバッファーへテキストを移動する、通常の方法です
(他の方法もいくつかあります。たとえばテキストをレジスターに格納すること
もできます。*note Registers::を参照してください。テキストを移動する他の
方法については、*note Accumulating Text::を参照してください)。

   killリングのエントリーの最大数は、変数‘kill-ring-max’で制御されます。
デフォルトは60です。エントリー数が制限に達しているとき新たにkillすると、
Emacsはkillリングの一番古いエントリーを削除して空きを作ります。

   killリングの実際の内容は、‘kill-ring’という名前の変数に格納されていま
す。killリングのエントリーの内容は、‘C-h v kill-ring’で見ることができま
す。


File: emacs.info,  Node: Earlier Kills,  Next: Appending Kills,  Prev: Kill Ring,  Up: Yanking

12.2.2 過去にkillしたテキストをyankする
---------------------------------------

*note Yanking::で説明したように、‘C-y’に数引数を指定して、最後にkillされ
たものではないテキストをyankできます。これはkillリングのどのエントリーが
欲しいか覚えているとき便利です。もし覚えていないときは、‘M-y’
(‘yank-pop’)コマンドを使って、候補を探すことができます。

   もし前のコマンドがyankコマンドのとき、‘M-y’はyankされたテキストを、
1つ前にkillされたテキストで置き換えます。つまり2番目に新しいkillされたテ
キストを復元するには、最初に‘C-y’で最後にkillされたテキストをyankし、次
に‘M-y’でその1回前にkillされたテキストで置き換えます。‘M-y’は、‘C-y’また
は他の‘M-y’の後しか使えません。

   killリングのエントリーを指す(ポイントする)、“last yank”ポインターとい
う概念で、‘M-y’を理解できるでしょう。なにかをkillする度に、“last yank”ポ
インターはリングの先頭に新たに作られたエントリーを指すように移動します。
‘C-y’は、“last yank”ポインターが指すエントリーをyankします。‘M-y’は“last
yank”ポインターが違うエントリーを指すように移動して、バッファーのテキス
トをポインターが指すテキストに変更します。‘M-y’コマンドを繰り返すことに
より、リングの任意のエントリーにポインターを移動できるので、任意のエント
リーをバッファーに取り込むことができます。やがてリングの最後に到達すると
、次の‘M-y’により再び最初のエントリーに戻ります。

   ‘M-y’はリング内で“last yank”ポインターを移動させますが、リング内のエ
ントリーの順番は変更しません。リングのエントリーは、常に最後にkillされた
ものを先頭に、記憶されているもので一番古いエントリーへと並んでいます。

   “last yank”ポインターを何回進めるかを、‘M-y’に数引数で指定できます。
負の引数はリングの先頭に向かってポインターを移動させます。リングの先頭で
は一番古いエントリーに“戻り”、そこから先頭へと移動します。

   望むテキストを見つけてバッファーに取り込んだら、‘M-y’コマンドを止めれ
ばそのテキストはそこに残ります。このテキストはkillリングのエントリーの単
なるコピーなので、それを編集してもリングの中のエントリーは変更されません
。新しく何かをkillしない限り、“last yank”ポインターは同じ位置に留まるの
で、‘C-y’でそのテキストの別のコピーをyankできます。

   ‘C-y’に数引数を指定するときも、yankするエントリーに“last yank”ポイン
ターをセットします。


File: emacs.info,  Node: Appending Kills,  Prev: Earlier Kills,  Up: Yanking

12.2.3 killしたテキストの追加
-----------------------------

通常はkillコマンドを実行するごとに、新しいエントリーがkillリングにpushさ
れます。しかし2回以上の連続するkillコマンドにより、killされたテキストを
1つのエントリーとしてまとめ、すべてのテキストを1単位として、あたかもそれ
がkillされたかのように、1回の‘C-y’でyankできます。

   つまりテキストを1つの単位としてyankしたいとき、そのテキストすべてを
1回でkillする必要はありません。すべてがkillされるまで行から行、単語から
単語へとkillを続け、それを一度に取得することができます。

   ポイントから前方にkillするコマンドは、直前にkillされたテキストの最後
に追加します。ポイントから後方にkillするコマンドは、テキストの先頭に追加
します。この方法により前方と後方を併用した連続するkillコマンドは、すべて
のkillされたテキストを再配置しなくてもよいように、1つのエントリーにまと
めます。数引数を指定してもkillの連続性は途切れません。たとえば以下のよう
なテキストを含むバッファーがあるとしましょう:

     This is a line ★of sample text.

ポイントの位置は★で示された場所です。‘M-d M-<DEL> M-d M-<DEL>’とタイプし
て、前方と後方へのkillを交互に行うと、最後にkillリングには‘a line of
sample’という1つのエントリー、バッファーには‘This is  text.’が残ります
(‘is’と‘text’の間には2つのスペースがあることに注意してください。これは
‘M-<SPC>’または‘M-q’で取り除くことができます)。

   同じテキストをkillする別の方法は、‘M-b M-b’で単語2つ後方に移動してか
ら、‘C-u M-d’で前方の単語4つをkillする方法です。これはバッファーとkillリ
ングに、正確に同じ結果をもたらします。‘M-f M-f C-u M-<DEL>’で後方に
killしても結果は同じです。killリングのエントリーは、常にバッファーから
killされる前と同じ順番になります。

   killコマンドと最後のキルコマンドの間に、(単なる数引数ではない)他のコ
マンドが入ると、killリングには新たなエントリーが作られます。しかし、あら
かじめ‘C-M-w’ (‘append-next-kill’)とタイプすることにより、最後にkillされ
たテキストに追加するように強制できます。‘C-M-w’は、後に続くコマンドが
killコマンドであれば、killしたテキストを前にkillしたテキストに付け加える
よう指示します。この方法でも、前方にkillするコマンドの場合は、前にkillさ
れたテキストの最後に追加され、後方にkillするコマンドの場合は、先頭に追加
されます。この方法により、1ヶ所にyankするために離れた場所にあるいくつか
のテキスト断片を、killして集めることができます。

   ‘M-w’ (‘kill-ring-save’)の後のkillコマンドは、‘M-w’でkillリングにコピ
ーされたテキストへの追加はしません。


File: emacs.info,  Node: Cut and Paste,  Next: Accumulating Text,  Prev: Yanking,  Up: Killing

12.3 グラフィカルなディスプレーでのカットアンドペースト
=======================================================

ほとんどのグラフィカルなデスクトップ環境では、異なるアプリケーション間の
データ転送(通常はテキスト)に、“クリップボード(clipboard)”と呼ばれるシス
テム機能を使います。Xでは他にプライマリー選択(primary selection)とセカン
ダリー選択(secondary selection)という、同様の機能が利用可能です。Emacsを
グラフィカルなディスプレーで実行している場合、killとyankコマンドはこれら
の機能に統合されているので、Emacsと他のグラフィカルアプリケーション間で
、簡単にテキストを転送できます。

   デフォルトでは、Emacsはプログラム間テキスト転送のコーディングシステム
として、UTF-8を使います。もしコピーしたテキストが期待したものでない場合
、‘C-x <RET> x’または‘C-x <RET> X’とタイプして、他のコーディングシステム
を指定できます。‘x-select-request-type’をカスタマイズして、異なるデータ
タイプを要求することもできます。*note Communication Coding::を参照してく
ださい。

* Menu:

* Clipboard::                Emacsがシステムクリップボードを使う方法。
* Primary Selection::        一時的に選択されたテキストの選択。
* Secondary Selection::      ポイントとマークを変化させずに切り取る。


File: emacs.info,  Node: Clipboard,  Next: Primary Selection,  Up: Cut and Paste

12.3.1 クリップボードを使う
---------------------------

“クリップボード(clipboard)”とは、ほとんどのグラフィカルなアプリケーショ
ンが、“カットアンドペースト”のために使う機能です。もしクリップボードが存
在する場合、Emacsのkillおよびyankコマンドもそれを使います。

   何らかのテキストを、‘C-w’ (‘kill-region’)のようなコマンドでkillしたり
、‘M-w’ (‘kill-ring-save’)のようなコマンドでkillリングにコピーしたとき、
そのテキストはクリップボードにも転送されます。

   Emacsのkillコマンドがテキストをクリップボードに転送すると、通常クリッ
プボードの既存の内容は失われます。オプションとして、
‘save-interprogram-paste-before-kill’を‘t’に変更できます。これにより、
Emacsは古いクリップボードのデータが失われることを防ぐために、最初にクリ
ップボードのデータをkillリングに保存します。これにはデータが大きくなると
、メモリー消費が増えるというリスクがあります。

   ‘C-y’ (‘yank’)のようなyankコマンドもクリップボードを使います。他のア
プリケーションがクリップボードを“所有”する場合(たとえばEmacsで最後に
killコマンドを実行した後に、他のアプリケーションでテキストをカットまたは
コピーした場合)、Emacsはkillリングではなくクリップボードからyankします。

   通常killリングを‘M-y’ (‘yank-pop’)で巡回することでは、クリップボード
は変更されません。しかし‘yank-pop-change-selection’を‘t’に変更すると、
‘M-y’は新しいyankをクリップボードに保存します。

   killおよびyankコマンドがクリップボードにアクセスしないようにするには
、変数‘x-select-enable-clipboard’を‘nil’に変更してください。

   多くのXデスクトップ環境は、“クリップボードマネージャー(clipboard
manager)”と呼ばれる機能をサポートします。もしEmacsがクリップボードのデー
タの現在の“持ち主”のときにEmacsを終了し、そのときクリップボードマネージ
ャーが実行されていると、Emacsはクリップボードのデータをクリップボードマ
ネージャーに転送するのでデータは失われません。ある状況において、これは
Emacsが終了するが遅くなる原因となります。Emacsがクリップボードマネージャ
ーにデータをを転送しないようにするには、変数
‘x-select-enable-clipboard-manager’を‘nil’に変更してください。

   Emacs 24以前は、killおよびyankコマンドは、クリップボードではなくプラ
イマリー選択(*note Primary Selection::を参照してください)を使っていまし
た。もしこのほうがよいなら、‘x-select-enable-clipboard’を‘nil’、
‘x-select-enable-primary’を‘t’、‘mouse-drag-copy-region’を‘t’に変更して
ください。この場合は、次のコマンドを使って、クリップボードに明示的にアク
セスできます。リージョンをkillしてクリップボードに保存するには
‘clipboard-kill-region’、リージョンをkillリングにコピーするとともにクリ
ップボードに保存するには‘clipboard-kill-ring-save’、クリップボードの内容
をポイント位置にyankするには‘clipboard-yank’です。


File: emacs.info,  Node: Primary Selection,  Next: Secondary Selection,  Prev: Clipboard,  Up: Cut and Paste

12.3.2 他のウィンドウアプリケーションにたいするカットアンドペースト
-------------------------------------------------------------------

Xウィンドウシステム下では、“プライマリー選択(primary selection)”に、Xア
プリケーションで最後に選択されたテキスト(通常はマウスのドラッグで選択さ
れる)が存在します。一般的に、このテキストは他のXアプリケーションに
‘mouse-2’をクリックして挿入することができます。プライマリー選択はクリッ
プボードとは別のものです。プライマリー選択の内容は、より“脆弱”です。なぜ
なら、クリップボードは明示的な“カット”または“コピー”だけにより上書きされ
るのにくらべ、プライマリー選択はマウスでテキストが選択される度に上書きさ
れるからです。

   Xの下では、リージョンがアクティブ(*note Mark::を参照してください)にな
ればいつでも、リージョンのテキストはプライマリー選択に保存されます。これ
は、そのリージョンの選択がマウスでドラッグやクリック(*note Mouse
Commands::を参照してください)されたのか、キーボードコマンド(たとえば
‘C-<SPC>’をタイプしてからポイントを移動したなど。*note Setting Mark::を
参照してください)なのかによらず適用されます。

   変数‘select-active-regions’を‘only’に変更すると、Emacsは一時的にアク
ティブになったリージョン(たとえばマウスやシフト選択など。*note Shift
Selection::を参照してください)だけをプライマリー選択に保存します。
‘select-active-regions’を‘nil’に変更すると、Emacsはアクティブなリージョ
ンをプライマリー選択に保存しません。

   プライマリー選択をEmacsのバッファーに挿入するには、挿入したい場所で
‘mouse-2’ (‘mouse-yank-primary’)をクリックします。*note Mouse
Commands::を参照してください。

   MS-Windowsはプライマリー選択を提供しませんが、Emacsは単一のEmacsセッ
ション内で選択されたテキストを内部に格納することにより、これをエミュレー
トします。したがってWindowsでも、プライマリー選択に関するすべての機能と
コマンドは、Xと同様に機能します。しかしこれは同一セッションにおけるカッ
トやペーストなどの場合で、Emacsセッションと他のアプリケーション間では機
能しません。


File: emacs.info,  Node: Secondary Selection,  Prev: Primary Selection,  Up: Cut and Paste

12.3.3 セカンダリー選択
-----------------------

プライマリー選択に加えて、Xウィンドウシステムは“セカンダリー選択
(secondary selection)”として知られる、同様な第2の機能を提供します。最近
ではセカンダリー選択を使うXアプリケーションの数は多くありませんが、以下
のEmacsコマンドによりアクセスできます:

‘M-Drag-Mouse-1’
     ボタンを押した場所からボタンを話した場所までを、セカンダリー選択と
     してセットします(‘mouse-set-secondary’)。ドラッグして選択されたテキ
     ストは、フェイス‘secondary-selection’を使ってハイライトされます。ウ
     ィンドウの上端または下端を越えてマウスをドラッグすると、
     ‘mouse-set-region’と同様にウィンドウは自動的にスクロールします
     (*note Mouse Commands::を参照してください)。

     このコマンドはkillリングを変更しません。

‘M-Mouse-1’
     “セカンダリー選択”の始点をセットします(‘mouse-start-secondary’)。

‘M-Mouse-3’
     ‘M-Mouse-1’で指定された位置から、クリックされた点を終点とするセカン
     ダリー選択をセットします(‘mouse-secondary-save-then-kill’)。これは
     選択されたテキストをkillリングにも保存します。同じ場所での2回目の
     ‘M-Mouse-3’は、作成されたセカンダリー選択をkillします。

‘M-Mouse-2’
     クリックした場所にセカンダリー選択を挿入し、ポイントをyankしたテキ
     ストの最後に配します(‘mouse-yank-secondary’)。

   ‘Mouse-1’と同様、‘M-Mouse-1’のダブルクリックで単語、トリプルクリック
で行を処理します。

   ‘mouse-yank-at-point’が非‘nil’の場合、‘M-Mouse-2’はポイント位置に
yankします。どこをクリックしたか、さらにはフレームのどのウィンドウをクリ
ックしたかは関係ありません。*note Mouse Commands::を参照してください。


File: emacs.info,  Node: Accumulating Text,  Next: Rectangles,  Prev: Cut and Paste,  Up: Killing

12.4 テキストの追加
===================

テキストのコピーや移動は、それをkillしてyankすることにより通常行います。
しかし多くの箇所にあるテキストブロックをコピーしたり、たくさんのテキスト
の断片を1ヶ所にコピーする便利な方法があります。ここではテキストの断片を
、バッファーやファイルに追加するコマンドを説明します。

‘M-x append-to-buffer’
     リージョンを指定したバッファーの内容の後に追加(append)します。
‘M-x prepend-to-buffer’
     リージョンを指定したバッファーの内容の前に追加(prepend)します。
‘M-x copy-to-buffer’
     リージョンを指定したバッファーにコピーして、バッファーの古い内容は
     削除されます。
‘M-x insert-buffer’
     指定したバッファーの内容を、現在のバッファーのポイント位置に挿入し
     ます。
‘M-x append-to-file’
     リージョンを指定したファイルの内容の最後に追加します。

   テキストをバッファーに追加するには、‘M-x append-to-buffer’を使います
。これはバッファー名を読み取り、リージョンのコピーを指定したバッファーに
挿入します。存在しないバッファーを指定すると、‘append-to-buffer’はそのバ
ッファーを作成します。テキストは、そのバッファーのポイント位置に挿入され
ます。バッファーを編集用に使っていると、コピーされたテキストはその時ポイ
ントがあった位置に挿入されます。

   バッファーのポイントは、コピーされたテキストの最後に残ります。連続し
て‘append-to-buffer’を使うと、テキストは指定したバッファーにコピーした順
番で追加されていきます。厳密に言うと‘append-to-buffer’は既存のバッファー
のテキストにたいして、常に追加をする訳ではありません。これはポイントがバ
ッファーの最後にあるときに追加をします。しかしバッファーを変更するのに
‘append-to-buffer’しか使わない場合、ポイントは常にバッファーの最後に位置
することになります。

   ‘M-x prepend-to-buffer’も‘append-to-buffer’と同様ですが、他のバッファ
ーのポイントはコピーされたテキストの前に置かれるので、連続してテキストを
追加すると結果は逆の順番にコピーされます。‘M-x copy-to-buffer’も同様です
が、他のバッファーの既存の内容は削除されるので、バッファーの内容は新しく
コピーされたテキストだけになります。

   コマンド‘M-x insert-buffer’は、追加するテキストを他のバッファーから取
得するために使われます。これはバッファー名の入力を求め、そのバッファーの
すべてのテキストのコピーを、現在のバッファーのポイント位置に挿入します。
ポイントは挿入されたテキストの先頭になります。挿入されたテキストの最後の
位置もマークリングに追加されます。マークは非アクティブになります。バッフ
ァーに関する背景情報は、*note Buffers::を参照してください。

   バッファーのテキストを追加するかわりに、‘M-x append-to-file’でテキス
トを直接ファイルに追加できます。これはファイル名の入力を求め、リージョン
のテキストを指定されたファイルの最後に追加します。ディスク上のファイルは
すぐに変更されます。

   ‘append-to-file’は、Emacsがvisitして_いない_ファイルだけに使うべきで
す。Emacsで編集中のファイルにたいして使用すると、それはEmacsの背後でファ
イルが変更されることになるため、編集内容が失われる可能性があります。

   テキストの移動に関する他の方法はレジスターに格納する方法です。*note
Registers::を参照してください。


File: emacs.info,  Node: Rectangles,  Next: CUA Bindings,  Prev: Accumulating Text,  Up: Killing

12.5 矩形領域(Rectangles)
=========================

“矩形領域(rectangle)”コマンドは、テキストの矩形領域を操作します。矩形領
域のテキストとは、特定の行範囲内にある、特定の2つの列の間にある文字すべ
ての文字です。Emacsには矩形領域にたいしてkill、yank、クリアー、スペース
やテキストでんpフィル、削除を行うコマンドがあります。矩形領域コマンドは
、複数列のテキストを操作したり、テキストをそのように変更したり戻したりす
る場合に便利です。

   コマンドで操作する矩形領域を指定するには、一方の角にマークを設定し、
その対角にポイントを置きます。このように設定した矩形領域を矩形リージョン
(region-rectangle)と呼びます。ポイントとマークが同じ列の場合、矩形リージ
ョンは空になります。ポイントとマークが同じ行の場合、矩形リージョンの高さ
は1行になります。

   矩形リージョンは、リージョンの制御と大体同じ方法で制御できます。しか
し、ポイントとマークの組がリージョンとして解釈されるのか、あるいは矩形領
域として解釈されるかは、それらを使うコマンドに依存することに注意してくだ
さい。

‘C-x r k’
     矩形リージョンをkillして、内容を“最後にkillされた矩形領域”として保
     存します(‘kill-rectangle’)。
‘C-x r M-w’
     矩形リージョンのテキストを“最後にkillされた矩形領域”として保存しま
     す(‘copy-rectangle-as-kill’)。
‘C-x r d’
     矩形リージョンのテキストを削除します(‘delete-rectangle’)。
‘C-x r y’
     最後にkillされた矩形領域の左上隅をがポイント位置になるようにyankし
     ます(‘yank-rectangle’)。
‘C-x r o’
     矩形領域にスペースを挿入します(‘open-rectangle’)。これにより矩形リ
     ージョンの以前の内容は右にずれます。
‘C-x r N’
     矩形リージョンの左端に行番号を挿入します
     (‘rectangle-number-lines’)。これにより矩形リージョンの以前の内容は
     右にずれます。
‘C-x r c’
     矩形リージョンの内容をスペースに置き換えてクリアーします
     (‘clear-rectangle’)。
‘M-x delete-whitespace-rectangle’
     指定された矩形領域の各行で、矩形領域の左端の列から空白文字を削除し
     ます。
‘C-x r t STRING <RET>’
     矩形領域の各行にたいして、内容をSTRINGに置き換えます
     (‘string-rectangle’)。
‘M-x string-insert-rectangle <RET> STRING <RET>’
     矩形領域の各行にたいして、STRINGを挿入します。
‘C-x <SPC>’
     Rectangle Markモードを切り替えます(‘rectangle-mark-mode’)。このモー
     ドがアクティブのとき矩形領域はハイライトされ、拡大・縮小が可能にな
     ります。標準のkillおよびyankコマンドは、それにたいして操作を行いま
     す。

   矩形領域の操作は2種類に分類できます。それは矩形領域を消去または挿入す
るものと、空の矩形領域を作るものです。

   矩形領域のテキストを消去するには2つの方法があります。‘C-x r d’
(‘delete-rectangle’)はテキストを無条件に削除します。‘C-x r k’
(‘kill-rectangle’)はテキストを取り除いて、それを“最後にkillされた矩形領
域”として保存します。両方とも矩形領域の各行の指定したテキストを消去する
ように、矩形リージョンを消去します。その行の後に続くテキストがある場合、
削除による隙間を生めるために後方に移動されます。

   矩形領域の“kill”は普通のkillとは異なります。矩形領域はkillリングには
保存されず、一番最後にkillされた矩形領域だけを記録する、特別な場所に保存
されます。矩形領域のyankは線形テキストのyankとは大きく異なるので、異なる
yankコマンドが使われるからです。矩形領域にたいしてyankのpopは定義されて
いません。

   ‘C-x r M-w’ (‘copy-rectangle-as-kill’)は矩形領域用の‘M-w’に相当します
。これはバッファーからテキストを削除することなく、矩形領域を“最後に
killされた矩形領域”として記録します。

   killされた矩形領域をyankするには、‘C-x r y’ (‘yank-rectangle’)とタイ
プします。矩形領域の最初の行はポイント位置に挿入されます。矩形領域の2行
目はポイントの1行下の位置に挿入され、以下同様に挿入されていきます。影響
を受ける行数は、保存された矩形領域の高さにより決定されます。

   たとえば1列のリスト2つを2列のリストに変換できます。一方の1列リストを
矩形領域としてkillしてもう一方の1列リストの隣にyankすればよいのです。

   ‘C-x r r R’と‘C-x r i R’で、矩形領域をレジスターにコピーしたり取り出
したりできます。*note Rectangle Registers::を参照してください。

   空の矩形領域を作るために使うことのできるコマンドが2つあります。‘C-x r
c’ (‘clear-rectangle’)は、矩形リージョンの既存のテキストを空白に置き換え
ます。‘C-x r o’ (‘open-rectangle’)は空白の矩形領域を挿入します。

   ‘M-x delete-whitespace-rectangle’は、指定した列を起点に水平方向の空白
文字を削除します。これは矩形領域の各行に適用され、開始列は矩形領域の左端
です。矩形領域の右端はこのコマンドに影響を及ぼしません。

   コマンド‘C-x r N’ (‘rectangle-number-lines’)は、矩形領域の左端に行番
号を挿入します。通常は矩形領域の最初の行を1として番号が開始されます。プ
レフィクス引数を指定すると、このコマンドは開始番号と、番号を出力する際の
書式文字列(*note (elisp)Formatting Strings::を参照してください)の入力を
求めます。

   コマンド‘C-x r t’ (‘string-rectangle’)は、矩形リージョンの各行を文字
列で置き換えます。文字列の幅は矩形領域と同じ幅である必要はありません。矩
形領域の後ろのテキストは、文字列の幅が少ないときは左に、文字列の幅が大き
いときは右にシフトされます。

   コマンド‘M-x string-insert-rectangle’は、‘string-rectangle’と同様です
が、各行に文字列を挿入し、元の文字列は右にシフトされます。

   コマンド‘C-x <SPC>’ (‘rectangle-mark-mode’)は、矩形リージョンをハイラ
イトするか、標準のリージョンをハイライトするかを切り替えます(最初にリー
ジョンをアクティブにする必要があります)。このモードが有効な場合、‘C-f’、
‘C-n’などのコマンドは矩形領域に合ったやり方でリージョンのサイズを変更し
、kill、yankは矩形領域を処理します。*note Killing::を参照してください。
このモードはリージョンがアクティブな間だけ持続します。


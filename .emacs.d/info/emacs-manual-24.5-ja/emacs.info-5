This is emacs.info, produced by makeinfo version 6.1 from emacs.texi.

This is the ‘GNU Emacs Manual’, updated for Emacs version 24.5.

   Copyright © 2015–2016 Ayanokoji Takesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).            拡張可能なセルフドキュメント形式のテキストエディター。
END-INFO-DIR-ENTRY


File: emacs.info,  Node: ForIndent Conv,  Next: ForIndent Vars,  Prev: ForIndent Num,  Up: Fortran Indent

26.14.2.4 構文的な慣習
......................

Fortranモードは正しくインデントを行うために、あなたが、Fortranプログラム
解読を単純化する特定の慣習にしたがうと仮定します：

   • ネストされた2つの‘do’ループは、‘continue’命令を共有しない。

   • ‘if’、‘else’、‘then’、‘do’、その他のFortranキーワードは、空白文字や
     行ブレークを含まずに記述される。

     Fortranコンパイラーは一般的に文字列定数の外の空白文字を無視しますが
     、Fortranモードはこれらのキーワードが隣接していない場合、それらを認
     識しません。‘else if’や‘end do’のような構成は許されますが、2つ目の
     単語は継続行ではなく、1つ目の単語と同じ行にあるべきです。

これらの慣習にしたがわない場合、インデントコマンドは醜いインデントをする
かもしれません。しかし正しいFortranプログラムなら、慣習にしたがわずにイ
ンデントされたものでも、その意味は変わりません。


File: emacs.info,  Node: ForIndent Vars,  Prev: ForIndent Conv,  Up: Fortran Indent

26.14.2.5 Fortranのインデントのための変数
.........................................

Fortranのインデントがどのように機能するかを制御する、追加の変数がいくつ
かあります:

‘fortran-do-indent’
     ‘do’命令の各レベルにたいする、追加のインデントです(デフォルトは3)。

‘fortran-if-indent’
     ‘if’、‘select case’、‘where’命令の各レベルにたいする、追加のインデ
     ントです(デフォルトは3)。

‘fortran-structure-indent’
     ‘structure’、‘union’、‘map’、‘interface’命令の各レベルにたいする、
     追加のインデントです(デフォルトは3)。

‘fortran-continuation-indent’
     継続行の本文にたいする、追加のインデントです(デフォルトは3)。

‘fortran-check-all-num-for-matching-do’
     Fortran 77では、番号つきの‘do’命令は、それにマッチする行番号をもつ
     任意の命令で終了します。この目的のためには‘continue’命令を使うのが
     一般的です(が、強制ではありません)。この変数が非‘nil’値の場合、番号
     が付与された命令をインデントするとき、そこで終了する‘do’をチェック
     しなければなりません。‘do’命令を常に‘continue’(またはよりモダンな
     ‘enddo’)で終了する場合は、この変数を‘nil’(デフォルト)にセットするこ
     とにより、インデントの速度を上げることができます。

‘fortran-blink-matching-if’
     この変数が‘t’の場合、‘endif’(または‘enddo’)命令のインデントにより、
     マッチする‘if’(または‘do’)命令にカーソルが数瞬移動します。デフォル
     トは‘nil’です。

‘fortran-minimum-statement-indent-fixed’
     固定形式の継続行スタイルを使用する場合の、Fortran命令にたいする最小
     のインデントです。命令本体はこれより小さい値でインデントされること
     はありません。デフォルトは6です。

‘fortran-minimum-statement-indent-tab’
     タブ形式の継続行スタイルを使用する場合の、Fortran命令にたいする最小
     のインデントです。命令本体はこれより小さい値でインデントされること
     はありません。デフォルトは8です。

   以下のセクションでは、コメントのインデントを制御する変数を説明します
。


File: emacs.info,  Node: Fortran Comments,  Next: Fortran Autofill,  Prev: Fortran Indent,  Up: Fortran

26.14.3 Fortranのコメント
-------------------------

通常のEmacsのコメントコマンドは、コード行の後にコメントを記述できると仮
定します。Fortran 77では、標準のコメント構文はコメント行に行全体を要求し
ます。したがってFortranモードは、標準のEmacsコメントコマンドを置き換え、
新しい変数も定義します。

   Fortranモードは、‘!’で始まり、他のテキストの後に記述することができる
、Fortran 90のコメント構文も処理できます。この構文を許すFortran 77コンパ
イラーは限られているので、Fortranモードは、あらかじめそれを行うように指
示しない限り、そのようなコメントを挿入しません。これを行うには、変数
‘fortran-comment-line-start’に‘"!"’をセットします。通常とは異なる値を使
う場合、‘fortran-comment-line-start-skip’も変更する必要があるでしょう。

‘M-;’
     コメントの位置揃え、または新しいコメントを挿入します
     (‘comment-dwim’)。

‘C-x ;’
     非標準の‘!’だけを適用します(‘comment-set-column’)。

‘C-c ;’
     リージョンのすべての行をコメントにします。または(引数を指定した場合
     は)コメントを実際のコードに戻します(‘fortran-comment-region’)。

   Fortranモードで実行すると、これは標準の‘comment-dwim’を実行します。こ
れは任意の種類の既存のコメントを認識して、それらのテキストの位置揃えをし
ます。既存のコメントがない場合は、コメントの挿入・位置揃えをします。
Fortranモードでのコメントの挿入および位置揃えは、他のモードとは異なりま
す。

   新しいコメントが挿入されなければならない場合、カレント行が空のときは
、行全体をコメントとして挿入します。その行が空でない場合、もしそれを使う
ことを指示していれば、非標準の‘!’コメントが挿入されます。そうでない場合
はカレント行の前に新しい行を挿入して、その行全体をコメントにします。

   非標準の‘!’コメントは、他の言語のコメントと同じように位置揃えされます
が、行全体のコメントは異なります。標準の行全体のコメントは、コメント区切
り自体は常に列0に出現しなければなりません。位置揃えできるのは、コメント
の中のテキストです。変数‘fortran-comment-indent-style’に、以下の3つの値
のうち1つをセットすることにより、3つのスタイルの位置揃えを選択できます。

‘fixed’
     テキストを固定列に位置揃えします。これは
     ‘fortran-comment-line-extra-indent’と命令文の最小のインデントとの和
     です。これがデフォルトです。

     最小のインデントは、タブ形式の継続行スタイルの場合は
     ‘fortran-minimum-statement-indent-tab’で、固定形式スタイルの場合は
     ‘fortran-minimum-statement-indent-fixed’です。

‘relative’
     そのテキストがコード行であるかのように位置揃えしますが、
     ‘fortran-comment-line-extra-indent’に指定した列のインデントが追加さ
     れます。

‘nil’
     行全体のコメントを自動的に移動しません。

   これらに加えて、変数‘fortran-comment-indent-char’に、使用したい1文字
をセットすることにより、行全体のコメントのインデントに使用する文字を指定
することができます

   コンパイラーにたいする命令行や、プリプロセッサー行は、コメント行と同
じ外観をもっています。しかし、‘fortran-comment-indent-style’の値に関わら
ず、そのような行が決してインデントされないことが重要です。変数
‘fortran-directive-re’は、どのような行がそのような命令なのかを指定する正
規表現です。これにマッチする行はインデントされず、特別な外観のフォントが
適用されます。

   Emacsの通常のコメントコマンド‘C-x ;’ (‘comment-set-column’)は再定義さ
れません。‘!’コメントを使用している場合、このコマンドをそれらに使用でき
ます。そうでない場合、これはFortranモードでは役に立ちません。

   コマンド‘C-c ;’ (‘fortran-comment-region’)は、リージョンのすべての行
の行頭に文字列‘c$$$’を挿入することにより、これらをコメントにします。数引
数を指定した場合、各行の行頭から‘c$$$’を削除することにより、リージョンを
コードに戻します。これらのコメントに使用する文字列は、変数
‘fortran-comment-region’をセットすることにより制御できます。これはコマン
ドと変数が同じ名前をもつ例であることに注意してください。同じ名前を2つの
用途で使用することによる衝突はありません。なぜならLispおよびEmacsではそ
れが意味するものは、コンテキストにより明らかだからです。


File: emacs.info,  Node: Fortran Autofill,  Next: Fortran Columns,  Prev: Fortran Comments,  Up: Fortran

26.14.4 FortranモードでのAuto Fill
----------------------------------

Fortranモードは、Auto Fillモードにたいする特別なサポートをもっています。
これは命令文を挿入するとき、それが長くなりすぎた場合は自動的に分割するマ
イナーモードです。命令文の分割は、‘fortran-continuation-string’を使用し
た継続行により行われます(*note ForIndent Cont::を参照してください)。この
分割は<SPC>、<RET>、<TAB>、およびFortranのインデントコマンドにより発生し
ます。FortranモードでのAuto Fillの有効化は、通常の方法で行うことができま
す。 *note Auto Fill::を参照してください。

   Auto Fillは、その行が望ましい幅(‘fill-column’の値)より長くなった場合
は、スペースおよび区切り文字で行をブレークします。Auto Fillが行をブレー
クする(空白文字以外の)区切り文字は‘+’、‘-’、‘/’、‘*’、‘=’、‘<’、‘>’、
‘,’です。‘fortran-break-before-delimiters’が‘nil’の場合、区切り文字の後
ろで行ブレークします。そうでない場合(デフォルト)、区切り文字の前で行ブレ
ークします。

   すべてのFortranバッファーでAuto Fillを有効にするには、
‘fortran-mode-hook’に‘auto-fill-mode’を追加します。 *note Hooks::を参照
してください。


File: emacs.info,  Node: Fortran Columns,  Next: Fortran Abbrev,  Prev: Fortran Autofill,  Up: Fortran

26.14.5 Fortranでの列のチェック
-------------------------------

標準のFortran 77では、72列目以降は無視されます。ほとんどのコンパイラーは
これを変更するオプションを提供します(たとえばgfortranの
‘-ffixed-line-length-N’)。変数‘fortran-line-length’をカスタマイズするこ
とにより、Fortranモードでの行の長さを変更できます。このポイント以降はコ
メントにfont-lockされます(ただし文字列内の場合は除きます。
‘fortran-line-length’を超える文字列は、font-lockを混乱させるでしょう)。

‘C-c C-r’
     カレント行の上に、“列目盛(column ruler)”を一時的に表示します。
‘C-c C-w’
     ‘fortran-line-length’列の幅になるように、カレントウィンドウを水平に
     分割します(‘fortran-window-create-momentarily’)。これは、Fortranコ
     ンパイラーにより課せられた制限を超えないようにする助けになるでしょ
     う。
‘C-u C-c C-w’
     (‘fortran-window-create’)列の幅になるように、カレントウィンドウを水
     平に分割します。その後は編集を続行できます。
‘M-x fortran-strip-sequence-nos’
     列‘fortran-line-length’以上のすべてのテキストを削除します。

   コマンド‘C-c C-r’ (‘fortran-column-ruler’)は、カレント行の上に列目盛
を一時的に表示します。列目盛は2行のテキストで、Fortranプログラムにおいて
特別な意味をもつ列の位置を表示します。角カッコ(square brackets)は行番号
の範囲を示し、中カッコ(curly brackets)は命令文本体の範囲を示します。列番
号がその上に表示されます。

   GNU Emacsでは、列番号は常に0から数えることに注意してください。結果と
して、この番号はあなたが親しんでいる番号より1小さくなるかもしれません。
しかしこの行で示される位置は、Fortranの標準です。

   列目盛を表示するのに使用されるテキストは、変数‘indent-tabs-mode’の値
に依存します。‘indent-tabs-mode’が‘nil’の場合、変数
‘fortran-column-ruler-fixed’の値が列目盛として使用されます。それ以外は、
変数‘fortran-column-ruler-tab’の値が表示されます。これらの値を変更するこ
とにより、表示される列目盛を変更できます。

   ‘C-c C-w’ (‘fortran-window-create-momentarily’)で、一時的にカレントウ
ィンドウを水平方向に分割して、ウィンドウの幅を‘fortran-line-length’列に
することにより、長くなりすぎた行を見つけることができます。スペースをタイ
プすると元の幅に戻ります。

   適切な位置でウィンドウを水平方向に分割して、編集を継続することもでき
ます。これを行うには、‘C-u C-c C-w’ (‘M-x fortran-window-create’)を使用
します。このウィンドウで編集することより、Fortranでの正しい長さを超える
行をすぐに見つけることができます。

   コマンド‘M-x fortran-strip-sequence-nos’は、カレントバッファーのすべ
ての行にたいして、列‘fortran-line-length’以上のテキストすべてを削除しま
す。これは古いシーケンス番号を削除する一番簡単な方法です。


File: emacs.info,  Node: Fortran Abbrev,  Prev: Fortran Columns,  Up: Fortran

26.14.6 FortranキーワードのAbbrev
---------------------------------

Fortranモードは、一般的なキーワードや定義にたいするabbrev(abbreviation:
省略形)を提供します。あなたが定義できるabbrevと同様なものがあります。こ
れらを使用するには、Abbrevモードをオンに切り替えなければなりません。
*note Abbrevs::を参照してください。

   ビルトインのabbrevは、1つの点で特異です。これらはすべてセミコロンから
始まります。たとえばFortranのビルトインのabbrevである‘;c’は、
‘continue’にたいする省略形です。‘;c’を挿入してから、スペースや改行のよう
な区切りとなる文字を挿入すると、Abbrevモードが有効な場合、‘;c’は自動的に
‘continue’に展開されます。

   ‘;?’または‘;C-h’とタイプすると、すべてのビルトインのFortranのabbrevの
リストと、それが何を意味するかが表示されます。


File: emacs.info,  Node: Building,  Next: Maintaining,  Prev: Programs,  Up: Top

27 プログラムのコンパイルとテスト
*********************************

前のチャプターでは、プログラムを変更するのに便利なEmacsコマンドについて
議論しました。このチャプターでは、プログラムのコンパイルとテストに役立つ
コマンドを扱います。

* Menu:

* Compilation::              Lisp以外の言語(C、Pascal、など)のプログラムのコンパイル。
* Compilation Mode::         コンパイラーのエラーをvisitするモード。
* Compilation Shell::        compilationバッファーで使えるように、シェルを適切にカスタマイズする。
* Grep Searching::           grepによる検索。
* Flymake::                  オンザフライでの構文エラーの検索。
* Debuggers::                非Lispプログラムのための、シンボルデバッガーの実行。
* Executing Lisp::           Lispプログラムを編集するためのさまざまなモードと、Lispプログラムを実行する異なる機能。
* Libraries: Lisp Libraries.  LispプログラムがEmacsにロードされる方法。
* Eval: Lisp Eval.           Emacsで1つのLisp式を実行する。
* Interaction: Lisp Interaction.  EmacsバッファーでLispを実行する。
* External Lisp::            Emacsを通じて別のLispと通信する。


File: emacs.info,  Node: Compilation,  Next: Compilation Mode,  Up: Building

27.1 Emacs下でのコンパイルの実行
================================

Emacsは、CやFortranのような言語のためのコンパイラーを実行でき、コンパイ
ルログをEmacsのバッファーに取り込むことができます。エラーメッセージを解
析して、エラーが発生した場所を示すこともできます。

‘M-x compile’
     Emacs下で非同期にコンパイラーを実行し、エラーメッセージは
     ‘*compilation*’バッファーに送られます。
‘M-x recompile’
     最後に呼び出した‘M-x compile’と同じコマンドで、コンパイラーを呼び出
     します。
‘M-x kill-compilation’
     サブプロセスで実行されているコンパイルをkillします。

   ‘make’、または他のコンパイルコマンドを実行するには、‘M-x compile’とタ
イプします。これはミニバッファーを使用してシェルのコマンドラインを読み取
り、シェルをEmacsのサブプロセス(または“下位プロセス(inferior process)”)と
して、そのコマンドを実行します。出力は‘*compilation*’という名前のバッフ
ァーに挿入されます。カレントバッファーのデフォルトディレクトリーが、コマ
ンドを実行する作業ディレクトリーとして使用されます。したがって、通常はそ
のディレクトリーでコンパイルが行われます。

   デフォルトのコンパイルコマンドは‘make -k’で、これは‘make’ユーティリテ
ィーを使ってコンパイルするプログラムにたいして通常正しいコマンドです
(‘-k’フラグは‘make’に、エラー後も可能な限りコンパイルを継続するよう指示
します)。*note Make: (make)Top.を参照してください。前に‘M-x compile’を実
行している場合、それに指定したコマンドは自動的に変数‘compile-command’に
格納されます。これは、次に‘M-x compile’とタイプしたときのデフォルトとな
ります。ファイルのファイルローカルな値で‘compile-command’を指定すること
もできます(*note File Variables::を参照してください)。

   コンパイルを開始すると、他のウィンドウで‘*compilation*’バッファーが表
示されますが、そのウィンドウは選択されません。コンパイルが実行中は、
‘*compilation*’バッファーのメジャーモードインジケーターに‘run’という単語
が表示され、単語‘Compiling’がすべてのモードラインに表示されます。コンパ
イル実行中、常に‘*compilation*’バッファーを表示している必要はありません
。表示されていなくてもコンパイルは継続します。何らかの理由によりコンパイ
ルが終了したときは、‘*compilation*’バッファーのモードラインが‘exit’(その
後に終了コード。‘[0]’の場合は通常終了)、または‘signal’(何らかのシグナル
がプロセスを終了させた場合)に変化します。

   コンパイルの経過を見たいときは、バッファー‘*compilation*’に切り替えて
、ポイントをバッファーの最後に移動します。ポイントが最後にある場合、コン
パイル出力はポイント位置に挿入されるので、ポイントは最後に留まります。そ
うでない場合は、バッファーの最後にコンパイル出力が追加される間も、ポイン
ト位置は固定されたままです。

   変数‘compilation-scroll-output’を非‘nil’値に変更した場合、
‘*compilation*’バッファーは出力に追随して自動的にスクロールします。値が
‘first-error’の場合は、最初のエラーが出現した箇所でスクロールがストップ
し、ポイントはエラー箇所に留まります。その他の任意の非‘nil’値の場合は、
出力がなくなるまでスクロールが継続されます。

   最後にコンパイルしたのと同じコマンドで再実行するには、‘M-x
recompile’とタイプします。これは最後に呼び出した‘M-x compile’からコンパ
イルコマンドを再利用します。これは‘*compilation*’バッファーも再利用し、
コンパイルもそのバッファーのデフォルトディレクトリー、つまり前にコンパイ
ルが開始されたのと同じディレクトリーで行われます。

   新しいコンパイルの開始は、すでに‘*compilation*’で実行中のコンパイルを
killします。これは、そのバッファーが1度に1つのコンパイルしか処理できない
からです。しかし実行中のコマンドを実際にkillする前に、‘M-x compile’は確
認を求めます。常に確認なしで自動的にコンパイルをkillするには、変数
‘compilation-always-kill’を‘t’に変更します。コマンド‘M-x
kill-compilation’で、コンパイルプロセスをkillすることもできます。

   1度に2つのコンパイルを実行するには、最初に1つを開始してから(多分
‘rename-uniquely’を使用して。*note Misc Buffer::を参照してください
)‘*compilation*’、バッファーをリネームして、それからバッファーを切り替え
て他のコンパイルを開始します。これにより新しい‘*compilation*’バッファー
が作成されます。

   コンパイルコマンドに渡される環境は、変数‘compilation-environment’で制
御できます。この変数の値は環境変数のセッティングのリストで、各要素は文字
列‘"ENVVARNAME=VALUE"’の形式です。これらの環境変数のセッティングは、通常
の値をオーバーライドします。


File: emacs.info,  Node: Compilation Mode,  Next: Compilation Shell,  Prev: Compilation,  Up: Building

27.2 Compilationモード
======================

‘*compilation*’バッファーは、Compilationモードと呼ばれるメジャーモードを
使用します。Compilationモードは、バッファーのエラーメッセージをハイパー
リンクに変換します。ポイントをそこに移動して<RET>をタイプするか、マウス
でクリック(*note Mouse References::を参照してください)すると、別のウィン
ドウでエラーメッセージの“locus”をvisitします。locusとは、エラーが発生し
たファイルの特定の位置を意味します。

   変数‘compilation-auto-jump-to-first-error’を非‘nil’値に変更した場合、
Emacsは、‘*compilation*’バッファーに表れる最初のエラーメッセージの
locusを自動的にvisitします。

   Compilationモードは、以下の追加のコマンドを提供します。これらのコマン
ドは‘*grep*’バッファーでも使用できます。このバッファーではエラーメッセー
ジのかわりに、検索にたいするマッチにハイパーリンクが設定されます(*note
Grep Searching::を参照してください)。

‘M-g M-n’
‘M-g n’
‘C-x `’
     次のエラーメッセージ(またはマッチ)のlocusをvisitします
     (‘next-error’)。
‘M-g M-p’
‘M-g p’
     前のエラーメッセージ(またはマッチ)のlocusをvisitします
     (‘previous-error’)。
‘M-n’
     locusをvisitせずに、ポイントを次のエラーメッセージ(またはマッチ)に
     移動します(‘compilation-next-error’)。
‘M-p’
     locusをvisitせずに、ポイントを前のエラーメッセージ(またはマッチ)に
     移動します(‘compilation-previous-error’)。
‘M-}’
     他のファイルで発生した次のエラーメッセージ(またはマッチ)にポイント
     を移動します(‘compilation-next-file’)。
‘M-{’
     他のファイルで発生した前のエラーメッセージ(またはマッチ)にポイント
     を移動します(‘compilation-previous-file’)。
‘C-c C-f’
     Next Error Followマイナーモードに切り替えます。これはcompilationバ
     ッファーでのカーソル移動にしたがって、ソースを自動的に表示するモー
     ドです。

   順番にエラーをvisitするには、‘C-x `’ (‘next-error’)とタイプするか、こ
れと等価な‘M-g M-n’または‘M-g n’とタイプします。このコマンドは
Compilationモードのバッファーだけでなく、任意のバッファーから呼び出すこ
とができます。コンパイル後に最初に呼び出すときは、最初のエラーメッセージ
のlocusをvisitします。連続した‘C-x `’は、同じ方法で次のエラーをvisitしま
す。‘*compilation*’バッファーから<RET>またはマウスクリックで特定のエラー
をvisitした場合、‘C-x `’はそのエラーの次のエラーからvisitしていきます。
これ以上visitするエラーメッセージがない場合、‘C-x `’はエラーをシグナルし
ます。‘C-u C-x `’はcompilationバッファーの先頭から再開して、最初の
locusをvisitします。

   ‘M-g M-p’または‘M-g p’ (‘previous-error’)は、反対方向にエラーを巡回し
ます。

   コマンド‘next-error’および‘previous-error’は、バッファー
‘*compilation*’または‘*grep*’にリストされたエラー(またはマッチ)だけに作
用されるわけではありません。これらのコマンドは‘M-x occur’ (*note Other
Repeating Search::を参照してください)のようなコマンドで生成されたエラー
(またはマッチ)を巡回する方法も知っています。すでにエラーメッセージ(また
はマッチ)を含むバッファーにいる場合、それらは巡回できるものの1つです。そ
うでない場合、Emacsは選択されたフレームのウィンドウの中でエラーメッセー
ジ(またはマッチ)を含むバッファー、そして‘next-error’または
‘previous-error’が前に巡回したバッファー、そして最後はすべての他のバッフ
ァーの中からバッファーを探します。巡回するために選択されたバッファーが現
在ウィンドウに表示されていなければ、そのバッファーが表示されます。

   デフォルトでは、コマンド‘next-error’および‘previous-error’は、重要で
ないメッセージはスキップします。変数‘compilation-skip-threshold’が、これ
を制御します。デフォルト値は1で、これは警告(warning)より重要でないメッセ
ージをスキップします。2の場合、エラー(error)より重要でないものをスキップ
し、0はメッセージをスキップしません。

   Emacsがエラーメッセージのlocusをvisitしているとき、関連するソース行が
一時的にハイライトされます。このハイライトの持続時間は、変数
‘next-error-highlight’により決定されます。

   ‘*compilation*’バッファーが左フリンジ(*note Fringes::を参照してくださ
い)のあるウィンドウで表示されている場合、locusをvisitするコマンドはカレ
ントエラーメッセージを指す矢印をフリンジに配します。テキスト端末のように
、左フリンジがないウィンドウの場合、これらのコマンドは、カレントメッセー
ジがウィンドウの一番上にくるようにウィンドウをスクロールします。変数
‘compilation-context-lines’を整数値Nに変更した場合、これらのコマンドは、
フリンジの有無に関わらずメッセージがウィンドウの上からN行目にくるように
ウィンドウをスクロールします。デフォルト値の‘nil’では上述したように振る
舞います。

   コンパイラーからのメッセージを解析するために、Compilationモードは変数
‘compilation-error-regexp-alist’を使用します。これはさまざまなエラーメッ
セージのフォーマットをリストし、それらからlocusを抽出する方法をEmacsに指
示します。同じような変数‘grep-regexp-alist’は、‘grep’コマンド(*note Grep
Searching::を参照してください)の出力を解析する方法を指示します。

   Compilationモードは、スクリーン単位でスクロールを行うために、キー
<SPC>および<DEL>も定義します。‘M-n’ (‘compilation-next-error’)および
‘M-p’ (‘compilation-previous-error’)は、次または前のエラーメッセージに移
動します。‘M-{’ (‘compilation-next-file’)および‘M-}’
(‘compilation-previous-file’)は、違うソースファイルの、次または前のエラ
ーメッセージに移動します。

   ‘C-c C-f’とタイプして、Next Error Followモードに切り替えることができ
ます。このマイナーモードでは、compilationバッファーでの通常のカーソル移
動により、自動的にソースを表示するバッファーが更新されます。たとえばカー
ソルをエラーメッセージに移動すると、そのエラーにたいするlocusが表示され
ます。

   Compilationモードの機能は、Compilation Minorモード呼ばれるマイナーモ
ードでも利用可能です。これは通常のコンパイル出力のバッファーだけでなく、
任意のバッファーのエラーメッセージを解析します。‘M-x
compilation-minor-mode’とタイプすることにより、このマイナーモードが有効
になります。たとえばRloginバッファー(*note Remote Host::を参照してくださ
い)では、Compilation minorモードはリモートのソースファイルに、FTPを通じ
て自動的にアクセスします(*note File Names::を参照してください)。


File: emacs.info,  Node: Compilation Shell,  Next: Grep Searching,  Prev: Compilation Mode,  Up: Building

27.3 コンパイルのためのサブシェル
=================================

‘M-x compile’コマンドは、コンパイルコマンドを実行するためにシェルを使い
ますが、オプションで非対話的なシェルを指定します。これは、シェルがプロン
プトなしで開始されることを意味します。‘*compilation*’バッファーで、通常
のシェルプロンプトの見映えがよくない場合、それはシェルの初期化ファイルで
、無条件にプロンプトをセットするという間違いを犯していることを意味します
(この初期化ファイルは使用しているシェルに応じて‘.bashrc’、‘.profile’、
‘.cshrc’、‘.shrc’などの名前がついています)。シェルの初期化ファイルでは、
プロンプトがすでにあるときだけプロンプトをセットするべきです。これを
bashで行うには、以下のようにします:

     if [ "${PS1+set}" = set ]
     then PS1=...
     fi

cshで行うには以下のようにします:

     if ($?prompt) set prompt = ...

   Emacsは、コンパイラープロセスが非同期なサブプロセスで実行されることを
要求しません。もしこれを行う場合、メインのコンパイラープロセスが終了した
後で、サブプロセスがまだ実行中のときは、Emacsはこれらをkillするか、それ
らの出力はEmacsには到達しません。この問題を避けるには、メインのコンパイ
ルプロセスが、それのサブプロセスの終了までwaitするようにします。シェルス
クリプトでは、以下のように‘$!’と‘wait’を使用して、これを行うことができま
す:

     (sleep 10; echo 2nd)& pid=$!  # サブプロセスのpidを記録
     echo first message
     wait $pid                     # サブプロセスのwait

バックグラウンドのプロセスがcompilationバッファーに何も出力せず、メイン
のコンパイルプロセスが終了したときに、これらがkillされるのを防ぐことだけ
が必要な場合は、以下で充分です:

     nohup COMMAND; sleep 1

   MS-DOS“オペレーティングシステム”では、非同期なサブプロセスはサポート
されていないので、‘M-x compile’はコンパイルコマンドを同期実行します(たと
えばEmacsで他のことを行うには、コマンドが終了するまで待たなければなりま
せん)。*note MS-DOS::を参照してください。


File: emacs.info,  Node: Grep Searching,  Next: Flymake,  Prev: Compilation Shell,  Up: Building

27.4 Emacs下でのGrepによる検索
==============================

Emacsからコンパイラーを実行して、コンパイルエラーの行をvisitできるように
、‘grep’を実行して見つかったマッチの行をvisitすることもできます。これは
‘grep’が報告するマッチを、“エラー”のように扱うことで機能します。出力バッ
ファーはGrepモードを使用します。これはCompilationモードの変種です(*note
Compilation Mode::を参照してください)。

‘M-x grep’
‘M-x lgrep’
     Emacs下で‘grep’を非同期で実行し、‘*grep*’という名前のバッファーにマ
     ッチした行をリストします。
‘M-x grep-find’
‘M-x find-grep’
‘M-x rgrep’
     ‘find’を通じて‘grep’を実行し、出力を‘*grep*’バッファーに収集します
     。
‘M-x zrgrep’
     ‘zgrep’を実行して、出力を‘*grep*’バッファーに収集します。
‘M-x kill-grep’
     実行中の‘grep’サブプロセスをkillします。

   ‘grep’を実行するには、‘M-x grep’とタイプしてから、どのように‘grep’を
実行するかを指定するコマンドラインを入力します。これは通常、‘grep’を実行
するとき与える引数と同じです。‘grep’スタイルのregexp(通常、シェルのスペ
シャル文字をクォートするためシングルクォートで囲む)の後に、ファイル名(ワ
イルドカードも使用できる)を続けます。‘M-x grep’にプレフィクス引数を指定
した場合、バッファーのポイント位置周辺のtag(*note Tags::を参照してくださ
い)を探して、それを‘grep’コマンドのデフォルトにします。

   指定するコマンドは、単純に‘grep’を実行するものである必要はありません
。同じフォーマットで出力を生成するシェルコマンドを使用することができます
。たとえば、以下のように、‘grep’コマンドを連結することができます:

     grep -nH -e foo *.el | grep bar | grep toto

   ‘grep’コマンドの出力は、‘*grep*’バッファーに送られます。オリジナルの
ファイルの対応する行は、コンパイルエラーと同様、‘C-x `’、<RET>などで見つ
けることができます。

   マッチをハイライトするために、その周囲に特別なマーカーを出力する
‘--color’オプションを指定できるgrepプログラムもあります。この機能を使う
には、‘grep-highlight-matches’を‘t’にセットします。これによりソースバッ
ファーのマッチを表示するとき、ソース行全体ではなく、正確なマッチだけがハ
イライトされます。

   コマンド‘M-x grep-find’(‘M-x find-grep’でも利用可能)は、‘M-x grep’と
似ていますが、コマンドにたいして提供される初期のデフォルトが異なります —
このデフォルトは‘find’と‘grep’の両方を実行するもので、これによりディレク
トリーツリーの各ファイルを検索できます。*note Dired and Find::の
‘find-grep-dired’コマンドも参照してください。

   コマンド‘M-x lgrep’ (local grep)および‘M-x rgrep’ (recursive grep)は
、‘grep’および‘grep-find’のユーザーフレンドリーなバージョンで、これらは
マッチにたいする正規表現、検索するファイル、検索の基準となるディレクトリ
ーを個別に尋ねます。検索での大文字小文字の区別は、‘case-fold-search’の値
で制御されます。コマンド‘M-x zrgrep’は‘M-x rgrep’と似ていますが、これは
‘grep’のかわりに‘zgrep’を呼び出し、gzipされたファイルの内容を検索します
。

   これらのコマンドは、変数‘grep-template’(‘lgrep’用)、および
‘grep-find-template’(‘rgrep’用)にもとづいてシェルコマンドを構築します。
検索するファイルには、変数‘grep-files-aliases’で定義されたエイリアスを使
用できます。

   変数‘grep-find-ignored-directories’にリストされたディレクトリーは、
‘M-x rgrep’の検索で自動的にスキップされます。デフォルト値には、さまざま
なバージョンコントロールシステムで使用されるデータディレクトリーが含まれ
ます。


File: emacs.info,  Node: Flymake,  Next: Debuggers,  Prev: Grep Searching,  Up: Building

27.5 オンザフライで構文エラーを見つける
=======================================

FlymakeモードはC、C++、Perl、HTML、TeX/LaTeXを含む、多くのプログラミング
言語およびマークアップ言語の構文チェックを、オンザフライ(on-the-fly)で処
理するマイナーモードです。これは通常の人間の言語にたいしてスペルチェック
を処理する、Flyspellモード(*note Spelling::を参照してください)と、その方
法において類似しています。Flymakeモードはファイルの編集にしたがい、その
バッファーの一時的なコピーを使用して、適切な構文チェックツールをバックグ
ラウンドで実行します。それからエラーメッセージと警告メッセージを解析して
、そのバッファーの間違った行をハイライトします。使用される構文チェックツ
ールは、言語に依存します。たとえば通常、C/C++ファイルの場合は、Cコンパイ
ラーです。Flymakeは、複雑なプロジェクトにたいしてのチェックでは、
‘make’のようなビルドツールを使うこともできます。

   Flymakeモードを有効にするには、‘M-x flymake-mode’とタイプします。‘M-x
flymake-goto-next-error’および‘M-x flymake-goto-prev-error’を使用して、
これが見つけたエラーにジャンプすることができます。カレント行に関連するエ
ラーメッセージを表示するには、‘M-x
flymake-display-err-menu-for-current-line’とタイプしてください。

   Flymakeの使用についての詳細は、 *note Flymake: (flymake)Top.を参照し
てください。


File: emacs.info,  Node: Debuggers,  Next: Executing Lisp,  Prev: Flymake,  Up: Building

27.6 Emacs下でのデバッガーの実行
================================

GUD(Grand Unified Debugger)ライブラリーは、広範なシンボリックデバッガー
にたいするEmacsのインターフェースを提供します。これはGNUデバッガー
(GDB)、同様にDBX、SDB、XDB、Paerlのデバッグモード、Pythonデバッガーの
PDB、JavaデバッガーのJDBを実行することができます。

   EmacsはGDBにたいする特別なインターフェースを提供します。これはデバッ
グされているプログラムの状態を表示する追加のEmacsウィンドウを使用します
。*note GDB Graphical Interface::を参照してください。

   Emacsは、Emacs Lispプログラムにたいするビルトインのデバッガーももって
います。*note The Lisp Debugger: (elisp)Debugging.を参照してください。

* Menu:

* Starting GUD::             デバッガーサブプロセスを開始する方法。
* Debugger Operation::       デバッガーとソースバッファーの関係。
* Commands of GUD::          一般的なコマンドのキーバインディング。
* GUD Customization::        GUDにたいして独自のコマンドを定義する。
* GDB Graphical Interface::  GDB機能を使用して、グラフィカルなデバッグ環境を実装する拡張モード。


File: emacs.info,  Node: Starting GUD,  Next: Debugger Operation,  Up: Debuggers

27.6.1 GUDの開始
----------------

デバッガーサブプロセスを開始する複数のコマンドがあり、それらは特定のデバ
ッガープログラムに対応しています。

‘M-x gdb’
     GDBをサブプロセスとして実行し、IDE-likeなEmacsインターフェースを通
     じてやりとりをします。このコマンドに間する詳細は、*note GDB
     Graphical Interface::を参照してください。

‘M-x gud-gdb’
     GDBサブプロセスとの入出力に、GUD interactionバッファーを使用して
     GDBを実行します((*note Debugger Operation::を参照してください))。そ
     のようなバッファーがすでに存在している場合はそのバッファーに切り替
     え、存在しない場合はバッファーを作成して切り替えます。

     ここにリストされている他のコマンドは、他のデバッガープログラムにた
     いして同じことを行います。

‘M-x perldb’
     Perlインタープリターをデバッグモードで実行します。

‘M-x jdb’
     Javaデバッガーを実行します。

‘M-x pdb’
     Pythonデバッガーを実行します。

‘M-x dbx’
     DBXデバッガーを実行します。

‘M-x xdb’
     XDBデバッガーを実行します。

‘M-x sdb’
     SDBデバッガーを実行します。

   これらの各コマンドは、ミニバッファーを使ってデバッガーを呼び出すコマ
ンドラインを読み取ります。ミニバッファーの初期内容は、デバッガーの標準的
な実行ファイル名とオプションで、デバッグしたいと推測される実行ファイル名
の場合もあります。シェルのワイルドカードと変数は、このコマンドラインでは
使用できません。Emacsは‘-’で始まらない最初のコマンド引数を、実行ファイル
名とみなします。

   Trampは、同じリモートホスト上のデバッガーとプログラムによる、リモート
デバッグ機能を提供します。詳細については、*note (tramp)Running a
debugger on a remote host::を参照してください。これはGDBのリモートデバッ
グ機能とは別の物です、なぜなら、プログラムとデバッガーは違うマシンで実行
されるからです(*note Debugging Remote Programs: (gdb)Remote Debugging.を
参照してください)。


File: emacs.info,  Node: Debugger Operation,  Next: Commands of GUD,  Prev: Starting GUD,  Up: Debuggers

27.6.2 デバッガーの操作
-----------------------

“GUD interactionバッファー”は、デバッガーサブプロセスにテキストコマンド
を送ったり、それの出力を記録するのに使用されるEmacsバッファーです。これ
は‘M-x gud-gdb’や、 *note Starting GUD::にリストされた他のコマンドで使用
される、デバッガーとやりとりするための基本的なインターフェースです。
‘M-x gdb’コマンドは、ブレークポイント、スタックフレーム、その他のデバッ
ガーの状態の様相を制御する、追加の特別なバッファーにより、この機能を拡張
します(*note GDB Graphical Interface::を参照してください)。

   GUD interactionはShellモードの変種を使用するので、Shellモードで定義さ
れたEmacsコマンドが利用可能です(*note Shell Mode::を参照してください)。
ほとんどのデバッガーコマンドにたいして補完(*note Completion::を参照して
ください)が利用可能で、それらを繰り返すのに、通常のShellモードのヒストリ
ーコマンドを使うことができます。 GUD interactionバッファーで使用できる特
別なコマンドについては、*note Commands of GUD:: を参照してください。

   プログラムをデバッグすると、Emacsは関連するソースファイルをEmacsバッ
ファーにvisitして、カレント実行行には左フリンジに矢印が表示されます(テキ
スト端末では最初の2列に‘=>’の矢印が表示されます)。そのようなバッファーで
のポイントの移動は、矢印を移動しません。これらのソースファイルの編集はで
きますが、行の挿入や削除により矢印の位置は失われることに注意してください
。なぜならEmacsには編集されたソース行が、デバッガーサブプロセスから報告
されるどの行に対応するか、知る手立てがないからです。この情報を更新するに
は通常、プログラムのリコンパイルと再実行が必要です。

   GUD Tooltipモードは、GUDにツールチップサポートを追加するグローバルな
マイナーモードです。このモードに切り替えるには、‘M-x gud-tooltip-mode’と
タイプします。このモードはデフォルトで無効になっています。有効にした場合
、変数、関数、マクロ(“識別子”として総称される)にマウスを移動すると、それ
らの値がツールチップで表示されます(*note Tooltips::を参照してください)。
かわりにマウスをドラッグして識別子または式をマークしてから、マウスをマー
クした領域から離すと、式の値がツールチップに表示されます。GUD Tooltipモ
ードは、GUD interactionバッファー、および‘gud-tooltip-modes’にリストされ
たメジャーモードの、すべてのソースバッファーで効果があります。変数
‘gud-tooltip-echo-area’が非‘nil’の場合、またはツールチップモードがオフの
場合は、ツールチップではなくエコーエリアに値が表示されます。

   ‘M-x gud-gdb’でGUD Tooltipモードを使用する場合、GDBにより表示される式
の値は、マクロを展開する場合があり、これはデバッグされているプログラムに
副作用をもたらすかもしれません。この理由により、‘gud-gdb’ではツールチッ
プの使用は無効になっています。‘M-x gdb’インターフェースを使用する場合、
この問題は発生しません。なぜなら副作用を避ける特別なコードがあるからです
。さらにプログラムが実行されていないときに、識別子に関連付けられたマクロ
の定義を表示することもできます。


File: emacs.info,  Node: Commands of GUD,  Next: GUD Customization,  Prev: Debugger Operation,  Up: Debuggers

27.6.3 GUDのコマンド
--------------------

GUDはブレークポイントのセットとクリアー、スタックフレームの選択、プログ
ラムのステップ実行のためのコマンドを提供します。

‘C-x C-a C-b’
     ポイントのあるソース行にブレークポイントをセットします。

   ソースバッファーから‘C-x C-a C-b’ (‘gud-break’)が呼び出された場合、カ
レントソース行にデバッガーのブレークポイントをセットします。このコマンド
はGUDを開始した後だけ利用可能です。デバッガーサブプロセスに関連付けられ
ていないバッファーで呼び出すと、エラーをシグナルします。

   以下のコマンドは、GUD interactionバッファーとグローバルの両方で利用可
能ですが、キーバインドが異なります。キーが‘C-c’で始まるものはGUD
interactionバッファーだけで利用可能で、‘C-x C-a’で始まるものはグローバル
に利用可能です。コマンドのいくつかはツールバーを通じても利用可能です。ま
た、特定のデバッガーではサポートされないものもあります。

‘C-c C-l’
‘C-x C-a C-l’
     GUD interactionバッファーで参照される最後のソース行を、別のウィンド
     ウに表示します(‘gud-refresh’)。

‘C-c C-s’
‘C-x C-a C-s’
     次の1行を実行します(‘gud-step’)。その行が関数呼び出しを含む場合、関
     数呼び出しに入った後に実行をストップします。

‘C-c C-n’
‘C-x C-a C-n’
     次の1行を実行します(‘gud-next’)。その行が関数呼び出しを含む場合、関
     数の中でストップせずに関数をステップオーバーします。

‘C-c C-i’
‘C-x C-a C-i’
     機械語の1命令を実行します(‘gud-stepi’)。

‘C-c C-p’
‘C-x C-a C-p’
     ポイント位置の式を評価します(‘gud-print’)。表示したい正確な式を
     Emacsが表示しない場合、最初に式をリージョンとしてマークします。

‘C-c C-r’
‘C-x C-a C-r’
     停止位置を指定せずに実行を継続します。プログラムは、ブレークポイン
     トに達する、プログラム終了、またはデバッガーがチェックしているシグ
     ナルを受けとるまで実行を続けます。

‘C-c C-d’
‘C-x C-a C-d’
     カレントソース行にブレークポイントがある場合、ブレークポイントを削
     除します。GUD interactionバッファーでこのコマンドを使用する場合、プ
     ログラムが最後に停止した位置に適用されます。

‘C-c C-t’
‘C-x C-a C-t’
     カレントソース行に、一時的なブレークポイントをセットします
     (‘gud-tbreak’)。GUD interactionバッファーでこのコマンドを使用した場
     合、プログラムが最後に停止した位置に適用されます。

‘C-c <’
‘C-x C-a <’
     次の外側のスタックフレームを選択します(‘gud-up’)。これはGDBコマンド
     の‘up’と等価です。

‘C-c >’
‘C-x C-a >’
     次の内側のスタックフレームを選択します(‘gud-down’)。これはGDBコマン
     ドの‘down’と等価です。

‘C-c C-u’
‘C-x C-a C-u’
     カレント行まで実行を継続します(‘gud-until’)。プログラムは、ブレーク
     ポイントに達する、プログラム終了、またはデバッガーがチェックしてい
     るシグナルを受けとる、またはカーソルがある行に到達するまで実行を続
     けます。

‘C-c C-f’
‘C-x C-a C-f’
     選択されたフレームがリターンするか、他の理由により停止するまでプロ
     グラムを実行します(‘gud-finish’)。

   GDBを使用している場合、追加のキーバインディングが利用可能です:

‘C-x C-a C-j’
     ソースバッファーだけで有用です。‘gud-jump’はプログラムの実行箇所を
     カレント行に転送します。別の言い方をすると、プログラムが次に実行す
     るのは、このコマンドを与えた位置になります。新しく実行される行が前
     の関数とは異なる場合、多分奇妙な結果になるので、GDBは確認を求めます
     。詳細は、GDBマニュアルのエントリー‘jump’を参照してください。

‘<TAB>’
     GDBの場合、シンボル名を補完します(‘gud-gdb-complete-command’)。この
     キーはGUD interactionバッファーだけで利用可能です。

   これらのコマンドは、それが意味がある場合には、数引数を繰り返し回数と
解釈します。

   <TAB>は補完コマンドに割り当てられているので、GDBでデバッグしているプ
ログラムへのタブの入力には使えません。タブの入力には‘C-q <TAB>’とタイプ
してください。


File: emacs.info,  Node: GUD Customization,  Next: GDB Graphical Interface,  Prev: Commands of GUD,  Up: Debuggers

27.6.4 GUDのカスタマイズ
------------------------

起動時にGUDは以下のフックの1つを実行します:
GDBを使用している場合は‘gdb-mode-hook’、
DBXを使用している場合は‘dbx-mode-hook’、
SDBを使用している場合は‘sdb-mode-hook’、
XDBを使用している場合は‘xdb-mode-hook’、
Perlのデバッグモードを使用している場合は‘perldb-mode-hook’、
PDBを使用している場合は‘pdb-mode-hook’、
JDBを使用している場合は‘jdb-mode-hook’を実行します。
*note Hooks::を参照してください。

   Lispマクロ‘gud-def’(*note (elisp)Defining Macros::を参照してください
)は、デバッガーに特定のコマンド文字列を送るEmacsコマンドを定義して、GUD
interactionバッファーで、それにたいするキーバインドをセットアップする便
利な方法を提供します:

     (gud-def FUNCTION CMDSTRING BINDING DOCSTRING)

   これはデバッガープロセスにCMDSTRINGを送る、ドキュメント文字列が
DOCSTRINGの、FUNCTIONという名前のコマンドを定義します。コマンド
FUNCTIONを、任意のバッファーで使用できます。BINDINGが非‘nil’の場合、
‘gud-def’はそのコマンドを、GUDバッファーのモードでは‘C-c BINDING’、グロ
ーバルには‘C-x C-a BINDING’にバインドします。

   コマンド文字列CMDSTRINGには、FUNCTIONが呼び出されたときに書き込まれる
データのための、特定の‘%’シーケンスを含めることができます:

‘%f’
     カレントソースファイルの名前です。カレントバッファーがGUDバッファー
     の場合、“カレントソースファイル”はプログラムがストップしているファ
     イルです。

‘%l’
     カレントソース行の番号です。カレントバッファーがGUDバッファーの場合
     、“カレントソース行”はプログラムがストップしている行です。

‘%e’
     transient-mark-modeでは、リージョンがアクティブの場合はリージョンの
     テキストです。そうでない場合、ポイント位置またはそれに隣接する位置
     にあるCのlvalue(左辺値)、または関数呼び出し式です。

‘%a’
     ポイント位置またはそれに隣接する位置にある、16進アドレスのテキスト
     です。

‘%p’
     呼び出された関数の数引数の10進数です。コマンドに数引数が指定されな
     かった場合、‘%p’は空文字列になります。

     コマンド文字列に‘%p’を使用しない場合、定義したコマンドは数引数を無
     視します。

‘%d’
     カレントソースファイルのディレクトリー名です。

‘%c’
     ポイントを取り囲む式から派生された、完全に記述されたされたclass名
     (fully qualified class name)です(jdbのみ)。


File: emacs.info,  Node: GDB Graphical Interface,  Prev: GUD Customization,  Up: Debuggers

27.6.5 GDBのグラフィカルインターフェース
----------------------------------------

コマンド‘M-x gdb’はブレークポイント、スタックフレーム、その他のデバッグ
状態の様相を制御するために特化したバッファーで、IDE-likeなインターフェー
スでGDBを開始します。これは、たとえばマウスソースバッファーのフリンジを
クリックすることにより、そこにブレークポイントをセットするなどの、マウス
によりデバッグセッションを制御する追加の方法も提供します。

   これらの追加機能を使わずにGUD interactionバッファーのインターフェース
だけを使ってGDBを実行するには、‘M-x gud-gdb’ (*note Starting GUD::を参照
してください)を使用します。これは、(現在のところ‘M-x gdb’ではサポートさ
れていない)1つのEmacsセッションで複数のプログラムをデバッグしたいときだ
け使用しなければなりません。

   内部的には、‘M-x gdb’はGDBにたいして“スクリーンサイズ”に制限がないと
告げます。正しい操作のために、デバッグセッションの間はGDBのスクリーンの
高さと幅の値を変更してはいけません。

* Menu:

* GDB User Interface Layout::  複数表示されたバッファーの制御。
* Source Buffers::           プログラムを制御するためにフリンジ・余白でマウスを使う。
* Breakpoints Buffer::       ブレークポイントのコントロールパネル。
* Threads Buffer::           スレッドの表示。
* Stack Buffer::             callスタックからのフレームの選択。
* Other GDB Buffers::        GDBの状態を制御するその他のバッファー。
* Watch Expressions::        speedbarで変数の値をモニターする。
* Multithreaded Debugging::  複数スレッドのプログラムのデバッグ。


File: emacs.info,  Node: GDB User Interface Layout,  Next: Source Buffers,  Up: GDB Graphical Interface

27.6.5.1 GDBのユーザーインターフェースのレイアウト
..................................................

変数‘gdb-many-windows’が‘nil’(デフォルト)の場合、‘M-x gdb’は通常GUD
interactionバッファーだけを表示します。しかし‘gdb-show-main’が非‘nil’の
場合、2つのウィンドウで開始します。その場合、1つはGUD interactionバッフ
ァーを表示して、もう一方はデバッグするプログラムの‘main’関数のソースを表
示します。

   ‘gdb-many-windows’が非‘nil’の場合、‘M-x gdb’は以下のフレームレイアウ
トを表示します。

     +--------------------------------+--------------------------------+
     |   GUD interaction buffer       |   Locals/Registers buffer      |
     |--------------------------------+--------------------------------+
     |   Primary Source buffer        |   I/O buffer for debugged pgm  |
     |--------------------------------+--------------------------------+
     |   Stack buffer                 |   Breakpoints/Threads buffer   |
     +--------------------------------+--------------------------------+

   ウィンドウのレイアウトを変更した場合、‘M-x gdb-restore-windows’とタイ
プして“複数ウィンドウ”のレイアウトをリストアできます。複数ウィンドウレイ
アウトと、GUD interactionバッファーとソースファイルだけの単純なレイアウ
トを切り替えるには、‘M-x gdb-many-windows’とタイプしてください。

   同じフレームまたは異なるフレームに、GDBに関連した追加のバッファーを表
示するように指定できます。‘M-x gdb-display-BUFFERTYPE-buffer’または‘M-x
gdb-frame-BUFFERTYPE-buffer’とタイプして、望むバッファーを選択します。こ
こでBUFFERTYPEは‘breakpoints’のような、該当するバッファータイプです。
‘GUD’メニューの、サブメニュー‘GDB-Windows’または‘GDB-Frames’により、メニ
ューバーから同じことができます。

   デバッグを終えたら‘C-x k’でGUD interactionバッファーをkillすれば、こ
のセッションでの関連するすべてのバッファーをkillできます。しかしEmacsで
ソースコードの編集とリコンパイル終えて、さらにデバッグを続けたいときは、
これを行う必要はありません。実行を再開すると、GDBは自動的に新しい実行フ
ァイルを見つけます。GUD interactionバッファーを残しておけば、シェルヒス
トリー、同様にGDBブレークポイントを残すことができる利点があります。最近
編集したソースファイルのブレークポイントが、正しい場所にあるかチェックす
る必要があります。


File: emacs.info,  Node: Source Buffers,  Next: Breakpoints Buffer,  Prev: GDB User Interface Layout,  Up: GDB Graphical Interface

27.6.5.2 Sourceバッファー
.........................

‘Mouse-1’ (in fringe)
     その行にブレークポイントをセットまたはクリアーします。

‘C-Mouse-1’ (in fringe)
     その行のブレークポイントを有効または無効にします。

‘Mouse-3’ (in fringe)
     その行まで実行を継続します。

‘C-Mouse-3’ (in fringe)
     その行にジャンプします。

   グラフィカルなディスプレーでは、sourceバッファーのフリンジを
‘Mouse-1’でクリックして、その行にブレークポイントをセットできます(*note
Fringes::を参照してください)。クリックした場所に赤いドットが表示されます
。すでにそこにブレークポイントが存在する場合、クリックでそれを削除します
。既存のブレークポイントを‘C-Mouse-1’でクリックすることにより、有効また
は無効にします。クリアーされておらず無効になったブレークポイントは、グレ
イのドットで示されます。

   テキスト端末またはフリンジが無効な場合、有効なブレークポイントはウィ
ンドウの左端に、‘B’という文字で示されます。無効なブレークポイントは‘b’で
示されます(余白はブレークポイントがあるときだけ表示されます)。

   sourceバッファーの左フリンジの塗りつぶされた矢印は、デバッグされてい
るプログラムがストップした最内フレームの行を示します。中抜きの矢印はより
高いレベルのフレームの現在実行されている行を示します。フリンジの矢印を
‘Mouse-1’でドラッグすると、ボタンを離した行まで実行が進みます。かわりに
フリンジを‘Mouse-3’でクリックすることにより、その行まで実行を進めること
ができます。フリンジを‘C-Mouse-3’でクリックすることにより、間にある行を
実行せずに、その行にジャンプできます。このコマンドは後方へもジャンプでき
るので、すでに実行中のコードの実行の詳細を調べるのに便利です。


File: emacs.info,  Node: Breakpoints Buffer,  Next: Threads Buffer,  Prev: Source Buffers,  Up: GDB Graphical Interface

27.6.5.3 Breakpointsバッファー
..............................

GDB Breakpointsバッファーは、デバッガーセッションのブレークポイント
(breakpoint)、ウォッチポイント(watchpoint)、キャッチポイント
(catchpoint)を表示します。*note (gdb)Breakpoints::を参照してください。こ
れは以下のコマンドを提供します。これらのコマンドのほとんどは“カレントブ
レークポイント”(ポイントのあるブレークポイント)に適用されます。

‘<SPC>’
     カレントブレークポイントを有効または無効にします
     (‘gdb-toggle-breakpoint’)。グラフィカルなディスプレーでは、これは
     sourceバッファーのフリンジのドットのカラーを変更します。ドットのカ
     ラーは、ブレークポイントが有効なときは赤、無効なときはグレーです。

‘D’
     カレントブレークポイントを削除します(‘gdb-delete-breakpoint’)。

‘<RET>’
     カレントブレークポイントのソース行をvisitします
     (‘gdb-goto-breakpoint’)。

‘Mouse-2’
     クリックしたブレークポイントのソース行をvisitします。

   ‘gdb-many-windows’が非‘nil’の場合、GDB Breakpointsバッファーは、GDB
Threadsバッファーとウィンドウを共有します。一方から他方へ切り替えるには
、ヘッダー行の関連するボタンを‘Mouse-1’でクリックします。
‘gdb-show-threads-by-default’が非‘nil’の場合、GDB Threadsバッファーがデ
フォルトとして表示されます。


File: emacs.info,  Node: Threads Buffer,  Next: Stack Buffer,  Prev: Breakpoints Buffer,  Up: GDB Graphical Interface

27.6.5.4 Threadsバッファー
..........................

GDB Threadsバッファーは、デバッグされているプログラムのスレッドのサマリ
ーを表示します。*note Threads: (gdb)Threads.を参照してください。スレッド
を選択するには、ポイントをそこに移動して<RET> (‘gdb-select-thread’)を押
すか、それを‘Mouse-2’でクリックします。これにより、それに関連する
sourceバッファーが表示され、他のGDBバッファーの内容も更新されます。

   GDB Threadsバッファーに含まれる項目を選択するために、‘gdb-buffers’グ
ループ配下の変数をカスタマイズできます。

‘gdb-thread-buffer-verbose-names’
     ‘Thread 0x4e2ab70 (LWP 1983)’のような長いスレッド名を表示します。

‘gdb-thread-buffer-arguments’
     スレッドのトップフレームの引数を表示します。

‘gdb-thread-buffer-locations’
     ファイル情報またはライブラリー名を表示します。

‘gdb-thread-buffer-addresses’
     threadバッファーのスレッドフレームのアドレスを表示します。

   複数のスレッドの情報を同時に閲覧するには、GDB Threadsバッファーの以下
のコマンドを使用します。

‘d’
     カレント行のスレッドのdisassemblyバッファーを表示します
     (‘gdb-display-disassembly-for-thread’)。

‘f’
     カレント行のスレッドのGDB Stackバッファーを表示します
     (‘gdb-display-stack-for-thread’)。

‘l’
     カレント行のスレッドのGDB Localsバッファーを表示します
     (‘gdb-display-locals-for-thread’)。

‘r’
     カレント行のスレッドのGDB Registersバッファーを表示します
     (‘gdb-display-registers-for-thread’)。

これらのコマンドの大文字‘D’、‘F’、‘L’、‘R’は、対応するバッファーを新しい
フレームに表示します。

   特定のスレッドについての情報を表示するバッファーを作成した場合、それ
はそのスレッドにバインドされて、プログラムをデバッグする間、情報を表示し
続けます。各GDBバッファーのモードインジケーターは、情報が表示されている
スレッドの番号が表示されます。スレッドの番号はバインドされたバッファーの
バッファー名にも含まれます。

   GDB Threadsバッファーでは、さらに他のコマンドも利用可能で、それはプロ
グラムの実行を制御するのに使われるGDBのモードに依存します。*note
Multithreaded Debugging::を参照してください。


File: emacs.info,  Node: Stack Buffer,  Next: Other GDB Buffers,  Prev: Threads Buffer,  Up: GDB Graphical Interface

27.6.5.5 Stackバッファー
........................

GDB Stackバッファーは、“コールスタック(call stack)”を表示します。これは
、1行がデバッガーセッションでのネストされたサブルーチン呼び出し(“stack
frames: スタックフレーム”)にそれぞれ対応します。*note Backtraces:
(gdb)Backtrace.を参照してください。

   グラフィカルなディスプレーでは、選択されたスタックフレームは、フリン
ジの矢印で示されます。テキスト端末、またはフリンジが無効な場合、選択され
たスタックフレームは反転して表示されます。スタックフレームを選択するには
、ポイントをその行に移動して<RET> (‘gdb-frames-select’)とタイプするか、
それを‘Mouse-2’でクリックします。これを行うことにより、Localsバッファー
も更新されます (*note Other GDB Buffers::を参照してください)。


File: emacs.info,  Node: Other GDB Buffers,  Next: Watch Expressions,  Prev: Stack Buffer,  Up: GDB Graphical Interface

27.6.5.6 その他のGDBバッファー
..............................

Localsバッファー
     このバッファーは、カレントフレームのローカル変数の値を、簡単なデー
     タ型で表示します(*note Frame Info: (gdb)Frame Info.を参照してくださ
     い)。値を編集したいときは、そこで<RET>を押すか、‘Mouse-2’でクリック
     してください。

     配列と構造体については、その型だけが表示されます。GDB 6.4以降では、
     ポイント位置で<RET>をタイプ、または‘Mouse-2’でクリックすることによ
     り、ローカル変数の値を調べることができます。それより前のバージョン
     のGDBでは、型の説明(‘[struct/union]’または‘[array]’)にたいして、
     <RET>または‘Mouse-2’を使用します。*note Watch Expressions::を参照し
     てください。

Registersバッファー
     このバッファーは、レジスターに保持されている値を表示します(*note
     (gdb)Registers::を参照してください)。値を編集したいときは、そのレジ
     スターで<RET>を押すか、‘Mouse-2’をクリックします。GDB6.4以降では、
     最近変化したレジスター値は、‘font-lock-warning-face’で表示されます
     。

Assemblerバッファー
     assemblerバッファーは、カレントフレームをマシン語コードで表示します
     。矢印はカレント命令を指し、sourceバッファーのようにブレークポイン
     トのセットと削除ができます。ブレークポイントのアイコンも、フリンジ
     または余白に表示されます。

Memoryバッファー
     memoryバッファーは、プログラムのメモリーセクションを調べるためのバ
     ッファーです(*note Memory: (gdb)Memory.を参照してください)。ヘッダ
     ー行の適切な箇所を‘Mouse-1’でクリックすることにより、そのバッファー
     が表示するメモリーの開始アドレス、またはデータアイテムの数が変化し
     ます(または‘S’および‘N’を使用)。ヘッダー行を‘Mouse-3’でクリックする
     ことにより、データアイテムのフォーマット、またはユニットサイズのど
     ちらを表示するか選択します。

   ‘gdb-many-windows’が非‘nil’の場合、breakpointsバッファーとthreadsバッ
ファーがウィンドウを共有するように、localsバッファーとregistersバッファ
ーもウィンドウを共有します。一方から他方へ切り替えるには、ヘッダー行の関
連するボタンを‘Mouse-1’でクリックしてください。


File: emacs.info,  Node: Watch Expressions,  Next: Multithreaded Debugging,  Prev: Other GDB Buffers,  Up: GDB Graphical Interface

27.6.5.7 ウォッチ式
...................

プログラムを停止するたびに、変数がどのように変化するか見たいときは、ポイ
ントを変数名に移動して、ツールバーのウォッチアイコンをクリック
(‘gud-watch’)するか、‘C-x C-a C-w’とタイプします。プレフィクス引数を指定
した場合、変数名をミニバッファーで入力することができます。

   各ウォッチ式は、speedbarに表示されます(*note Speedbar::を参照してくだ
さい)。配列や、構造体、共有体のような複雑なデータ型はツリー形式で表示さ
れます。ツリーの子ノード、および単純なデータ型では、式の名前とその値が表
示され、speedbarフレームが選択されたときは型がツールチップで表示されます
。それより高いレベルでは名前、型、ポインターのアドレス値、そうでない場合
は名前と型だけが表示されます。ルート式では、それらがどこで定義されている
かを識別するために、ツールチップでフレームアドレスも表示されます

   複雑なデータ型を展開または折り畳むには、式の左のタグを‘Mouse-2’をクリ
ックするか<SPC>を押します。式の子にあたるデータの数が、変数
‘gdb-max-children’の値を超える場合、Emacsは式を展開する前に確認を求めま
す。

   複雑なウォッチ式を削除するには、speedbarのルート式にポイントを移動し
て、‘D’ (‘gdb-var-delete’)とタイプしてください。

   単純なデータ型の変数、または複雑なデータ型の単純な要素を編集するには
、speedbarのその箇所にポイントを移動して、<RET> (‘gdb-edit-value’)とタイ
プするか、値を‘Mouse-2’でクリックして、それを編集します。どちらの方法も
、ミニバッファーを使って新しい値を読み取ります。

   変数‘gdb-show-changed-values’を非‘nil’値(デフォルト)にセットした場合
、Emacsは最近変化した値を‘font-lock-warning-face’でハイライトし、スコー
プから外れた変数は目立たない‘shadow’フェイスで表示します。変数がスコープ
から外れた場合、値を変更することはできません。

   変数‘gdb-delete-out-of-scope’が非‘nil’(デフォルト)の場合、Emacsはスコ
ープから外れたときウォッチ式を自動的に削除します。この変数を‘nil’にして
おけば、同じ関数に再入したとき、新たにウォッチ式を作成しなくてよいので便
利かもしれません。

   変数‘gdb-use-colon-colon-notation’が非‘nil’の場合、Emacsは
‘FUNCTION::VARIABLE’というフォーマットを使います。これにより同じ変数名を
共有するウォッチ式を表示することができます。デフォルト値は‘nil’です。

   ウォッチ式の表示が更新されるたびに、自動的にspeedbarを前に表示するに
は、‘gdb-speedbar-auto-raise’を非‘nil’にセットします。これはEmacsフレー
ムを全画面表示にしてデバッグしているとき便利です。


File: emacs.info,  Node: Multithreaded Debugging,  Prev: Watch Expressions,  Up: GDB Graphical Interface

27.6.5.8 マルチスレッドのデバッグ
.................................

GDBの“all-stop mode”では、プログラムが停止すると、すべてのスレッドの実行
が停止します。同様に、プログラムを再開すると、すべてのスレッドが実行を開
始します。*note All-Stop Mode: (gdb)All-Stop Mode.を参照してください。マ
ルチスレッド化されたいくつかのターゲットにたいして、GDBはこれを超える操
作のためのモードをサポートします。これは“non-stop mode”と呼ばれ、他のス
レッドが自由に実行を継続している間に、デバッガーで停止したプログラムのス
レッドを調べることができます。*note Non-Stop Mode: (gdb)Non-Stop Mode.を
参照してください。GDBのバージョン7.0以前では、non-stop modeはサポートさ
れておらず、すべてのターゲットにたいしては機能しません。

   変数‘gdb-non-stop-setting’は、EmacsがGDBをall-stop modeとnon-stop
modeのどちらで実行するかを決定します。デフォルトは‘t’で、これは利用可能
な場合はnon-stop modeを使うことを意味します。値を‘nil’に変更した場合、ま
たはnon-stop modeが利用不可の場合、EmacsはGDBをall-stop modeで実行します
。この変数はEmacsがデバッグセッションを開始したときに効果をもちます。値
を変更した場合、アクティブなデバッグセッションを再起動する必要があります
。

   non-stop modeモードでスレッドが停止すると、通常Emacsはそのスレッドに
切り替えます。すでに選択したスレッドから停止した他のスレッドへの切り替え
を行わないようにするには、変数‘gdb-switch-when-another-stopped’を‘nil’に
変更してください。

   Emacsが停止したスレッドに切り替えるかどうかの決定は、そのスレッドが停
止した理由に依存します。変数‘gdb-switch-reasons’をカスタマイズすることに
より、スレッドの切り替えを行う停止理由を選択できます。

   変数‘gdb-stopped-functions’には、あるスレッドが停止したときに実行する
関数を指定できます。

   non-stop modeでは、GUDの実行制御コマンドのための異なるモードを切り替
えることができます。

“Non-stop/A”

     ‘gdb-gud-control-all-threads’が‘t’(デフォルト)の場合、中断および継
     続のためのコマンドはすべてのスレッドに適用されるので、
     ‘gud-stop-subjob’または‘gud-cont’の1コマンドで、すべてのスレッドを
     停止または継続できます。少なくとも1つのスレッドが停止している場合、
     ツールバーに‘Go’ボタンが表示されます。また、少なくとも1つのスレッド
     が実行中の場合、‘Stop’ボタンが表示されます。

“Non-stop/T”

     ‘gdb-gud-control-all-threads’が‘nil’の場合、カレントスレッドだけを
     停止または継続します。GUDツールバーの‘Go’および‘Stop’のボタンの表示
     は、カレントスレッドの状態に依存します。

   ‘gdb-gud-control-all-threads’のカレント値は、ツールバーまたは
‘GUD->GDB-MI’メニューで変更できます。

   ステップコマンドは常にカレントスレッドに適用されます。

   non-stop modeでは、スレッドを選択せずにスレッドを中断または継続できま
す。threadsバッファーで、ポイント位置のスレッドにたいして‘i’をタイプする
と中断、‘c’で継続、‘s’でステップ実行します。今後さらにそのようなコマンド
が追加されるかもしれません。

   スレッドを中断した場合、停止理由は‘signal received’になることに注意し
てください。この理由が‘gdb-switch-reasons’に含まれている場合(デフォルト
では含まれています)、Emacsはそのスレッドに切り替えます。


File: emacs.info,  Node: Executing Lisp,  Next: Lisp Libraries,  Prev: Debuggers,  Up: Building

27.7 Lisp式の実行
=================

Emacsには、Lispのいくつかの変種のためのメジャーモードがあります。これら
は他のプログラミング言語のモードと同じ編集コマンドを使用します(*note
Programs::を参照してください)。それに加えて、Lisp式を実行するための特別
なコマンドを提供します。

Emacs Lispモード
     Emacs Lispのソースファイルを編集するためのモードです。このモードは
     カレントのトップレベルのLisp式を評価する‘C-M-x’を定義します。*note
     Lisp Eval::を参照してください。

Lisp Interactionモード
     Emacs Lispとの対話的なセッションのためのモードです。このモードはポ
     イントの前の式を評価して、その値をバッファーに挿入する‘C-j’を定義し
     ます。*note Lisp Interaction::を参照してください。

Lispモード
     Emacs Lispではない、他のLispを実行するプログラムのソースファイルを
     編集するためのモードです。このモードは、カレントのトップレベルの式
     を外部のLispで評価する‘C-M-x’を定義します。*note External Lisp::を
     参照してください。

Inferior Lispモード
     Emacsのサブプロセス(または“inferior process: 下位プロセス”)として実
     行される外部Lispと、対話的にセッションするためのモードです。 *note
     External Lisp::を参照してください。

Schemeモード
     Lispモードと同様ですが、Schemeプログラムのためのモードです。

Inferior Schemeモード
     Inferior Lispモードと同様ですが、Schemeのためのモードです。


File: emacs.info,  Node: Lisp Libraries,  Next: Lisp Eval,  Prev: Executing Lisp,  Up: Building

27.8 EmacsのためのLispコードによるライブラリー
==============================================

Emacs Lispのコードは、慣習として‘.el’で終わる名前のファイルに保存されま
す。このようなファイルは、自動的にEmacs Lispモードでvisitされます。

   Emacs Lispのコードは、loadが速く省スペースで、実行も速いバイトコード
にコンパイルできます。慣習により、コンパイルされたEmacs Lispのコードは
‘.elc’で終わる名前の別のファイルに保存されます。たとえば、‘foo.el’をコン
パイルしたコードは‘foo.elc’になります。*note Byte Compilation:
(elisp)Byte Compilation.を参照してください。

   Emacs Lispファイルを“ロード(load)”するには、‘M-x load-file’とタイプし
ます。このコマンドはミニバッファーを使ってファイル名を読み取り、そのファ
イル内容をEmacs Lispコードとして実行します。最初にファイルをvisitしてお
く必要はありません。このコマンドは、既存のEmacsバッファーからではなく、
ディスクからファイルを直接読み込みます。

   Emacs Lispファイルが、Emacs Lispの“ロードパス(load path: 以下で定義
)”にインストールされている場合、‘M-x load-file’ではなく‘M-x
load-library’とタイプしてロードできます。‘M-x load-library’コマンドは、
ファイル名ではなく“ライブラリー名(library name)”の入力を求めます。これは
Emacs Lispのロードパスの各ディレクトリーを検索して、そのライブラリー名に
マッチするファイルを見つけようと試みます。ライブラリー名が‘FOO’の場合、
ファイル名‘FOO.elc’、‘FOO.el’、‘FOO’を見つけようと試みます。デフォルトの
動作では、最初に見つかったファイルをロードします。このコマンドは‘.el’よ
り‘.elc’を優先します。それはコンパイルされたファイルの方が、ロードと実行
が速いからです。‘LIB.el’が‘LIB.elc’より新しい場合、警告を発します。この
場合、誰かが‘.el’を変更したもののリコンパイルを忘れたようだが、ともかく
‘.elc’をロードする、という警告です(この振る舞いにより、編集が終わってお
らず、まだリコンパイルする準備ができていないEmacs Lispのソースファイルを
保存することができます)。しかしオプション‘load-prefer-newer’を非‘nil’値
にセットした場合、上記の手順ではなく、Emacsは新しいファイルのバージョン
をロードします。

   Emacs Lispプログラムは通常、‘load’関数を使用してEmacs Lispファイルを
ロードします。これは‘load-library’と似ていますが、より低レベルで追加の引
数を指定できます。*note (elisp)How Programs Do Loading::を参照してくださ
い。

   Emacs Lispのロードパスは、変数‘load-path’により指定されます。この変数
の値は、ディレクトリー名(文字列)のリストです。これらのディレクトリーは、
‘M-x load-library’コマンド、低レベルの‘load’関数、その他のEmacs Lispライ
ブラリーを探すEmacs関数により、指定された順に検索されます。‘load-path’の
リストの要素には、特別な値‘nil’も指定できます。これはカレントのデフォル
トディレクトリーを意味しますが、これを使うのは大抵間違っています(リスト
に‘nil’を含めたいと思うとき、大抵の場合は、本当に望んでいるのは‘M-x
load-file’を使用することです)。

   ‘load-path’のデフォルト値は、Emacs自身がLispコードを格納するディレク
トリーのリストです。他のディレクトリーに独自のライブラリーがある場合、ロ
ードパスにそのディレクトリーを追加できます。このマニュアルで説明されてい
る他の大半の変数とは異なり、‘load-path’はCustomizeインターフェース(*note
Easy Customization::を参照してください)を通じての変更はできません。しか
しinitファイルに以下のような行を記述して、ディレクトリーを追加できます
(*note Init File::を参照してください):

     (add-to-list 'load-path "/path/to/my/lisp/library")

   いくつかのコマンドは、“自動ロード(autoload)”されます。これらを実行す
るとき、Emacsは最初に関連するライブラリーを自動的にロードします。たとえ
ば‘M-x compile’コマンド(*note Compilation::を参照してください)は、自動ロ
ードされます。これを呼び出した場合、Emacsは最初に、自動的に‘compile’ライ
ブラリーをロードします。対照的にコマンド‘M-x recompile’は、自動ロードさ
れません。そのため、このコマンドは‘compile’ライブラリーをロードするまで
利用できません。

   自動的なロードは、自動ロードされたコマンドのドキュメントを探すとき
(*note Name Help::を参照してください)にも発生します。それは、ドキュメン
トがライブラリーの他の関数や変数を参照する場合です(ライブラリーのロード
により‘*Help*’バッファーのハイパーリンクが適切にセットアップされます)。
この機能を無効にするには、変数‘help-enable-auto-load’を‘nil’に変更してく
ださい。

   デフォルトではEmacsは、XEmacs —Emacsの変更されたバージョン — でコンパ
イルされたコンパイル済みのLispファイルのロードを拒絶します。なぜならそれ
はEmacsのクラッシュをさせるからです。これらのロードを試みる場合は、変数
‘load-dangerous-libraries’に‘t’をセットしてください。


File: emacs.info,  Node: Lisp Eval,  Next: Lisp Interaction,  Prev: Lisp Libraries,  Up: Building

27.9 Emacs Lisp式の評価
=======================

Emacs LispモードはEmacs Lispを編集するためのメジャーモードです。これのモ
ードコマンドは‘M-x emacs-lisp-mode’です。

   Emacsは、Emacs Lisp式を評価するためのコマンドをいくつか提供します。記
述しているEmacs Lispコードをテストするために、これらのコマンドをEmacs
Lispモードで使用できます。たとえば、関数を書き換えた後、以降の関数呼び出
しでそれを有効にするために、関数定義を評価します。これらのコマンドはグロ
ーバルに利用可能で、Emacs Lispモード以外でも使用できます。

‘M-:’
     1つのEmacs Lisp式をミニバッファーで読み取り、それを評価して、値をエ
     コーエリアに出力します(‘eval-expression’)。
‘C-x C-e’
     ポイントの前のEmacs Lisp式を評価して、値をエコーエリアに出力します
     (‘eval-last-sexp’)。
‘C-M-x’ (Emacs Lispモード)
‘M-x eval-defun’
     ポイントの後またはポイントを含むdefunを評価して、値をエコーエリアに
     出力します(‘eval-defun’)。
‘M-x eval-region’
     リージョンのすべてのEmacs Lisp式を評価します。
‘M-x eval-buffer’
     バッファーのすべてのEmacs Lisp式を評価します。

   ‘M-:’ (‘eval-expression’)は、ミニバッファーを使って式を読み取り、それ
を評価します(式を評価する前に、カレントバッファーは、式をタイプするため
のミニバッファーではなく、‘M-:’をタイプしたときカレントだったバッファー
に切り替わります)。

   コマンド‘C-x C-e’ (‘eval-last-sexp’)は、そのバッファーのポイントの前
にあるEmacs Lisp式を評価して、その値をエコーエリアに表示します。評価した
結果が整数のときは、他のフォーマット(8進、16進、文字)も一緒に値を表示し
ます。

   ‘M-:’および‘C-x C-e’にプレフィクス引数を与えた場合、値をエコーエリア
に表示するのではなく、カレントバッファーのポイント位置に値を挿入します。
プレフィクス引数が0の場合、整数出力は他のフォーマット(8進、16進、文字)と
一緒に挿入されます。プレフィクス引数は、‘eval-expression-print-level’お
よび‘eval-expression-print-length’にしたがった出力の省略も防ぎます(以下
参照)。

   ‘eval-defun’コマンドは、Emacs Lispモードでは‘C-M-x’にバインドされてい
ます。これはポイントを含む、またはポイントの後ろのトップレベルのLisp式を
評価して、値をエコーエリアに出力します。このコンテキストでは、トップレベ
ルの式は“defun”として参照されますが、実際の‘defun’(関数定義)である必要は
ありません。このコマンドは‘defvar’式を特別に扱います。通常、‘defvar’式を
評価しても、それが定義する変数がすでに値をもっている場合は、何も起こりま
せん。しかし、このコマンドは無条件に‘defvar’で指定された初期値に変数をリ
セットします。これはEmacs Lispプログラムをデバッグするとき便利です。式
‘defcustom’および‘defface’も同様に扱われます。このセクションで説明してい
る他のコマンドは、この特別な機能をもっていません。

   プレフィクス引数を指定すると、‘C-M-x’はEmacs LispデバッガーのEdebugの
ために関数定義をインストルメント(instrument: 処置)します。*note
Instrumenting for Edebug: (elisp)Instrumenting.を参照してください。

   コマンド‘M-x eval-region’は、リージョンのテキストを1つ以上のLisp式と
して解析して、それらを1つずつ評価します。‘M-x eval-buffer’も同様ですが、
これはバッファー全体を評価します。

   オプション‘eval-expression-print-level’および
‘eval-expression-print-length’は、評価コマンドが結果を出力する前に省略す
る、リストの最大の深さと長さを制御します。‘eval-expression’または
‘eval-last-sexp’にプレフィクス引数0を指定すると、リストはすべて出力され
ます。‘eval-expression-debug-on-error’は、これらのコマンドが使用されると
き、評価エラーによりデバッガーを呼び出すかを制御します、デフォルトは
‘t’です。


File: emacs.info,  Node: Lisp Interaction,  Next: External Lisp,  Prev: Lisp Eval,  Up: Building

27.10 Lisp Interactionバッファー
================================

Emacsを開始したとき、‘*scratch*’という名前のバッファーが含まれます、これ
はEmacs Lisp式の対話的な評価を提供します。このバッファーのメジャーモード
は、Lisp Interactionモードです。‘M-x lisp-interaction-mode’とタイプして
も、Lisp Interactionモードを有効にできます。

   ‘*scratch*’バッファー、およびその他のLisp Interactionモードのバッファ
ーでは、‘C-j’ (‘eval-print-last-sexp’)はポイントの前のLisp式を評価して、
値をポイント位置に挿入します。したがってバッファーに式をタイプするたび、
その後ろで‘C-j’をタイプすることにより、そのバッファーは式の評価とその値
を記録した写しになります。その他すべてのLisp Interactionモードのコマンド
は、Emacs Lispモードと同じです。

   起動時には、‘*scratch*’バッファーは、それが何かを説明するLispコメント
形式の短いメッセージを含んでいます。このメッセージは変数
‘initial-scratch-message’により制御され、値は文字列または‘nil’(メッセー
ジを抑止するという意味)です。

   Emacs Lisp式を対話的に評価する別の方法は、Inferior Emacs Lispモードを
使う方法です。これはEmacs Lisp式の評価にShellモード(*note Shell Mode::を
参照してください)に似たインターフェースを提供します。‘M-x ielm’とタイプ
することにより、このモードを使用する‘*ielm*’というバッファーが作成されま
す。詳細は、コマンドのドキュメントを参照してください。


File: emacs.info,  Node: External Lisp,  Prev: Lisp Interaction,  Up: Building

27.11 外部Lispの実行
====================

Lispモードは、Common Lispのような一般用途のためのLisp方言で記述されたプ
ログラムを記述するためのメジャーモードです。これのモードコマンドは‘M-x
lisp-mode’です。Emacsは名前が‘.l’、‘.lsp’、‘.lisp’で終わるファイルにたい
して、自動的にLispモードを使用します。

   外部LispセッションをEmacsのサブプロセス、または“下位プロセス(inferior
process)”として実行して、式を評価するために渡すことができます。外部
Lispセッションを開始するには、‘M-x run-lisp’とタイプします。これは
‘lisp’という名前のプログラムを実行して、‘*inferior-lisp*’という名前の
Emacsバッファーを通じて入出力を行うようにセットアップします。‘M-x
run-lisp’で実行されるLispプログラムの名前を変更するには、変数
‘inferior-lisp-program’を変更してください。

   ‘*lisp*’バッファーのためのメジャーモードはInferior Lispモードで、これ
はLispモードの性質とShellモード(*note Shell Mode::を参照してください)の
性質をあわせ持っています。Lispセッションに入力を送るには、‘*lisp*’バッフ
ァーの最後に移動して、入力をタイプしてから<RET>をタイプします。Lispセッ
ションからの端末出力は、自動的にそのバッファーに挿入されます。

   LispプログラムをLispモードで編集する場合、‘C-M-x’
(‘lisp-eval-defun’)とタイプして、Lispモードのバッファーから、‘M-x
run-lisp’で開始したLispセッションに式を送ることができます。送信される式
はポイント位置、またはポイントの後ろのトップレベルのLisp式です。結果とな
る値は通常どおり、‘*inferior-lisp*’バッファーに送られます。Lispモードで
の‘C-M-x’の効果は、それが評価されるEmacsに送られるのではなく、異なる
Lisp環境に送られる点を除けば、Emacs Lispモード(*note Lisp Eval::を参照し
てください)での効果とよく似ていることに注意してください。

   Schemeコードを編集して、式をSchemeサブプロセスに送る機能は、よく似て
います。Schemeソースファイルは、Schemeモードで編集されます。このモードは
‘M-x scheme-mode’で明示的に有効にできます。‘M-x run-scheme’とタイプする
ことにより、Schemeセッションを開始し、‘C-M-x’とタイプして式の送ることが
できます(Schemeと対話するためのバッファーは、‘*scheme*’という名前です)。


File: emacs.info,  Node: Maintaining,  Next: Abbrevs,  Prev: Building,  Up: Top

28 大きなプログラムの保守
*************************

このチャプターでは、大きなプログラムをメンテナンスするEmacsの機能を説明
します。Lispの大きなプログラムをメンテナンスしている場合は、ここで説明し
ている機能に加え、‘ERT’ (“Emacs Lisp Regression Testing”)ライブラリーも
便利だと思うかもしれません(*note ERT: (ert)Top.を参照してください)。

* Menu:

* Version Control::          バージョンコントロールシステムの使用。
* Change Log::               プログラムの変更履歴をメンテナンスする。
* Tags::                     1つのコマンドでプログラムの任意の関数に直接移動する。Tagsはそれがどのファイルにあるか記憶する。
* EDE::                      Emacsのための統合開発環境。
* Emerge:: 2つのバージョンのプログラムをマージする便利な方法。


File: emacs.info,  Node: Version Control,  Next: Change Log,  Up: Maintaining

28.1 バージョンコントロール
===========================

“バージョンコントロールシステム(version control system)”は、ソースファイ
ルの複数のバージョンを記録したり、それらのバージョンの作成日時などや、誰
が作成したか、何が変更されたかの説明などを記録できるプログラムのことです
。

   Emacsのバージョンコントロールのためのインターフェースは、“VC”と呼ばれ
ます。VCコマンドは、複数の異なるバージョンコントロールシステムで機能しま
す。現在のところ、GNU Arch、Bazaar、CVS、Git、Mercurial、Monotone、RCS、
SCCS/CSSC、Subversionがサポートされます。これらの中で、GNUプロジェクトの
ディストリビューションはCVS、Arch、RCS、Bazaarです。

   バージョン管理システムで生成されたファイルをvisitすると、自動的にVCが
有効になります。VCを無効にするには、カスタマイズ可能な変数
‘vc-handled-backends’を‘nil’をセットします (*note Customizing VC::を参照
してください)。

* Menu:

* Introduction to VC::       バージョンコントロールが機能する一般的な方法。
* VC Mode Line::             モードラインがバージョンコントロールの状態を表示する方法。
* Basic VC Editing::         バージョンコントロール下のファイルの編集方法。
* Log Buffer::               logエントリーバッファーで利用可能な機能。
* Registering::              バージョンコントロール下にファイルを置く。
* Old Revisions::            古いバージョンの調査と比較。
* VC Change Log::            VC Change Logの閲覧。
* VC Undo::                  コミット前後の変更の取り消し。
* VC Ignore::                バージョンコントロール下のファイルの無視。
* VC Directory Mode::        バージョンコントロールで管理されたファイルの一覧。
* Branches::                 開発における複数行。
* Miscellaneous VC:: その他のVCのさまざまなコマンドと機能。
* Customizing VC:: VCの動作を変更する変数。


File: emacs.info,  Node: Introduction to VC,  Next: VC Mode Line,  Up: Version Control

28.1.1 バージョンコントロールの紹介
-----------------------------------

VCは、Emacsからのバージョンコントロールシステムの使用、およびバージョン
コントロールの操作と編集をスムーズに統合します。VCは、多くのバージョンコ
ントロールシステムでの一般的な操作にたいする、統一されたインターフェース
を提供します。

   リポジトリー設定の変更など、非一般的または複雑なバージョンコントロー
ルの操作は、VCではサポートされません。そのようなタスクは、Emacsの外(たと
えばコマンドライン)で処理する必要があります。

   このセクションは、バージョンコントロールの一般的な概観を提供し、VCが
サポートするバージョンコントロールを説明します。すでに使いたいバージョン
コントロールシステムをよく知っている場合、このセクションはスキップできま
す。

* Menu:

* Why Version Control?::     問題が示すところを理解するには。
* Version Control Systems::  バックエンドシステムとしてサポートされるバージョンコントロール。
* VCS Concepts::             バージョンコントロールに関連する単語と概念。
* VCS Merging::              ファイルの衝突を処理する方法。
* VCS Changesets::           変更がグループ化される方法。
* VCS Repositories::         バージョンコントロールのリポジトリーが格納される場所。
* Types of Log File::        VCS logとChangeLogの違い。


File: emacs.info,  Node: Why Version Control?,  Next: Version Control Systems,  Up: Introduction to VC

28.1.1.1 問題の背景
...................

バージョンコントロールシステムは、3つの重要な能力を提供します。

   • “Reversibility(可逆性)”: ある変更が間違い、または間違えた考えにもと
     づくものだと気づいたときに、前の状態に戻す能力です。

   • “Concurrency(並列性)”: 多くの人が同じファイルコレクションを変更する
     とき、変更の衝突を検知して解決する能力です。

   • “History(履歴)”: それを変更した背後の意図を説明するコメントなど、履
     歴データをデータに付す能力です。1人で作業するプログラマーでさえ、変
     更履歴は記憶を助けるのに重要です。複数人のプロジェクトでは、開発者
     間のコミュニケーション形式として、とても重要です。


File: emacs.info,  Node: Version Control Systems,  Next: VCS Concepts,  Prev: Why Version Control?,  Up: Introduction to VC

28.1.1.2 サポートされるバージョンコントロールシステム
.....................................................

VCは現在のところ、多くの異なるバージョンコントロールで機能し、それらを
“バックエンド(back ends)”として参照します:

   • SCCSは、これまでに構築された一番最初のバージョンコントロールシステ
     ムで、ずっと以前に、もっと進んだものに取って代わられました。SCCSに
     ない特定の機能のためのVCコンポーネントは、それら自身により実装され
     ています。複数ブランチなど、その他のVC機能は単に利用不可です。
     SCCSはフリーではないので、これを避けることを推奨します。

   • CSSCはSCCSのフリーな置き換えです。何らかの理由により、もっと新しい
     、より良いデザインのバージョンコントロールシステムを使うことができ
     ないときだけ、CSSCを使うべきです。

   • RCSは、VCが最初に構築された頃の、フリーなバージョンコントロールシス
     テムです。これは比較的に初期のものです。これはネットワークを超えて
     使うことはできず、ファイルに個別のレベルで機能します。RCSでできるほ
     とんどのことは、VCを通じて行うことができます。

   • CVSは、フリーなバージョンコントロールシステムで、最近(2008年ごろ)ま
     ではフリーソフトウェアプロジェクトの大半で使われていました。最近で
     は、新しいシステムに徐々に置き換えられています。CVSではローカルまた
     はネットワーク越しの、複数ユーザーによる並列開発が可能です。新しい
     システムとは異なり、アトミックなコミットとファイルの移動・リネーム
     にたいするサポートがありません。VCはCVS下での基本的な編集操作をサポ
     ートします。

   • Subversion(svn)は、CVSと同じようにデザインされた、フリーなバージョ
     ンコントロールシステムですが、CVSのもつ問題はありません(たとえば、
     これはファイルセットのアトミックなコミット、ディレクトリーのバージ
     ョニング、シンボリックリンク、メタデータ、リネーム、コピー、削除を
     サポートします)。

   • GNU Archは、一番古い“分散化された(decentralized)”バージョンコントロ
     ールシステムです(他にMonotoneがあります)。分散化されたバージョンコ
     ントロールシステムの説明は、*note VCS Concepts::を参照してください
     。Bazaarを優先するために、もはや活発に開発されておらず、推奨されて
     いません。

   • Gitは、最初にLinus TorvaldsによりLinux(彼のkernel)の開発をサポート
     するために考案されました。VCは多くのGit操作をサポートしますが、その
     他のリポジトリーの同期などはコマンドラインを使わなければなりません
     。

   • Mercurial(hg)は、Gitに酷似した分散化されたバージョンコントロールシ
     ステムです。VCは、リポジトリーの同期操作を除いて、ほとんどの
     Mercurialコマンドをサポートします。

   • Bazaar(bzr)は、リポジトリーベースと分散化されたバージョニングの両方
     をサポートする、分散化されたバージョンコントロールシステムです。
     VCはBazaar下でのほとんどの基本的な編集操作をサポートします。


File: emacs.info,  Node: VCS Concepts,  Next: VCS Merging,  Prev: Version Control Systems,  Up: Introduction to VC

28.1.1.3 バージョンコントロールの概念
.....................................

ファイルがバージョンコントロールの配下にある時、それがバージョンコントロ
ールシステムに“登録されている(registered)”と言います。バージョンコントロ
ールシステムは、“リポジトリー(repository)”をもちます。これはファイルの現
在の状態、および古いバージョンから現在のバージョンを再構成するのに充分な
変更履歴の、両方を保存します。リポジトリーには、各ファイルに行われた変更
の説明である“ログエントリー(log entries)”など、その他の情報も含まれます
。

   実際に編集する、バージョンコントロールされたファイルのコピーのことを
、“作業ファイル(work file)”と呼びます。作業ファイルは、通常のファイルを
同じように変更できます。一連の変更を終えた後、その変更を“コミット
(commit)”または“チェックイン(check in)”します。これにより、その変更はロ
グエントリーの記述とともに、リポジトリーに記録されます。

   作業ファイルのディレクトリツリーを、“作業ツリー(working tree)”と呼び
ます。

   co８mmitするたびに、リポジトリーに新しい“リビジョン(revision)”が作成
されます。バージョンコントロールシステムは、過去のすべてのリビジョンと、
各リビジョンで行われた変更を記録します。各リビジョンには、“リビジョン
ID(revision ID)”により名前がつけられます。リビジョンIDのフォーマットは、
バージョンコントロールシステムに依存します。もっとも簡単なケースでは、リ
ビジョンIDは単なる整数です。

   これらの基本的な概念を超えるにつれ、各バージョンコントロールシステム
の違いの、3つの様相を理解する必要がでてくるでしょう。以降の3つのセクショ
ンで説明するように、各バージョンコントロールシステムには、ロックベース
(lock-based)とマージベース(merge-based)、ファイルベース(file-based)と変
更セットベース(changeset-based)、集中型(centralized)と分散型
(decentralized)の違いがあります。VCはこれらすべてのモードの操作を処理し
ますが、それらの違いを隠蔽することはできません。


File: emacs.info,  Node: VCS Merging,  Next: VCS Changesets,  Prev: VCS Concepts,  Up: Introduction to VC

28.1.1.4 バージョンコントロールにおけるマージベースとロックベース
.................................................................

バージョンコントロールシステムは通常、同じファイルを変更したい複数ユーザ
ーを調整するために、何らかのメカニズムをもちます。これを行うには2つの方
法 — マージとロック — があります。

   マージを使うバージョンコントロールシステムでは、各ユーザーはいつでも
作業ファイルを変更します。バージョンコントロールシステムは、コミットされ
ていない変更を含むユーザーの作業ファイルを、他のユーザーによりコミットさ
れた最新の変更とマージします。

   古いバージョンコントロールシステムは、かわりに“ロック(locking)”を使い
ます。この場合、作業ファイルは通常は読み取り専用です。ファイルを編集する
には、それを“ロック”することにより書き込み可能にできるか、バージョンコン
トロールシステムに尋ねます。ある時点で、そのファイルをロックできるユーザ
ーは1人だけです。この手順は、通常のファイルの同時編集をEmacsが検知する方
法と類似しているようですが、異なります(*note Interlocking::を参照してく
ださい)。変更をコミットすると、ファイルはアンロック(unlocks)され、作業フ
ァイルは再び読み取り専用になります。他のユーザーは、変更するためにそのフ
ァイルをロックすることができます。

   ロックおよびマージの両方のシステムは、複数ユーザーが同じときに同じフ
ァイルの変更を試みたときに問題が発生し得ます。ロックを使うシステムには、
“ロックの衝突(lock conflicts)”があります。あるユーザーはファイルのチェッ
クアウトを試みますが、それがすでにロックされている場合はロックできません
。マージを使うシステムには、“マージの衝突(merge conflicts)”があります。
これはファイルに行った変更をコミットするとき、それが後からチェックアウト
した他の誰かによる変更のコミットと衝突するときに発生します。どちらの衝突
も、人間の判断と意思疎通により解決する必要があります。経験から、開発者に
取っての利便性と、実際に発生する衝突の重大性と数を最小にするという両方の
点で、マージはロックに優ります。

   SCCSは常にロックを使います。RCSはデフォルトではロックベースですが、マ
ージスタイルで処理するように指示できます。CVSとSubversionはデフォルトで
はマージベースですが、ロックモードで処理するように指示できます。GNU
Arch、Git、Mercurialのような分散型のバージョンコントロールシステムは、マ
ージベースだけです。

   VCはロックとマージの両方のバージョンコントロールをサポートします。
“commit(コミット)”と“update(更新)”という用語は、新しいバージョンコントロ
ールシステムで使用されます。古いロックベースのシステムでは、“check in(チ
ェックイン)”と“check out(チェックアウト)”という用語が使用されます。VCは
これらの違いをできる限り隠蔽します。


File: emacs.info,  Node: VCS Changesets,  Next: VCS Repositories,  Prev: VCS Merging,  Up: Introduction to VC

28.1.1.5 バージョンコントロールに置ける変更セットベースとファイルベース
.......................................................................

SCCS、RCS、CVS、およびその他の初期のバージョンコントロールシステムでは、
バージョンコントロールの操作は“ファイルベース(file-based)”です。各ファイ
ルは、他のすべてのファイルとは別に、ファイル自身のコメントとリビジョン履
歴をもちます。Subversionで始まる新しいシステムは、“変更セットベース
(changeset-based)”です。コミットは複数ファイルにたいする変更を含むときが
あり、一連の変更全体を1つの単位として扱います。変更にたいするコメントは
1つのファイルではなく、変更セットに属します。

   変更セットベースのバージョンコントロールは、ファイルベースのバージョ
ンコントロールより、柔軟で強力です。通常、複数ファイルの変更を元に戻す必
要がある時、それを簡単に識別してすべてを削除できます。


File: emacs.info,  Node: VCS Repositories,  Next: Types of Log File,  Prev: VCS Changesets,  Up: Introduction to VC

28.1.1.6 リポジトリーにおける分散型と集中型
...........................................

初期のバージョンコントロールシステムは、“集中型(centralized)”モデルでデ
ザインされていて、各プロジェクトはすべての開発者が使用するただ1つのリポ
ジトリーをもちます。SCCS、RCS、CVS、Subversionはこの種のモデルを共有しま
す。このモデルの欠点の1つは、リポジトリーが信頼性と効率の要衝となること
です。

   GNU Archは、“分配型(distributed)”または“分散型(decentralized)”のバー
ジョンコントロールの先駆で、後にGit、Mercurial、Bazaarで実装されました。
プロジェクトは複数の異なるリポジトリーをもつことができ、これらのシステム
はリポジトリー間で変更履歴を調停する、ある種のスーパーマージをサポートし
ます。開発者ごとに1つのリポジトリーがあり、リポジトリーのマージがコミッ
ト操作を代行します。

   VCは個人の作業ファイルと、リポジトリーとの間で行われる通信を管理する
手助けをします。VCは、リポジトリーが唯一のマスターなのか、それともネット
ワークのピアーのレポジトリーの1つなのかは関知しません。


File: emacs.info,  Node: Types of Log File,  Prev: VCS Repositories,  Up: Introduction to VC

28.1.1.7 ログファイルのタイプ
.............................

バージョンコントロールシステムを使うプロジェクトは、変更にたいする2つの
タイプのログをもつことができます。1つはバージョンコントロールシステムで
保守されるログです。変更をコミットするたびに、変更にたいする“ログエント
リー(log entry)”を入力します(*note Log Buffer::を参照してください)。これ
は“バージョンコントロールログ(version control log)”と呼ばれます。

   もう1つの種類のログは、‘ChangeLog’です(*note Change Log::を参照してく
ださい)。これはプログラムの大きな部分(通常は1つのディレクトリーと、その
サブディレクトリー)にたいする変更の記録を、年代順に記録します。小さなプ
ログラムは、1つの‘ChangeLog’を使用するでしょう。大きなプログラムは、主要
なディレクトリーごとに‘ChangeLog’をもつかもしれません。*note Change
Log::を参照してください。プログラマーは、バージョンコントロールシステム
のずっと前からChangeLogを使ってきました。

   変更セットベースのバージョンシステムは、通常システム全体にたいして変
更セットベースの修正ログを保守します。これはChangeLogを冗長なものにしま
す。ChangeLogを残す利点の1つは、他のディレクトリーとは別に、1つのディレ
クトリーの履歴トランザクションが見れるのは便利なときがあるからです。他の
利点として、多くのバージョンコントロールシステムはコミットログを特定でき
ないからです。

   バージョンコントロールで管理されるプロジェクトは、バージョンコントロ
ールログだけを使用するか、両方の種類のログを使用します。あるファイルにた
いしては1つのログを使い、他のファイルにたいしては別の方法を使うこともで
きます。プロジェクトごとに、したがうべきポリシーがあります。

   両方を使うというポリシーの場合は通常、変更にたいして1度だけエントリー
を書いて、それを両方のログに書き込みたいと思うでしょう。‘ChangeLog’にエ
ントリーを記述して、変更をコミットするとき‘C-c C-a’でログバッファーにコ
ピーできます。または変更をコミットするときログバッファーにエントリーを記
述して、後で‘C-x v a’コマンドでそれを‘ChangeLog’にコピーできます (*note
Change Logs and VC::を参照してください)。


File: emacs.info,  Node: VC Mode Line,  Next: Basic VC Editing,  Prev: Introduction to VC,  Up: Version Control

28.1.2 バージョンコントロールとモードライン
-------------------------------------------

バージョンコントロール配下のファイルをvisitしたとき、Emacsはモードライン
にそれを示します。たとえば‘Bzr-1223’と表示された場合、そのファイルに
Bazaarが使用され、カレントのリビジョンIDが1223であることを示します。

   バックエンド名とリビジョンIDの間の文字は、作業ファイルの“バージョンコ
ントロール状態(version control status)”を示します。マージベースのバージ
ョンコントロールシステムでは、文字‘-’は作業ファイルが変更されていないこ
とを示し、文字‘:’は作業ファイルが変更されていることを示します。文字‘!’は
最新のマージ処理の結果により、そのファイルに衝突が含まれていることを示す
か(*note Merging::を参照してください)、そのファイルがバージョンコントロ
ールから削除されたことを示します。最後に、文字‘?’は、そのファイルがバー
ジョンコントロールの配下にあるが、作業ツリーにないことを示します。

   ロックベースのシステムでは、‘-’はファイルがロックされていないことを示
し、‘:’はファイルが他のユーザー(たとえば‘jim’)にロックされていることを示
し、‘RCS:jim:1.3’のように表示されます。‘@’は、そのファイルがローカルに追
加されたが、まだマスターリポジトリーにコミットされていないことを示します
。

   グラフィカルなディスプレーでは、モードラインのインジケーターの上にマ
ウスを移動すると、“ツールチップ”が表示され、それにはバージョンコントロー
ル状態の、より多くの説明が表示されます。インジケーターを‘Mouse-1’でクリ
ックすると、メニューバーの‘Tools / Version Control’と同じVCコマンドがの
メニューがポップアップします。

   Auto Revertモード(*note Reverting::を参照してください)がバージョンコ
ントロール配下のバッファーをリバートするとき、これはモードラインのバージ
ョンコントロール情報を更新します。しかし、Auto Revertモードは、作業ファ
イルの変更をともなわない、カレントのEmacsセッションの外でのバージョンコ
ントロール状態の変化の情報は、正しく更新しないかもしれません。
‘auto-revert-check-vc-info’を‘t’にセットすると、Auto Revertモードは、作
業ファイル自身を変更していなくても、‘auto-revert-interval’秒ごとにバージ
ョンコントロール状態の情報を更新します。CPU使用率はバージョンコントロー
ルシステムに依存しますが、通常はそれほど高価な処理ではありません。


File: emacs.info,  Node: Basic VC Editing,  Next: Log Buffer,  Prev: VC Mode Line,  Up: Version Control

28.1.3 バージョンコントロール下での基本的な編集
-----------------------------------------------

ほとんどのVCコマンドは、“VCファイルセット(VC filesets)”にたいして処理を
行います。VCファイルセットは、VC操作が機能する1つ以上のファイルのコレク
ションです。バージョンコントロールされたファイルをvisitしているバッファ
ーでVCコマンドをタイプすると、VCファイルセットは単にそのファイル1つだけ
になります。VC Directoryバッファーで、いくつかのファイルをマークしている
ときにVCコマンドをタイプしたときは、VCファイルセットはマークされたファイ
ルです(*note VC Directory Mode::を参照してください)。

   現代的な変更セットベースのバージョンコントロールシステム(*note VCS
Changesets::を参照してください)では、VCコマンドは複数ファイルからなる
VCファイルセットを1つのグループとして扱います。たとえば複数ファイルから
なるVCファイルセットをコミットすると、それらすべてのファイルにたいする変
更を含む、1つのリビジョンが生成されます。CVSのような古いファイルベースの
バージョンコントロールシステムでは、複数ファイルからなるVCファイルセット
の各ファイルは個別に処理されます。たとえば、コミットにより、変更されたフ
ァイル後とに1つのリビジョンが生成されます。

‘C-x v v’
     カレントVCファイルセットにたいして、次の適切なバージョンコントロー
     ル操作を処理します。

   重要なVCコマンド‘C-x v v’ (‘vc-next-action’)は多目的なもので、カレン
トのVCファイルセットにたいして、“もっとも適切”な操作を処理します。このコ
マンドは、それをバージョンコントロールシステムに登録するか、コミットする
か、ロックを外すか、変更をマージします。正確な動作の詳細は、以下のサブセ
クションで説明します。‘C-x v v’は、ファイルをvisitしているバッファーと、
VC Directoryバッファーの両方で使うことができます。

   VCファイルセットは、ファイルを閲覧したりvisitするためのグループ機能と
して使用される、“名前付のファイルセット(named filesets)”とは別の物だとい
うことに注意してください(*note Filesets::を参照してください)。名前付のフ
ァイルセットとは異なり、VCファイルセットは名前をもたず、セッションをまた
いで持続しません。

* Menu:

* VC With A Merging VCS::    ロックしない:
                               CVSのデフォルトモード。
* VC With A Locking VCS::    RCSのデフォルトモード、SCCS、オプションでCVS。
* Advanced C-x v v::         プレフィクス引数で利用可能な上級機能。


File: emacs.info,  Node: VC With A Merging VCS,  Next: VC With A Locking VCS,  Up: Basic VC Editing

28.1.3.1 マージでの基本的なバージョンコントロール
.................................................

マージベースのバージョンコントロールシステム(たとえばもっとも現代的な方
法の1つ。*note VCS Merging::を参照してください)では、‘C-x v v’は以下のこ
とを行います:

   • VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョン
     コントロール状態と矛盾する場合、エラーをシグナルします(しかしファイ
     ルセットには、“新しく追加された”ファイルと、“変更された”ファイルを
     含むことができることに注意してください。*note Registering::を参照し
     てください)。

   • VCファイルセットに、バージョンコントロールシステムに登録されたファ
     イルがない場合、VCファイルセットを登録(たとえばバージョンコントロー
     ルの配下に置く)します。*note Registering::を参照してください。
     Emacsが登録すべきシステムを見つけられない場合、リポジトリータイプの
     入力を求め、新しいリポジトリーを作成して、VCファイルセットをそれに
     登録します。

   • VCファイルセットの、すべての作業ファイルが変更されていない場合は、
     何もしません。

   • VCファイルセットの各作業ファイルが変更されている場合、変更をコミッ
     トします。これを行うには、Emacsが‘*vc-log*’バッファーをポップアップ
     するので、新しいリビジョンのログエントリーをタイプしてから、‘C-c
     C-c’でコミットします。*note Log Buffer::を参照してください。

     共有リポジトリーにコミットする場合、最後に更新したときからリポジト
     リーが変更されているときは、コミットが失敗するでしょう。このような
     場合、再試行する前に更新をしなければなりません。分散型のバージョン
     コントロールシステムでは、‘C-x v +’(*note VC Pull::を参照してくださ
     い)、またh‘C-x v m’を使用します(*note Merging::を参照してください
     )。集中型のバージョンコントロールシステムでは、リポジトリーに変更を
     マージするために、再度‘C-x v v’とタイプしてください。

   • 最後に、集中型のバージョンコントロールシステムでは、VCファイルセッ
     トの各ファイルが最新かチェックします。リポジトリーで変更されたファ
     イルがある場合、更新を提案します。

   これらのルールは、変更はリポジトリーから自動的にマージされない点をの
ぞき、RCSを“非ロック”モードで使用している場合も適用されます。あなたがフ
ァイルの編集を始めた後に、他のユーザーが同じファイルをコミットした場合、
何の情報も与えられません。あなたのリビジョンをコミットしたとき、彼の変更
は失われます(しかし、それはリポジトリーには残るので、決定的に失われるわ
けではありません)。したがって、変更をコミットする前に、カレントリビジョ
ンが変更されていないことを調べなければなりません。それに加えて、このモー
ドでもRCSでロックすることが可能です。変更されていないファイルでの‘C-x v
v’は、RCSの通常のロックモードのようにそのファイルをロックします。(*note
VC With A Locking VCS::を参照してください)。


File: emacs.info,  Node: VC With A Locking VCS,  Next: Advanced C-x v v,  Prev: VC With A Merging VCS,  Up: Basic VC Editing

28.1.3.2 ロックでの基本的なバージョンコントロール
.................................................

ロックベースのバージョンコントロールシステム(SCCSやRCSのデフォルトモード
など)では、‘C-x v v’は以下のことを行います:

   • VCファイルセットに1つ以上のファイルがあり、そのファイルがバージョン
     コントロール状態と矛盾する場合、エラーをシグナルします。

   • VCファイルセットに、バージョンコントロールシステムに登録されたファ
     イルがない場合、VCファイルセットを登録します。*note Registering::を
     参照してください。Emacsが登録すべきシステムを見つけられない場合、リ
     ポジトリータイプの入力を求め、新しいリポジトリーを作成して、VCファ
     イルセットをそれに登録します。

   • 各ファイルが登録されていてロックされていなければ、それを書き込み可
     能にするためにロックして、編集を開始できるようにします。

   • 各ファイルのロックを獲得していて、それらが変更を含む場合、その変更
     をコミットします。これを行うことにより、Emacsは‘*vc-log*’バッファー
     をポップアップするので、新しいリビジョンのログエントリーをタイプし
     てから、C-c C-cでコミットします(*note Log Buffer::を参照してくださ
     い)。

   • 各ファイルのロックをすでに獲得していて、変更がない場合、ファイルを
     再び読み取り専用にするために、ロックを開放します。

   • 各ファイルが他のユーザーによりロックされている場合、“ロックを横取り
     する(steal the lock)”か、確認を求めます。これにyesと応えると、あな
     たがロックを獲得して、その前にファイルをロックしていたユーザーに、
     警告メッセージが送られます。

   このルールは、CVSがロックの横取りをサポートしない点をのぞき、CVSをロ
ックモードで使用している場合も適用されます。


File: emacs.info,  Node: Advanced C-x v v,  Prev: VC With A Locking VCS,  Up: Basic VC Editing

28.1.3.3 ‘C-x v v’の高度な制御
..............................

‘vc-next-action’にプレフィクス引数を与えた場合(‘C-u C-x v v’)、論理的に
次のバージョンコントロール操作を処理する点に変わりはありませんが、どのよ
うに操作を行うかを正確に指定するために、追加の引数を指定できるようになり
ます。

   • バージョンコントロールシステムの名前を指定できます。これは、ファイ
     ルセットが複数のバージョンコントロールシステムで管理されていて、
     Emacsが正しいものを検知するのに失敗するとき便利です。

   • そうでない場合で、CVSかRCSを使用しているときは、リビジョンIDを指定
     できます。

     ファイルセットが変更(またはロック)されている場合、Emacsは指定したリ
     ビジョンIDでそれをコミットします。適切なリビジョンIDを与えることに
     より、新しいブランチを作成できます(*note Branches::を参照してくださ
     い)。

     ファイルセットが変更(またはロック)されていない場合、これは指定した
     リビジョンを作業ツリーにチェックインします。リビジョンIDまたはブラ
     ンチIDを与えることにより、他のブランチのリビジョンを指定できます
     (*note Switching Branches::を参照してください)。空の引数(例: ‘C-u
     C-x v v <RET>’)は、カレントブランチの最新のリビジョン(“head”)をチェ
     ックアウトします。

     これは、分散型のバージョンコントロールシステムではエラーをシグナル
     します。これらのシステムでは、独自のリビジョンIDは指定できず、個別
     のファイルを“チェックアウト”するという概念も使いません。


File: emacs.info,  Node: Log Buffer,  Next: Registering,  Prev: Basic VC Editing,  Up: Version Control

28.1.4 Log Entryバッファーの機能
--------------------------------

VCに変更のコミットを指示したとき、‘*vc-log*’という名前のバッファーがポッ
プアップします。このバッファーには、行った変更を説明する“ログエントリー
(log entry)”を書き込みます。書き込んだら‘C-c C-c’ (‘log-edit-done’)とタ
イプして, そのバッファーを抜けて、ログエントリーとともに変更をコミットし
ます。

   ‘*vc-log*’バッファーのためのメジャーモードはLog Editモードで、これは
Textモードの変種です(*note Text Mode::を参照してください)。Log Editモー
ドに入ると、Emacsはフック‘text-mode-hook’および‘vc-log-mode-hook’を実行
します(*note Hooks::を参照してください)。

   ‘*vc-log*’バッファーでは、１行以上の“ヘッダー行(header lines)”を記入
できます。これにはバージョンコントロールシステムにより提供される、追加の
情報を指定します。各ヘッダー行は、そのバッファーの最初の1行を占めなけれ
ばなりません。ヘッダー行でない最初の行は、ログエントリーの開始として扱わ
れます。たとえば以下のヘッダー行は、その変更が他の開発者によるものだとい
うことを示します:

     Author: J. R. Hacker <jrh@example.com>

‘Author’ヘッダーとは別に、Emacsは‘Date’ヘッダー(コミット日時を手入力で指
定します)、‘Fixes’ヘッダー(変更によるバグフィクスへの参照)を認識します。
すべてのバージョンコントロールシステムが、すべてのヘッダーを認識するわけ
ではありません。Bazaarは3つのヘッダーすべてを認識し、Git、Mercurial、
Monotoneは‘Author’と‘Date’だけを認識します。そのシステムでサポートされて
いないヘッダーを指定した場合、それはログエントリーの一部として扱われます
。

   ‘*vc-log*’バッファーにいる間は、“カレントVCファイルセット(current VC
fileset)”とは、‘C-c C-c’とタイプすることによりコミットされるファイルセッ
トだと考えられます。そのVCファイルセットのファイル一覧を閲覧するには、
‘C-c C-f’ (‘log-edit-show-files’)とタイプします。そのVCファイルセットと
、編集を開始したバージョンとのdiffを閲覧するには、‘C-c C-d’
(‘log-edit-show-diff’)とタイプしてください。

   VCファイルセットが1つ以上の‘ChangeLog’(*note Change Log::を参照してく
ださい)ファイルを含む場合、‘C-c C-a’ (‘log-edit-insert-changelog’)とタイ
プすると、関連するエントリーを、‘*vc-log*’バッファーに引用します。各
‘ChangeLog’ファイルの一番上のアイテムが、今日の日付でユーザー名があなた
の場合、このコマンドはコミットされるファイルにマッチするエントリーのアイ
テムを検索して、それを挿入します。 CVSまたはRCSを使用している場合は、反
対のこと — Log EditバッファーからChangeLogエントリーを生成 — を行います
。*note Change Logs and VC::を参照してください。

   コミットを中止するには、そのバッファーで単に‘C-c C-c’を_タイプしない
_で、バッファーを切り替えて他の編集を行うことができます。他のコミットを
試みなければ、編集していたエントリーは‘*vc-log*’に残っているので、後でそ
のバッファーに戻ってコミットを完了できます。

   コミットコメントをコピーするために、以前のログエントリーの履歴を閲覧
することもできます。これは、似たようなコメントで複数のコミットを行いたい
とき便利です。これを行うコマンド‘M-n’、‘M-p’、‘M-s’、‘M-r’は、これらがミ
ニバッファーの外で使用される点を除けば、ミニバッファーのヒストリーコマン
ド(*note Minibuffer History::を参照してください)と同様です。


File: emacs.info,  Node: Registering,  Next: Old Revisions,  Prev: Log Buffer,  Up: Version Control

28.1.5 バージョンコントロールへのファイルの登録
-----------------------------------------------

‘C-x v i’
     visitしているファイルを、バージョンコントロールに登録します。

   コマンド‘C-x v i’ (‘vc-register’)は、カレントVCファイルセットの各ファ
イルを、バージョンコントロールの配下に置きます。これは登録されていない
VCファイルセットにたいして、‘C-x v v’が行う動作と基本的に同じですが、
VCファイルセットがすでに登録されているとき(*note Basic VC Editing::を参
照してください)、‘C-x v v’は他の操作を処理しますが、‘C-x v i’はエラーを
シグナルする、という点が異なります。

   ファイルを登録するために、Emacsはバージョンコントロールシステムを選択
しなければなりません。複数ファイルのVCファイルセットにたいしては、VC
Directoryバッファーが使用するシステムを指定します(*note VC Directory
Mode::を参照してください)。VCファイルセットのファイルが1つで、そのファイ
ルのディレクトリーがすでにバージョンコントロールシステムに登録されたファ
イルを含むか、そのディレクトリーがバージョンコントロールシステムにより制
御される作業ツリーの一部の場合、Emacsはそのシステムを選択します。複数の
バージョンコントロールシステムが当てはまる場合、Emacsは変数
‘vc-handled-backends’に最初に表れるシステムを使用します(*note
Customizing VC::)。 Emacsがファイルを登録するバージョンコントロールシス
テムを見つけられなかった場合、リポジトリータイプの入力を求め、新しいリポ
ジトリーを作成して、そのリポジトリーにファイルを登録します。

   ほとんどのバージョンコントロールシステムでは、‘C-x v i’または‘C-x v
v’でファイルを登録することにより、それを“作業ツリー(working tree)”に追加
しますが、リポジトリーには追加しません。そのようなファイルは、VC
Directoryバッファーでは‘added’とラベル付けされ、モードラインのリビジョン
IDには‘@@’が表示されます。リポジトリーにたいして登録を有効にするには、コ
ミットを行わなければなりません(*note Basic VC Editing::を参照してくださ
い)。1つのコミットに、ファイルの追加と、既存ファイルの編集の両方を含むこ
とができるのに注意してください。

   ロックベースのバージョンコントロールシステム(*note VCS Merging::を参
照してください)では、ファイルの登録により、ファイルはロックされていない
読み取り専用の状態に留まります。編集を開始するには、‘C-x v v’とタイプし
ます。


File: emacs.info,  Node: Old Revisions,  Next: VC Change Log,  Prev: Registering,  Up: Version Control

28.1.6 古いリビジョンの調査と比較
---------------------------------

‘C-x v =’
     カレントVCファイルセットの作業ファイルと、編集を開始したバージョン
     を比較します(‘vc-diff’)。プレフィクス引数を指定した場合、カレント
     VCファイルセットの2つのリビジョンの入力を求め、それらを比較します。
     このコマンドをDiredバッファーから呼び出すこともできます(*note
     Dired::を参照してください)。

‘M-x vc-ediff’
     ‘C-x v =’と同様ですが、Ediffを使用します。*note Ediff: (ediff)Top.を
     参照してください。

‘C-x v D’
     編集を開始したリビジョンの、作業ツリー全体を比較します
     (‘vc-root-diff’)。プレフィクス引数を指定した場合、2つのリビジョンの
     入力を求め、それらのツリーを比較します。

‘C-x v ~’
     カレントファイルのリビジョンの入力を求め、それを別のバッファーで
     visitします(‘vc-revision-other-window’)。

‘C-x v g’
     カレントファイルの、注釈付きのバージョンを表示します。各行には、そ
     の行が変更された最新のリビジョンが表示されます(‘vc-annotate’)。

   ‘C-x v =’ (‘vc-diff’)は、“diff”を表示します。これはカレントVCファイル
セットの各作業ファイルを、編集を開始したときのバージョンと比較します。
diffは別のウィンドウに、‘*vc-diff*’という名前のDiff modeモードのバッファ
ー(*note Diff Mode::を参照してください)で表示されます。このバッファーで
は、通常のDiffモードコマンドが利用可能です。特に‘g’ (‘revert-buffer’)コ
マンドは、ファイル比較を再び行い、新しいdiffを生成します。

   カレントVCファイルセットの、任意の2つのリビジョンを比較するには、‘C-u
C-x v =’のようにプレフィクス引数を指定して、‘vc-diff’を呼び出します。こ
れは2つのリビジョンID(*note VCS Concepts::を参照してください)の入力を求
め、ファイルセットのそれらのバージョンの間のdiffを表示します。このコマン
ドは、バージョンコントロールシステムが変更セットベースではなくファイルベ
ースの場合(たとえばCVS)に、複数ファイルのVCファイルセットにたいして確実
に動作しません。なぜなら同じリビジョンIDをもつ異なるファイル同士を、意味
のある方法で関連させることができないからです。

   リビジョンIDではなく、他のフォーマットでリビジョンを指定するバージョ
ンコントロールシステムもいくつかあります。たとえばBazaarでは、‘C-u C-x v
=’(および関連するコマンド)に‘date:yesterday’と入力でき、これは昨日以降コ
ミットされた最初のリビジョンを指定します。詳細については、バージョンコン
トロールシステムのドキュメントを参照してください。

   Diredバッファー(*note Dired::を参照してください)で‘C-x v =’または‘C-u
C-x v =’を呼び出すと、カレント行にリストされたファイルが、カレントVCファ
イルセットとして扱われます。

   ‘M-x vc-ediff’は、‘C-x v =’と同じように機能しますが、Ediffセッション
を使用します。*note Ediff: (ediff)Top.を参照してください。

   ‘C-x v D’ (‘vc-root-diff’)は、‘C-x v =’と似ていますが、カレント作業ツ
リー全体の変更を表示します(たとえばカレントVCファイルセットを含む作業ツ
リー)。このコマンドをDiredバッファーから呼び出すと、そのディレクトリーを
含む作業ツリーに適用されます。

   ‘C-x v =’および‘C-x v D’が、diffを生成するために使用する‘diff’オプシ
ョンをカスタマイズできます。オプションには、変数
‘vc-BACKEND-diff-switches’、‘vc-diff-switches’、‘diff-switches’(*note
Comparing Files::)の順に、最初の非‘nil’の値が使用されます。ここで
BACKENDは、関連するバージョンコントロールシステムで、たとえばBazaarの場
合は‘bzr’です。‘nil’は順番に次の変数をチェックすることを意味するので、ス
イッチを指定しない場合は最初の2つの値を‘t’にします。ほとんどの
‘vc-BACKEND-diff-switches’変数のデフォルトは‘nil’ですが、いくつかの
backendのデフォルトは‘t’です。Subversionのように、これらのバージョンコン
トロールシステムの‘diff’実装は、一般的なdiffオプションを受け付けません。

   ファイルの古いバージョンを直接調べるには、作業ファイルをvisitして、
‘C-x v ~ REVISION <RET>’ (‘vc-revision-other-window’)とタイプします。こ
れはREVISIONに対応するバージョンのファイルを取得して、それを
‘FILENAME.~REVISION~’に保存してから、別のウィンドウでvisitします。

   多くのバージョンコントロールシステムでは、‘C-x v g’ (‘vc-annotate’)と
タイプして、行ごとにリビジョン情報の“注釈付き(annotated)”でファイルを閲
覧できます。これは新しいバッファー(“annotateバッファー”)を作成して、各行
に古さを示すカラーをつけて、ファイルのテキストを表示します。赤いテキスト
は新しく、古いものは青、その中間色は中間のバージョンを示します。デフォル
トでは、一番古い変更を青、一番新しい変更を赤で、すべてのバージョンレンジ
にカラーをスケーリングします。

   このコマンドにプレフィクス引数を指定した場合、Emacsはミニバッファーを
使って、表示および注釈つけする(カレントファイル内容のかわりの)リビジョン
と、カラーレンジがカバーすべきタイムスパンの、2つの引数を読み取ります。

   annotateバッファーでは、‘VC-Annotate’メニューから、これら、または他の
カラースケールオプションが利用可能です。このバッファーでは、過去のリビジ
ョンの注釈の表示、diffの閲覧、ログエントリーの閲覧を行うために、以下のキ
ーを使うこともできます:

‘p’
     前のリビジョン(たとえば現在の注釈付きのリビジョンの1つ前のリビジョ
     ン)に注釈を付けます。数引数は繰り返し回数となるので、‘C-u 10 p’は
     10個前のリビジョンに注釈を付けます。

‘n’
     次のリビジョン(たとえば現在の注釈付きのリビジョンの1つ後のリビジョ
     ン)に注釈を付けます。数引数は繰り返し回数です。

‘j’
     カレント行に示されたリビジョンに解釈を付けます。

‘a’
     カレント行に示されたリビジョンの、1つ前のリビジョンに注釈を付けます
     。これはカレント行が変更される前の状態のファイルを見るとき便利です
     。

‘f’
     カレント行に示されたリビジョンのファイルを、バッファーに表示します
     。

‘d’
     カレント行のリビジョンと、その前のリビジョンの間のdiffを表示します
     。これはカレント行のリビジョンが実際にどのように変更されたか、ファ
     イルを見るとき便利です。

‘D’
     カレント行のリビジョンと、その前のリビジョンの間で、(変更セットをサ
     ポートするバージョンコントロールシステムの)変更セットのすべてのファ
     イルのdiffを表示します。これはカレント行のリビジョンが、実際にどの
     ように変更されたかツリー内を見るとき便利です。

‘l’
     カレント行のリビジョンのログを表示します。これはカレント行のリビジ
     ョンの変更にたいする執筆者(author)の説明を見るのに便利です。

‘w’
     作業中のリビジョン(編集中のもの)に注釈を付けます。‘p’や‘n’を使って
     他のリビジョンを表示している場合、このキーで作業中のリビジョンに戻
     ることができます。

‘v’
     注釈の表示・非表示を切り替えます。これは邪魔になる注釈抜きでファイ
     ル内容だけを見たいとき便利です。


File: emacs.info,  Node: VC Change Log,  Next: VC Undo,  Prev: Old Revisions,  Up: Version Control

28.1.7 VC Change Log
--------------------

‘C-x v l’
     カレントファイルセットの変更履歴を表示します(‘vc-print-log’)。

‘C-x v L’
     カレントリポジトリーの変更履歴を表示します(‘vc-print-root-log’)。

‘C-x v I’
     pull操作が取り込む変更を表示します(‘vc-log-incoming’)。

‘C-x v O’
     push操作が送信する変更を表示します(‘vc-log-outgoing’)。

   ‘C-x v l’ (‘vc-print-log’)は、‘*vc-change-log*’という名前のバッファー
を表示して、誰が変更したのか、その日時、各変更のログエントリー(これらは
‘*vc-log*’バッファーを通じて入力したログエントリーと同じです。*note Log
Buffer::を参照してください)を含む、カレントファイルに行われた変更の履歴
を表示します。現在visitしているファイルのリビジョンに、ポイントが配され
ます。プレフィクス引数を指定した場合、このコマンドはポイントが配されるリ
ビジョンと、表示するリビジョンの最大数の入力を求めます。

   VC Directoryバッファー(*note VC Directory Mode::を参照してください)、
またはDiredバッファー(*note Dired::を参照してください)から‘C-x v l’を呼
び出した場合、カレント行にリストされたファイルにたいして適用されます。

   ‘C-x v L’ (‘vc-print-root-log’)は、‘*vc-change-log*’バッファーを表示
して、バージョンコントロールされたディレクトリーツリー全体を表示します。
このコマンドはプレフィクス引数を指定した場合、表示するリビジョンの最大数
の入力を求めます。

   ‘C-x v L’では履歴は簡略化された形式で表示され、通常は各ログエントリー
の最初の行だけが表示されます。しかし‘*vc-change-log*’バッファーで<RET>
(‘log-view-toggle-entry-display’)とタイプすると、ポイント位置のリビジョ
ンのログエントリー全体を表示します。2回目の<RET>で、再びそれを隠します。

   分散型のバージョンコントロールシステムでは、‘C-x v I’
(‘vc-log-incoming’)コマンドは、次回にバージョンコントロールの“pull”コマ
ンドを実行するときに、他のリポジトリーから受け取る新しいリビジョンにより
適用される変更を、ログバッファーに表示します(*note VC Pull::を参照してく
ださい)。ここで他のリポジトリーとは、バージョンコントロールシステムで定
義される、変更がpullされるリポジトリーのことです。プレフィクス引数を指定
すると、‘vc-log-incoming’は特定のリポジトリーの入力を求めます。同様に、
‘C-x v O’ (‘vc-log-outgoing’)は、次回に“push”コマンドを実行するときに、
他のリポジトリーに送る変更を表示します。プレフィクス引数を指定すると、特
定の送信先リポジトリーの入力を求めます。

   ‘*vc-change-log*’バッファーでは、リビジョンのログまたはファイル間の移
動や、過去のリビジョン(*note Old Revisions::を参照してください)を調べた
り比較するために、以下のキーを使うことができます:

‘p’
     前のリビジョンエントリーに移動します(logバッファーのリビジョンエン
     トリーは通常、日時の降順になっているので、前のリビジョンアイテムは
     通常、もっと新しいリビジョンに対応します)。数引数は繰り返し回数です
     。

‘n’
     次のリビジョンエントリーに移動します。数引数は繰り返し回数です。

‘P’
     複数ファイルのVCファイルセットのログを表示している場合は、前のファ
     イルのログに移動します。そうでない場合は、単にログの先頭に移動しま
     す。数引数は繰り返し回数です。

‘N’
     複数ファイルのVCファイルセットのログを表示している場合は、次のファ
     イルのログに移動します。数引数は繰り返し回数です。

‘a’
     カレント行のリビジョンに注釈を付けます(*note Old Revisions::を参照
     してください)。

‘e’
     ポイント位置に表示された変更コメントを修正します。すべてのバージョ
     ンコントロールシステムが、変更コメントの修正をサポートするわけでは
     ないことに注意してください。

‘f’
     カレント行に示されたリビジョンをvisitします。

‘d’
     ポイント位置のリビジョンと、次に古いリビジョンとの間で、特定のファ
     イルにたいするdiffを表示します。

‘D’
     ポイント位置のリビジョンと、次に古いリビジョンとの間で、変更セット
     のdiffを表示します。これは、そのリビジョンですべてのファイルにたい
     して行われた変更を表示します。

‘<RET>’
     簡略形式のlogバッファー(たとえば‘C-x v L’で作成されたバッファー)で
     、ポイント位置のログエントリーにたいして、完全なログエントリーの表
     示・非表示を切り替えます。

   多くのログエントリーを取得するには時間がかかるので、
‘*vc-change-log*’バッファーは、デフォルトで2000を超えるリビジョンは表示
しません。変数‘vc-log-show-limit’はこの制限を指定します。この値を0にセッ
トすると、制限が削除されます。既存の‘*vc-change-log*’で、バッファーの最
後のボタン‘Show 2X entries’または‘Show unlimited entries’をクリックして
、表示するリビジョン数を増やすこともできます。しかしRCS、SCCS、CVSはこの
機能をサポートしません。


File: emacs.info,  Node: VC Undo,  Next: VC Ignore,  Prev: VC Change Log,  Up: Version Control

28.1.8 バージョンコントロール操作のアンドゥ
-------------------------------------------

‘C-x v u’
     カレントVCファイルセットの作業ファイルを、最後のリビジョンにリバー
     トします(‘vc-revert’)。

   カレントVCファイルセットにたいするすべての変更を破棄したい場合、‘C-x
v u’ (‘vc-revert-buffer’)とタイプします。これは作業ファイルと、編集を開
始したときのリビジョンのdiffを表示して、変更を破棄するか確認を求めます。
これに同意するとファイルセットはリバートされます。‘C-x v u’でdiffを表示
させたくない場合は、変数‘vc-revert-show-diff’に‘nil’をセットします(この
設定をしても‘C-x v =’で直接diffを表示できます。*note Old Revisions::を参
照してください)。‘C-x v u’は通常のアンドゥコマンドでは戻せないので、注意
して使用してください(*note Undo::を参照してください)。

   ロックベースのバージョンコントロールシステムでは、‘C-x v u’はファイル
をロックしないまま残します。編集を再開するには、再度ロックしなければなり
ません。ファイルをロックしてから、やはりそれを変更しないと決めたときも、
‘C-x v u’でファイルのロックを開放できます。


File: emacs.info,  Node: VC Ignore,  Next: VC Directory Mode,  Prev: VC Undo,  Up: Version Control

28.1.9 バージョンコントロールファイルを無視する
-----------------------------------------------

‘C-x v G’
     カレントのバージョンコントロールシステム配下のファイルを無視します
     (‘vc-ignore’)。

   ソースツリーの多くは、エディターのバックアップや、オブジェクトファイ
ル、バイトコードファイル、ビルドされるプログラムなどの、バージョン管理す
る必要のないファイルを含みます。これらは単に追加しないだけでも構いません
が、常に不明なファイルとして現れるでしょう。ツリーのトップの、無視するフ
ァイルのリストにこれらのファイルを追加して、それらを無視するようにバージ
ョンコントロールシステムに指示することもできます。これを行うには‘C-x v
G’ (‘vc-ignore’)が助けとなるでしょう。プレフィクス引数を指定すると、無視
するファイルリストからファイルを削除できます。


File: emacs.info,  Node: VC Directory Mode,  Next: Branches,  Prev: VC Ignore,  Up: Version Control

28.1.10 VC Directoryモード
--------------------------

“VC Directoryバッファー”は、ディレクトリーツリーにあるファイルのバージョ
ンコントロール状態を見て、それらのファイルにバージョンコントロール操作を
実行するために特化したバッファーです。特に複数ファイルのVCファイルセット
にたいして、‘C-x v v’のようなコマンドを適用するのに使用されます(*note VC
Directory Commands::を参照してください)。

   VC Directoryバッファーを使用するには、‘C-x v d’ (‘vc-dir’)とタイプし
ます。これはミニバッファーを使用してディレクトリー名を読み取り、そのディ
レクトリーにたいするVC Directoryバッファーに切り替えます。デフォルトでは
、バッファーの名前は‘*vc-dir*’です。その内容については、 *note VC
Directory Buffer::で説明します。

   ‘vc-dir’コマンドは、指定したディレクトリーで使用されているバージョン
コントロールシステムを自動的に検知します。そのディレクトリーにたいして複
数のバージョンコントロールシステムが使用されている場合、‘C-u C-x v d’の
ようにプレフィクス引数を指定して、このコマンドを呼び出す必要があるでしょ
う。これはVC Directoryバッファーが使用すべきバージョンコントロールシステ
ムの入力を求めます。

   VC Directoryバッファーに加えて、EmacsにはCVSに特化したPCL-CVSと呼ばれ
る似た機能があります。*note About PCL-CVS: (pcl-cvs)Top.を参照してくださ
い。

* Menu:

* Buffer: VC Directory Buffer.  バッファーの外観と意味。
* Commands: VC Directory Commands.  VC
                                      directoryバッファーで使用するコマンド。


File: emacs.info,  Node: VC Directory Buffer,  Next: VC Directory Commands,  Up: VC Directory Mode

28.1.10.1 VC Directoryバッファー
................................

VC Directoryバッファーは、バージョンコントロールされたファイルと、それら
のバージョンコントロール状態を含みます。これは、(‘C-x v d’を呼び出すこと
により指定される)カレントディレクトリーの、“注目すべき”状態のファイルと
サブディレクトリーをだけリストします。最新のファイル(リポジトリーのもの
と同じ)は省略されます。サブディレクトリーのファイルがすべて最新の場合、
そのサブディレクトリーもリストされません。例外として、VCコマンドの直接の
結果として最新になったファイルはリストされます。

   以下はVC Directoryバッファーのリストの例です:

                          ./
         edited           configure.ac
     *   added            README
         unregistered     temp.txt
                          src/
     *   edited           src/main.c

2つの作業ファイル、カレントディレクトリーの‘configure.ac’と、サブディレ
クトリー‘src/’の‘foo.c’は、変更されていますがコミットされていません。
‘README’という名前のファイルは追加されましたが、まだコミットされていませ
ん。そして‘temp.txt’はバージョンコントロールの配下にありません(*note
Registering::を参照してください)。

   エントリー‘README’および‘src/main.c’の隣の‘*’という文字は、ユーザーが
それらのファイルをカレントVCファイルセットとしてマークしたことを示します
(*note VC Directory Commands::を参照してください)。

   上記は、Bazaar、Git、Mercurialのような分散型のバージョンコントロール
システムでの典型的な例です。他のシステムでは、他の状態も見られます。たと
えばCVSは、リポジトリーが変更されていて、それがまだ作業ファイルに適用さ
れていないときは、‘needs-update’という状態を表示します。RCSとSCCSは、ロ
ックされているファイルの状態に、ロックしているユーザーの名前を表示します
。

   CVSとSubversionでは通常、‘vc-dir’コマンドは更新のチェックのために、お
そらくはリモートマシン上にあるであろうリポジトリーにアクセスします。変数
‘vc-stay-local’(CVSは‘vc-cvs-stay-local’。*note CVS Options::を参照して
ください)を‘nil’に変更すると、EmacsはVC Directoryバッファーが生成される
ときのリモートのリポジトリーへのアクセスを避けます(コミットを行うときな
ど、必要なときはアクセスします)。これは、オフラインで作業していたり、ネ
ットワークが遅いときは望ましいでしょう。

   VC Directoryバッファーは、変数‘vc-directory-exclusion-list’にリストさ
れているサブディレクトリーを省略します。この変数のデフォルト値には、バー
ジョンコントロールシステムにより内部的に使用されるディレクトリーが含まれ
ています。


File: emacs.info,  Node: VC Directory Commands,  Prev: VC Directory Buffer,  Up: VC Directory Mode

28.1.10.2 VC Directoryコマンド
..............................

EmacsはVC Directoryバッファーの操作と、カレントVCファイルセットに属させ
るために、ファイルを“マーク”するためのコマンドをいくつか提供します。

‘n’
‘<SPC>’
     次のエントリーにポイントを移動します(‘vc-dir-next-line’)。

‘p’
     前のエントリーにポイントを移動します(‘vc-dir-previous-line’)。

‘<TAB>’
     次のディレクトリーエントリーに移動します(‘vc-dir-next-directory’)。

‘S-<TAB>’
     前のディレクトリーエントリーに移動します
     (‘vc-dir-previous-directory’)。

‘<RET>’
‘f’
     カレント行にリストされたファイル、またはディレクトリーをvisitします
     (‘vc-dir-find-file’)。

‘o’
     カレント行にリストされたファイル、またはディレクトリーを別のウィン
     ドウでvisitします(‘vc-dir-find-file-other-window’)。

‘m’
     カレント行のファイルまたはディレクトリーをマークして、それをカレン
     トVCファイルセットに加えます(‘vc-dir-mark’)。リージョンがアクティブ
     のときは、リージョンの中のすべてのファイルをマークします。

     すでにマークされたディレクトリーの中のファイル、またはそのサブディ
     レクトリーは、このコマンドではマークされません。同様に、ツリーの中
     のいくつかのファイルがマークされているディレクトリーは、このコマン
     ドではマークされません。

‘M’
     ポイントがファイルエントリーにあるときは、同じ状態のすべてのファイ
     ルをマークします。ポイントがディレクトリーエントリーにあるときは、
     そのディレクトリーツリーのすべてのファイルをマークします
     (‘vc-dir-mark-all-files’)。プレフィクス引数を指定した場合、リストさ
     れたファイルとディレクトリーのすべてをマークします。

‘q’
     VC Directoryバッファーを終了して、隠します(‘quit-window’)。

‘u’
     カレント行のファイル、またはディレクトリーのマークを外します
     (‘vc-dir-unmark’)。リージョンがアクティブのときは、リージョンの中の
     すべてのファイルのマークを外します。

‘U’
     ポイントがファイルエントリーにあるときは。同じ状態のすべてのファイ
     ルのマークを外し、ポイントがディレクトリーエントリーにあるときは、
     そのディレクトリーツリーのすべてのファイルのマークを外します
     (‘vc-dir-unmark-all-files’)。プレフィクス引数を指定した場合、すべて
     のファイルおよびディレクトリーのマークを外します。

‘x’
     状態が‘up-to-date’のファイルを隠します(‘vc-dir-hide-up-to-date’)。
     プレフィクス引数を指定した場合、状態がポイント位置のアイテムと同じ
     アイテムを隠します。

   VC Directoryバッファーでは、‘m’ (‘vc-dir-mark’)または‘M’
(‘vc-dir-mark’)でマークしたすべてのファイルが、カレントVCファイルセット
になります。ディレクトリーエントリーを‘m’でマークした場合、そのディレク
トリーツリーにリストされたすべてのファイルが、カレントVCファイルセットに
なります。カレントVCファイルセットに属するファイルとディレクトリーは、VC
Directoryではバージョンコントロール状態の隣に、文字‘*’が示されます。この
方法により‘C-x v v’ (*note Basic VC Editing::を参照してください)、
‘C-x v =’ (*note Old Revisions::を参照してください)、‘C-x v u’ (*note VC
Undo::を参照してください)のようなVCコマンドが作用する、複数ファイルの
VCファイルセットをセットアップできます。

   VC Directoryバッファーは、‘C-x v’というプレフィクスをもつコマンドを、
1キーで入力するショートカット(‘=’、‘+’、‘l’、‘i’、‘D’、‘L’、‘G’、‘I’、
‘v’)を定義します。

   たとえば、VC Directoryバッファーで開いて編集された一連のファイルは、
‘edited’という状態でリストされ、それらのファイルをマークして、‘v’または
‘C-x v v’ (‘vc-next-action’)でコミットできます。バージョンコントロールシ
ステムが変更セットベースの場合、Emacsはそれらのファイルを1つのリビジョン
としてコミットします。

   VC Directoryバッファーでは、以下のコマンドによりカレントVCファイルセ
ットの検索と置換を処理することもできます:

‘S’
     ファイルセットを検索します(‘vc-dir-search’)。

‘Q’
     ファイルセットにたいして、正規表現による問い合わせ置換を行います
     (‘vc-dir-query-replace-regexp’)。

‘M-s a C-s’
     ファイルセットにたいして、インクリメンタル検索を行います
     (‘vc-dir-isearch’)。

‘M-s a C-M-s’
     ファイルセットにたいして、インクリメンタルな正規表現検索を行います
     (‘vc-dir-isearch-regexp’)。

複数ファイルに作用する点を除けば、これらのコマンドは1つのバッファーに作
用する同等のコマンドに似ています(*note Search::を参照してください)。

   上記のコマンドは、メニューバーおよび‘Mouse-2’によるコンテキストメニュ
ーを通じても利用可能です。さらにVCのバックエンドのいくつかは、そのバック
エンド特有のコマンドを提供するメニューを使用します。たとえばGitと
Bazaarでは、“stashes(隠してあるもの)”と“shelves(棚)”を操作できます(コミ
ットされていない変更を一時的に除外して、後でそれを戻すコマンドです)。


File: emacs.info,  Node: Branches,  Next: Miscellaneous VC,  Prev: VC Directory Mode,  Up: Version Control

28.1.11 バージョンコントロールのブランチ
----------------------------------------

バージョンコントロールの活用法の1つとして、“ブランチ(branches)”と呼ばれ
る複数の独立した開発ラインのサポートがあります。中でもとりわけブランチは
、プログラムの“安定版(stable)”と“開発版(development)”を個別に保守したり
、関係のない機能を他の版から隔離して開発するのに使用されます。

   現在のところVCのブランチ操作にたいするサポートは、かなり制限されてい
ます。分散型のバージョンコントロールシステムにたいしては、あるブランチを
他のブランチのコンテンツで“更新”するコマンドと、2つの異なるブランチの変
更を“マージ”するコマンドを提供します。集中型のバージョンコントロールシス
テムにたいしては、異なるブランチからチェックアウトして、新規または異なる
ブランチにコミットするコマンドを提供します。

* Menu:

* Switching Branches::       既存のブランチを取得する方法。
* VC Pull::                  ブランチの内容の更新。
* Merging::                  ブランチ間での変更の転送。
* Creating Branches::        新しいブランチを開始する方法。


File: emacs.info,  Node: Switching Branches,  Next: VC Pull,  Up: Branches

28.1.11.1 ブランチ間の切り替え
..............................

さまざまなバージョンコントロールシステムにおいて、ブランチが実装される方
法は異なり、VCはこれらの違いを完全に隠蔽することはできません。

   BazaarとMercurialを含む分散型バージョンコントロールシステムのいくつか
は、ノーマルモードの操作では、各ブランチは自身の作業ディレクトリーツリー
をもつので、ブランチの切り替えは単にディレクトリーを切り替えるだけです。
Gitでは、ブランチは通常、同じディレクトリーの“共通場所(co-located)”を使
用し、ブランチの切り替えは、作業ツリーの内容をそのブランチに一致するよう
に変更する、‘git checkout’を使用して行われます。Bazaarも共通場所をサポー
トし、この場合は‘bzr switch’コマンドによりカレントディレクトリーでブラン
チを切り替えます。Subversionでは他のブランチに切り替えるのに、‘svn
switch’コマンドを使用します。

   カレントディレクトリーの他のブランチに切り替えるVCコマンドは、‘C-x v
r BRANCH-NAME <RET>’ (‘vc-retrieve-tag’)です。

   集中型のバージョンコントロールシステムでは、最新の作業ファイルで‘C-u
C-x v v’とタイプして(*note Advanced C-x v v::を参照してください)、他のブ
ランチのリビジョンIDを入力することにより、ブランチ間を切り替えることもで
きます。たとえばCVSでは、“trunk(幹の意。開発の主要ラインを示します)”のリ
ビジョンは通常、1.1、1.2、1.3、...という形式をもち、最初のブランチがリビ
ジョン1.2から作成された場合、リビジョン1.2は1.2.1.1、1.2.1.2、...という
リビジョンIDをもち、さらに2番目のブランチが同じくリビジョン1.2から作成さ
れた場合、それは1.2.2.1、1.2.2.2、...という形式になります。ブランチのリ
ビジョンIDから最後の部分を除いた(たとえば1.2.1)、“ブランチID(branch
ID)”を指定して、そのブランチの最新のリビジョンに切り替えることもできます
。

   ロックベースのシステムでは、他のブランチに切り替えることにより、作業
ツリーのロックが解除(書き込み禁止)になります。

   1度ブランチを切り替えると、そのブランチを他に切り替えるまで、VCコマン
ドはそのブランチに適用されます。たとえば任意のVCファイルセットをコミット
すると、そのブランチにコミットされるようになります。


File: emacs.info,  Node: VC Pull,  Next: Merging,  Prev: Switching Branches,  Up: Branches

28.1.11.2 ブランチへの変更の取り込み
....................................

‘C-x v +’
     分散型のバージョンコントロールシステムでは、他の場所から変更を
     “pull”することにより、カレントのブランチを更新します。

     集中型のバージョンコントロールシステムでは、カレントVCファイルセッ
     トを更新します。

   分散型のバージョンコントロールシステムでは、コマンド‘C-x v +’
(‘vc-pull’)は、カレントブランチと作業ツリーを更新します。これは通常、リ
モートのブランチのコピーを更新するのに使用されます。プレフィクス引数を与
えた場合、このコマンドは使用する正確なバージョンコントロールコマンドの入
力をもとめます。これにより変更をどこからpullするか指定できます。プレフィ
クス引数を指定しない場合は、バージョンコントロールシステムにより決定され
る、デフォルトの場所からpullします。

   分散型のバージョンコントロールシステムの中で、現在‘C-x v +’がサポート
するのはBazaar、Git、Mercurialだけです。Bazaarでは、これは通常のブランチ
にたいしては、(マスターブランチをミラーリングされたブランチにpullするた
めに)‘bzr pull’を呼び出し、バインドされたブランチにたいしては、(中心とな
るリポジトリーからpullするために)‘bzr update’を呼び出します。Gitでは、こ
れはリモートのリポジトリーから変更を取得して、それをカレントブランチにマ
ージするために、‘git pull’を呼び出します。Mercurialでは、デフォルトのリ
モートリポジトリーから変更を取得して、作業ディレクトリーを更新するために
‘hg pull -u’を呼び出します。

   pullする前に‘C-x v I’ (‘vc-log-incoming’)を使用して、適用される変更の
logバッファーを閲覧できます。*note VC Change Log::を参照してください。

   CVSのような集中型のバージョンコントロールシステムでは、‘C-x v +’はリ
ポジトリーからカレントVCファイルセットを更新します。


File: emacs.info,  Node: Merging,  Next: Creating Branches,  Prev: VC Pull,  Up: Branches

28.1.11.3 ブランチのマージ
..........................

‘C-x v m’
     分散型のバージョンコントロールシステムでは、カレントのブランチに他
     のブランチの変更をマージします。

     集中型のバージョンコントロールシステムでは、カレントVCファイルセッ
     トに他のブランチの変更をマージします。

   ブランチで開発している場合、すでに他のブランチで行われた変更を“マージ
(merge)”する必要があるときがあります。これは2つのブランチでの変更が重な
る場合もあるため、些細な操作とはいえません。

   分散型のバージョンコントロールシステムでは、マージはコマンド‘C-x v m’
(‘vc-merge’)により行われます。Bazaarでは、これは‘bzr merge’に渡す正確な
引数の入力を求めます。そのとき、可能であれば目的にかなったデフォルトを提
示します。Gitでは、これはマージするブランチ名の入力を求めます。このとき
、(カレントリポジトリーが知っているブランチ名にもとづく)補完を行います。
マージコマンドの実行による出力は、他のバッファーに表示されます。

   CVSのような集中型のバージョンコントロールシステムでは、‘C-x v m’はブ
ランチID、または2つのリビジョンIDの入力を求めます。コマンドはそのブラン
チからの変更点、または指定した2つのリビジョン間の差分を探して、それらの
変更をカレントVCファイルセットにマージします。<RET>だけをタイプした場合
、Emacsは単にそのファイルをチェックアウトしたブランチに行われた変更をマ
ージします。

   マージを処理した直後は、作業ツリーだけが変更されており、‘C-x v D’およ
び関連するコマンドで、マージにより生成された変更をレビューできます(*note
Old Revisions::を参照してください)。2つのブランチが重なった変更をもつ場
合、マージは“衝突(conflict)”を生成します。その場合、マージコマンドの出力
には警告が現れ。影響のある作業ファイルの、衝突する2つの変更の周囲に、“衝
突マーカー(conflict markers)”が挿入されます。衝突を解決するには、衝突す
るファイルを編集しなければなりません。編集が終わったら、マージが効果を発
揮するように、通常の方法により変更したファイルをコミットしなければなりま
せん(*note Basic VC Editing::を参照してください)。


File: emacs.info,  Node: Creating Branches,  Prev: Merging,  Up: Branches

28.1.11.4 新しいブランチの作成
..............................

CVSのような集中型のバージョンコントロールシステムでは、Emacsはコミット操
作の一部として、新しいブランチの作成をサポートします。変更されたVCファイ
ルセットをコミットするとき、‘C-u C-x v v’ (‘vc-next-action’のようにプレ
フィクス引数を指定します。*note Advanced C-x v v::を参照してください).す
ると、Emacsは新しいリビジョンのリビジョンIDの入力を求めます。ここでカレ
ントリビジョンから開始するブランチの。適切なブランチIDを指定する必要があ
ります。たとえば、カレントリビジョンIDが2.5の場合、ブランチIDは2.5.1、
2.5.2、...となるべきでしょう。ブランチIDは、その時点での既存のブランチの
番号に依存します。

   (すでにブランチのヘッドではない)古いリビジョンに新しいブランチを作成
するには、最初にそのリビジョンを選択します(*note Switching Branches::を
参照してください)。その後の手順は、ロックベースのバージョンコントロール
システムを使っているか、マージベースのものを使っているかで異なります。

   ロックベースのバージョンコントロールシステムでは、‘C-x v v’で古いリビ
ジョンのブランチを選択します。古いリビジョンを選択する場合、本当に新しい
ブランチを作成したいのか確認を求めます。これにnoと応えた場合、かわりに最
新のリビジョンをロックする機会が与えられます。マージベースのバージョンコ
ントロールシステムでは、このステップはスキップします。

   変更を行なってから、再び‘C-x v v’とタイプして、新しいリビジョンをコミ
ットします。これは選択されたリビジョンから始まる、新しいブランチを作成し
ます。

   ブランチが作成された後は、それ以降のコミットは、そのブランチに新しい
リビジョンを作成します。ブランチを離れるには、‘C-u C-x v v’で明示的に異
なるリビジョンを選択しなければなりません。


File: emacs.info,  Node: Miscellaneous VC,  Next: Customizing VC,  Prev: Branches,  Up: Version Control

28.1.12 VCのその他のコマンドと機能
----------------------------------

このセクションでは、それほど頻繁には使用されないVCの機能を説明します。

* Menu:

* Change Logs and VC::       logエントリーからChangeLogファイルを生成する。
* VC Delete/Rename::         バージョンコントロールされたファイルの削除とリネームについて。
* Revision Tags::            リビジョンにたいするシンボリック名。
* Version Headers::          作業ファイルへのバージョンコントロールヘッダーの挿入。


File: emacs.info,  Node: Change Logs and VC,  Next: VC Delete/Rename,  Up: Miscellaneous VC

28.1.12.1 変更ログとVC
......................

‘ChangeLog’ファイル (*note Change Log::を参照してください)をもつプロググ
ラムにたいしてRCSやCVSを使用する場合、 バージョンコントロールの以前のコ
ミットのログエントリーから、ChangeLogのエントリーを生成することができま
す。

   これはRCSとCVSだけで機能することに注意してください。この手段は特に、
現代的な変更セットベースのバージョンコントロールシステムには不適切です。
なぜなら、‘ChangeLog’ファイルへの変更自体が、通常は変更セットの一部とし
てコミットされるからです。この場合、最初にChangeLogエントリーを記述して
、コミットするときにそれを‘*vc-log*’バッファーに引用します (*note Log
Buffer::を参照してください)。

‘C-x v a’
     カレントディレクトリーの‘ChangeLog’ファイルをvisitして、そのディレ
     クトリーの登録されたファイルにたいして、最新のChangeLogエントリー以
     降にコミットされたバージョンにたいする、新しいエントリーを作成しま
     す。(‘vc-update-change-log’)。

‘C-u C-x v a’
     上記と同様ですが、カレントバッファーのファイルにたいするエントリー
     だけを探します。

   たとえば、‘ChangeLog’の最初の行の日付が1999-04-10で、それ以降のチェッ
クインは1999-05-22のNathaniel Bowditchによる‘rcs2log’だけで、それのログ
エントリーが‘Ignore log messages that start with `#'.’だったとします。そ
の場合、‘C-x v a’は‘ChangeLog’エントリーとして、以下を挿入します:

     1999-05-22  Nathaniel Bowditch  <nat@apn.org>

             * rcs2log: Ignore log messages that start with `#'.

バージョンコントロールのログエントリーが、(行頭にカッコで括られて記述さ
れる)関数名を指定する場合、それは‘ChangeLog’のエントリーに反映されます。
たとえば‘vc.el’にたいするログエントリーが‘(vc-do-command): Check
call-process status.’の場合、‘ChangeLog’のエントリーは以下のようになりま
す:

     1999-05-06  Nathaniel Bowditch  <nat@apn.org>

             * vc.el (vc-do-command): Check call-process status.

   ‘C-x v a’が複数のChangeLogエントリーを1度に追加するとき、それらがすべ
て同じ作者に、ほぼ同じ日時にチェックインされている場合、関連するログエン
トリーとしてそれらをグループ化します。複数のファイルにたいするログエント
リーがすべての同じテキストの場合、それらを1つのエントリーにまとめます。


File: emacs.info,  Node: VC Delete/Rename,  Next: Revision Tags,  Prev: Change Logs and VC,  Up: Miscellaneous VC

28.1.12.2 バージョンコントロールされたファイルの削除とリネーム
..............................................................

‘M-x vc-delete-file’
     ファイル名の入力を求め、そのファイルを作業ツリーから削除して、コミ
     ット時に削除するようスケジュールします。

‘M-x vc-rename-file’
     2つのファイル名VARおよびOLDの入力を求め、作業ツリーのファイルをリネ
     ームし、コミット時にリネームを行うようスケジュールします。

   バージョンコントロールされたファイルを削除したい場合、コマンド‘M-x
vc-delete-file’を使用します。これはファイル名の入力を求め、バージョンコ
ントロールシステムを通じてそれを削除します。ファイルは作業ツリーから削除
され、VC Directoryバッファー (*note VC Directory Mode::を参照してくださ
い) では、状態に‘removed’が表示されます。それをコミットするとき、リポジ
トリー内で削除が実行されます。

   バージョンコントロールされたファイルをリネームするには、‘M-x
vc-rename-file’とタイプします。これは2つの引数の入力を求めます。それはリ
ネームしたいファイルの名前を、それの新しい名前です。そしてバージョンコン
トロールシステムを通じてリネームを処理します。作業ツリーではリネームは即
座に行われます。リネームされたファイルをコミットするとき、リポジトリーに
反映されます。

   現代的なバージョンコントロールシステムは、リネームにたいするビルトイ
ンのサポートがあり、リネームされたファイルは元のファイルのすべての変更履
歴を保持します。CVSおよび古いバージョンコントロールシステムでは、
‘vc-rename-file’コマンドは、実際には古いファイルを新しい名前にコピーして
、それを登録してから古いファイルを削除することにより機能します。この場合
、変更履歴は保存されません。


File: emacs.info,  Node: Revision Tags,  Next: Version Headers,  Prev: VC Delete/Rename,  Up: Miscellaneous VC

28.1.12.3 リビジョンタグ
........................

ほとんどのバージョンコントロールシステムは、バージョンコントロールされた
ツリーの特定のバージョンにたいして、“リビジョンタグ(revision tag)”を適用
できます。現代的な変更セットベースのバージョンコントロールシステムでは、
リビジョンタグは単に特定のリビジョンにたいするシンボリック名です。CVSの
ようなファイルベースの古いシステムで、各タグははバージョンコントロールさ
れた一連のファイル全体に追加され、それらを1つの単位として処理できるよう
にします。リビジョンタグは一般的にユーザーに配布されるリリースを識別する
のに使用されます。

   タグにたいする2つの基本的なコマンドがあります。1つは与えられた名前で
タグを作成し、もう1つは名前がつけられたタグを取得するコマンドです。

‘C-x v s NAME <RET>’
     カレントディレクトリーまたはその配下のディレクトリーの、すべての登
     録されたファイルの作業リビジョンにたいする、NAMEという名前のタグを
     定義します(‘vc-create-tag’)。

‘C-x v r NAME <RET>’
     カレントディレクトリーまたはその配下のディレクトリーの、すべての登
     録されたファイルにたいして、リビジョンのタグがNAMEのものを取得しま
     す。NAMEがブランチ名で、バージョンコントロールシステムがタグからブ
     ランチを区別する場合、このコマンドはブランチを切り替えます。
     (‘vc-retrieve-tag’).

     カレントディレクトリーまたは配下のディレクトリーのファイルがロック
     されている場合、このコマンドは何もせずにエラーを報告します。これは
     作業中の上書きを避けるためです。

   ‘C-x v =’または‘C-x v ~’の引数として、タグまたはブランチ名を与えるこ
とができます (*note Old Revisions::を参照してください)。 したがって、カ
レントファイルとタグ付けされたバージョンを比較したり、タグ付けされたバー
ジョン同士を比較することができます。

   SCCSでは、VC自身がタグを実装しているので、VCを通じてのみタグを見るこ
とができます。それより新しいほとんどのシステム(CVS、Subversion、bzr、
git、hgを含む)は、ネイティブのタグ機能をもっており、利用可能な場合、VCは
それを使用します。これらのタグは、VCを通さなくても見ることができます。

   ファイルベースのバージョンコントロールシステムでは、登録されたファイ
ルをリネームするとき、それのマスターもリネームする必要があります。コマン
ド‘vc-rename-file’は、これを自動的に行います (*note VC Delete/Rename::を
参照してください)。 SCCSを使用している場合、、そのファイルが新しい名前に
なったことを告げるために、タグの記録も更新しなければなりません
(‘vc-rename-file’もこれを行います)。記録された名前では、すでに存在しない
マスターファイルを参照する古いタグは無効になります。VCはそれを取得しませ
ん。RCSおよびSCCSでのタグの手修正は、このマニュアルの範囲を超えるでしょ
う。‘vc-rename-file’を使用することにより、ファイルを取得できる有効なタグ
を作成できますが、それですべての問題が解決されるわけではありません。たと
えば、プログラムのいくつかのファイルは、他のファイルを名前で参照するかも
しれません。少なくともmakefileはリネームしたファイルを参照するでしょう。
古いタグを取得した場合、リネームされたファイルは、makefileが期待しない新
しい名前で取得されます。そのため、プログラムはうまく機能しないでしょう。


File: emacs.info,  Node: Version Headers,  Prev: Revision Tags,  Up: Miscellaneous VC

28.1.12.4 バージョンコントロールヘッダーの挿入
..............................................

Subversion、CVS、RCS、SCCSでは、“バージョンヘッダー(version headers)”と
呼ばれる文字列を、ファイル内に置くことができます。そのファイルがコミット
されたとき、バージョンコントロールシステムは自動的にリビジョン番号、コミ
ットしたユーザーの名前、その他関連する情報をバージョンヘッダーに挿入しま
す。

   VCは通常、バージョンヘッダーの情報を使用しません。例外として、RCSを使
用している場合、EmacsはRCSのマスターファイルより信頼できる場合が多いとい
う理由で、ファイルのバージョンを決定するためにバージョンヘッダーを使用し
ます。この方法でバージョンヘッダーを使用するのを禁ずるには、変数
‘vc-consult-headers’を‘nil’に変更します。

   カレントバッファーに適切なヘッダー文字列を挿入するには、‘C-x v h’
(‘vc-insert-headers’)とタイプします。このコマンドはSubversion、CVS、
RCS、SCCSだけで機能します。変数‘vc-BACKEND-header’には、バージョンヘッダ
ーに挿入されるキーワードのリストが含まれます。たとえばCVSは
‘vc-cvs-header’を使用し、これのデフォルト値は‘'("\$Id\$")’です(余分なバ
ックスラッシュは、もしEmacs Lispファイルがバージョンコントロールにより保
守されるときに、文字列定数がヘッダーと解釈されるのを防ぐためのものです
)。‘C-x v h’コマンドは。ポイント位置の新しい行にリストのタブで囲まれた各
キーワードを挿入し、必要ならばコメント区切りで囲みます。

   変数‘vc-static-header-alist’は、バッファー名にもとづき追加する文字列
を指定します。これの値は、‘(REGEXP . FORMAT)’という形式の要素からなるリ
ストです。REGEXPがバッファー名にマッチした場合、バージョンヘッダーの一部
としてFORMATも挿入されます。FORMATの中の‘%s’は、そのファイルのバージョン
コントロールのタイプに置換されます。


File: emacs.info,  Node: Customizing VC,  Prev: Miscellaneous VC,  Up: Version Control

28.1.13 VCのカスタマイズ
------------------------

変数‘vc-handled-backends’は、どのバージョンコントロールシステムが処理す
るかを決定します。デフォルト値は‘(RCS CVS SVN SCCS Bzr Git Hg Mtn
Arch)’で、これには、現在サポートされている、すべてのバージョンコントロー
ルが含まれています。VCにこれらのシステムの1つ以上を無視させたい場合、リ
ストからそのシステムの名前を除外します。VC全体を無効にするには、変数に
‘nil’をセットしてください。

   リストのシステム順序には意味があります。これらのシステムの1つ以上に登
録されているファイルをvisitした場合、デフォルトではVCは
‘vc-handled-backends’で最初にくるシステムを使用します。ファイルを最初に
登録するときも、この順序が意味をもちます (*note Registering::を参照して
ください)。

* Menu:

* General VC Options::       複数のバックエンドに適用されるオプション。
* RCS and SCCS::             RCSとSCCSのためのオプションについて。
* CVS Options::              CVSにたいするオプションについて


File: emacs.info,  Node: General VC Options,  Next: RCS and SCCS,  Up: Customizing VC

28.1.13.1 一般的なオプション
............................

Emacsは通常、バージョンコントロールにより保守されるソースファイルのバッ
クアップファイルを保存しません。バージョンコントロールを使用したファイル
にもバックアップファイルを作成したいときは、変数‘vc-make-backup-files’に
非‘nil’値をセットしてください。

   そのファイルがバージョンコントロールされていると知らずに、シンボリッ
クリンクを通じてバージョンコントロールされたファイルを編集すると、予期せ
ぬ結果を招くことがあります。変数‘vc-follow-symlinks’は、バージョンコント
ロールされたファイルを指すシンボリックリンクをvisitしようと試みたときの
、Emacsの振る舞いを制御します。値が‘ask’(デフォルト)の場合、Emacsは確認
を求めます。値が‘nil’の場合、Emacsは警告メッセージを表示するだけです。値
が‘t’の場合、Emacsは自動的にリンクをたどって、かわりに実際のファイルを
visitします。

   ‘vc-suppress-confirm’が非‘nil’の場合、‘C-x v v’および‘C-x v i’は確認
を求めずにカレントバッファーを保存し、‘C-x v u’も確認を求めず処理を行い
ます。

   VCモードは多くの処理を、バージョンコントロールシステムにたいする適切
なシェルコマンドを実行することにより行います。‘vc-command-messages’が非
‘nil’の場合、VCはそれが実行するシェルコマンドを示すメッセージと、コマン
ドが終了したときの追加のメッセージを表示します。


File: emacs.info,  Node: RCS and SCCS,  Next: CVS Options,  Prev: General VC Options,  Up: Customizing VC

28.1.13.2 RCSとSCCSにたいするオプション
.......................................

デフォルトでは、複数ユーザーの活動を調停するためにRCSはロックを使用しま
すが、最初にファイルをロックしなくても変更をチェックインできる、“厳密で
ないロック(non-strict locking)”と呼ばれるモードもあります。特定のファイ
ルにたいして厳密でないロックに切り替えるには、‘rcs -U’を使用します。詳細
については、‘rcs’のman-pageを参照してください。

   RCSファイルのバージョンコントロール状態を推論するとき、VCは最初にその
ファイルのRCSバージョンヘッダー文字列を調べます(*note Version Headers::を
参照してください)。ヘッダー文字列がない場合、VCは通常、作業ファイルのパ
ーミッションを調べます。これは速い処理です。ファイルのパーミッションが信
頼できない状況もあるかもしれません。そのような場合はマスターファイルが調
べられます。これはより高価な処理です。マスターファイルから判るのは、_も
し_そのファイルにたいして何らかのロックがある場合、作業ファイルが実際に
ロックされたバージョンを含むかどうか、だけです。

   ‘vc-consult-headers’を‘nil’にセットすることにより、VCがファイル状態を
決定するのにバージョンヘッダーを使用しないように指定できます。その場合、
VCは常に、(それが信用できると思われる場合は)ファイルのパーミッションを使
うか、マスターファイルをチェックします。

   変数‘vc-mistrust-permissions’を設定することにより、ファイルのパーミッ
ションを信頼すべきかの判断基準を指定できます。値が‘t’(常にファイルのパー
ミッションを疑い、マスターファイルをチェックする)、‘nil’(常にファイルの
パーミッションを信頼する)、または1つの引数をとってその判断を行う関数です
。引数は‘RCS’サブディレクトリーのディレクトリー名です。その関数が非
‘nil’値を戻した場合、パーミッションを信頼しません。作業ファイルのパーミ
ッションが誤って変更されたのに気づいた場合、‘vc-mistrust-permissions’を
‘t’にセットします。そうすればVCはファイル状態を決定するために、常にマス
ターファイルをチェックします。

   VCがSCCSの配下にあるファイルのバージョンコントロール状態を決定する方
法は、RCSとほぼ同じです。しかしSCCSのバージョンヘッダーは考慮しません。
したがってSCCSを使用する場合、‘vc-mistrust-permissions’は効果があります
が、‘vc-consult-headers’は効果がありません。


File: emacs.info,  Node: CVS Options,  Prev: RCS and SCCS,  Up: Customizing VC

28.1.13.3 CVSに特有のオプション
...............................

変数‘vc-cvs-global-switches’で、すべてのCVS操作に渡す追加のコマンドライ
ンオプションを指定できます。これらのスイッチは‘cvs’コマンドの直後、呼び
出す操作名の前に挿入されます。

   リモートマシンのCVSリポジトリーを使用する場合、VCはネットワークでの通
信を最小にしようと試みます。これは変数‘vc-cvs-stay-local’により制御され
ます。他の変数‘vc-stay-local’もあり、これはCVSを含む、それをサポートする
他のバックエンドにもこの機能を有効にします。以下では
‘vc-cvs-stay-local’についてだけ説明しますが、すべて‘vc-stay-local’にも適
用できます。

   ‘vc-cvs-stay-local’が‘only-file’(デフォルト)の場合、VCはローカルの
CVSサブディレクトリーのエントリーと、前のCVSコマンドから戻された情報だけ
を使って、各ファイルのバージョンコントロール状態を決定します。結果として
、あなたがファイルを変更しているとき、他の誰かが他の変更をチェックインし
た場合、それのコミットを試みるまで衝突を通知されません。

   ‘vc-cvs-stay-local’を‘nil’に変更した場合、ローカルのリポジトリーと同
じように、‘vc-next-action’ (‘C-x v v’)が何を行うか決定する_前_に、VCはリ
モートのリポジトリーに問い合わせを行います。

   ‘vc-cvs-stay-local’に、リポジトリーのあるホスト名にマッチする正規表現
を指定することもできます。この場合、ホスト名がパターンにマッチしたときは
、VCはローカルに留まります。

   リモートのリポジトリーを使用する場合、Emacsは通常、編集された各ファイ
ルのオリジナルバージョンである、“自動バージョンバックアップ(automatic
version backups)”を作成します。これらのローカルのバックアップは、変更を
最初にファイルに保存したときに作成され、リポジトリーに変更をコミットした
後で削除されます(これらは通常のEmacsのバックアップファイルとは異なること
に注意してください。 *note Backup::を参照してください)。 ‘C-x v =’や‘C-x
v u’のようなコマンドは、ネットワークへのアクセスを避けるため、可能な場合
は自動バージョンバックアップを使用します。

   ‘vc-cvs-stay-local’を‘nil’にセットすることにより、自動バージョンバッ
クアップの作成を無効にできます。

   自動バージョンバックアップは、‘FILE.~VERSION.~’という形式の名前をもち
ます。これは‘C-x v ~’が古いバージョンを保存するときの名前と似ています
(*note Old Revisions::を参照してください)。 例外は、バージョンの後ろにあ
る追加のドット(‘.’)です。関連するVCコマンドは、これら両方の種類のバージ
ョンバックアップを使用できます。主な違いは、‘C-x v ~’により“手動”で作成
されたバージョンバックアップは、コミットしたとき自動的に削除されないこと
です。

   デフォルトでCVSはロックを使用しませんが、‘CVSREAD’または“watch”の機能
を使用して、ロックのような振る舞いを有効にする方法があります。詳細につい
ては、CVSのドキュメントを参照してください。そのような場合、ロックベース
のバージョンコントロールシステムで行うように、Emacsで‘C-x v v’を使用して
、ロックを切り替えることができます (*note VC With A Locking VCS::を参照
してください)


File: emacs.info,  Node: Change Log,  Next: Tags,  Prev: Version Control,  Up: Maintaining

28.2 変更ログ
=============

多くのソフトウェアプロジェクトでは、“変更ログ(change log)”を管理します。
これは通常、いつどのようにして、そのプログラムが変更されたかの日付順の記
録を含む、‘ChangeLog’という名前のファイルです。これらのファイルは、バー
ジョンコントロールシステムに保存された変更ログエントリーから自動的に生成
されたり、それらの変更ログエントリーを自動的に生成するのに使われる場合も
あります。複数の変更ログファイルがあり、それぞれが1つのディレクトリー、
またはディレクトリーツリーに対応する場合もあります。

* Menu:

* Change Log Commands::      変更ログファイルを編集するためのコマンド。
* Format of ChangeLog::      変更ログファイルがどのように見えるか。


File: emacs.info,  Node: Change Log Commands,  Next: Format of ChangeLog,  Up: Change Log

28.2.1 変更ログコマンド
-----------------------

Emacsコマンド‘C-x 4 a’は、編集しているファイルにたいする新しいエントリー
を、変更ログファイルに追加します(‘add-change-log-entry-other-window’)。
そのファイルが実際にはバックアップファイルの場合、このコマンドはそのファ
イルの元のファイルのエントリーを適切に作成します — これはカレントバージ
ョンから削除された関数のログエントリーを作成するとき便利です。

   ‘C-x 4 a’は変更ログファイルをvisitして、一番最近のエントリーが今日の
日付であなたの名前でない場合は、新しいエントリーを作成します。これはカレ
ントファイルにたいする、新しいアイテムも作成します。このコマンドは多くの
言語にたいして、変更された関数またはその他のオブジェクトを推測することす
らできます。

   変数‘add-log-keep-changes-together’が非‘nil’の場合、‘C-x 4 a’は新しい
アイテムを開始せず、そのファイルにたいする既存のアイテムに追加します。

   同じ性質の複数の変更を1つにまとめることができます。最初の‘C-x 4 a’の
後にテキストを何も入力せずに、続けて‘C-x 4 a’をタイプしていくと、他のシ
ンボルが変更ログエントリーに追加されます。

   ‘add-log-always-start-new-record’が非‘nil’の場合、最後のエントリーが
同じ日付のあなたによる変更だったときでも、‘C-x 4 a’は常に新しいエントリ
ーを作成します。

   変数‘change-log-version-info-enabled’の値が非‘nil’の場合、‘C-x 4 a’は
、ファイルのバージョン番号を変更ログのエントリーに追加します。これは変数
‘change-log-version-number-regexp-list’の正規表現を使用して、ファイルの
最初の10%から、バージョン番号を探します。

   変更ログファイルは、Change Logモードでvisitされます。このメジャーモー
ドでは、グループ化されたアイテムの集まりは1つのパラグラフと扱われ。各エ
ントリーはページとみなされます。これはエントリーの編集を容易にします。
‘C-j’およびauto-fillは、新しい行を前の行と同様にインデントします。これは
エントリーの内容を入力するとき便利です。

   Change Logモードがオンの場合、‘next-error’コマンド(デフォルトでは‘C-x
`’にバインドされています)を使用して、変更ログのエントリー間を移動するこ
とができます。次の変更ログエントリーだけでなく、そのファイルが変更された
実際の場所にジャンプすることもあるでしょう。同じリストを戻って移動するの
に、‘previous-error’を使うこともできます。

   コマンド‘M-x change-log-merge’を使用して、他のログファイルを、エント
リーの日付順を保持したまま、Change Logモードのバッファーにマージできます
。

   プログラムの変更を追跡して変更ログを維持する他の方法として、バージョ
ンコントロールシステムがあります。VC logバッファーでは、‘C-c C-a’
(‘log-edit-insert-changelog’)とタイプすると、変更ログが存在する場合は、
関連する変更ログのエントリーを追加します。


File: emacs.info,  Node: Format of ChangeLog,  Prev: Change Log Commands,  Up: Change Log

28.2.2 ChangeLogの書式
----------------------

変更ログエントリーは、現在の日付、名前(変数‘add-log-full-name’より取得
)、電子メールアドレス(変数‘add-log-mailing-address’より取得)を含むヘッダ
ー行から開始されます。ヘッダー行を除いた変更ログの各行は、スペースまたは
タブで開始されます。エントリーの大部分は、空白文字とアスタリスクで行が開
始される、“アイテム(items)”から構成されます。以下は2つのアイテムおよび
1つのアイテムをもつ、日付が1993年5月の、2つのエントリーの例です。

     1993-05-25  Richard Stallman  <rms@gnu.org>

             * man.el: Rename symbols `man-*' to `Man-*'.
             (manual-entry): Make prompt string clearer.

             * simple.el (blink-matching-paren-distance):
             Change default to 12,000.

     1993-05-24  Richard Stallman  <rms@gnu.org>

             * vc.el (minor-mode-map-alist): Don't use it if it's void.
             (vc-cancel-version): Doc fix.

   1つのエントリーで複数の変更を記述できます。変更はそれぞれアイテム、ま
たはアイテムの中の行を占めます。アイテムの間には通常、空行があります。ア
イテムが関連している場合(異なる場所での同じ変更など)、それらの間に空行を
置かずにそれらをグループ化します。

   変更ログファイルの最後には、著作権表示と使用許諾を配すべきです。以下
は例です:

     Copyright 1997, 1998 Free Software Foundation, Inc.
     Copying and distribution of this file, with or without modification, are
     permitted provided the copyright notice and this notice are preserved.

これはもちろん、正しい年と版権所有者に置き換えて使う必要があります。


File: emacs.info,  Node: Tags,  Next: EDE,  Prev: Change Log,  Up: Maintaining

28.3 タグテーブル
=================

“タグ(tag)”とは、プログラムまたはドキュメント内のサブユニットにたいする
リファレンスです。ソースコードではタグは、関数サブルーチン、データ型、マ
クロなどのプログラムの構文要素を参照します。ドキュメントではチャプター、
セクション、アペンディクスなどを参照します。タグは対応するサブユニットが
定義されているファイルの場所と、サブユニットがファイルのどこで定義されて
いるかを指定します。

   “タグテーブル(tags table)”は、特定のプログラムまたはドキュメントのソ
ースコードをスキャンすることにより抽出されたタグを記録します。生成された
ファイルから抽出されたタグは、タグ抽出の際にスキャンされる生成されたファ
イルではなく、その元になるファイルを参照します。生成されたファイルの例と
して、Cwebソース、Yaccパーサー、Lexスキャナー定義から生成されたCファイル
や、プリプロセスされたCファイルの‘.i’、‘.fpp’ソースファイルをプリプロセ
スすることにより生成されるFortranファイルがあります。

   タグテーブルを生成するには、ドキュメントまたはソースコードファイルに
たいして、シェルコマンド‘etags’を実行します。‘etags’プログラムは、“タグ
テーブルファイル(tags table file)”、または略記して“タグファイル(tags
file)”にタグを書き込みます。タグファイルは慣習的に‘TAGS’という名前です。
*note Create Tags Table::を参照してください。

   Emacsは、タグテーブルに記録された情報を使用して検索や置換を行う、多く
のコマンドを提供します。たとえば‘M-.’ (‘find-tag’)は、指定した関数にたい
して、それのソースファイルの関数定義の場所にジャンプします。*note Find
Tag::を参照してください。

   Ebrowse機能は‘etags’に似ていますが、C++に特化したものです。*note
Ebrowse: (ebrowse)Top.を参照してください。 Semanticパッケージは、
‘etags’機能とは別の、タグを生成して使用する他の方法を提供します。*note
Semantic::を参照してください。

* Menu:

* Tag Syntax::               さまざまなタイプのコードおよびテキストファイルにたいするタグ構文。
* Create Tags Table::        ‘etags’によるタグテーブルの作成。
* Etags Regexps::            正規表現を使用した任意タグの作成。
* Select Tags Table::        タグテーブルをvisitする方法。
* Find Tag::                 特定のタグの定義を見つけるコマンド。
* Tags Search::              検索と置換にたいしてタグテーブルを使う。
* List Tags::                補完および補完候補の一覧にタグを使う。


File: emacs.info,  Node: Tag Syntax,  Next: Create Tags Table,  Up: Tags

28.3.1 ソースファイルタグの構文
-------------------------------

以下は、もっともポピュラーな言語でタグ構文が定義される方法です:

   • Cコードでは、Cの関数やtypedefはタグなので、‘struct’、‘union’、
     ‘enum’の定義もタグです。タグテーブルを作成するとき、
     ‘--no-defines’を指定しなければ、‘#define’マクロ定義、‘#undef’および
     ‘enum’定数もタグになります。同様に、‘--no-globals’を指定しなければ
     グローバル変数もタグで、‘--no-members’を指定していなければ構造体の
     メンバーもタグです。‘--no-globals’、‘--no-defines’、
     ‘--no-members’を使用することにより、タグテーブルを小さくすることが
     できます。

     ‘etags’に‘--declarations’オプションを与えることにより、関数定義
     (function definitions)に加えて、関数宣言(function declarations)と外
     部変数(external variables)もタグ付けできます。

   • C++コードでは、Cコードのすべてのタグ構成に加えて、メンバー関数も認
     識されます。‘--no-members’オプションを使用しなければ、メンバー変数
     も認識されます。クラスの変数および関数にたいするタグは、
     ‘CLASS::VARIABLE’および‘CLASS::FUNCTION’という名前になります。‘演算
     子(operator)’定義は‘operator+’のような名前になります。

   • Javaコードでは、C++で認識されるのすべてのタグ構成に加えて、
     ‘interface’、‘extends’、‘implements’もタグとして認識されます。クラ
     スの変数および関数にたいするタグは、‘CLASS.VARIABLE’および
     ‘CLASS.FUNCTION’という名前になります。

   • LaTeXドキュメントでは、‘\chapter’、‘\section’、‘\subsection’、
     ‘\subsubsection’、‘\eqno’、‘\label’、‘\ref’、‘\cite’、‘\bibitem’、
     ‘\part’、‘\appendix’、‘\entry’、‘\index’、‘\def’、‘\newcommand’、
     ‘\renewcommand’、‘\newenvironment’、‘\renewenvironment’にたいする引
     数がタグになります。

     ‘etags’を呼び出す前に、環境変数‘TEXTAGS’で指定することにより、他の
     コマンドも同様にタグにできます。この環境変数の値には、コロンで区切
     られたコマンド名のリストを指定します。たとえば、

          TEXTAGS="mycommand:myothercommand"
          export TEXTAGS

     これは、(Bourneシェルの構文の使用して)コマンド‘\mycommand’と
     ‘\myothercommand’もタグとして定義します。

   • Lispコードでは、‘defun’で定義された任意の関数、‘defvar’および
     ‘defconst’で定義された任意の変数、および一般的に列0から‘(def’で始ま
     る任意の式の最初の引数はタグです。例外として‘(defvar FOO)’という形
     式の式は、宣言として扱われ、‘--declarations’オプションが与えられた
     ときだけタグになります。

   • Schemeコードでは、‘def’で定義されたすべて、または名前が‘def’で始ま
     る構成がタグに含まれます。これらは、ファイルのトップレベルで
     ‘set!’でセットされる変数も含まれます。

   他の言語もいくつかサポートされます:

   • Adaコードでは、関数(functions)、プロシージャー(procedures)、パッケ
     ージ(packages)、タスク(tasks)、タイプ(types)がタグです。
     ‘--packages-only’オプションを使用することにより、タグをパッケージに
     たいしてだけ作成できます。

     Adaでは、異なる種類のエンティティー(たとえば関数とプロシージャー)に
     、同じ名前を使うことができます。またパッケージ、プロシージャー、関
     数と似たものに、スペック(spec、たとえばinterface)およびボディー
     (body、たとえばimplementation)があります。欲しい定義を簡単に取り出
     すために、Adaのタグ名にはエンティティーのタイプを示す接尾辞がつきま
     す:

     ‘/b’
          パッケージのボディー(package body)。
     ‘/f’
          関数(function)
     ‘/k’
          タスク(task)。
     ‘/p’
          プロシージャー(procedure)。
     ‘/s’
          パッケージのスペック(package spec)。
     ‘/t’
          タイプ(type)。

     したがって、‘M-x find-tag <RET> bidule <RET>’は単に‘bidule’という任
     意のタグを検索しますが、‘M-x find-tag <RET> bidule/b <RET>’は直接パ
     ッケージ‘bidule’のボディーに移動します。

   • アセンブラーコードでは、行の開始に現れ、後にコロンが続くラベルがタ
     グです。

   • BisonまたはYaccの入力ファイルでは、各構文規則で定義する非終端記号が
     タグです。ファイル内に含まれるCコードの部分は、Cコードとして解析し
     ます。

   • Cobolコードでは、タグはパラグラフ名なので、列8から始まり、後にピリ
     オドが続く任意の単語がタグです。

   • Erlangコードでは、ファイルで定義された関数(functions)、レコード
     (records)、マクロ(macros)がタグです。

   • Fortranコードでは、サブルーチン(subroutines)およびブロックデータ
     (block data)がタグです。

   • HTML入力ファイルでは、‘title’、および‘h1’、‘h2’、‘h3’ヘッダーがタグ
     です。アンカー内の‘name=’、およびすべての‘id=’もタグです。

   • Lua入力ファイルでは、すべての関数(functions)がタグです。

   • makefileでは、ターゲット(targets)がタグで、‘--no-globals’を指定しな
     ければ変数(variables)もタグです。

   • Objective Cコードでは、クラスにたいするObjective C定義、クラスカテ
     ゴリー(class categories)、メソッド(methods)、プロトコル
     (protocols)が含まれます。クラスの変数および関数にたいするタグの名前
     は、‘CLASS::VARIABLE’および‘CLASS::FUNCTION’になります。

   • Pascalコードでは、ファイル内で定義された関数およびプロシージャーが
     タグです。

   • Perlコードでは、パッケージ、サブルーチン、変数がタグで、キーワード
     ‘package’、‘sub’、‘use constant’、‘my’、‘local’で定義されます。グロ
     ーバル変数をタグ付けしたい場合、‘--globals’を使用します。サブルーチ
     ンにたいするタグの名前は、‘PACKAGE::SUB’になります。デフォルトのパ
     ッケージで定義されたサブルーチンの名前は、‘main::SUB’になります。

   • PHPコードでは、関数(functions)、クラス(classes)、定義(defines)がタ
     グです。‘--no-members’オプションを使用しなければ、変数(vars)もタグ
     です。

   • PostScriptコードでは、関数がタグです。

   • Prologコードでは、行頭の述語(predicates)とルール(rules)がタグです。

   • Pythonコードでは、行頭の‘def’および‘class’はタグを生成します。

   他の書式や言語を扱うために、regexpにたいするマッチにもとづいてタグを
生成することもできます(*note Etags Regexps::を参照してください)。


File: emacs.info,  Node: Create Tags Table,  Next: Etags Regexps,  Prev: Tag Syntax,  Up: Tags

28.3.2 タグテーブルの作成
-------------------------

‘etags’プログラムは、タグテーブルファイルを作成するために使用されます。
このコマンドは、 *note Tag Syntax::で説明している複数の構文を理解します
。 以下は‘etags’を実行する方法です:

     etags INPUTFILES...

‘etags’プログラムは、指定されたファイルを読み込んで、カレント作業ディレ
クトリーの‘TAGS’という名前のファイルに、タグテーブルを書き込みます。
‘--output=FILE’オプションを使用して、タグテーブルに異なる名前のファイル
名を指定することもできます。ファイル名に‘-’を指定すると、タグテーブルを
標準出力に出力します。

   指定されたファイルが見つからない場合、‘etags’はそれらの圧縮されたバー
ジョンを探して、それらを解凍して読み込みます。MS-DOSでは、コマンドライン
に‘mycode.c’が与えられ、‘mycode.c’が存在しないとき、‘etags’は
‘mycode.cgz’のような名前のファイルを探します。

   ファイルの内容が変更されてタグテーブルが古くなったときは、‘etags’を再
び実行することにより、タグテーブルを更新できます。タグテーブルにタグが記
録されていなかったり、間違ったファイルにたいして記録している場合、タグテ
ーブルを更新するまで、Emacsはそれの定義を見つけることができません。しか
しタグに記録されている位置が、(編集により)少し間違っているようなときは、
少しの遅れは生じますがEmacsは正しい位置を見つけることができます。

   したがって、編集するたびにタグテーブルを更新する必要はありません。リ
ストしたい新しいタグを定義したときや、タグ定義をあるファイルから他のファ
イルへ移動したとき、または大幅な変更を施したときは、タグテーブルを更新す
るべきです。

   ‘etags’に‘--include=FILE’オプションを渡すことにより、タグテーブルに他
のタグテーブルを“インクルード(include)”できます。これによりインクルード
されたタグファイルでカバーされる、すべてのファイルをカバーできます。

   ‘etags’を実行するとき、ソースファイルを相対ファイル名で指定した場合、
タグファイルには、そのタグファイルが最初に書き込まれたディレクトリーにた
いする相対ファイル名が含まれます。この方法を使えば、ディレクトリーツリー
全体を移動しても、タグファイルは正しくソースファイルを参照します。しかし
タグファイルが‘-’または‘/dev’のときは、ファイル名はカレント作業ディレク
トリーにたいする相対ファイル名になります。これはタグを‘/dev/stdout’に書
き込むときに便利です。

   相対ファイル名を使う場合、違うディレクトリーにあるタグファイルを指す
シンボリックリンクを指定するべきではありません。なぜならこれは一般的にフ
ァイル名を無効にするからです。

   ‘etags’の引数に絶対ファイル名を指定した場合、タグファイルには絶対ファ
イル名が含まれます。この方法では、ソースファイルが同じ場所にある限り、タ
グファイルを移動してもタグファイルは同じ名前を参照します。絶対ファイル名
は‘/’で開始されるか、MS-DOSおよびMS-Windowsでは‘DEVICE:/’で開始されます
。

   非常に大きな数のファイルからタグテーブルを作成したい場合、それをコマ
ンドラインに指定すると問題が発生するかもしれません。なぜならコマンドライ
ン引数の長さに制限のあるシステムもあるからです。この制限は、以下のように
ファイル名の場所にダッシュを指定して、‘etags’にファイル名を標準入力から
読み込むように指示して回避することができます。

     find . -name "*.[chCH]" -print | etags -

   ‘etags’はファイル名とファイル内容にもとづいて、入力ファイルで使用され
ている言語を認識します。‘--language=NAME’オプションで、明示的に言語を指
定できます。このオプションはファイル名に混ぜることができます。各指定はそ
の後に続くファイル名に適用されます。‘--language=auto’の指定は、ファイル
名とファイル内容から言語を推測するよう‘etags’に指示します。
‘--language=none’を指定すると、言語に特有の処理を完全にオフに切り替えま
す。この場合、‘etags’はregexpのマッチングだけでタグを認識します(*note
Etags Regexps::を参照してください)。

   オプション‘--parse-stdin=FILE’は、‘etags’をプログラムから呼び出すとき
に便利です。これは、(1回だけ)コマンドラインからファイル名を読み取るとき
使用できます。‘etags’は標準入力から読み取り、生成されたタグがファイル
FILEに属するとマークします。

   ‘etags --help’オプションは‘etags’が認識する言語と、言語を推測するため
のファイル名ルールのリストを出力します。これは利用可能な‘etags’オプショ
ンと、簡単な説明のリストも出力します。このオプションの後に、1つ以上の
‘--language=LANG’を指定すると、LANGにたいするタグの生成方法の詳細を出力
します。


File: emacs.info,  Node: Etags Regexps,  Next: Select Tags Table,  Prev: Create Tags Table,  Up: Tags

28.3.3 EtagsのRegexps
---------------------

‘--regex’オプションは、正規表現のマッチにもとづいて‘etags’がタグを認識で
きるようにします。このオプションはファイル名と混ぜることができます。オプ
ションは、それぞれのオプション後に続くソースファイルに適用されます。複数
の‘--regex’を指定した場合、それらすべては並列に使用されます。構文は以下
のとおりです:

     --regex=[{LANGUAGE}]/TAGREGEXP/[NAMEREGEXP/]MODIFIERS

オプション値の肝心な部分はTAGREGEXPで、これはタグにマッチするregexpです
。これは常に位置が固定されており、行の開始だけにマッチします。インデント
されたタグの場合、最初の空白文字にマッチさせるために、‘[ \t]*’で始まる
regexpを使用します。

   これらの正規表現では、‘\’は次の文字をクォートします。またGCCのエスケ
ープ文字シーケンスのすべて、すなわち‘\a’(bell)、‘\b’(back space)、
‘\d’(delete)、‘\e’(escape)、‘\f’(formfeed)、‘\n’(newline)、‘\r’(carriage
return)、‘\t’(tab)、and ‘\v’(vertical tab)がサポートされます。

   理想的には、TAGREGEXPはタグとして認識させるのに必要な文字以上にマッチ
させるべきではありません。構文がそれを求める場合、タグより多くの文字にマ
ッチするTAGREGEXPを記述して、そのマッチからタグだけをピックアップするた
めに、NAMEREGEXPを追加するべきです。これはEmacsがより正しくタグを見つけ
て、タグ名の補完をより確実にすることを可能にします。

   MODIFIERS(修飾子)は、‘etags’がマッチングを行う方法を変更するための0文
字以上の文字シーケンスです。修飾子がないregexpは、大文字小文字を区別する
方法で、入力ファイルの各行にたいして順番に適用されます。修飾子とその意味
は以下のとおりです:

‘i’
     このregexpのマッチングで、大文字小文字を無視します。
‘m’
     この正規表現はファイル全体にマッチするので、複数行のマッチが可能で
     す。
‘s’
     この正規表現はファイル全体にマッチし、TAGREGEXP内の‘.’は改行にマッ
     チします。

   ‘-R’オプションは、それの前に‘--regex’で定義されたregexpをすべて取り消
します。これは後に続くファイル名にも適用されます。以下は例です:

     etags --regex=/REG1/i voo.doo --regex=/REG2/m \
         bar.ber -R --lang=lisp los.er

この例では、‘etags’は‘voo.doo’と‘bar.ber’にたいして。ファイル内容に一致
する解析用の言語を選択します。‘etags’は、‘voo.doo’内の追加のタグを認識す
るためにREG1も使用し、‘bar.ber’内の追加のタグを認識するためにREG1と
REG2の両方を使用します。‘voo.doo’と‘bar.ber’の各行にたいして大文字小文字
を区別せずにREG1がチェックされ、‘bar.ber’のファイル全体にたいして大文字
小文字を区別してREG2がチェックされ、これは複数行へのマッチが許されます。
‘los.er’のタグの認識にはユーザー指定のregexpマッチは行わず、Lispのタグル
ールだけが使用されます。

   オプションのプレフィクス{LANGUAGE}を使用して、与えられた言語だけに
‘--regex’オプションを制限できます(‘etags --help’で‘etags’が認識する言語
のリストが表示されます)。これはファイルに、‘etags’にたいして事前に定義さ
れた多くの正規表現が含まれている場合に便利です。以下の例は、EmacsのC言語
のソースファイルの‘DEFVAR’マクロにたいするタグです:

     --regex='{c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/'

正規表現が複雑な場合、そのリストをファイルに保存することができます。以下
のオプション構文は、‘etags’に正規表現が保存された2つのファイルを指示しま
す。2つ目のファイルに含まれる正規表現は、大文字小文字を区別せずにマッチ
します。

     --regex=@CASE-SENSITIVE-FILE --ignore-case-regex=@IGNORE-CASE-FILE

‘etags’にたいするregexファイルは、行ごとに1つの正規表現を含みます。空行
およびスペースかタブで始まる行は無視されます。表の開始が‘@’の場合、
‘etags’はその行の残りを他の正規表現ファイルとみなすので、そのようなファ
イルを他のファイルをインクルードできます。他のすべての行は正規表現です。
最初の非空白文字が‘--’の場合、その行はコメントです。

   たとえば、以下の内容の‘emacs.tags’という名前のファイルを作成できます:

             -- This is for GNU Emacs C source files
     {c}/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/\1/

これは以下のように使用します:

     etags --regex=@emacs.tags *.[ch] */*.[ch]

   さらに例を示しましょう。regexpはシェルから解釈され内容にクォートされ
ています。

   • Octaveファイルのタグ:

          etags --language=none \
                --regex='/[ \t]*function.*=[ \t]*\([^ \t]*\)[ \t]*(/\1/' \
                --regex='/###key \(.*\)/\1/' \
                --regex='/[ \t]*global[ \t].*/' \
                *.m

     タグはスクリプトにたいして生成されるので、そのスクリプトにジャンプ
     したいときは、あなた自身で‘###key SCRIPTNAME’という形式の行を追加す
     る必要があることに注意してください。

   • Tclファイルのタグ:

          etags --language=none --regex='/proc[ \t]+\([^ \t]+\)/\1/' *.tcl

   • VHDLファイルのタグ:

          etags --language=none \
            --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/' \
            --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
            \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'


File: emacs.info,  Node: Select Tags Table,  Next: Find Tag,  Prev: Etags Regexps,  Up: Tags

28.3.4 タグテーブルの選択
-------------------------

Emacsは常に、“選択された”タグテーブルを1つもちます。タグテーブルにたいし
て機能するすべてのコマンドは、選択されたタグテーブルを使用します。タグテ
ーブルを選択するには、‘M-x visit-tags-table’とタイプします。これは、引数
としてタグテーブルファイル名を読み取ります。デフォルトディレクトリーの
‘TAGS’がデフォルトです。

   Emacsは、タグテーブルを使用するまでは実際にタグテーブルの内容を読み込
みません。‘visit-tags-table’が行うのは、ファイル名を変数
‘tags-file-name’に格納するのがすべてなので、あなた自身でこの変数をセット
しても同じことができます。この変数の初期値は‘nil’です。この変数の値は、
タグテーブルにたいして機能するすべてのコマンドに、使用するタグテーブルフ
ァイル名を知らせます。

   タグテーブルがすでにロードされているときに‘visit-tags-table’を使用す
ると、2つの選択肢が与えられます。つまり、タグテーブルのカレントリストに
新しいタグを追加するか、あるいは新しいリストを開始することもできます。タ
グコマンドは、カレントリストのすべてのタグテーブルを使用します。新しいリ
ストを開始した場合、他のものの_かわりに_、新しいタグテーブルが使用されま
す。カレントリストに新しいタグテーブルを追加した場合、それは他のものと
_同じように_使用されます。

   以下のようにして、変数‘tags-table-list’に文字列のリストをセットするこ
とにより、タグテーブルのリストを正確に指定できます:

     (setq tags-table-list
           '("~/emacs" "/usr/local/lib/emacs/src"))

これは、タグコマンドが‘TAGS’ファイルを、‘~/emacs’ディレクトリーと
‘/usr/local/lib/emacs/src’ディレクトリーから探すよう指示します。上記で説
明したように、順序は、対象にしているファイルと、どのタグテーブルがそのフ
ァイルを記述しているかに依存します。

   ‘tags-file-name’と‘tags-table-list’の両方をセットしてはいけません。


File: emacs.info,  Node: Find Tag,  Next: Tags Search,  Prev: Select Tags Table,  Up: Tags

28.3.5 タグの検索
-----------------

タグテーブルが可能にすることの中で一番重要なのは、指定したタグの定義を探
すことです。

‘M-. TAG <RET>’
     TAGの最初の定義を探します(‘find-tag’)。
‘C-u M-.’
     最後に指定したタグにたいして、次の候補の定義を探します。
‘C-u - M-.’
     前に見つかったタグに戻ります。
‘C-M-. PATTERN <RET>’
     PATTERNにマッチする名前のタグを探します(‘find-tag-regexp’)。
‘C-u C-M-.’
     最後に使用したパターンにマッチする名前のタグを探します。
‘C-x 4 . TAG <RET>’
     TAGの最初の定義を探して、他のウィンドウに表示します
     (‘find-tag-other-window’)。
‘C-x 5 . TAG <RET>’
     TAGの最初の定義を探して、新しいフレームを作成してそのバッファーを選
     択します(‘find-tag-other-frame’)。
‘M-*’
     前に‘M-.’または同種のコマンドを呼び出した場所に戻ります。

   ‘M-.’ (‘find-tag’)はタグ名の入力を求め、それのソース定義にジャンプし
ます。これはタグテーブルからタグのファイルと、おおよその文字位置を検索し
て、そのファイルをvisitし、記録されたおおよその位置から、範囲を広げなが
らタグ定義の検索をします。

   ‘M-.’の引数にタグを入力するとき、通常のミニバッファーの補完コマンドを
使用できます(*note Completion::を参照してください)。補完では、選択された
タグテーブルのタグ名が補完候補になります。空の引数を指定した場合、ポイン
ト位置またはその前の、対応がとれた式がデフォルトの引数になります。*note
Expressions::を参照してください。

   ‘M-.’に、タグの完全な名前を与える必要はありません。名前の一部で充分で
す。‘M-.’は、引数を部分文字列として含むタグを探します。しかし部分文字列
にたいするマッチより、正確なマッチの方が好ましいです。同じ部分文字列にマ
ッチする他のタグを探すには、‘C-u M-.’または‘M-0 M-.’のように、
‘find-tag’に数引数を与えます。これはタグ名を読み取らず、最後に使用された
のと同じ部分文字列を含む他のタグにたいして、タグテーブルのテキストの検索
を継続します。

   バッファーを切り替えるほとんどのコマンドと同様に、‘find-tag’は新しい
バッファーを他のウィンドウ、または新しいバッファーのために新しいフレーム
を作成する変種をもっています。前者は‘C-x 4 .’ (‘find-tag-other-window’)、
後者は‘C-x 5 .’ (‘find-tag-other-frame’)です。

   前のタグ定義に戻るには‘C-u - M-.’を使用します。より一般的には、
‘M-.’に負の数引数を指定します。同様に‘C-x 4 .’に負の引数を指定すると、他
のウィンドウで前のタグ位置を探します。

   最近探したタグの位置に戻るのと同様に、‘M-*’ (‘pop-tag-mark’)を使用し
て、それらを探すのを始めた場所に戻ることができます。したがって何かにたい
して‘M-.’で探して調べた後、‘M-*’で元の場所に戻ることができます。

   ‘C-u - M-.’および‘M-*’は、‘find-tag-marker-ring-length’により決定され
る深さで、それまでのステップを遡ることができます。

   コマンド‘C-M-.’ (‘find-tag-regexp’)は、指定した正規表現にマッチするタ
グをvisitします。これは‘M-.’と同じですが、部分文字列にたいするマッチでは
なく、regexpにたいするマッチです。


File: emacs.info,  Node: Tags Search,  Next: List Tags,  Prev: Find Tag,  Up: Tags

28.3.6 タグテーブルの検索と置換
-------------------------------

このセクションのコマンドは、選択されたタグテーブルにリストされたファイル
を、1つずつvisitして検索します。これらのコマンドにたいして、タグテーブル
は検索する一連のファイルを指定するためだけに使用されます。これらのコマン
ドは、タグテーブルのリストの最初のタグテーブルから、(もしあれば)カレント
ファイルを記述するものを走査して、そこからリストの最後まで進めて、その後
リストの先頭からリストのすべてのタグテーブルをカバーするまで走査します。

‘M-x tags-search <RET> REGEXP <RET>’
     選択されたタグテーブルのファイルから、REGEXPを検索します。
‘M-x tags-query-replace <RET> REGEXP <RET> REPLACEMENT <RET>’
     選択されたタグテーブルの各ファイルにたいして、
     ‘query-replace-regexp’を実行します。
‘M-,’
     ポイントのカレント位置から上記のコマンドの1つを再開します
     (‘tags-loop-continue’)。

   ‘M-x tags-search’は、ミニバッファーを使用してregexpを読み取り、選択さ
れたタグテーブルのすべてのファイルから、1ファイルずつマッチを検索します
。これは検索しているファイル名を表示するので、進行状況を確認することがで
きます。マッチが見つかった場合、‘tags-search’はリターンします。

   1つのマッチが見つかったら、おそらく残りのすべてについても検索したいと
思うでしょう。‘M-,’ (‘tags-loop-continue’)とタイプすると、多くのマッチを
探すために‘tags-search’を再開します。これはカレントバッファーの残りの部
分を検索して、その後タグテーブルの残りのファイルを検索します。

   ‘M-x tags-query-replace’は、タグテーブルのすべてのファイルにたいして
、1つの‘query-replace-regexp’を実行します。これは、通常の‘M-x
query-replace-regexp’と同様、検索するregexpと、それを置換する文字列を読
み取ります。この検索はむしろ‘M-x tags-search’に似ていますが、入力へのマ
ッチを繰り返し処理します。問い合わせ付き置換については、*note Query
Replace::を参照してください。

   変数‘tags-case-fold-search’の値をカスタマイズすることにより、タグ検索
コマンドの大文字小文字の扱いを制御できます。デフォルトには、
‘case-fold-search’の値と同じ設定が使用されます(*note Search Case::を参照
してください)。

   1回の‘M-x tags-query-replace’の呼び出しで、タグテーブルのすべてのファ
イルを検索することが可能です。しかし、一時的に検索を抜けられると便利なと
きもあります。これは、問い合わせ付き置換として特別な意味をもたない入力イ
ベントで行うことができます。つづけて問い合わせ付き置換を再開するには、
‘M-,’とタイプします。このコマンドは、最後のタグ検索または置換コマンドを
再開します。たとえばカレントファイルの残りをスキップするには、‘M-> M-,’と
タイプします。

   このセクションのコマンドは、‘find-tag’系の検索より広範な検索を行いま
す。‘find-tag’コマンドは、部分文字列または正規表現にマッチするタグ定義だ
けを検索します。コマンド‘tags-search’および‘tags-query-replace’は、通常
の検索および置換コマンドがカレントバッファーにたいして行うように、すべて
のマッチを検索します。

   これらのコマンドは、(それらがすでにEmacsバッファーでvisitされていなけ
れば)検索する必要があるファイルのために、一時的なバッファーを作成します
。マッチが見つからないバッファーは、速やかにkillされます。そうでない場合
は残されます。

   ‘tags-search’のかわりに、サブプロセスとして‘grep’を実行して、Emacsに
マッチした行を1つずつ表示させることができます。*note Grep Searching::を
参照してください。


File: emacs.info,  Node: List Tags,  Prev: Tags Search,  Up: Tags

28.3.7 タグテーブルの照会
-------------------------

‘C-M-i’
‘M-<TAB>’
     タグテーブルがロードされているときは、選択されたタグテーブルを使っ
     て、ポイント周囲のテキストの置換を行います(‘completion-at-point’)。
‘M-x list-tags <RET> FILE <RET>’
     プログラムファイルFILEで定義されているタグのリストを表示します。
‘M-x tags-apropos <RET> REGEXP <RET>’
     REGEXPにマッチする、すべてのタグのリストを表示します。

   プログラミング言語のモードのほとんどでは、‘C-M-i’または‘M-<TAB>’
(‘completion-at-point’)とタイプして、ポイント位置のシンボルを補完できま
す。選択されたタグテーブルがある場合、このコマンドは補完候補を生成するた
めにそれを使用することができます。*note Symbol Completion::を参照してく
ださい。

   ‘M-x list-tags’は、選択されたタグテーブルでカバーされたファイルの名前
を1つ読み取り、そのファイルで定義されたタグのリストを表示します。タグテ
ーブルに記録されたファイル名にディレクトリーが含まれない場合は、ファイル
名にディレクトリーを含めないでください。

   ‘M-x tags-apropos’は、タグにたいする‘apropos(適切な)’のようなものです
(*note Apropos::を参照してください)。これは、選択されたタグテーブルのエ
ントリーがREGEXPにマッチするタグのリストを表示します。変数
‘tags-apropos-verbose’が非‘nil’の場合、タグ名と一緒にタグファイル名も表
示します。フェイスにたいする変数‘tags-tag-face’をセットすることにより、
出力の外観をカスタマイズできます。変数
‘tags-apropos-additional-actions’をカスタマイズすることにより、追加の出
力を表示できます。詳細は、変数のドキュメントを参照してください。

   ‘M-x next-file’は、選択されたタグテーブルでカバーされるファイルを
visitします。最初に呼び出したとき、テーブルでカバーされた最初のファイル
をvisitします。続けて呼び出すことにより、次のカバーされたファイルを
visitしていきます。プレフィクス引数を指定した場合、最初のファイルに戻り
ます。


File: emacs.info,  Node: EDE,  Next: Emerge,  Prev: Tags,  Up: Maintaining

28.4 Emacs開発環境
==================

EDE(“Emacs Development Environment: Emacs開発環境”)は、Emacsでの大きなプ
ログラムの作成、ビルド、デバッグなどのタスクを単純化するパッケージです。
これはEmacsにおいて、IDE(“Integrated Development Environment: 統合開発環
境”)の機能をいくつか提供します。

   このセクションは、EDEの簡単な説明を提供します。 完全な詳細については
、*note EDE: (ede)Top.を参照してください。

   EDEは、グローバルなマイナーモードとして実装されています(*note Minor
Modes::を参照してください)。有効にするには‘M-x global-ede-mode’とタイプ
するか、‘Tools’メニューの‘Project Support (EDE)’アイテムをクリックします
。以下の行をinitファイルに追加することにより、Emacs開始時にEDEを有効にす
ることもできます。

     (global-ede-mode t)

EDEを有効にすることにより、メニューバーに‘Development’という名前のメニュ
ーが追加されます。以下で説明するコマンドを含めて、多くのEDEコマンドをこ
のメニューから呼び出すことができます。

   EDEは、ファイルを“プロジェクト(projects)”に編成します。プロジェクトは
ディレクトリーに対応します。“プロジェクトルート(project root)”は、プロジ
ェクトの最上層のディレクトリーです。新しいプロジェクトを定義するには、プ
ロジェクトルートのファイルをvisitして、‘M-x ede-new’とタイプします。この
コマンドは“プロジェクトタイプ(project type)”の入力を求めます。これは
EDEがプロジェクトを背後で管理する方式です(*note EDE: (ede)Creating a
project.を参照してください)。もっとも一般的なプロジェクトタイプは、
Makefilesを使用する‘Make’、およびGNU Automake(*note Automake:
(automake)Top.を参照してください)を使用する‘Automake’です。どちらの場合
も、EDEはプロジェクトに関する情報を格納する、‘Project.ede’という名前のフ
ァイルを作成します。

   プロジェクトには、1つ以上の“ターゲット(targets)”を含めることができま
す。ターゲットとは、プロジェクトの1つ以上のファイルから“ビルド”されるオ
ブジェクトファイル、実行ファイル、またはその他の種類のファイルです。

   プロジェクトに新しい“ターゲット(target)”を追加するには、‘C-c . t’
(‘M-x ede-new-target’)とタイプします。このコマンドは、カレントファイルを
そのターゲットに“追加”するか尋ねます。これはターゲットがそのファイルから
ビルドされることを意味します。ターゲットを定義した後は、‘C-c . a’
(‘ede-add-file’)とタイプすることにより、ターゲットにファイルを追加するこ
とができます。

   ターゲットをビルドするには、‘C-c . c’ (‘ede-compile-target’)とタイプ
します。プロジェクトのすべてのターゲットをビルドするには、‘C-c . C’
(‘ede-compile-project’)とタイプします。EDEはターゲットがどのようにビルド
されるべきか推測するために、ファイルタイプを使用します。


File: emacs.info,  Node: Emerge,  Prev: EDE,  Up: Maintaining

28.5 Emergeでのファイルのマージ
===============================

行き違いの指示を受けて、同じプログラムを異なる2つの方向に修正してしまう
のは、プログラマーにとって珍しいことではありません。この混乱を正常な状態
に戻すには、2つのバージョンをマージする必要があります。Emergeはこれを簡
単にします。ファイルを比較する他の方法については、 *note Comparing
Files::、 および*note Ediff: (ediff)Top.を参照してください。

* Menu:

* Overview of Emerge::       Emergeを開始する方法と、基本的な概念。
* Submodes of Emerge::       Fastモード vs. Editモード。Skip
                               PrefersモードとAuto Advanceモード。
* State of Difference::      各相違にたいして、AまたはBの状態を指定することによりマージを行う。
* Merge Commands::           相違を選択したり、相違の状態を変更するコマンドなど。
* Exiting Emerge::           マージを終えた後に行うこと。
* Combining in Emerge::      相違にたいする両方の候補を維持する方法。
* Fine Points of Emerge::    その他の問題。


File: emacs.info,  Node: Overview of Emerge,  Next: Submodes of Emerge,  Up: Emerge

28.5.1 Emergeの概要
-------------------

Emergeを開始するには、以下の4つのコマンドの1つを実行します:

‘M-x emerge-files’
     指定した2つのファイルをマージします。

‘M-x emerge-files-with-ancestor’
     共通の祖先(ancestor)を参照して、指定した2つのファイルをマージします
     。

‘M-x emerge-buffers’
     2つのバッファーをマージします。

‘M-x emerge-buffers-with-ancestor’
     第3のバッファーにある共通の祖先を参照して、2つのバッファーをマージ
     します。

   Emergeコマンドは2つのファイルまたはバッファーを比較して、3つのバッフ
ァーにそれ表示します。最初の2つは入力テキスト(“Aバッファー”と“Bバッファ
ー”)で、残りの1つ(“マージバッファー”)はどこにマージが行われたかを表示し
ます。マージバッファーは相違だけではなく、マージされたテキストをすべて表
示します。2つの入力テキストが異なる場所では、どちらをマージバッファーに
含めるか選択できます。

   既存のバッファーから入力を得るEmergeコマンドは、そのバッファーがナロ
ーされている場合は、バッファーのアクセス可能な部分だけを使用します。
*note Narrowing::を参照してください。

   2つのマージされるテキストの元となる、共通の祖先となるバージョンが利用
可能な場合は、Emergeはどちらが正しい候補かを推測するために、それを使用す
ることができます。一方のカレントバージョンが祖先に一致する場合、Emergeは
もう一方のカレントバージョンが、マージされたバージョンに残すべき、意図し
た変更であると仮定します。共通の祖先となるテキストを指定したい場合は、
‘with-ancestor’がつくコマンドを使用します。これらのコマンドは3つのファイ
ルまたはバッファーの名前 — バージョンA、バージョンB、そして共通の祖先の
名前を読み取ります。

   比較が終了してバッファーの準備ができた後、対話的なマージが開始されま
す。マージバッファーで特別な“マージコマンド”をタイプすることにより、マー
ジを制御できます(*note Merge Commands::を参照してください)。入力テキスト
の相違それぞれにたいして、どちらを残すか、または両方編集するか選択するこ
とができます。

   マージバッファーはこれらの選択を行うために、Emergeモードという特別な
メジャーモードを使用します。しかし、そのバッファーでは通常のEmacsコマン
ドで編集することもできます。

   常にEmergeの注目は、“選択された”相違と呼ばれる、特定の相違に焦点を置
きます。この相違は、3つのバッファーで以下のようにマークされます:

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

Emergeはすべての相違に順番に番号をふり、モードラインには選択された相違の
番号が常に表示されます。

   マージバッファーは通常、バージョンAのテキストで開始されます。しかしバ
ージョンAの相違が共通の祖先と一致する場合、その相違の初期値にはバージョ
ンBが優先されます。

   マージバッファーを抜けるとき、Emergeはマージされたテキストを残します
。このとき、‘C-x C-w’で、それをファイルに保存できます。‘emerge-files’ま
たは‘emerge-files-with-ancestor’に数引数を与えた場合、ミニバッファーを使
用して、出力するファイル名を読み取ります(これは、このコマンドが読み取る
ファイル名の最後のファイル名です)。その後Emergeから抜けると、マージされ
たテキストを出力ファイルに保存します。

   通常、Emergeコマンドは終了するとき出力バッファーを、そのバッファーの
ファイルに保存します。Emergeを‘C-]’で中断した場合、Emergeコマンドは出力
バッファーを保存しませんが、もし保存したいときは自分で保存することができ
ます。


File: emacs.info,  Node: Submodes of Emerge,  Next: State of Difference,  Prev: Overview of Emerge,  Up: Emerge

28.5.2 Emergeのサブモード
-------------------------

マージコマンドに与える2つのモード — FastモードとEditモードを選択すること
ができます。Fastモードでは、基本的なマージコマンドは1文字ですが、通常の
Emacsコマンドは利用不可です。これはマージコマンドだけを使いたいときは便
利です。Editモードでは、すべてのマージコマンドはプレフィクスキー‘C-c
C-c’で始まり、通常のEmacsコマンドも利用可能です。これによりマージバッフ
ァーで編集することができますが、Emerge操作は遅くなります。

   ‘e’でEditモード、‘C-c C-c f’でFastモードに切り替わります。モードライ
ンにはEditモードおよびFastモードは、‘E’と‘F’で示されます。

   Emergeは、特定のマージコマンドがどのように機能するかに影響を与える、
2つの追加的なサブモード — Auto AdvanceモードとSkip Prefersモードがありま
す。

   Auto Advanceモードが効力をもつ場合、‘a’または‘b’コマンドで次の相違に
移動します。これは候補を単に選んでいくだけで、素早くマージすることができ
ます。Auto Advanceモードの場合、モードラインに‘A’が示されます。

   Skip Prefersモードが効力をもつ場合、‘n’および‘p’コマンドは、状態が
“prefer-A”と“prefer-B”の相違をスキップします(*note State of
Difference::を参照してください)。したがって、どちらのバージョンも“正しい
”と推定できない相違だけを見ていくことができます。Skip Prefersモードの場
合、モードラインに‘S’が示されます。このモードは祖先がある場合にだけ適し
ています。

   Auto Advanceをセットまたはクリアーするには、コマンド‘s a’
(‘emerge-auto-advance’)を使用します。Skip Prefersモードをセットまたはク
リアーするには、‘s s’ (‘emerge-skip-prefers’)を使用します。これらのコマ
ンドは、正の引数の場合はモードをオンにして、負または0の引数のときはモー
ドをオフにし、引数がないときはモードのオン・オフを切り替えます。


File: emacs.info,  Node: State of Difference,  Next: Merge Commands,  Prev: Submodes of Emerge,  Up: Emerge

28.5.3 相違の状態
-----------------

マージバッファーでは、相違は文字‘v’および‘^’のラインでマークされます。各
相違は、以下の7つの状態のうち1つをもちます:

A
     相違にはバージョンAが表示されています。‘a’コマンドは常にこの状態を
     生成します。モードラインには‘A’が示されます。

B
     相違にはバージョンBが表示されています。‘b’コマンドは常にこの状態を
     生成します。モードラインには‘B’が示されます。

default-A
default-B
     選択を行っていないので、相違にはデフォルトとしてAまたはBの状態が表
     示されています。すべての相違はdefault-A状態で開始されます(したがっ
     てマージバッファーはAバッファーのコピーとなります)が、例外として、
     もう一方のほうが“preferred(好ましい)”場合を除きます(以下参照)。

     相違を選択したときに、状態はdefault-Aまたはdefault-Bから、Aまたは
     Bに遷移します。したがって、選択された相違が状態default-Aまたは
     default-Bをもつことはなく、これらの状態がモードラインに表示されるこ
     とはありません。

     コマンド‘d a’は、デフォルトの状態にdefault-Aを選択し、‘d b’は
     default-Bを選択します。これらで選択されるデフォルトは、まだ1度も選
     択していないか、好ましい候補をもたないすべての相違に適用されます。
     順番に移動しながらマージを行っている場合、一度も選択されていない相
     違とは、選択された相違の後のすべての相違です。したがって順番に移動
     しながら、セクションの間で‘d a’と‘d b’を使い分けることにより、マー
     ジバッファーのあるセクションにたいしてはバージョンAをデフォルトに、
     他のセクションにはバージョンBを効果的に選択できます。

prefer-A
prefer-B
     相違には、状態Aまたは状態Bが表示されています。なぜなら、それが
     “preferred(好ましい)”からです。これはまだ明示的な選択を行なっていな
     いが、一方の候補は共通の祖先と同じなので、もう一方の候補の方が正し
     く見えることを意味します。したがってAバッファーが共通の祖先と同じ場
     合、バージョンBの方が好ましいといえます。なぜなら、それは実際に変更
     されているからです。

     これら2つの状態は、モードラインに‘A*’と‘B*’で表示されます。

combined
     ‘x c’または‘x C’コマンドの結果として、相違は状態Aおよび状態Bが混合
     されたものを表示しています。

     相違が1度この状態になると、‘a’コマンドと‘b’コマンドは、数引数を与え
     ないかぎり何もしません。

     モードラインには状態‘comb’が表示されます。


File: emacs.info,  Node: Merge Commands,  Next: Exiting Emerge,  Prev: State of Difference,  Up: Emerge

28.5.4 マージコマンド
---------------------

以下はFastモードのマージコマンドです。Editモードでは前に‘C-c C-c’をつけ
てください:

‘p’
     前の相違を選択します。

‘n’
     次の相違を選択します。

‘a’
     この相違にバージョンAを選択します。

‘b’
     この相違にバージョンBを選択します。

‘C-u N j’
     番号Nの相違を選択します。

‘.’
     ポイントを含む相違を選択します。

‘q’
     終了 — マージを終了します。

‘C-]’
     中断 — マージをexitして出力を保存しません。

‘f’
     Fastモードに移行します(Editモードでは実際には‘C-c C-c f’です)。

‘e’
     Editモードに移行します。

‘l’
     3つのウィンドウにたいして、(‘C-l’のように)再センタリングをします。
     引数を指定すると、デフォルトの3ウィンドウ表示を再構築します。

‘-’
     数引数の一部を指定します。

‘DIGIT’
     これも数引数の一部を指定します。

‘d a’
     ポイント位置からマージバッファーの下方へ、バージョンAをデフォルトと
     して選択します。

‘d b’
     ポイント位置からマージバッファーの下方へ、バージョンBをデフォルトと
     して選択します。

‘c a’
     この相違のバージョンAを、killリングにコピーします。

‘c b’
     この相違のバージョンBを、killリングにコピーします。

‘i a’
     この相違のバージョンAを、ポイント位置に挿入します。

‘i b’
     この相違のバージョンBを、ポイント位置に挿入します。

‘m’
     相違の周囲に、ポイントとマークを配します。

‘^’
     3つのウィンドウすべてを、(‘M-v’のように)下にスクロールします。

‘v’
     3つのウィンドウすべてを、(‘C-v’のように)上にスクロールします。

‘<’
     3つのウィンドウすべてを、(‘C-x <’のように)左にスクロールします。

‘>’
     3つのウィンドウすべてを、(‘C-x >’のように)右にスクロールします。

‘|’
     3つのウィンドウすべての水平スクロールをリセットします。

‘x 1’
     マージウィンドウを1行に縮めます(フルサイズに復元するには‘C-u l’を使
     用します)。

‘x c’
     この相違の2つのバージョンを合成します(*note Combining in Emerge::を
     参照してください)。

‘x f’
     Emergeが操作しているファイルまたはバッファーの名前を、Helpウィンド
     ウに表示します(ウィンドウを復元するには‘C-u l’を使用します)。

‘x j’
     この相違を次の相違に結合します(‘C-u x j’は前の相違に結合します)。

‘x s’
     この相違を2つの相違に分割します。このコマンドを使う前に、3つのバッ
     ファーで、相違を分割したい位置にポイントを配してください。

‘x t’
     相違の上部と下部にある、同じ行を取り除きます。このような行は、バー
     ジョンAとバージョンBが同じでも、それらが祖先となるバージョンと異な
     る場合に発生します。


File: emacs.info,  Node: Exiting Emerge,  Next: Combining in Emerge,  Prev: Merge Commands,  Up: Emerge

28.5.5 Emergeの終了
-------------------

‘q’コマンド(‘emerge-quit’)はマージを終了して、指定されている場合は結果を
出力ファイルに保存します。これはバッファーAおよびBの内容を正しいものに復
元するか、もしそれらがEmergeにより作成され、何も変更されていないときは
killします。これによりマージバッファーでEmergeコマンドは使えなくなります
。なぜならそれらを実行することにより、さまざまなバッファーの内容にダメー
ジを与えるからです。

   ‘C-]’はマージを中断します。これは出力ファイルに書き込まずに終了するこ
とを意味します。出力ファイルを指定していない場合、マージの終了と中断に実
際の違いはありません。

   Emergeコマンドが他のLispプログラムから呼び出された場合、正常終了の戻
り値は‘t’で、中断(abort)のときは‘nil’です。


File: emacs.info,  Node: Combining in Emerge,  Next: Fine Points of Emerge,  Prev: Exiting Emerge,  Up: Emerge

28.5.6 2つのバージョンの合成
----------------------------

特定の相違にたいして両方の候補を使いたいときがあります。これを行なうには
マージバッファーを以下のように編集する‘x c’を使用します:

     #ifdef NEW
     VERSION FROM B BUFFER
     #else /* not NEW */
     VERSION FROM A BUFFER
     #endif /* not NEW */

この例はCプリプロセッサー条件が2つのバージョン候補を区切っていますが、区
切りに使う文字列は、変数‘emerge-combine-versions-template’に選択した文字
列をセットすることにより、指定することができます。この文字列で‘%a’はバー
ジョンA、‘%b’はバージョンBです。上記の結果を生成するデフォルトのセッティ
ングは、以下のようなものです:

     "#ifdef NEW\n%b#else /* not NEW */\n%a#endif /* not NEW */\n"


File: emacs.info,  Node: Fine Points of Emerge,  Prev: Combining in Emerge,  Up: Emerge

28.5.7 Emergeの細かい注意点
---------------------------

マージの間、AおよびBバッファーを自分で編集してはいけません。Emergeは一時
的にこれらを変更しますが、最終的には元の内容に戻します。

   複数のマージを一度に行うことができます — ただし、ある1つのバッファー
を複数のマージの入力として使用しないでください。なぜなら、これらのバッフ
ァーに加えられる一時的な変更が、1つのバッファーに加えられてしまうからで
す。

   ファイル全体を比較する必要があるため、Emergeの開始には時間がかかるこ
ともあります。Emacsは、‘diff’が終了するまで他のことを行なえません。入力
ファイルが大きいときはバックグラウンドで比較を行なうように、誰かが
Emergeを変更するかもしれません — そうなればEmergeがコマンドを受け付けら
れるようになるまでの間、Emacsで他の作業を続けることができるでしょう。

   マージをセットアップした後、Emergeはフック‘emerge-startup-hook’を実行
します。 *note Hooks::を参照してください。


File: emacs.info,  Node: Abbrevs,  Next: Dired,  Prev: Maintaining,  Up: Top

29 abbrev(略語)
***************

定義された“abbrev(abbreviation: 略語の意)”とは、挿入したとき他のテキスト
に“展開”される単語のことです。abbrevは、特別な方法で展開されるようにユー
ザーにより定義されます。たとえば‘foo’を、‘find outer otter’に展開される
ように定義したとします。その後、‘f o o <SPC>’とタイプすることにより、バ
ッファーに‘find outer otter ’を挿入できます。

   略語機能の2番目の種類は、“動的abbrev展開(dynamic abbrev expansion)”と
呼ばれます。ポイントの前の文字で始まる単語をバッファーから探して、その文
字を展開するために、明示的なコマンドで動的abbrev展開を使用します。*note
Dynamic Abbrevs::を参照してください。

   “Hippie(ヒッピー)”展開は、略語展開を一般化したものです。*note Hippie
Expansion: (autotype)Hippie Expand.を参照してください。

* Menu:

* Abbrev Concepts::          定義されたabbrevの基本。
* Defining Abbrevs::         abbrevを定義することにより、タイプしたとき展開されるようになります。
* Expanding Abbrevs::        展開の制御 —
                               プレフィクス、展開の取り消し。
* Editing Abbrevs::          定義されたabbrevのリスト全体の閲覧と編集。
* Saving Abbrevs::           他のセッションのためにabbrevのリスト全体を保存する。
* Dynamic Abbrevs::          すでにバッファーにある単語にたいする略語。
* Dabbrev Customization::    動的abbrevのための単語とは何か。ケースごとの処理。


File: emacs.info,  Node: Abbrev Concepts,  Next: Defining Abbrevs,  Up: Abbrevs

29.1 abbrevの概念
=================

“abbrev”とは、特定の“展開結果”に“展開”されるために定義された単語のことで
す。abbrevの後ろに単語の区切りとなる文字を挿入したとき、それはabbrevを展
開し、abbrevを展開結果に置き換えます。たとえば‘foo’が‘find outer otter’に
展開されるabbrevとして定義された場合、‘f o o .’とタイプすると‘find outer
otter.’が挿入されます。

   abbrevは、バッファーローカルなマイナーモードのAbbrevモードが有効なと
きだけ展開されます。Abbrevモードを無効にすると、定義したabbrevは忘れられ
ますが、再びAbbrevモードを有効にすると展開されます。コマンド‘M-x
abbrev-mode’は、Abbrevモードを切り替えます。数引数を指定した場合、引数が
正のときはAbbrevモードをオン、他の場合はオフに切り替えます。*note Minor
Modes::を参照してください。

   abbrevは、あるメジャーモードのときだけアクティブになる、“モード特有
(mode-specific)”な定義をもつことができます。abbrevは、すべてのメジャーモ
ードでアクティブになる、“グローバル(global)”な定義をもつこともできます。
同じabbrevが、グローバルな定義と、異なるメジャーモードのための、さまざま
なモード特有の定義をもつことができます。カレントのメジャーモードにたいす
るモード特有の定義は、グローバルな定義をオーバーライドします。

   Abbrevモードが有効かにかかわらず、編集セッションの間に対話的に
abbrevを定義できます。後のセッションでリロードして使用するために、ファイ
ルにabbrev定義のリストを保存することもできます。


File: emacs.info,  Node: Defining Abbrevs,  Next: Expanding Abbrevs,  Prev: Abbrev Concepts,  Up: Abbrevs

29.2 abbrevの定義
=================

‘C-x a g’
     ポイントの前の1つ以上の単語を使用して、それが展開結果となるabbrevを
     定義します(‘add-global-abbrev’)。
‘C-x a l’
     同じですが、カレントメジャーモードに特有のabbrevを定義します
     (‘add-mode-abbrev’)。
‘C-x a i g’
     バッファーの単語をabbrevとして定義します
     (‘inverse-add-global-abbrev’)。
‘C-x a i l’
     バッファーの単語を、モード特有のabbrevとして定義します
     (‘inverse-add-mode-abbrev’)。
‘M-x define-global-abbrev <RET> ABBREV <RET> EXP <RET>’
     ABBREVを、EXPに展開されるabbrevとして定義します。
‘M-x define-mode-abbrev <RET> ABBREV <RET> EXP <RET>’
     ABBREVを、EXPに展開されるモード特有のabbrevとして定義します。
‘M-x kill-all-abbrevs’
     すべてのabbrev定義を削除して、白紙状態にします。

   abbrevを定義する通常の方法は、abbrevに展開させたいテキストを入力して
、ポイントをその後ろに配し、‘C-x a g’ (‘add-global-abbrev’)とタイプしま
す。これはミニバッファーを使ってabbrev自身を読み取り、ポイントの前の1つ
以上の単語にたいするabbrevとして定義します。数引数を使用してポイントの前
のいくつの単語が展開結果となるかを指定します。たとえば、上述したabbrevの
‘foo’を定義するには、‘find outer otter’とテキストをタイプしてから、‘C-u
3 C-x a g f o o <RET>’とタイプします。

   ‘C-x a g’の引数に0を指定すると、それは定義するabbrevの展開結果として
、リージョンの内容を使用することを意味します。

   ‘C-x a l’ (‘add-mode-abbrev’)は似ていますが、これはカレントのメジャー
モードにたいする、モード特有のabbrevを定義します。引数の機能は‘C-x a g’と
同じです。

   ‘C-x a i g’ (‘inverse-add-global-abbrev’)と‘C-x a i l’
(‘inverse-add-mode-abbrev’)は、逆のことを行ないます。abbrevとなるテキス
トがすでにバッファーに存在する場合、これらのコマンドはミニバッファーに展
開結果を指定することにより、abbrevを定義します。これらのコマンドは、この
定義を使ってabbrevテキストを展開します。

   abbrevまたは展開結果をバッファーに入力せずに、コマンド
‘define-global-abbrev’で定義することができます。これは2つの引数 —
abbrevと展開結果を読み取ります。コマンド‘define-mode-abbrev’は、モード特
有のabbrevにたいして同様のことを行います。

   abbrevの定義を変更するには、単に新しい定義を作成するだけです。
abbrevがすでに定義をもつ場合、abbrev定義コマンドはそれを置換する前に確認
を求めます。

   abbrev定義を削除するには、‘C-u - C-x a g’や‘C-u - C-x a l’のように、
abbrev定義コマンドに負の引数を与えます。前者はグローバルな定義を削除し、
後者はモード特有の定義を削除します。‘M-x kill-all-abbrevs’は、すべての
abbrevにたいしてグローバルとローカルの両方の定義を削除します。


File: emacs.info,  Node: Expanding Abbrevs,  Next: Editing Abbrevs,  Prev: Defining Abbrevs,  Up: Abbrevs

29.3 abbrev展開の制御
=====================

Abbrevモードが有効な場合、バッファーのポイントの前にabbrevがあり、そこで
自己挿入文字として空白文字か区切り文字(<SPC>やカンマなど)を挿入したとき
は、常にabbrevが展開されます。より正確には、単語を構成しない任意の文字は
abbrevを展開し、単語を構成する任意の文字はabbrevの一部となります。もっと
も一般的なabbrevの使用法は、まずabbrevを挿入し、それから区切り文字か空白
文字を挿入してabbrevを展開する方法です。

   abbrevの展開は、大文字小文字を維持します。つまり‘foo’は‘find outer
otter’に、‘Foo’は‘Find outer otter’に展開されます。デフォルトでは‘FOO’は
‘Find Outer Otter’に展開されますが、変数‘abbrev-all-caps’を非‘nil’値に変
更した場合は、‘FIND OUTER OTTER’に展開されます。

   以下はabbrevの展開を制御するコマンドです:

‘M-'’
     プレフィクスと、その後の展開されるabbrevを分割します
     (‘abbrev-prefix-mark’)。
‘C-x a e’
     ポイントの前のabbrevを展開します。(‘expand-abbrev’)。これはAッbレ
     vモードが有効でなくても効果があります。
‘M-x expand-region-abbrevs’
     リージョンで見つかったいくつか、またはすべてのabbrevを展開します。

   abbrevを展開して、その展開結果にプレフィクスをつけたい場合があるかも
しれません。たとえば、‘cnst’が‘construction’に展開されるとき、これを使っ
て‘reconstruction’を入力したいと思うかもしれません。しかし、‘recnst’とタ
イプしてもうまくいきません。なぜなら、それがabbrevとして定義される必要が
あるからです。これは、プレフィクス‘re’とabbrevの‘cnst’の間で、コマンド
‘M-'’ (‘abbrev-prefix-mark’)を使うことにより行なうことができます。最初に
まず‘re’を挿入します。そこで‘M-'’をタイプします。これにより、コマンドが
機能していることを示すためバッファーにハイフンが挿入されます。その後、
abbrevの‘cnst’を入力します。このときバッファーには‘re-cnst’が含まれます
。そこで単語を構成しない文字を挿入すると、abbrevの‘cnst’が
‘construction’に展開されます。この展開ステップでは、‘M-'’が使用中である
ことを示していたハイフンも削除されます。結果は期待した通り
‘reconstruction’となります。

   abbrevを展開せずにabbrevのテキストをバッファーに残したい場合、
abbrevの後ろの区切り文字を‘C-q’で挿入して、これを行なうことができます。
したがって‘foo C-q ,’とタイプすると、それは展開されず、バッファーには
‘foo,’が残ります。

   間違ってabbrevを展開した場合、‘C-/’ (‘undo’)で展開をアンドゥできます
。これはabbrev展開による挿入をアンドゥし、それをabbrevテキストに戻します
。期待する結果が展開されないabbrevと終端となる非単語文字の場合、‘C-q’で
クォートして終端文字を再挿入しなければなりません。‘M-x unexpand-abbrev’を
使えば終端文字を削除せずに、最後の展開を取り消すことができます。

   ‘M-x expand-region-abbrevs’は、リージョン内の定義されたabbrevを検索し
、見つかったabbrevそれぞれにたいして、abbrevを展開結果に置き換えるか尋ね
ます。このコマンドはabbrevを使ってテキストを挿入したが、最初にAbbrevモー
ドをオンにするのを忘れたときに便利です。これは特別なabbrev定義のセットで
、複数のグローバルな置き換えを一度に行なうときにも便利です。このコマンド
は、Abbrevモードが有効でなくても効果があります。

   関数‘expand-abbrev’は、‘abbrev-expand-function’が指定する関数を呼び出
すことにより展開を行ないます。この関数を変更することにより、abbrevの展開
を自由に変更できます。*note (elisp)Abbrev Expansion::を参照してください
。


File: emacs.info,  Node: Editing Abbrevs,  Next: Saving Abbrevs,  Prev: Expanding Abbrevs,  Up: Abbrevs

29.4 abbrevのテストと編集
=========================

‘M-x list-abbrevs’
     すべてのabbrev定義のリストを表示します。数引数を指定した場合は、ロ
     ーカルなabbrevのリストだけを表示します。
‘M-x edit-abbrevs’
     abbrevのリストを編集します。定義の追加、変更、削除ができます。

   ‘M-x list-abbrevs’の出力は以下のようなものです:

     他のさまざまなテーブル...
     (lisp-mode-abbrev-table)
     "dk"          0    "define-key"
     (global-abbrev-table)
     "dfn"         0    "definition"

(空行に意味はありません。また他のabbrevテーブルは省略しています。)

   カッコで括られた名前を含む行は、特定のabbrevテーブルのabbrevにたいす
るヘッダーです。‘global-abbrev-table’はすべてのグローバルなabbrevを含み
、その他のメジャーモードの後ろについたabbrevテーブルは、モード特有の
abbrevを含みます。

   それぞれのabbrevテーブルで、空行でない行は1つのabbrevの定義です。行の
先頭の単語はabbrevです。その後ろの数字は、そのabbrevが展開された回数です
。Emacsはこれを追跡することにより、実際に使用されているabbrevを調べて、
ときどきしか使わないものを削除するのを助けます。行の最後の文字列は
abbrevの展開結果です。

   ‘(sys)’とマークされているabbrevもいくつかあります。これらは“system”の
abbrevで、さまざまなモードにたいして事前に定義されており、ユーザーの
abbrevファイルには保存されません(*note (elisp)Abbrevs::を参照してくださ
い)。“system”のabbrevを無効にするには、同じ名前で展開結果がabbrev自身と
同じになるabbrevを定義し、それをabbrevファイルに保存してください。

   ‘M-x edit-abbrevs’を使うと、Emacsバッファーでabbrevのリストを編集する
ことにより、abbrev定義の追加、変更、killができます。リストの書式は、上記
で説明した書式を同じです。abbrevのバッファーは‘*Abbrevs*’と呼ばれ、モー
ドはEdit-Abbrevsモードです。このバッファーで‘C-c C-c’をタイプすると、そ
のバッファーで指定されたabbrev定義がインストールされ、リストに定義されて
いないabbrevは削除されます。

   コマンド‘edit-abbrevs’は、実際には‘list-abbrevs’と同じですが、
‘list-abbrevs’が単に‘*Abbrevs*’を他のウィンドウに表示するのに比べ、この
コマンドはそのバッファーを選択する点が異なります。


File: emacs.info,  Node: Saving Abbrevs,  Next: Dynamic Abbrevs,  Prev: Editing Abbrevs,  Up: Abbrevs

29.5 abbrevの保存
=================

以下のコマンドにより、編集セッション間でabbrev定義を維持できます。

‘M-x write-abbrev-file <RET> FILE <RET>’
     すべてのabbrev定義の記述を、ファイルFILEに書き込みます。
‘M-x read-abbrev-file <RET> FILE <RET>’
     ファイルFILEを読み込み、そこで指定されているabbrevを定義します。
‘M-x define-abbrevs’
     カレントバッファーの定義からabbrevを定義します。
‘M-x insert-abbrevs’
     すべてのabbrevとそれらの展開結果を、カレントバッファーに挿入します
     。

   ‘M-x write-abbrev-file’は、ミニバッファーを使用してファイル名を読み取
り、すべてのカレントのabbrev定義の記述を、そのファイルに書き込みます。こ
れは後のセッションで使用するために、abbrev定義を保存するのに使われます。
ファイルに保存されるテキストは一連のLisp式で、それが実行されると保存した
ときと同じabbrevを定義します。

   ‘M-x read-abbrev-file’は、ミニバッファーを使用してファイル名を読み取
り、ファイル内容に対応するabbrevを定義します。関数
‘quietly-read-abbrev-file’も同様ですが、これはエコーエリアにメッセージを
表示しません。これを対話的に呼び出すことはできず、主にinitファイル(*note
Init File::を参照してください)で使用されます。どちらの関数も引数に
‘nil’が指定されると、変数‘abbrev-file-name’で与えられるファイルを使用し
ます。この変数のデフォルトは‘~/.emacs.d/abbrev_defs’です。これは標準の
abbrev定義ファイルで、Emacsは起動時にこのファイルから自動的にabbrevをロ
ードします(例外としてEmacsがバッチモードで開始されたときはabbrevファイル
をロードしません。バッチモードについての説明は、*note Initial Options::を
参照してください)。

   abbrevのどれかを変更した場合、Emacsは((‘C-x s’や‘C-x C-c’などで)、す
べてのファイルの保存するか尋ねるときにabbrevについても尋ねます。これは
‘abbrev-file-name’で指定したファイルに、それらを保存します。この機能は変
数‘save-abbrevs’を‘nil’にセットすることにより抑止できます。

   コマンド‘M-x insert-abbrevs’および‘M-x define-abbrevs’は、前のコマン
ドと似ていますが、Emacsバッファーのテキストにたいして機能します。‘M-x
insert-abbrevs’は、カレントのabbrev定義の記述をカレントバッファーのポイ
ントの後ろにテキストとして挿入します。‘M-x define-abbrevs’は、カレントバ
ッファー全体を解析して、対応するabbrevを定義します。


File: emacs.info,  Node: Dynamic Abbrevs,  Next: Dabbrev Customization,  Prev: Saving Abbrevs,  Up: Abbrevs

29.6 動的abbrev展開
===================

上記で説明したabbrev機能は、テキストの挿入にしたがい自動的に処理されます
が、すべてのabbrevを明示的に定義しなければなりません。対照的に、“動的
abbrev(dynamic abbrevs)”は、バッファーの内容から略語の展開結果を自動的に
決定することができます、しかし動的abbrevの展開は、明示的に要求したときだ
け行なわれます。

‘M-/’
     バッファーのポイントの前の単語を“動的abbrev”として、その略語で始ま
     る単語をバッファーから検索することにより展開します
     (‘dabbrev-expand’)。

‘C-M-/’
     ポイントの前の単語を動的abbrevとして補完します
     (‘dabbrev-completion’)。

   たとえばバッファーが‘does this follow ’が含んでいて、‘f o M-/’とタイ
プすると、これは‘follow’を挿入します。なぜならそれが‘fo’で始まる、そのバ
ッファーの最後の単語だからです。‘M-/’に数引数を指定すると、それはポイン
トから後方に検索して2番目、3番目、...の異なる展開結果を検索します。
‘M-/’を繰り返すと他の展開結果を後方に検索します。ポイントの前のテキスト
をすべて検索した後は、ポイントの後のテキストを検索します。変数
‘dabbrev-limit’が非‘nil’の場合、それはバッファーの中で展開結果を探す範囲
を指定します。

   カレントバッファーを検索した後、‘dabbrev-check-all-buffers’を‘nil’に
セットしていなければ、通常‘M-/’は他のバッファーを検索します。

   どのバッファーを検索するかを制御するには、変数
‘dabbrev-ignored-buffer-regexps’をカスタマイズします。この変数の値は正規
表現のリストです。バッファー名がこれらの正規表現のどれかにマッチした場合
、動的abbrev展開はそのバッファーをスキップします。

   ‘C-u - M-/’のように‘M-/’に負の引数を指定すると、これは最初にポイント
の後ろの展開結果を検索し、その後は他のバッファーを検索し、ポイントの前の
展開結果は最後に報告します。他の展開結果を探すために‘M-/’を繰り返す場合
は、引数に何もしていしないでください。‘M-/’を繰り返すことにより、ポイン
トの後、その後はポイントの前の展開結果を巡回します。

   動的abbrevを展開した後、その展開結果の元のコンテキストで展開結果の後
ろに続く、追加の単語をコピーすることができます。コピーしたい追加の単語ご
とに、単に‘<SPC> M-/’とタイプします。単語間のスペースおよび区切り文字は
、単語とともにコピーされます。

   コマンド‘C-M-/’ (‘dabbrev-completion’)は、動的abbrevの補完を行ないま
す。利用可能な展開結果を1つずつ試すかわりに、これはすべてを検索して、そ
れらがもつ共通のテキストを挿入します。共通部分がない場合、‘C-M-/’は、通
常の方法で選択することができる補完リストを表示します。*note
Completion::を参照してください。

   動的abbrev展開は、Abbrevモードとは完全に独立しています。‘M-/’での単語
の展開は、その単語が通常のabbrevとして定義されていることとは無関係です。


File: emacs.info,  Node: Dabbrev Customization,  Prev: Dynamic Abbrevs,  Up: Abbrevs

29.7 動的abbrevのカスタマイズ
=============================

動的abbrev展開は通常、展開結果の検索で大文字小文字を無視します。したがっ
て、展開結果と展開する単語は、大文字小文字が一致する必要はありません。

   この機能は変数‘dabbrev-case-fold-search’により制御されます。この値が
‘t’の場合、検索で大文字小文字は無視されます。‘nil’の場合、単語と展開結果
は大文字小文字が一致していなければなりません。値が‘case-fold-search’(デ
フォルト)の場合、変数‘case-fold-search’が展開結果の検索で、大文字小文字
を無視するかどうかを制御します(*note Search Case::を参照してください)。

   動的abbrev展開は通常、大文字小文字のパターンにしたがって展開結果を変
換することにより、_展開する動的abbrev_の大文字小文字のパターンを維持しま
す。

   変数‘dabbrev-case-replace’は、動的abbrevの大文字小文字のパターンを維
持するかどうかを制御します。この値が‘t’の場合、動的abbrevの大文字小文字
のパターンはほとんどのケースで維持されます。‘nil’の場合、展開結果は常に
そのままコピーされます。値が‘case-replace’(デフォルト)の場合、変数
‘case-replace’が展開結果をそのままコピーするかどうかを制御します(*note
Replacement and Case::を参照してください)。

   しかし、展開結果が複雑にミックスされた大文字小文字のパターンを含む場
合、そして動的abbrevがそのパターンにある程度マッチする場合、これらの変数
の値にかかわらず、展開結果は常にそのままコピーされます。したがって、たと
えばバッファーが‘variableWithSillyCasePattern’というテキストを含む場合、
‘v a M-/’とタイプすると、大文字小文字のパターンを含めて展開結果をコピー
します。

   変数‘dabbrev-abbrev-char-regexp’が非‘nil’の場合、これは動的展開の目的
のために、どの文字を単語の一部とするかを制御します。正規表現は2文字以上
ではなく、ただ1文字だけにマッチしなければなりません。同じ正規表現が、ど
の文字が展開結果の一部となるかも決定します。値が‘nil’の場合は特別な意味
をもちます。動的abbrevは単語構成文字から構成されますが、展開結果は単語と
シンボル文字から構成されます。

   シェルスクリプトおよびmakefileでは、変数名にプレフィクス‘$’があるとき
と、ないときがあります。このタイプのテキストのためのメジャーモードは、オ
プションのプレフィクスを扱うために、変数
‘dabbrev-abbrev-skip-leading-regexp’をセットして、動的abbrev展開をカスタ
マイズできます。この値には、動的abbrev展開が無視すべきオプションのプレフ
ィクスにマッチする正規表現を指定します。

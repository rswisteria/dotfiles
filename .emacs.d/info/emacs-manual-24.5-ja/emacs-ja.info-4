This is emacs-ja.info, produced by makeinfo version 6.1 from emacs.texi.

This is the ‘GNU Emacs Manual’, updated for Emacs version 24.5.

   Copyright © 2015–2016 Ayanokoji Takesi <ayanokoji.takesi@gmail.com>
Copyright © 1985–1987, 1993–2015 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “The GNU Manifesto,”
     “Distribution” and “GNU GENERAL PUBLIC LICENSE,” with the
     Front-Cover Texts being “A GNU Manual,” and with the Back-Cover
     Texts as in (a) below.  A copy of the license is included in the
     section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs: (emacs).            拡張可能なセルフドキュメント形式のテキストエディター。
END-INFO-DIR-ENTRY


File: emacs-ja.info,  Node: Modifying Fontsets,  Next: Undisplayable Characters,  Prev: Defining Fontsets,  Up: International

22.15 フォントセットの修正
==========================

常にフォントセットをスクラッチから作成する必要はありません。軽微な変更だ
けが必要なときは、既存のフォントセットを修正するのが簡単な方法でしょう。
‘fontset-default’の修正は、それをフォールバックに使用する他のフォントセ
ットにも影響するので、特定のスクリプトのためにEmacsが選択するフォントに
関する問題を解決する、効果的な方法になり得ます。

   フォントセットは関数‘set-fontset-font’を使って、文字、文字セット、ス
クリプトフォントを修正する文字範囲、使用されるフォントの指定を修正するこ
とができます。以下は例です:

     ;; Use Liberation Mono for latin-3 charset.
     (set-fontset-font "fontset-default" 'iso-8859-3
                       "Liberation Mono")

     ;; Prefer a big5 font for han characters
     (set-fontset-font "fontset-default"
                       'han (font-spec :registry "big5")
                       nil 'prepend)

     ;; Use DejaVu Sans Mono as a fallback in fontset-startup
     ;; before resorting to fontset-default.
     (set-fontset-font "fontset-startup" nil "DejaVu Sans Mono"
                       nil 'append)

     ;; Use MyPrivateFont for the Unicode private use area.
     (set-fontset-font "fontset-default"  '(#xe000 . #xf8ff)
                       "MyPrivateFont")



File: emacs-ja.info,  Node: Undisplayable Characters,  Next: Unibyte Mode,  Prev: Modifying Fontsets,  Up: International

22.16 表示できない文字
======================

あなたの端末では表示できない非ASCII文字が、いくつか存在するかもしれませ
ん。ほとんどのテキスト端末は、1つの文字セットだけをサポートします
(Emacsに何を使うか指示するには、変数‘default-terminal-coding-system’を使
用します。*note Terminal Coding::を参照してください)。そのコーディングシ
ステムではエンコードできない文字は、デフォルトでは‘?’と表示されます。

   グラフィカルなディスプレーでは、より広範囲の文字を表示できますが、そ
れらすべてのフォントがインストールされていないかもしれません。フォントが
ない文字は、中空のボックスで表示されます。

   Latin-1文字を使用するとき、端末がLatin-1を表示できない場合、かわりに
ニーモニックASCIIシーケンスを表示できます。たとえばo-umlautのかわりに
‘"o’が表示されます。これを行うには‘iso-ascii’をロードします。

   端末がLatin-1を表示できる場合、Latin-1と等しい文字とASCIIニーモニック
を混交して、他のEuropean文字セットを表示できます。これは変数
‘latin1-display’をカスタマイズすることにより有効になります。ニーモニック
ASCIIシーケンスは、ほとんどがインプットメソッドのプレフィクスに対応しま
す。


File: emacs-ja.info,  Node: Unibyte Mode,  Next: Charsets,  Prev: Undisplayable Characters,  Up: International

22.17 Unibyte編集モード
=======================

ISO 8859 Latin-N文字セットは、さまざまなEuropean言語で必要とされるアクセ
ント文字と区切り文字を扱うために、8進の0240から0377(10進の160から250)の
範囲の文字コードを定義しています。Emacsはこの範囲のバイトを、たとえ
unibyteバッファー(たとえばマルチバイト文字を無効にしている場合)でも、そ
れらを文字としてではなく、rawバイトとみなします。しかし、それでもEmacsは
これらの文字コードを、あたかも_1つ_も1バイト文字セットに属するかのように
1度に扱うことができます。これらのコードの_どれ_を使うかを指定するには、
‘M-x set-language-environment’を呼び出して、‘Latin-N’のような適切な言語
環境を指定します。*note Disabling Multibyte Characters: (elisp)Disabling
Multibyte.を参照してください。

   端末や使っているフォントがこれらの文字をサポートしている場合、Emacsは
160から255の文字を読み取り可能な文字として表示できます。これは自動的に行
われます。グラフィカルなディスプレーでは、Emacsはフォントセットを通じて
1バイト文字として表示できます。これは現在の言語環境で、それらに対応する
マルチバイト文字を表示することにより行われます。これを行うには、変数
‘unibyte-display-via-language-environment’に非‘nil’値を設定します。この
セッティングは、これらのバイトを表示する方法だけに影響しますが、Emacsが
それらを文字としてではなくrawバイトとして扱うという基礎事実は変わらない
ことに注意して下さい。

   端末でLatin-1文字セットを表示できない場合、Emacsはこれらの文字をその
文字が少なくとも何であるかを明確に理解できるような、ASCIIシーケンスとし
て表示できます。これを行うには、ライブラリー‘iso-ascii’をロードします。
他のLatin-N文字セットに対しても似たようなライブラリを実装できますが、こ
れは まだ行われていません。

   通常、非ISO 8859文字セット(10進文字の128から159のコードも含む)は、8進
でエスケープ表示されます。ライブラリー‘disp-table’の関数
‘standard-display-8bit’を使うことにより、非標準の“拡張”バージョンのISO
8859文字セットに変更できます。

   1バイトの非ASCII文字を入力する2つの方法があります:

   • 選択した言語環境のインプットメソッドを使用することができます。*note
     Input Methods::を参照してください。unibyteバッファーでインプットメ
     ソッドを使用した場合、入力した非ASCII文字は、ユニバイトに変換されま
     す。

   • キーボードが、非ASCII文字を表現する(10進の)128以上の文字コードを生
     成できるならば、それらの文字コードを直接タイプすることができます。

     グラフィカルなディスプレーでは、これらのキーを使うのに特別なことを
     する必要はありません。それらは単純に機能するでしょう。テキスト端末
     では、コマンド‘M-x set-keyboard-coding-system’を使うか、変数
     ‘keyboard-coding-system’をカスタマイズして、キーボードが使用するコ
     ーディングシステムを指定します(*note Terminal Coding::を参照してく
     ださい)。この機能を有効にすることにより、おそらくMeta文字を入力する
     ために<ESC>を使う必要が生じるでしょう。しかし、コンソール端末、また
     は‘xterm’では、Metaを<ESC>にアレンジすることが可能です。また8ビット
     文字を直接キーボードから入力したり、<Compose>キーや<AltGr>キーを使
     うこともできます。*note User Input::を参照してください。

   • Latin-1にたいしてだけですが、非ASCIIのLatin-1のプリント文字入力の
     “合成文字”プレフィックスとして‘C-x 8’を使用できます。‘C-x 8’は、(ミ
     ニバッファーや他のバッファーでの)挿入、検索、キーシーケンスが許され
     る他のコンテキストなどで使用できます。

     ライブラリー‘iso-transl’をロードすることにより‘C-x 8’は機能します。
     1度ライブラリーをロードすると、<Alt>修飾キーがある場合は、‘C-x 8’と
     同じ目的で使用できます。後続の文字を修飾するには、アクセント文字と
     一緒に<Alt>を使用します。さらにLatin-1の“専用アクセント文字”キーが
     あると、1度‘iso-transl’をロードした後は、それらのキーも後続の文字を
     合成するように定義されます。

     ‘C-x 8 C-h’を使用すると、利用可能なすべての‘C-x 8’翻訳を一覧します
     。


File: emacs-ja.info,  Node: Charsets,  Next: Bidirectional Editing,  Prev: Unibyte Mode,  Up: International

22.18 文字セット
================

Emacsでは“文字セット(character set)”を縮めて、“charset”と呼びます。
Emacsは、ほとんどの有名なcharsets(‘ascii’、‘iso-8859-1’、‘cp1250’、
‘big5’、‘unicode’など)に加えて、Emacs自身のcharsets(‘emacs’、
‘unicode-bmp’、‘eight-bit’など)をサポートします。すべてのサポートされた
文字は、1つ以上のcharsetsに属します。

   Emacsは通常、charsetsにたいして“正しいことを行う(does the right
thing)”ので、あなたはそれらを心配する必要はありません。しかし、
charsetsの背景の詳細を知ることが助けになる場合もあります。

   1つの例はフォント選択です(*note Fonts::を参照してください)。それぞれ
の言語環境(*note Language Environments::を参照してください)は、さまざま
な文字にたいする“優先リスト(priority list)”を定義します。フォントを検索
するとき、Emacsは最初に一番優先度の高いcharsetsを表示できるものを探すこ
とを試みます。たとえばJapanese言語環境では、charsets
‘japanese-jisx0208’は一番高い優先度をもっているので、Emacsは‘registry’プ
ロパティーが‘JISX0208.1983-0’のフォントの使用を試みます。

   charsetsに関する情報を得るのに使うことができるコマンドが2つあります。
コマンド‘M-x list-charset-chars’はcharset名の入力を求め、その文字セット
のすべての文字を表示します。コマンド‘M-x describe-character-set’は
charset名の入力を求め、Emacsでの内部表現も含めたそのcharsetに関する情報
を表示します。

   ‘M-x list-character-sets’は、すべてのサポートされたcharsetsを表示しま
す。このリストはcharsetsの名前と、各charsetを識別する追加の情報を与えま
す。詳細は、International Register of Coded Character Sets
(http://www.itscj.ipsj.or.jp/ISO-IR/)を参照してください。このリストでは
、charsetsは2つのカテゴリーに分かれています。“通常のcharsets(normal
charsets)”が最初にリストされ、その後に“追加のcharsets(supplementary
charsets)”が続きます。追加のcharsetは他のcharsetを定義するのに(サブセッ
トの親として)使用されるか、古いバージョンのEmacsとの互換性のために提供さ
れます。

   バッファーの文字がどのcharsetに属するか探すには、ポイントをその文字の
前において、‘C-u C-x =’をタイプします(*note International Chars::を参照
してください)。


File: emacs-ja.info,  Node: Bidirectional Editing,  Prev: Charsets,  Up: International

22.19 双方向の編集
==================

EmacsはArabicやHebrewのような、テキストを水平方向の右から左に記述するス
クリプトで書かれたテキストの編集をサポートします。しかし数字やそれらのス
クリプトに埋め込まれたLatinテキストは、左から右に表示されます。Latin文書
の中に少量のArabicやHebrewのテキスト部分が含まれている場合も、稀ではあり
ません(例: プログラムソース内のコメントや文字列)。これらの理由により、こ
れらのスクリプトを使うテキストは、実際には“双方向(bidirectional)”、つま
りそれらはleft-to-right(左から右)の文字とright-to-left(右から左)文字の混
交されたものになります。

   このセクションでは、双方向テキストを編集するためにEmacsが提供する機能
とオプションを説明します。

   Emacsはright-to-leftおよび双方向テキストを、いわゆる“logical”順(また
は“reading”順)で格納します。バッファーまたは文字列の最初の文字の位置は、
次に読む文字の前になります。双方向テキストを“visual”順に再配置するには、
表示時間が発生します。結果として文字の位置は、それらが表示される位置にた
いして単調に増加しなくなります。Emacsは表示のための双方向テキストの再配
置を、Unicode Standard Annex #9で説明されているUnicode Bidirectional
Algorithmで実装しています。

   バッファーローカルな変数‘bidi-display-reordering’は、表示用にバッファ
ーのテキストを再配置するかどうかを制御します。この変数の値が非‘nil’の場
合、Emacsは右から左の方向に表示される文字を再配置します。デフォルト値は
‘t’です。

   双方向テキストの各パラグラフは、それ自身の“base direction(基本方向
)”をもっており、それはright-to-leftまたはleft-to-rightです(パラグラフの
境界は空行、たとえば行全体が空白文字の行などです)。left-to-rightのパラグ
ラフはスクリーンの左端から開始し、右端に到達すると切り詰め、または継続さ
れます。対照的にright-to-leftのパラグラフのテキストは右端から開始し、左
端で継続、または切り詰められて表示されます。

   Emacsは、パラグラフを開始するテキストにもとづいて、各パラグラフの基本
方向を動的に決定します。しかし、バッファーのパラグラフにたいして特定の基
本方向を強制する必要もあるでしょう。変数‘bidi-paragraph-direction’が非
‘nil’の場合、これは基本方向の動的な決定を無効にして、バッファーのすべて
のパラグラフの方向を、このバッファーローカルな値で指定された方向に強制し
ます。値には‘right-to-left’と‘left-to-right’が指定できます。これ以外の値
は‘nil’と解釈されます。

   かわりにパラグラフの先頭に特別な文字を挿入することにより、パラグラフ
の基本方向を制御できます。特別な文字‘RIGHT-TO-LEFT MARK’またはRLMは、以
降に続くパラグラフをright-to-left方向に強制します。その効果は
‘LEFT-TO-RIGHT MARK’またはLRMによりleft-to-right方向に再強制されるまで続
きます(‘C-x 8 <RET>’を使ってこれらの文字を挿入できます)。GUIセッションで
はLRM文字およびRLM文字は、極端に細いスペースで表示されます。テキスト端末
では、それらはスペースで表示されます。

   文字は表示用に再配置されるので、logical順で処理を行うEmacsコマンドや
バッファーの拡大は、普通とは異なる効果を生みます。たとえばコマンド
‘C-f’および‘C-b’はポイントをlogical順で移動するので、再配置された双方向
テキストではポイントがジャンプすることがあります。同様に隣接する文字位置
の範囲をカバーするハイライトされたリージョンは、リージョンが再配置された
テキストにかかる場合には不連続に見える場合があります。これは双方向テキス
トをサポートする他のプログラムの振る舞いとしては普通であり、似通っていま
す。‘visual-order-cursor-movement’を非‘nil’値にセットした場合、矢印キー
によるカーソル移動は、スクリーンでのvisual順にしたがいます(*note
visual-order movement: Moving Point.を参照してください)。


File: emacs-ja.info,  Node: Modes,  Next: Indentation,  Prev: International,  Up: Top

23 メジャーモードとマイナーモード
*********************************

Emacsには多くの“編集用モード(editing modes)”が含まれており、これは基本的
な振る舞いを、編集に便利な方法に変更します。これらの編集用モードは“メジ
ャーモード(major modes)”と“マイナーモード(minor modes)”に分けられます。

   メジャーモードは、Cソースファイル(*note Programs::を参照してください
)などの特定のファイルタイプや、shellバッファー(*note Shell::を参照してく
ださい)などの、特別なタイプの非ファイルバッファーにたいして作業するため
の特別な機能を提供します。メジャーモードは互いに排他であり、各バッファー
は常に1つのメジャーモードをもちます。

   マイナーモードはオンとオフを切り替えることができるオプションの機能で
、ファイルやバッファーのタイプに特定する必要はありません。たとえばAuto
Fillモードは、単語の間にタイプした<SPC>で行を区切るマイナーモードです
(*note Auto Fill::を参照してください)。マイナーモードは互いに独立してい
て、選択されたメジャーモードからも独立しています。

* Menu:

* Major Modes::              Textモード vs. Lispモード
                               vs. Cモード...
* Minor Modes::              マイナーモードは他と独立して有効にできる機能です。
* Choosing Modes::           ファイルをvisitしたときにモードが選択される方法。


File: emacs-ja.info,  Node: Major Modes,  Next: Minor Modes,  Up: Modes

23.1 メジャーモード
===================

すべてのバッファーはメジャーモードをもっており、そのバッファーがカレント
である間の編集の動作を決定します。モードラインには通常カレントのメジャー
モード名がカッコ内に表示されます(*note Mode Line::を参照してください)。

   もっとも特殊化されていないメジャーモードは、“Fundamental(基本)モード
”と呼ばれます。このモードには、モード独自の再定義や変数設定がないので、
各Emacsコマンドはもっとも一般的な振る舞いをし、各ユーザーオプションはデ
フォルトの状態になっています。

   Lispや英文テキストのように、Emacsが認識できる特定のタイプのテキスト編
集には、LispモードやTextモードのような、より特殊化されたメジャーモードを
通常は使用します。ほとんどのメジャーモードは3つのグループに分けられます
。最初のグループはプレインまたはマークアップされた通常テキストのためのモ
ードを含みます。これにはTextモード、HTMLモード、SGMLモード、TeXモードや
Outlineモードなどが含まれます。2番目のグループはプログラミング言語特有の
モードです。これらは、Lispモード(いくつかの変種を有する)、Cモード、
Fortranモードなどが含まれます。3番目のグループはファイルに直接関連付けら
れていないメジャーモードが含まれます。これらはEmacsが特別の目的のために
作るバッファーで使用されるもので、Diredが作成するバッファーのための
Diredモード(*note Dired::を参照してください)、‘C-x m’で作成されるバッフ
ァーのためのMessageモード(*note Sending Mail::を参照してください)、下位
のシェルプロセスとの通信用のバッファーのためのShellモード(*note
Interactive Shell::を参照してください)などが含まれます。

   通常、メジャーモードは最初にファイルをvisitしたとき、またはバッファー
を作成したときに、Emacsにより自動的にセットされます。‘M-x’コマンドを使う
ことにより、新しいメジャーモードを明示的に選択することができます。モード
の名前に‘-mode’を追加することにより、モードを選択するコマンド名を得るこ
とができます(たとえば、Lispモードを選択する場合は‘M-x lisp-mode’)。

   バッファーローカルな変数‘major-mode’の値は、メジャーモードコマンドと
同じ名前のシンボル(たとえば‘lisp-mode’)です。この変数は自動的にセットさ
れます。あなた自身が変更するべきではありません。

   ‘major-mode’のデフォルト値は、メジャーモードが指定されていないファイ
ルを使うときや、‘C-x b’で作成した新しいバッファーのメジャーモードを決定
します。通常、デフォルト値はFundamentalモードを指定する、シンボル
‘fundamental-mode’です。Customizationインターフェースを通じて、このデフ
ォルト値を変更できます(*note Easy Customization::を参照してください)。
initファイルに以下のような行を追加しても変更できます(*note Init File::を
参照してください):

     (setq-default major-mode 'text-mode)

‘major-mode’のデフォルト値が‘nil’の場合、メジャーモードは前のカレントバ
ッファーから引き継がれます。

   特殊化されたメジャーモードは、特定のキーにたいして、そのモードにより
適した何かを行うよう、意味づけが変更される場合があります。たとえばプログ
ラミングに関連するモードでは、<TAB>には、カレント行をその言語のルールに
したがってインデントする機能がバインドされます(*note Indentation::を参照
してください)。一般的に変更されるキーは<TAB>、<DEL>、‘C-j’です。多くのモ
ードがモード自身の特別なコマンドを定義しており、それらは通常、プレフィク
スキーが‘C-c’のコマンドにバインドされます。メジャーモードはユーザーオプ
ションと変数も変更できます。たとえばプログラミングに間するモードは通常、
変数‘comment-start’にバッファーローカルな値をセットします。これはソース
コードのコメントがどのように区切られるかを決定します(*note Comments::を
参照してください)。

   カレントメジャーモードのキーバインディング一覧も含めたドキュメントを
閲覧するには、‘C-h m’ (‘describe-mode’)とタイプします。

   Fundamentalモード以外のすべてのメジャーモードは、“モードフック(mode
hook)”を定義します。これはバッファーでそのモードが有効になるたびに実行さ
れる、カスタマイズ可能なLisp関数のリストです。フックに間する詳細は、
*note Hooks::を参照してください。各モードフックはメジャーモード名の後に
名前がつけられます。たとえばFortranモードのモードフックは、
‘fortran-mode-hook’です。さらにすべてのテキストベースのメジャーモードは
、‘text-mode-hook’、すべてのプログラミング言語のモードは、その言語モード
自身のモードフックの前に、‘prog-mode-hook’を実行します。フック関数は変数
‘major-mode’の値を調べて、どのモードに入ろうとしているか調べることができ
ます。

   モードフックは、一般的にマイナーモードを有効にするために使用されます
(*note Minor Modes::を参照してください)。たとえば以下の行をinitファイル
に記述すると、すべてのテキストベースのメジャーモードでFlyspellマイナーモ
ード(*note Spelling::を参照してください)を、Emacs LispモードでEldocマイ
ナーモード(*note Lisp Doc::を参照してください)を有効にすることができます
:

     (add-hook 'text-mode-hook 'flyspell-mode)
     (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)


File: emacs-ja.info,  Node: Minor Modes,  Next: Choosing Modes,  Prev: Major Modes,  Up: Modes

23.2 マイナーモード
===================

マイナーモードは明確な方法でEmacsの動作を変更する、オプションの編集用モ
ードです。メジャーモードとは異なり、いつでも任意の数のマイナーモードを有
効にできます。いくつかのマイナーモードは“バッファーローカル
(buffer-local)”で、特定のバッファーにたいしてオン(有効)にして、他のバッ
ファーではオフ(無効)に切り替えることができます。それ以外のマイナーモード
は“グローバル(global)”で、それが有効な間はEmacsセッションのすべてのバッ
ファーで行う、すべての操作に影響します。ほとんどのマイナーモードはデフォ
ルトで無効ですが、デフォルトで有効なものもいくつかあります。

   ほとんどのバッファーローカルなマイナーモードは、モードラインのメジャ
ーモード標識のすぐ後ろに有効であることを示します。たとえばモードラインに
‘Fill’と表示されているとき、それはAuto Fillモードが有効であることを意味
します。*note Mode Line::を参照してください。

   メジャーモードと同様に、各マイナーモードは“モードコマンド(mode
command)”に関連付けられていて、それはモード名の後ろに‘-mode’を付けた名前
です。たとえばAuto Fillモードのモードコマンドは‘auto-fill-mode’です。し
かしメジャーモードのコマンドは、単純にそのモードを有効にするだけですが、
マイナーモードのモードコマンドは、モードを有効または無効にすることができ
ます。

   • ‘M-x’を通じて、またはバインドしたキー(*note Key Bindings::を参照し
     てください)をタイプすることにより、モードコマンドをプレフィクスキー
     なしで直接呼び出すと、それはマイナーモードを“切り替え(toggles)”ます
     。つまり、マイナーモードがオフのときはオンに、オンのときはオフに切
     り替えます。

   • プレフィクス引数を指定してモードコマンドを呼び出すと、引数が0または
     負のときは無条件にマイナーモードをオフにし、それ以外のときは無条件
     にオンに切り替えます。

   • Lispからモードコマンドが呼び出された場合、引数が省略されているか
     ‘nil’のとき、マイナーモードは無条件にオンになります。これはメジャー
     モードのモードフックからマイナーモードをオンに切り替えるのを簡単に
     します(*note Major Modes::を参照してください)。非‘nil’の引数は、上
     で説明したインタラクティブなプレフィクス引数と同様に処理されます。

   ほとんどのマイナーモードは、モードコマンドと同じ名前の“モード変数
(mode variable)”をもっています。変数の値が非‘nil’のときはモードが有効で
、‘nil’なら無効です。一般的に、Lispから直接モード変数を変更して、モード
を有効または無効にするべきではありません。かわりにモードコマンドを使うべ
きです。しかしCustomizeインターフェース(*note Easy Customization::を参照
してください)を通じてのノード変数のセットは、Customizeが自動的にモードコ
マンドを実行するので、常に正しくモードを有効または無効にします。

   以下にいくつかのバッファーローカルなマイナーモードのリストを示します:

   • Abbrevモードは、事前に定義された省略形(abbreviation)の定義にもとづ
     いて、テキストを自動的に展開します。*note Abbrevs::を参照してくださ
     い。

   • Auto Fillモードは、行が長くなりすぎるのを防ぐため、タイプされた文字
     にしたがって改行を挿入します。*note Filling::を参照してください。

   • Auto Saveモードはバッファー内容を定期的に保存して、クラッシュした場
     合等に失われる作業量を減らします。*note Auto Save::を参照してくださ
     い。

   • Enrichedモードは、書式つきのテキストの編集と保存を可能にします。
     *note Enriched Text::を参照してください。

   • Flyspellモードは、自動的に間違ったスペルの単語をハイライトします。
     *note Spelling::を参照してください。

   • Font-Lockモードは、プログラム内で見つかった特定のテキスト単位を自動
     的にハイライトします。このモードはデフォルトでグローバルに有効にな
     っていますが、個別のバッファーで無効にすることができます。*note
     Faces::を参照してください。

   • Linumモードは、各行の行番号をウィンドウの左端に表示します。

   • Outline minorモードは、Outlineモードと呼ばれるメジャーモードと同様
     な機能を提供します。*note Outline Mode::を参照してください。

   • Overwriteモードは、通常のプリント文字の挿入により、後の文字をずらす
     かわりに、既存のテキストを置き換えます。たとえば、ポイントが
     ‘FOOBAR’の‘B’の前にある場合、‘G’をタイプすると通常は‘FOOGBAR’となり
     ますが、Overwriteモードでは‘FOOGAR’になります。Overwriteモードでは
     、コマンド‘C-q’は次の文字が何であれ、たとえそれが数字であってもその
     文字を挿入します — これにより既存のテキストを置き換える代わりに文字
     を挿入する方法が与えられます。モードコマンド‘overwrite-mode’は、
     <Insert>キーにバインドされています。

   • Binary Overwriteモードは、バイナリーファイルを編集するための、
     Overwriteモードの変種です。このモードは改行とタブを他の文字と同じよ
     うに扱うので、他の文字を上書きしたり、他の文字で上書きさせたりする
     ことができます。Binary Overwriteモードでは‘C-q’の後の数字は、通常ど
     おり8進文字コードを指定します。

   • Visual Lineモードは、 “単語単位の折り返し(word wrapping)”を処理しま
     す。これにより長い行は単語境界で折り返されます。*note Visual Line
     Mode::を参照してください。

以下に便利なグローバルマイナーモードをいくつか示します:

   • Column Numberモードは、現在の列番号をモードラインに表示します。
     *note Mode Line::を参照してください。

   • Delete Selectionモードでは、リージョンがアクティブの場合、最初にリ
     ージョンのテキストを削除してからテキストを挿入します。*note Using
     Region::を参照してください。

   • Icompleteモードは、ミニバッファーで補完がアクティブのとき、利用可能
     な候補を表示します。*note Icomplete::を参照してください。

   • Line Numberモードは、現在の行番号をモードラインに表示します。このモ
     ードはデフォルトで有効です。*note Mode Line::を参照してください。

   • Menu Barモードは、各フレームにメニューバーを表示します。このモード
     はデフォルトで有効です。*note Menu Bars::を参照してください。

   • Scroll Barモードは、各ウィンドウにスクロールバーを表示します。この
     モードはデフォルトで有効ですが、スクロールバーが表示されるのはグラ
     フィカルな端末だけです。*note Scroll Bars::を参照してください。

   • Tool Barモードは、各フレームにツールバーを表示します。このモードは
     デフォルトで有効ですが、ツールバーが表示されるのはグラフィカルな端
     末だけです。*note Tool Bars::を参照してください。

   • Transient Markモードはリージョンをハイライトして、マークがアクティ
     ブなときはEmacsの多くのコマンドがリージョンにたいして操作を行うよう
     になります。このモードはデフォルトで有効です。*note Mark::を参照し
     てください。


File: emacs-ja.info,  Node: Choosing Modes,  Prev: Minor Modes,  Up: Modes

23.3 ファイルのモードを選択する
===============================

ファイルをvisitしたとき、Emacsは自動的にメジャーモードを選択します。これ
は通常、ファイル名にもとづいて選択されます—たとえば名前が‘.c’で終わるフ
ァイルは通常、Cモードで編集されます — が、ファイル内の特別なテキストにも
とづいてメジャーモードが選択されるときもあります。この特別なテキストは、
バッファーローカルなマイナーモードを有効にするためにも使用されます。

   以下は、これの正確な手順です:

   最初にEmacsは、ファイルにファイルローカル(file-local)なモード変数が含
まれているかチェックします。*note File Variables::を参照してください。メ
ジャーモードを指定するファイルローカル変数が存在する場合、Emacsは他の条
件をすべて無視してそのメジャーモードを使用します。ファイルローカル変数を
使用してメジャーモードを指定する方法はいくつかあります。一番単純なのは、
空行でない最初の行に、そのモードの名前と、モード名の前後に‘-*-’を記述す
る方法です。他のテキストがその行にあっても問題はありません。たとえば、

     ; -*-Lisp-*-

これはEmacsにLispモードを使用するよう指示します。Lispがこの行をコメント
として扱うように、セミコロンがどのように使われているか注意してください。
以下のように書くこともできます

     ; -*- mode: Lisp;-*-

ファイルローカル変数を使用して、バッファーローカルなマイナーモードを指定
することもできます。これは‘eval’指定を使用して行います。たとえば、空行で
ない最初の行に以下を記述すると、これはバッファーをLispモードにして、
Auto-Fillモードを有効にします。

     ; -*- mode: Lisp; eval: (auto-fill-mode 1); -*-

しかし、ほとんどのマイナーモードはユーザー個人の好みが表れるものなので、
この方法でマイナーモードを有効にするのは、通常は不適切です。特定のファイ
ルタイプにたいしてマイナーモードを個人的に使用したい場合は、メジャーモー
ドフックを通じてマイナーモードを有効にするのが、より良い方法です。

   2番目に、メジャーモードを指定するファイル変数が存在しない場合、
Emacsは最初の行が‘#!’で開始されていないかチェックします。もし該当したら
、それはそのファイルがファイルの最初の行に記述された名前のインタープリタ
ーを実行する(ファイルの残りはインタープリターへの入力として使用されます
)ことにより機能する、実行可能なシェルコマンドであることを示します。した
がってEmacsはインタープリター名を使って、モードの選択を試みます。たとえ
ば、‘#!/usr/bin/perl’で始まるファイルは、Perlモードで開かれます。変数
‘interpreter-mode-alist’は、インタープリター名とメジャーモードの対応を指
定します。

   最初の行が‘#!’で開始されている場合、最初の行で‘-*-’の機能は通常は使用
できません。なぜならインタープリターを実行するときにシステムが混乱するか
らです。そのため、Emacsはそのようなファイルにたいしては、1行目と同じよう
に2行目の‘-*-’を探します。これはマジック文字列‘'\"’で開始されるman pageで
、troffプリプロセッサーのリストを指定することと同じです。

   3番目に、Emacsは変数‘magic-mode-alist’にもとづいて、バッファーの先頭
のテキストを調べて、メジャーモードの決定を試みます。デフォルトではこの変
数は‘nil’(空のリスト)なので、Emacsはこのステップをスキップしますが、
initファイルでこれをカスタマイズできます(*note Init File::を参照してくだ
さい)。変数の値には、以下の形式のリスト要素を指定します

     (REGEXP . MODE-FUNCTION)

ここでREGEXPは正規表現(*note Regexps::を参照してください)で、
MODE-FUNCTIONはメジャーモード関数です。ファイルの先頭のテキストが
REGEXPにマッチした場合、EmacsはMODE-FUNCTIONで指定したメジャーモードを選
択します。

   ‘magic-mode-alist’の要素は、以下の形式でも指定できます

     (MATCH-FUNCTION . MODE-FUNCTION)

ここでMATCH-FUNCTIONは、バッファーの先頭で呼び出されるLisp関数です。この
関数が非‘nil’を返した場合、EmacsはメジャーモードをMODE-FUNCTIONにセット
します。

   4番目に —Emacsが適正なメジャーモードをまだ見つけていない場合 — 今度は
ファイル名を調べます。ファイル名とメジャーモードの対応付けは、変数
‘auto-mode-alist’で制御されます。この変数の値は、各要素が以下の形式のリ
ストです。

     (REGEXP . MODE-FUNCTION)

または以下の形式です

     (REGEXP MODE-FUNCTION FLAG)

たとえば、通常見られるようなリストの要素は、‘("\\.c\\'" . c-mode)’のよう
な形式で、これは名前が‘.c’で終わるファイルにたいして、Cモードを選択する
役目を負っています(正規表現で‘.’がもつ特別な意味を打ち消すために、文字列
に‘\’を含めなければなりません。これはLisp構文では‘\\’と記述する必要があ
ります)。要素が‘(REGEXP MODE-FUNCTION FLAG)’の形式をもち、FLAGが非
‘nil’の場合、EmacsはMODE-FUNCTIONを呼び出した後、EmacsはREGEXPとマッチし
た接尾辞を捨てて、ほかのマッチを検索します。

   GNU/Linuxおよび、ファイル名の大文字小文字を区別する他のシステムでは、
Emacsは‘auto-mode-alist’の検索で大文字小文字を区別します。この検索が失敗
すると、2回目は大文字小文字を区別せずにalistを再検索します。2回目の検索
を行わないようにするには、変数‘auto-mode-case-fold’を‘nil’に変更します。
Microsoft Windowsのような、ファイル名の大文字小文字を区別しないシステム
では、Emacsは大文字小文字を区別しないで‘auto-mode-alist’を検索します。

   最後に、Emacsが_まだ_使用するメジャーモードを見つけられない場合、
Emacsはバッファーの先頭のテキストと、変数‘magic-fallback-mode-alist’を比
較します。この変数は上述した‘magic-mode-alist’と同じように機能しますが、
‘auto-mode-alist’の後に調べられるという点が異なります。デフォルトでは
‘magic-fallback-mode-alist’にはイメージファイル、HTML/XML/SGMLファイル、
PostScriptファイルをチェックする形式が含まれています。

   バッファーのメジャーモードを変更したとき、‘M-x normal-mode’とタイプす
ると、Emacsが自動的に選択するメジャーモードに戻ることができます。この関
数は‘find-file’がメジャーモードを選択するために呼び出す関数と同じです。
この関数は、(もしあれば)ファイルの‘-*-’ 行およびローカル変数リストも処理
します。*note File Variables::を参照してください。

   コマンド‘C-x C-w’および‘set-visited-file-name’は、新しいファイル名が
何らかのモードに関係がある場合は、新しいメジャーコードに変更します(その
バッファーがファイルをvisitしていない場合、‘C-x C-s’も同じことを行います
)。しかしバッファーの内容がメジャーモードを指定していて、ある種の“特別
”なメジャーモードはモードの変更を許しません。このモード変更機能をオフに
するには、‘change-major-mode-with-file-name’を‘nil’にセットして下さい。


File: emacs-ja.info,  Node: Indentation,  Next: Text,  Prev: Modes,  Up: Top

24 インデント
*************

“インデント(Indentation)”とは、“空白文字”(スペースやタブ文字)を行のテキ
ストの先頭に挿入したり調整することを指します。このチャプターでは、インデ
ントコマンドと、Textモードやそれに関連するモード、同様にプログラミング言
語のモードでの一般的なオプションを記します。プログラミング用のモードでの
インデントに関する追加のドキュメントは、*note Program Indent::を参照して
ください。

   インデントを行うもっとも簡単な方法は、<TAB>キーです。ほとんどのメジャ
ーモードでは、これによりコマンド‘indent-for-tab-command’が実行されます
(Cおよびそれに関連するモードでは、<TAB>は同じように振る舞うコマンド
‘c-indent-line-or-region’を実行します)。

<TAB>
     空白文字を挿入、またはモードに適した方法でカレント行をインデントし
     ます(‘indent-for-tab-command’)。リージョンがアクティブのときは、リ
     ージョンのすべての行をインデントします。

   <TAB>の正確な動作は、メジャーモードに依存します。Textモードおよびそれ
に関連するモードでは、<TAB>は通常、空白とタブ文字を組み合わせたものを挿
入して、ポイントを次のタブストップに進めます。このために、先行する行の最
初の空白以外の文字の位置は、追加のタブストップとして扱われるので、
<TAB>を使って先行する行にポイントを“揃える”ことができます。リージョンが
アクティブ(*note Using Region::を参照してください)な場合、<TAB>は特別な
動作をします。これはリージョンの各行をインデントするので、各行の最初の空
白以外の文字は、先行する行に揃えられます。

   プログラミング関連のモードでは、<TAB>はコードのカレント行にたいして、
前の行のコードの意味を理解してインデントします。リージョンがアクティブな
場合、リージョンのすべての行はこの方法でインデントされます。ポイントが最
初にカレント行のインデント領域にあった場合、その行の最初の空白以外の文字
に再配置されます。

   単にタブ文字をバッファーに挿入したいときは、‘C-q <TAB>’とタイプします
(*note Inserting Text::を参照してください)。

* Menu:

* Indentation Commands::     インデントを処理するほかのコマンド。
* Tab Stops::                Textモードのインデントのストップポイント。
* Just Spaces::              インデントにスペース文字だけを使用する。
* Indent Convenience::       インデントのオプション機能。


File: emacs-ja.info,  Node: Indentation Commands,  Next: Tab Stops,  Up: Indentation

24.1 インデントコマンド
=======================

<TAB> (‘indent-for-tab-command’)コマンドとは別に、Emacsは他の方法でイン
デントを処理する、さまざまなコマンドを提供します。

‘C-M-o’
     カレント行をポイント位置で分割します(‘split-line’)。その行のポイン
     トの後にあるテキストは新しい行となり、ポイントがあった位置と同じ列
     にインデントされます。このコマンドは、最初にポイントを複数のスペー
     スまたはタブを飛び越えて移動させます。その後、ポイントは挿入された
     行の前に配されます。

‘M-m’
     カレント行の最初の空白以外の文字に移動(前方または後方)します
     (‘back-to-indentation’)。その行に空白文字しかない場合は、その行の行
     末に移動します。

‘M-i’
     ポイント位置の空白文字を次のタブストップまでインデントします
     (‘tab-to-tab-stop’)。*note Tab Stops::を参照してください。

‘M-x indent-relative’
     ポイントが前の行(実際には最後の空行以外の行)の、最初の空白以外の文
     字に揃うように、ポイント位置に空白文字を挿入します。ポイントがすで
     にその位置より右にある場合は、かわりに‘tab-to-tab-stop’を実行します
     — ただし数引数を指定した場合は何もしません。

‘M-^’
     前の行とカレント行をマージします(‘delete-indentation’)。このコマン
     ドはカレント行の前にある任意のインデントと、行の境界を1つのスペース
     で置き換えて、2つの行を明解に“結合”します。

     特別なケースとして、結合された文字が連続する開きカッコまたは閉じカ
     ッコの場合、または他の改行が続く場合、1つのスペースは省略されます
     (Lispコードにたいして有用)。

     fillプレフィクスが存在して、それが改行の後ろにあった場合、‘M-^’は
     fillプレフィクスを削除します。*note Fill Prefix::を参照してください
     。

‘C-M-\’
     リージョンのすべての行にたいして、各行の先頭で<TAB>をタイプしたかの
     ようにインデントします(‘indent-region’)。

     数引数が与えられた場合、その列番号までリージョンのすべての行をイン
     デントします。

‘C-x <TAB>’
     このコマンドは、リージョン内で開始されるすべての行のインデントを変
     更するのに使用されます。インデントの変更は、影響を受ける行を“厳格な
     (rigid)”単位として移動することにより行われます。

     引数を指定しないで呼び出されたとき、このコマンドは影響を受ける行の
     インデントを対話的に調整するために、transientモードをアクティブにし
     ます。transientモードがアクティブの間は、<LEFT>または<RIGHT>により
     、スペース1文字単位で左または右にインデントします。‘S-<LEFT>’または
     ‘S-<RIGHT>’とタイプすることにより、タブストップ単位で左または右にイ
     ンデントすることもできます。他のキーをタイプするとtransientモードは
     無効になり、通常の編集を再開します。

     プレフィクス引数Nを指定して呼び出すと、このコマンドは行をN個のスペ
     ースでインデントします(transientモードは有効になりません)。Nに値を
     与えると後方にインデントするので、リージョン内の行のすべてのインデ
     ントを除去したいときは、以下のように充分に大きい負の引数を与えます
     。

          C-u -999 C-x <TAB>


File: emacs-ja.info,  Node: Tab Stops,  Next: Just Spaces,  Prev: Indentation Commands,  Up: Indentation

24.2 タブストップ
=================

Emacsは、特定の列番号が“タブストップ”になるよう定義しています。これらは
Textモードおよびそれに関連するモードで、<TAB>および‘M-i’のようなコマンド
により、空白文字が挿入されるときのストップポイントとして使用されます。変
数‘tab-stop-list’は、これらの位置を制御します。デフォルト値は‘nil’で、こ
れはタブストップが8列ごとという意味です。値には、タブストップの列番号を
、0基準の列番号のリスト(昇順)で指定することもできます。Emacsは最後の要素
と、その1つ前の要素の差分を繰り返すことにより、リストを無限に拡張します
。

   変数‘tab-stop-list’を直接カスタマイズするかわりに、コマンド‘M-x
edit-tab-stops’を通じて、タブストップを視認しながらセットする便利な方法
があります。このコマンドは、以下のようなタブストップの説明を含んだバッフ
ァーに切り替えます。

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

最初の行は各タブストップ位置にコロンを示します。その後の2行はコロンが示
す位置を表示します。‘tab-stop-list’の値が‘nil’(デフォルト)の場合、最初は
コロンが表示されません。

   異なるタブストップを置きたい列に、コロンを配して指定するために、この
バッファーを編集できます。このバッファーはOverwriteモードを使用します
(*note Minor Modes::を参照してください)。Emacsは、最後に明示した2つのス
トップの差分を繰り返すことにより、タブストップのリストを無限に拡張するこ
とを思い出してください。編集が終わったら、新しいタブストップを有効にする
ために、‘C-c C-c’とタイプします。通常、新しいタブストップのセッティング
は、すべてのバッファーに適用されます。しかし‘M-x edit-tab-stops’を呼び出
したバッファーにたいして、ローカルな変数‘tab-stop-list’を作成していた場
合(*note Locals::を参照してください)、新しいタブストップのセッティングは
、そのバッファーだけに適用されます。将来のEmacsセッションのためにタブス
トップのセッティングを保存するには、Customizeインターフェースを使用して
‘tab-stop-list’の値を保存します(*note Easy Customization::を参照してくだ
さい)。

   このセクションで議論したタブストップは、バッファーでタブ文字が表示さ
れる方法には影響しないことに注意してください。タブ文字は常に次の“タブス
トップ表示(display tab stop)”まで拡張される、空のスペースとして表示され
ます。*note Text Display::を参照してください。


File: emacs-ja.info,  Node: Just Spaces,  Next: Indent Convenience,  Prev: Tab Stops,  Up: Indentation

24.3 タブ vs. スペース
======================

インデントコマンドは通常、スペース文字とタブ文字を最適にミックスした文字
列を挿入(または削除)することにより、望む列に行を揃えます。タブ文字は次の
“タブストップ表示(display tab stop)”まで伸長された、空のスペースとして表
示されます。デフォルトでは、‘tab-width’列ごと(デフォルトは8)に、1つのタ
ブストップ表示があります。*note Text Display::を参照してください。

   もし望むなら、すべてのインデントをスペースだけで行うこともできます。
これを要求するには、バッファーローカルな変数‘indent-tabs-mode’を‘nil’に
セットします。バッファーローカルな変数についての情報は、*note Locals::を
参照してください。しかし‘C-q <TAB>’は、‘indent-tabs-mode’の値とは無関係
に、常にタブ文字を挿入することに注意してください。

   ‘indent-tabs-mode’を‘nil’にセットする1つの理由は、すべてのエディター
がタブ文字を同じ方法で表示するわけではないという理由です。Emacsユーザー
も同様で、彼らはカスタマイズされた‘tab-width’により、異なる値をもつかも
しれません。スペースだけを使うことにより、ファイルが常に同じように見える
ことを保証できます。Emacsでどのように見えるかだけに関心がある場合、この
問題に取り組む他の方法は、ファイルローカルな変数‘tab-width’をセットする
方法です(*note File Variables::を参照してください)。

   空白以外の文字の列を常に保ちながら、スペースをタブに、またはその逆の
変換を行うコマンドも存在します。‘M-x tabify’は、リージョンの連続するスペ
ースをスキャンして、インデントを変更せずに、少なくとも2文字の連続するス
ペースをタブに変換します。‘M-x untabify’は、リージョンのすべてのタブを適
正な数のスペースに変更します。


File: emacs-ja.info,  Node: Indent Convenience,  Prev: Just Spaces,  Up: Indentation

24.4 インデントの便利な機能
===========================

変数‘tab-always-indent’は、<TAB> (‘indent-for-tab-command’)コマンドの動
作を微調整します。デフォルト値は‘t’で、これは*note Indentation::で説明し
た動作を与えます。値をシンボル‘complete’に変更すると、<TAB>は最初にカレ
ント行のインデントを試みます、すでにその行がインデントされている場合、こ
のコマンドはポイント位置のテキストの補完を試みます(*note Symbol
Completion::を参照してください)。値が‘nil’の場合、<TAB>はポイントが行の
左端かインデント位置にあるときだけインデントを行い、それ以外はタブ文字を
挿入します。

   Electric Indentモードはグローバルなマイナーモードで、これは<RET>をタ
イプしたあと自動的にインデントを行います。このモードはデフォルトで有効で
す。このマイナーモードを切り替えるには、‘M-x electric-indent-mode’とタイ
プします。1つのバッファーにたいしてモードを切り替えるには、‘M-x
electric-indent-local-mode’を使用してください。


File: emacs-ja.info,  Node: Text,  Next: Programs,  Prev: Indentation,  Up: Top

25 人間の言語のためのコマンド
*****************************

このチャプターでは“テキスト(text)” — 人間の言語(対照的なものとしてコンピ
ューターのプログラム言語があります)における、文字シーケンスという意味 —
にたいして動作する、Emacsコマンドを説明します。これらコマンドは、人間の
言語の構文および文体の規則に配慮した方法で動作します。単語、センテンス
(文)、パラグラフ(段落)、大文字に関する規則があります。“フィル(filling)”
— パラグラフの行をおおよそ同じ長さに再配置するという意味 — を行うコマン
ドもあります。これらのコマンドは主にテキストの編集を意図しており、プログ
ラムの編集にも便利なときがあります。

   Emacsには、人間言語のテキストを編集するためのメジャーモードがいくつか
あります。ファイルが普通のテキストを含む場合は、Textモードを使います。こ
れはEmacsを、テキストの構文規則にたいして少しカスタマイズしたものです。
Outlineモードは。アウトライン構造でテキストを操作する特別なコマンドを提
供します。Orgモードは、Outlineモードを拡張してEmacsを本格的なオーガナイ
ザーに変えます。これによりTODOリストを管理したり、ノートを保存して、それ
を多くのフォーマットで公開することができます。

   EmacsにはTeXやLaTeX (*note TeX Mode::を参照してください)、HTMLやSGML
(*note HTML Mode::を参照してください)、XML (*note The nXML Mode Manual:
(nxml-mode)Top.を参照してください)、 GroffやNroff (*note Nroff Mode::を
参照してください)のような、コマンドが“埋め込まれた”テキストのための、他
のメジャーモードがあります。

   テキスト文字で作られた絵(一般的には“ASCII art”と呼ばれます)を編集する
必要がある場合は、そのような絵を編集するための特別なメジャーモードの
Pictureモードを使用します *note Picture Mode::を参照してください。

   テキストを記述するときは、“自動タイピング”の機能が便利でしょう。*note
The Autotype Manual: (autotype)Top.を参照してください。

* Menu:

* Words::                    単語単位の移動とkill。
* Sentences::                センテンス単位の移動とkill。
* Paragraphs::               パラグラフ単位の移動。
* Pages::                    ページ単位の移動。
* Filling::                  テキストのフィルと調整。
* Case::                     テキストの大文字小文字の変更。
* Text Mode::                テキストファイルを編集するためのメジャーモード。
* Outline Mode::             アウトラインの編集。
* Org Mode::                 Emacsオーガナイザー。
* TeX Mode::                 TeXおよびLaTeXファイルの編集。
* HTML Mode::                HTMLおよびSGMLファイルの編集。
* Nroff Mode::               nroffフォーマッターへの入力の編集。
* Enriched Text::            フォント、カラーなどでenrichedテキストを編集する。
* Text Based Tables::        テキストベースのテーブルを編集するためのコマンド。
* Two-Column::               テキスト列を分割して別のウィンドウに表示する。


File: emacs-ja.info,  Node: Words,  Next: Sentences,  Up: Text

25.1 単語
=========

Emacsは、単語単位で移動するコマンドをいくつか定義しています:

‘M-f’
     1単語前方に移動します(‘forward-word’)。
‘M-b’
     1単語後方に移動します(‘backward-word’)。
‘M-d’
     単語の最後までkillします(‘kill-word’)。
‘M-<DEL>’
     単語の先頭までkillします(‘backward-kill-word’)。
‘M-@’
     次の単語の最後をマークします(‘mark-word’)。
‘M-t’
     2つの単語を入れ替える、または他の単語を飛び越えて単語をドラッグしま
     す(‘transpose-words’)。

   これらのキーは文字単位のコマンド‘C-f’、‘C-b’、‘C-d’、<DEL>、‘C-t’に類
似していることに注目してください。‘M-@’は‘C-@’(これは‘C-<SPC>’の別名です
)が由来です。

   コマンド‘M-f’ (‘forward-word’)および‘M-b’ (‘backward-word’)は、単語単
位で前方または後方に移動します。これらの<META>ベースのキーシーケンスは、
1文字単位で移動するキーシーケンス‘C-f’および‘C-b’に類似しています。類似
点は数引数にも拡張されます。これらは繰り返し回数を指定します。‘M-f’に負
の引数を与えると後方に移動し、‘M-b’に負の引数を与えると前方に移動します
。前方への移動は単語の最後の文字の直後で停止し、後方への移動は、最初の文
字の直前で停止します。

   ‘M-d’ (‘kill-word’)は、ポイントの後ろの単語をkillします。正確に言うと
、ポイントから、‘M-f’で移動する位置までのすべてをkillします。したがって
ポイントが単語の途中にある場合、‘M-d’はポイントの後だけをkillします。ポ
イントと次の単語の間に区切り文字がある場合、それは単語と一緒にkillされま
す（次の単語だけをkillして、その前にある区切り文字はkillしたくないときは
、‘M-f’で最後まで移動して、‘M-<DEL>’で単語を後方にkillします)。‘M-d’は
‘M-f’と同様の引数を取ります。

   ‘M-<DEL>’ (‘backward-kill-word’)は、ポイントの前の単語をkillします。
これはポイントから、‘M-b’で移動する位置までのすべてをkillします。たとえ
ばポイントが‘FOO, BAR’のスペースの後ろにある場合、これは‘FOO, ’をkillし
ます。‘FOO’だけをkillして、カンマとスペースは残したい場合は、‘M-<DEL>’の
かわりに‘M-b M-d’を使用します。

   ‘M-t’ (‘transpose-words’)は、ポイントの前またはポイントを含む単語を、
次の単語と交換します。単語間の区切り文字は移動されません。たとえば
‘FOO, BAR’は、‘BAR FOO,’ではなく、‘BAR, FOO’に入れ替えられます。入れ替え
については、*note Transpose::を参照してください。

   リージョンにたいして操作を行う際、単語単位で操作したいときは、コマン
ド‘M-@’ (‘mark-word’)を使用します。このコマンドは‘M-f’で移動する位置にマ
ークをセットします。このコマンドにつての詳しい詳細は、*note Marking
Objects::を参照してください。

   単語にたいするコマンドが理解する単語境界は、構文テーブル(syntax
table)で制御されます。単語の区切り文字に、(たとえば)任意の文字を使うこと
ができます。*note Syntax Tables: (elisp)Syntax Tables.を参照してください
。

   以上に加えて、リージョンまたはバッファーに含まれる単語数のカウントと
リポートを行う‘M-=’ (‘count-words-region’)および‘M-x count-words’コマン
ドについては、*note Position Info::を参照してください。


File: emacs-ja.info,  Node: Sentences,  Next: Paragraphs,  Prev: Words,  Up: Text

25.2 センテンス
===============

センテンス(文)とパラグラフ(段落)を操作するEmacsコマンドは、単語を処理す
るコマンドと同様、ほとんどがMetaキーに割り当てられています。

‘M-a’
     センテンスの先頭に、後方へ移動します(‘backward-sentence’)。
‘M-e’
     センテンスの最後に、前方へ移動します(‘forward-sentence’)。
‘M-k’
     センテンスの最後まで、前方にkillします(‘kill-sentence’)。
‘C-x <DEL>’
     センテンスの最初まで、後方にkillします(‘backward-kill-sentence’)。

   コマンド‘M-a’ (‘backward-sentence’)および‘M-e’ (‘forward-sentence’)は
、センテンスの先頭または最後に移動します。これらのコマンドのバインディン
グは、行の先頭と最後に移動する‘C-a’と‘C-e’に似せて選ばれました。似ていな
い点は、‘M-a’または‘M-e’を繰り返すと、センテンス単位で連続して移動するこ
とです。

   センテンスにたいして後方に移動すると、ポイントはセンテンスの最初の文
字の直前に移動します。前方に移動したときは、センテンスを終了させる区切り
文字の直後に移動します。どちらもセンテンスの境界にある空白文字にポイント
を移動することはありません。

   ‘C-a’と‘C-e’がkillコマンド‘C-k’をもつように、‘M-a’と‘M-e’にも対応する
killコマンドがあります。‘M-k’ (‘kill-sentence’)は、ポイントからセンテン
スの最後までをkillします。正の数引数Nを指定すると、次のNセンテンスを
killします。負の数引数−Nを指定すると、後方にN番目のセンテンスの先頭まで
をkillします。

   ‘C-x <DEL>’ (‘backward-kill-sentence’)は、センテンスの先頭までを後方
にkillします。

   センテンスのコマンドは、センテンスの最後に2つのスペースを置くという
Americanのタイピストの慣習に、ユーザーが従うと仮定します。つまりセンテン
スの最後は‘.’、‘?’、‘!’の後ろに改行または2つのスペースがあると仮定し、そ
の間に任意の個数の‘)’、‘]’、‘'’、‘"’が許されます。パラグラフの先頭および
最後は、センテンスの先頭および最後でもあります。この慣習にしたがうことに
より、Emacsのセンテンスにたいするコマンドがセンテンスの最後のピリオドと
、省略形を示すピリオドを区別できるので便利になります。

   センテンスの間を1つのスペースにしたい場合は、
‘sentence-end-double-space’を‘nil’にセットすることにより、センテンスのコ
マンドが1つのスペースで止まるようになります。しかし、これにはセンテンス
の終わりのピリオドと、省略形を示すピリオドを区別できなくなるという欠点が
あります。したがって便利で信頼できる編集のために、2つのスペースの慣習に
したがうことを推奨します。変数‘sentence-end-double-space’はフィルにも影
響します(*note Fill Commands::を参照してください)。

   変数‘sentence-end’は、センテンスの終了を認識する方法を制御します。非
‘nil’の場合、その値は正規表現にすべきで、それはセンテンスの最後の数文字
(センテンスの後ろのスペースも含む)とのマッチに使用されます。値が‘nil’(デ
フォルト)の場合、Emacsは‘sentence-end-double-space’の値のような、変数条
件に照らしてセンテンスの最後を計算します。

   Thaiのようないくつかの言語は、センテンスの最後を示すのにピリオドを使
用しません。そのような場合は変数‘sentence-end-without-period’に‘t’をセッ
トします。


File: emacs-ja.info,  Node: Paragraphs,  Next: Pages,  Prev: Sentences,  Up: Text

25.3 パラグラフ
===============

パラグラフ(段落)を操作するEmacsコマンドもMetaキーに割り当てられています
。

‘M-{’
     前のパラグラフの先頭に、後方へ移動します(‘backward-paragraph’)。
‘M-}’
     次のパラグラフの最後に、前方へ移動します(‘forward-paragraph’)。
‘M-h’
     そのパラグラフ、または次のパラグラフの周囲にポイントとマークを配し
     ます(‘mark-paragraph’)。

   ‘M-{’ (‘backward-paragraph’)は、カレントのパラグラフ、または前のパラ
グラフの先頭に移動します(パラグラフの定義は以下を参照してください)。
‘M-}’ (‘forward-paragraph’)は、カレントのパラグラフ、または次のパラグラ
フの最後に移動します。パラグラフの前に空行がある場合、‘M-{’はその空行に
移動します。

   パラグラフにたいして操作をしたい場合、‘M-h’ (‘mark-paragraph’)とタイ
プすることにより、パラグラフの周囲にリージョンがセットされます。たとえば
‘M-h C-w’は、パラグラフの周囲またはポイントの後ろをkillします。‘M-h’は、
ポイント位置のパラグラフの先頭にポイントを、最後にマークを配します。ポイ
ントがパラグラフの間(連続する空行の中、または境界)にある場合、‘M-h’はポ
イントの後ろに続くパラグラフの周囲にリージョンをセットします。パラグラフ
の最初の行の前に空行がある場合、その空行はリージョンに含まれます。 リー
ジョンがすでにアクティブの場合、このコマンドはポイントを変更せずにマーク
をセットします。連続する‘M-h’は、マークをパラグラフ単位で先にセットしま
す。

   パラグラフの定義はメジャーモードに依存します。Fundamentalモード、同様
にTextモードとそれに関連するモードでは、パラグラフと、その前後のパラグラ
フを分けるのは１行以上の“空行” — 空の行、スペースとタブだけからなる行、
およびそれらに改ページ文字がついた行 — です。プログラミング言語に関する
モードでは、通常パラグラフは同じような方法で定義されるので、パラグラフが
ないプログラムなどにたいしても、パラグラフのコマンドを使うことができます
。

   Textモードでは、インデントされた行自体では、パラグラフの区切りには_な
らない_ことに注意してください。インデントされた行をパラグラフの分割に使
用したい場合は、かわりにParagraph-Indent Textモードを使用します。*note
Text Mode::を参照してください。

   フィルプレフィクスをセットしている場合、フィルプレフィクスで始まって
いないすべての行は、パラグラフの区切りとなります。*note Filling::を参照
してください。

   パラグラフ境界の正確な定義は、変数‘paragraph-separate’および
‘paragraph-start’により制御されます。‘paragraph-start’の値には、パラグラ
フを開始または分割する行にマッチする正規表現を指定します。
‘paragraph-separate’の値には、パラグラフの一部とならないような、パラグラ
フを分割する行にマッチする正規表現を指定します。新しいパラグラフを開始す
るパラグラフに含まれる行は、‘paragraph-start’にはマッチしますが、
‘paragraph-separate’にはマッチしません。たとえばFundamentalモードでは、
‘paragraph-start’は‘"\f\\|[ \t]*$"’、‘paragraph-separate’は
‘"[ \t\f]*$"’です。


File: emacs-ja.info,  Node: Pages,  Next: Filling,  Prev: Paragraphs,  Up: Text

25.4 ページ
===========

“改ページ文字”(formfeed character: ASCIIコード12で、‘control-L’とも表示
されます)でページに分割されているものがあり、Emacsではそれらがエスケープ
シーケンス‘^L’で表示されます(*note Text Display::を参照してください)。伝
統的には、そのようなテキストファイルのハードコピーを印刷する場合、各改ペ
ージ文字で改ページされます。ほとんどのEmacsコマンドは、この文字をほかの
文字と同様に扱うので、‘C-q C-l’で挿入して、<DEL>で削除などができます。そ
れに加えて、Emacsはページ単位の移動や操作を行うコマンドを提供します。

‘M-x what-page’
     ポイント位置のページ番号と、ページ内での行番号を表示します。
‘C-x [’
     前のページ境界にポイントを移動します(‘backward-page’)。
‘C-x ]’
     次のページ境界にポイントを移動します(‘forward-page’)。
‘C-x C-p’
     現在のページ(または他のページ)の周囲に、ポイントとマークを配します
     (‘mark-page’)。
‘C-x l’
     現在のページの行数を数えます(‘count-lines-page’)。

   ‘M-x what-page’は、ファイルの先頭から数えたページ数と、そのページの行
数をエコーエリアに表示します。

   ‘C-x [’ (‘backward-page’)コマンドは、前のページ区切りの直後にポイント
を移動します。ポイントがすでにページ区切りの直後にある場合は、そのページ
区切りをスキップして、その前のページ区切りに移動します。数引数は繰り返し
回数を指定します。‘C-x ]’ (‘forward-page’)コマンドは、次のページ区切りに
前方に移動します。

   ‘C-x C-p’ (‘mark-page’)コマンドは、ポイントを現在のページの先頭(ペー
ジの先頭に隣接するページ区切りの後ろ)、マークをページの最後(ページの最後
に隣接するページ区切りの後ろ)に配します。

   ‘C-x C-p C-w’は、ページを他の場所に移動するためにkillする便利な方法で
す。‘C-x [’または‘C-x ]’で他のページへ移動して、そこにkillされたページを
yankすれば、すべてのページは再び適切に区切られます。‘C-x C-p’のリージョ
ンに後続のページ区切りだけが含まれるのは、これを確実に行うためです。

   ‘C-x C-p’に数引数を指定すると、現在のページから数えて何ページ目に移動
するかを指定します。0は現在のページ、1は次のページ、−1は前のページを意味
します。

   ‘C-x l’ (‘count-lines-page’)コマンドは、ページをどこで2つに分割するか
の良い指標になります。これは現在のページの全行数と、カレント行の前にある
行数と、後ろにある行数を以下のように表示します。

     Page has 96 (72+25) lines

合計が1少ないのに注意してください。これはポイントが行の先頭にない場合は
正しくなります。

   変数‘page-delimiter’は、ページがどこで始まるかを制御します。この値に
はページを分割する行の先頭にマッチする正規表現を指定します(*note
Regexps::を参照してください)。この変数の値は通常‘"^\f"’で、これは行の先
頭の改ページ文字にマッチします。


File: emacs-ja.info,  Node: Filling,  Next: Case,  Prev: Pages,  Up: Text

25.5 テキストのフィル
=====================

テキストを“フィル(fill)”するとは、指定した幅に収まるように行を分割するこ
とを意味します。Emacsはフィルを2つの方法で行います。Auto Fillモードでは
、自己挿入文字によるテキストの挿入で、自動的にフィルされます。テキストを
編集するときに使用できる、明示的なフィルコマンドもあります。

* Menu:

* Auto Fill::                Auto
                               Fillモードは長い行を自動的に分割します。
* Fill Commands::            パラグラフの再フィルと行の中央揃えコマンド。
* Fill Prefix::              インデントされていたり、コメントであるパラグラフのフィル。
* Adaptive Fill::            Emacsがフィルプレフィクスを自動的に決定する方法。


File: emacs-ja.info,  Node: Auto Fill,  Next: Fill Commands,  Up: Filling

25.5.1 Auto Fillモード
----------------------

“Auto Fill”モードは、行が長くなりすぎたとき、それを自動的に分割する、バ
ッファーローカルなマイナーモードです(*note Minor Modes::を参照してくださ
い)。分割は<SPC>または<RET>をタイプしたときだけ発生します。

‘M-x auto-fill-mode’
     Auto Fillモードを有効または無効にします。
‘<SPC>’
‘<RET>’
     Auto Fillモード中は、適切なときに行を分割します。

   モードコマンド‘M-x auto-fill-mode’は、カレントバッファーのAuto Fillモ
ードを切り替えます。正の数引数はAuto Fillモードを有効にし、負の引数は無
効にします。Lispから‘auto-fill-mode’が呼び出された場合、引数が省略されて
いるか‘nil’のときは、Auto Fillモードを有効にします。特定のメジャーモード
でAuto Fillモードを自動的に有効にするには、モードフックに
‘auto-fill-mode’を追加します(*note Major Modes::を参照してください)。
Auto Fillモードが有効なときは、モードラインにモード指標の‘Fill’が表示さ
れます(*note Mode Line::を参照してください)。

   Auto Fillモードは、行が望ましい幅より長くなったとき、空白の位置で自動
的に行を分割します。行の分割は、<SPC>か<RET>をタイプしたときだけ発生しま
す。行の分割をさせずにスペースまたは改行を挿入したいときは、‘C-q <SPC>’ま
たは‘C-q C-j’とタイプします。‘C-o’も行の分割を発生させずに改行を挿入しま
す。

   Auto Fillモードが行を分割するときは、“適応型フィルプレフィクス
(adaptive fill prefix)”にしたがうよう試みます。フィルプレフィクスがカレ
ントパラグラフの最初の１行目、および/または2行目で推論できる場合、そのフ
ィルプレフィクスは新しい行に挿入されます(*note Adaptive Fill::を参照して
ください)。そうでない場合、新しい行はその行で<TAB>をタイプしたかのように
インデントされます(*note Indentation::を参照してください)。プログラミン
グ言語に関するモードでは、行がコメントの途中で改行された場合、新しいコメ
ント区切りが適切に挿入されてコメントが分割されます。

   Auto Fillモードはパラグラフ全体を再フィルしません。これは行の分割はし
ますが、行のマージはしません。したがって、パラグラフの途中を編集している
ときは、適切にフィルされていないパラグラフがあり得ます。これをフィルする
には、フィルコマンドを明示的に呼び出してください (*note Fill Commands::を
参照してください)。


File: emacs-ja.info,  Node: Fill Commands,  Next: Fill Prefix,  Prev: Auto Fill,  Up: Filling

25.5.2 明示的なフィルコマンド
-----------------------------

‘M-q’
     カレントパラグラフをフィルします(‘fill-paragraph’)。
‘C-x f’
     フィルの列幅をセットします(‘set-fill-column’)。
‘M-x fill-region’
     リージョンの各パラグラフをフィルします(‘fill-region’)。
‘M-x fill-region-as-paragraph’
     リージョンを1つのパラグラフとしてフィルします。
‘M-o M-s’
     行を中央に揃えます。

   コマンド‘M-q’ (‘fill-paragraph’)は、カレントのパラグラフを“フィル”し
ます。このコマンドは特定の最大列幅に適合するような方法で、パラグラフの改
行を再配分して、パラグラフの余分なスペースやタブ文字を削除します。

   ‘M-q’は通常、ポイントがあるパラグラフに作用しますが、ポイントがパラグ
ラフの間にあるときは、ポイントの後ろのパラグラフに作用します。リージョン
がアクティブの場合、かわりにリージョンのテキストに作用します。‘M-x
fill-region’を呼び出して、リージョンのテキストを明確にフィルすることもで
きます。

   ‘M-q’および‘fill-region’は、パラグラフの境界を探すために、通常の
Emacsの条件式を使用します。より細かく制御するには、ポイントとマークの間
にあるすべてを1つのパラグラフとして再フィルする、‘M-x
fill-region-as-paragraph’を使用することができます。このコマンドはリージ
ョンの空行を削除するので、分割されたテキストブロックは、1つのブロックに
結合されます。

   ‘M-q’に数引数を指定した場合、これはテキストのフィルと同時に“割付
(justify)”も指示します。これは行の右端が正確にフィル列になるように、余分
なスペースが挿入されることを意味します。余分なスペースを削除するには、引
数を指定せずに‘M-q’を使用します(‘fill-region’と同じ)。

   フィルのための行の最大幅は、バッファーローカルな変数‘fill-column’によ
り指定されます。デフォルト値は70です(*note Locals::を参照してください)。
カレントバッファーの‘fill-column’をセットする一番簡単な方法は、コマンド
‘C-x f’ (‘set-fill-column’)を使用する方法です。数引数を指定すると、それ
を新しいフィル列として使用します。‘C-u’だけを指定すると、このコマンドは
現在のポイントの水平位置を‘fill-column’にセットします。

   コマンド‘M-o M-s’ (‘center-line’)は、現在のフィル列でカレント行を中央
に揃えます。数引数Nを指定すると、Nを中央に揃えた後、ポイントを先に移動し
ます。このバインディングはTextモードのためのもので、利用可能なのはTextモ
ードとそれに関連するモードだけです(*note Text Mode::を参照してください
)。

   デフォルトでは、Emacsは2つのスペースまたは改行が後にあるピリオドを、
センテンスの終わりと判断します。後に1つのスペースしかないピリオドは、セ
ンテンスの終わりではなく、省略形を示します。それに合わせて、フィルコマン
ドも後に1つのスペースしかないピリオドでは、行を分割しません。変数
‘sentence-end-double-space’を‘nil’にセットした場合、フィルコマンドは後に
1つのスペースしかないピリオドでも行を分割するようになり、各ピリオドの後
に1つのスペースを配すようになります。他の効果とこの方法の欠点については
、*note Sentences::を参照してください。

   変数‘colon-double-space’が非‘nil’の場合、フィルコマンドはコロンの後に
2つのスペースを配します。

   行分割を許さない場所の条件を追加で指定するには、アブノーマルフック変
数‘fill-nobreak-predicate’をカスタマイズします(*note Hooks::を参照してく
ださい)。このフックの各関数は、Emacsが行を分割すべきと判断する位置で、引
数なしで呼び出されます。関数が非‘nil’値を返した場合、Emacsはその位置で行
を分割しません。このフックに指定できる関数には、
‘fill-single-word-nobreak-p’(センテンスの最初の単語の後ろ、および最後の
単語の前では分割しません)、‘fill-single-char-nobreak-p’(1文字の単語の後
ろでは分割しません)、‘fill-french-nobreak-p’(‘(’の後ろ、および‘)’、‘:’、
‘?’の前では分割しません)が含まれます。


File: emacs-ja.info,  Node: Fill Prefix,  Next: Adaptive Fill,  Prev: Fill Commands,  Up: Filling

25.5.3 フィルプレフィクス
-------------------------

“フィルプレフィクス(fill prefix)”機能により、フィルされるパラグラフの各
行が、特別な文字列(インデントされたパラグラフの行頭につける複数のスペー
スなど)で開始されるようになります。フィルプレフィクスを明示的に指定する
ことができます。明示的に指定しない場合、Emacsは自動的にそれを推測するこ
とを試みます(*note Adaptive Fill::を参照してください)。

‘C-x .’
     フィルプレフィクスをセットします(‘set-fill-prefix’)。
‘M-q’
     現在のフィルプレフィクスで、パラグラフをフィルします
     (‘fill-paragraph’)。
‘M-x fill-individual-paragraphs’
     リージョンをフィルします。インデントの変化は、新しいパラグラフの開
     始と判断されます。
‘M-x fill-nonuniform-paragraphs’
     リージョンをフィルします。パラグラフを分割する行だけを、新しいパラ
     グラフの開始と判断します。

   カレントバッファーのフィルプレフィクスを指定するには、使用したいフィ
ルプレフィクスで開始される行に移動して、プレフィクスの最後にポイントを配
し、‘C-x .’ (‘set-fill-prefix’)とタイプします(‘C-x’の後にピリオドです)。
フィルプレフィクスをオフに切り替えるには、ポイントを行の先頭に移動して
‘C-x .’とタイプして、空のフィルプレフィクスを指定します。

   フィルプレフィクスの効果がある間、フィルコマンドはフィルを行う前にパ
ラグラフの各行のフィルプレフィクスを削除して、フィルを行った後で各行にフ
ィルプレフィクスを挿入します(パラグラフの最初の行は変更されずに残ります
。これは他の行と異なるように意図されていることがよくあるからです)。Auto
Fillモードは、新しい行を作成するときにフィルプレフィクスの自動的な挿入も
行います(*note Auto Fill::を参照してください)。‘C-o’コマンドは、行の先頭
で使用したときは、新しい行を作成してフィルプレフィクスを挿入します。コマ
ンド‘M-^’は逆に、削除する改行の後ろにフィルプレフィクスがあれば、プレフ
ィクスを削除します。

   たとえば‘fill-column’が50で、フィルプレフィクスが‘;; ’の場合、以下の
テキストにたいして‘M-q’を行うと、

     ;; This is an
     ;; example of a paragraph
     ;; inside a Lisp-style comment.

結果は以下のようになります:

     ;; This is an example of a paragraph
     ;; inside a Lisp-style comment.

   ‘M-q’およびパラグラフのコマンドは、フィルプレフィクスで開始されない行
を、パラグラフの開始と判断します。これは、最初の行を除く各行がインデント
されている形式のパラグラフにたいして、良い結果を与えます。空行、またはプ
レフィクスが削除されたインデントされた行も、パラグラフを分割または開始し
ます。これは各行にコメント区切りがある、複数パラグラフにわたるコメントを
記述するときに望ましいものです。

   ‘M-x fill-individual-paragraphs’を使用して、各パラグラフに自動的にフ
ィルプレフィクスをセットできます。このコマンドはリージョンをパラグラフに
分割して、インデントの変化を新しいパラグラフの開始として扱い、それらのパ
ラグラフをフィルします。したがって1つの“パラグラフ”のすべての行は、同じ
量のインデントをもちます。このインデントは、そのパラグラフにたいするフィ
ルプレフィクスの役目を果たします。

   ‘M-x fill-nonuniform-paragraphs’も同様なコマンドですが、別の方法でリ
ージョンをパラグラフに分割します。このコマンドは、
(‘paragraph-separate’で定義される)パラグラフ開始行だけを、新しいパラグラ
フの開始と判断します。これは1つのパラグラフの各行は異なる量のインデント
をもつことを想定しており、パラグラフの中で最小のインデント量をフィルプレ
フィクスに使用します。このコマンドは最初の行のインデントが、パラグラフの
他の行より少なくても多くても、良い結果をもたらします。

   フィルプレフィクスは、変数‘fill-prefix’に保存されます。変数の値は文字
列で、フィルプレフィクスがないときは‘nil’です。これはバッファーごとの変
数です。変数の変更はカレントバッファーだけに影響しますが、変更できるデフ
ォルト値も存在します。*note Locals::を参照してください。

   テキストプロパティー‘indentation’は、パラグラフのインデント量を制御す
る別の方法を提供します。*note Enriched Indentation::を参照してください。


File: emacs-ja.info,  Node: Adaptive Fill,  Prev: Fill Prefix,  Up: Filling

25.5.4 適応型フィル
-------------------

フィルコマンドは、特定なケースでは自動的に適切なフィルプレフィクスを推測
できます。空白文字または特定の区切り文字が行の先頭にあり、それがパラグラ
フの全行に適用されている場合です。

   パラグラフに2行以上の行がある場合は、2行目からフィルプレフィクスが取
得されますが、それは1行目にもそれが存在する場合だけです。

   パラグラフに1行しかない場合、フィルコマンドは、その行からフィルプレフ
ィクスを取得する_かも_しれません。この決定は複雑です。なぜならそのような
場合に妥当な、3つの選択肢があるからです。

   • 最初の行のプレフィクスを、パラグラフのすべての行に適用します。

   • 後続の行を空白文字でインデントします。これにより最初の行のプレフィ
     クスの下にテキストが並びますが、実際には最初の行からプレフィクスを
     コピーしません。

   • 2行目以降の行に特別なことは行いません。

   これら3つの書式スタイルは一般的に使用されているものです。そのためフィ
ルコマンドは、そのメジャーモードに出現するプレフィクスにもとづいて、望ま
しいスタイルを決定しようと試みます。判断基準は以下のとおりです。

   最初の行で見つかったプレフィクスが‘adaptive-fill-first-line-regexp’に
マッチするか、それがコメント開始シーケンス(メジャーモードに依存します)の
場合、見つかったプレフィクスをパラグラフのフィルに使用しますが、それは後
続の行でそれらがパラグラフの開始として振る舞わない場合に限られます。

   上記以外の場合、見つかったプレフィクスは同じ量のスペースに変換され、
それらのスペースは残りの行のフィルプレフィクスとして使用されますが、それ
は後続の行でそれらがパラグラフの開始として振る舞わない場合に限られます。

   Textモード、および空行またはページ区切りだけがパラグラフを分割するモ
ードでは、適応型フィルにより選択されるプレフィクスは、パラグラフの開始と
して振る舞わないので、常にフィルに使用できます。

   変数‘adaptive-fill-regexp’は、どのような行開始がフィルプレフィクスの
役目を果たすかを決定します。行がこの正規表現にマッチする文字で開始される
とき、プレフィクスとして使用されます。変数‘adaptive-fill-mode’を‘nil’に
セットした場合、フィルプレフィクスは自動的に選択されません。

   変数‘adaptive-fill-function’に関数をセットすることにより、より複雑な
方法で自動的にフィルプレフィクスを選択する方法を指定できます。この関数は
行の左端の直後のポイントで呼び出され、その行にもとづいた適切なフィルプレ
フィクスを返すべきです。この関数が‘nil’を返した場合、
‘adaptive-fill-regexp’がフィルプレフィクスを見つける機会を与えられます。


File: emacs-ja.info,  Node: Case,  Next: Text Mode,  Prev: Filling,  Up: Text

25.6 大文字小文字変換コマンド
=============================

Emacsには、1つの単語または任意の範囲のテキストを、大文字または小文字に変
換するコマンドがあります。

‘M-l’
     後続の単語を小文字に変換します(‘downcase-word’)。
‘M-u’
     後続の単語を大文字に変換します(‘upcase-word’)。
‘M-c’
     後続の単語の先頭の文字を大文字に変換します(‘capitalize-word’)。
‘C-x C-l’
     リージョンを小文字に変換します(‘downcase-region’)。
‘C-x C-u’
     リージョンを大文字に変換します(‘upcase-region’)。

   ‘M-l’ (‘downcase-word’)は、ポイントの後ろの単語を小文字に変換して、そ
の先にポイントを移動します。したがって、‘M-l’を繰り返すと、単語を連続し
て変換します。‘M-c’ (‘capitalize-word’)は、単語の最初の文字を大文字にし
て残りを小文字にしますが、‘M-u’ (‘upcase-word’)はすべての文字を大文字に
変換します。これらのコマンドはすべて、引数を与えると複数の単語を変換しま
す。これらのコマンドはすべてが大文字の大きなテキストを、これらが混成され
たものに変換するとき、特に有用です、なぜなら適切に‘M-l’、‘M-u’、‘M-c’を
使い分けて単語を変換しながら移動できるからです(変換が不要なときは‘M-f’を
使ってその単語をスキップします)。

   負の引数を与えると。ポイントの前の指定した数の単語にたいして、大文字
小文字の変換を適用しますが、ポイントは移動しません。これは大文字小文字を
間違えてタイプしたとき有用です。大文字小文字の変換コマンドを実行した後、
そのまま編集を続けられるからです。

   単語の途中で単語の大文字小文字を変換するコマンドが与えられた場合、ポ
イントの後ろに続く単語の一部だけに変換が適用されます(これは‘M-d’
(‘kill-word’)と互換性があります)。負の引数の場合は、ポイントの前にある単
語の一部が変換されます。

   他の大文字小文字の変換コマンドは‘C-x C-u’ (‘upcase-region’)と‘C-x
C-l’ (‘downcase-region’)で、これらはポイントとマークの間にあるすべてのテ
キストを大文字または小文字に変換します。ポイントとマークは移動しません。

   リージョンにたいする大文字小文字の変換コマンド‘upcase-region’および
‘downcase-region’は、通常では無効になっています。これは、これらを使おう
と試みたとき、確認を求められることを意味します。確認にたいして同意すると
コマンドが有効になり、それ以降は確認を求められなくなることを意味します。
*note Disabling::を参照してください。


File: emacs-ja.info,  Node: Text Mode,  Next: Outline Mode,  Prev: Case,  Up: Text

25.7 Textモード
===============

Textモードは、人間の言語のテキストファイルを編集するためのメジャーモード
です。‘.txt’という拡張子で終わる名前のファイルは、通常はTextモードで開か
れます。明示的にTextモードに切り替えるには、‘M-x text-mode’とタイプして
ください。

   Textモードでは、改行とページ区切りだけがパラグラフを分割します。結果
として、パラグラフはインデントすることができ、適応型フィルはパラグラフを
フィルするときに、どのインデントが使用されているか決定します。*note
Adaptive Fill::を参照してください。

   Textモードでは<TAB> (‘indent-for-tab-command’)コマンドは通常、カレン
ト行をインデントするかわりに、次のタブストップまで空白文字を挿入します。
詳細については、*note Indentation::を参照してください。

   Textモードは、明示的にそれらを呼び出した場合をのぞき、コメントに間す
る機能をオフに切り替えます。これは構文テーブル(syntax table)を変更するの
で、シングルクォートは単語の一部と判断されます(たとえば‘don't’は1つの単
語と判断されます))。しかし単語がシングルクォートで開始される場合、それは
先頭の文字を大文字にするためのプレフィクスとして扱われます(たとえば
‘M-c’により、‘'hello'’は‘'Hello'’に変換されます)。

   パラグラフの最初の行をインデントしている場合は、Textモードではなく
Paragraph-Indent Textモード(‘M-x paragraph-indent-text-mode’)を使用する
べきでしょう。このモーででは、パラグラフの間に空行を入れる必要はありませ
ん。最初の行のインデントだけでパラグラフの開始を判断するのに充分だからで
す。しかしパラグラフのすべてのの行がインデントされている場合は、サポート
されません。メジャーモードを変更したくないとき(たとえばメール作成時など
)は、‘M-x paragraph-indent-minor-mode’を使って、等価なマイナーモードを有
効にしてください。

   Textモードでは、‘M-<TAB>’が‘ispell-complete-word’にバインドされます。
このコマンドはバッファーのポイントの前にある単語を、スペル辞書を使用して
補完します。*note Spelling::を参照してください。ウィンドウマネージャーが
‘M-<TAB>’をウィンドウの切り替えに定義している場合は、かわりに‘<ESC>
<TAB>’または‘C-M-i’とタイプすることができます。

   Textモードに入ると、モードフック‘text-mode-hook’が実行されます(*note
Major Modes::を参照してください)。

   以下のセクションでは、Textモードから“派生”したいくつかのメジャーモー
ドを説明します。派生したモードは、上記で説明したTextモードのほとんどの機
能を継承します。とくに、Textモードから派生したモードは、それら自身のモー
ドフックの前に、‘text-mode-hook’を実行します。


File: emacs-ja.info,  Node: Outline Mode,  Next: Org Mode,  Prev: Text Mode,  Up: Text

25.8 Outlineモード
==================

OutlineモードはTextモードから派生したメジャーモードで、アウトライン
(outline: 概略、概要、要綱)を編集するために特化したモードです。このモー
ドはアウトライン構造のエントリー間を操作したり、バッファーの一部を一時的
に非表示にするコマンドを提供するので、アウトライン構造をより簡単に閲覧す
ることができるでしょう。‘M-x outline-mode’とタイプすることにより、
Outlineモードに切り替わります。Outlineモードに入ることにより、フック
‘text-mode-hook’、およびそれに続けてフック‘outline-mode-hook’が実行され
ます(*note Hooks::を参照してください)。

   Outlineモードで行を非表示にするコマンド(*note Outline Visibility::を
参照してください)を使用した場合、それらの行は画面に表示されなくなります
。非表示行の前にある表示された行の後ろには省略記号(3つのピリオド)が表示
され、そこに隠れたテキストがあることを示します。連続する複数の行を非表示
にした場合も、省略記号は1つだけです。

   ‘C-n’や‘C-p’のような、複数の行にたいして操作を行う編集コマンドは、非
表示の行のテキストを、その前にある表示された行の一部として扱います。表示
された行の最後にある省略記号をkillすると、省略記号に対応する後続のすべて
の非表示テキストを実際にkillします。

   Outline minorモードは、メジャーモードであるOutlineモードと同じコマン
ドを提供する、バッファーローカルなマイナーモードで、他のメジャーモードと
合わせて使うことができます。‘M-x outline-minor-mode’とタイプして、カレン
トバッファーにたいしてOutline minorモードを切り替えることができます。フ
ァイルローカル変数のセッティングを使用して、特定のファイルにたいして有効
にすることもできます(*note File Variables::を参照してください)。

   メジャーモードのOutlineモードは、‘C-c’プレフィクスで特別なキーバイン
ディングを提供します。Outline minorモードは、‘C-c @’プレフィクスで同様な
バインディングを提供します。これは他のメジャーモードの特別なコマンドとの
競合を減らすためです(変数‘outline-minor-mode-prefix’は、使用するプレフィ
クスを制御します)。

* Menu:

* Outline Format::           アウトラインのテキストがどのように見えるか。
* Outline Motion::           アウトラインを移動するための特別なコマンド。
* Outline Visibility::       なにを表示するか制御するコマンド。
* Outline Views::            アウトラインと複数ビュー。
* Foldout::                  アウトラインをズームする折り畳み。


File: emacs-ja.info,  Node: Outline Format,  Next: Outline Motion,  Up: Outline Mode

25.8.1 アウトラインのフォーマット
---------------------------------

Outlineモードは、バッファーの行には2つのタイプがあると仮定します。それは
“ヘッダー行(heading lines)”と“ボディー行(body lines)”です。ヘッダー行は
アウトラインのトピックを表します。ヘッダー行は1つ以上のアスタリスク文字
(‘*’)で開始されます。アスタリスクの数はアウトライン構造でのヘッダーの深
さを決定します。したがって1つの‘*’がついたトピックは、メジャーなトピック
になります。このヘッダーと、次の‘*’が1つのヘッダーの間にある、‘*’が2つの
ヘッダー行は、そのヘッダーのサブトピックです。ヘッダー行ではないすべての
行はボディー行です。ボディー行は、それの前にあるヘッダー行に属します。以
下は例です:

     * Food
     This is the body,
     which says something about the topic of food.

     ** Delicious Food
     This is the body of the second-level header.

     ** Distasteful Food
     This could have
     a body too, with
     several lines.

     *** Dormitory Food

     * Shelter
     Another first-level topic with its header line.

   ヘッダー行とそれに属するすべてのボディー行を合わせて、“エントリー
(entry)”と呼びます。ヘッダー行と、その配下にあるすべてのヘッダー行、それ
らすべてのボディー行を、“サブツリー(subtree)”と呼びます。

   ヘッダー行と判別する条件は、変数‘outline-regexp’をセットすることによ
りカスタマイズできます(これを行う推奨された方法は、メジャーモードの関数
を使うか、ファイルローカル変数を使う方法です)。行の開始がこのregexpにマ
ッチする行は、ヘッダー行と判断されます。(行の左端ではなく)行の途中でのマ
ッチは勘定に入りません。

   テキストにたいするマッチの長さは、ヘッダーのレベルを決定します。長い
マッチは、より深くネストされたレベルとなります。‘@chapter’、‘@section’、
‘@subsection’というコマンドが、ドキュメントをチャプター、セクション、サ
ブセクションに分割するようなテキストフォーマッターがある場合(訳注:
texinfo形式のこと)、‘outline-regexp’に‘"@chap\\|@\\(sub\\)*section"’をセ
ットすることにより、それらの行をヘッダー行と判断させることができます。こ
こでトリックに注意してください。2つの単語‘chapter’と‘section’は同じ長さ
です。しかしregexp‘chap’だけにマッチするように定義することによって、チャ
プターのヘッダーにマッチするテキストの長さを短くすることができるので、
Outlineモードはセクションがチャプターの配下であることを知ることができま
す。これは‘@chap’で始まるコマンドが他にない場合に限り機能します。

   変数‘outline-level’をセットすることにより、ヘッダー行のレベルを計算す
るためのルールを明示できに指定できます。‘outline-level’の値には、引数を
とらないカレントヘッダーのレベルを返す関数を指定します。この変数をセット
する推奨された方法は、メジャーモードのコマンドを使うか、ファイルローカル
変数を使用する方法です。


File: emacs-ja.info,  Node: Outline Motion,  Next: Outline Visibility,  Prev: Outline Format,  Up: Outline Mode

25.8.2 アウトライン移動コマンド
-------------------------------

Outlineモードはヘッダー行を後方または前方に移動する、特別な移動コマンド
を提供します。

‘C-c C-n’
     ポイントを次の可視なヘッダー行に移動します
     (‘outline-next-visible-heading’)。
‘C-c C-p’
     ポイントを前の可視なヘッダー行に移動します
     (‘outline-previous-visible-heading’)。
‘C-c C-f’
     ポイントを同じレベルの、次の可視なヘッダー行に移動します
     (‘outline-forward-same-level’)。
‘C-c C-b’
     ポイントを同じレベルの、前の可視なヘッダー行に移動します
     (‘outline-backward-same-level’)。
‘C-c C-u’
     ポイントを、より低い(より包括的な)レベルの可視のヘッダー行に移動し
     ます(‘outline-up-heading’)。

   ‘C-c C-n’ (‘outline-next-visible-heading’)は、次のヘッダー行へ下に移
動します。‘C-c C-p’ (‘outline-previous-visible-heading’)は、同じように後
方へ移動します。両方とも数引数で繰り返し回数を指定できます。

   ‘C-c C-f’ (‘outline-forward-same-level’)および‘C-c C-b’
(‘outline-backward-same-level’)は、1つのヘッダー行から、アウトライン上で
同じ深さの可視なヘッダー行に移動します。‘C-c C-u’
(‘outline-up-heading’)は、より浅くネストされたヘッダー行に後方へ移動しま
す。


File: emacs-ja.info,  Node: Outline Visibility,  Next: Outline Views,  Prev: Outline Motion,  Up: Outline Mode

25.8.3 アウトライン表示コマンド
-------------------------------

Outlineモードには、アウトライン構造にもとづいてバッファーの一部を一時的
に非表示にしたり可視にするコマンドが、いくつかあります。これらのコマンド
はアンドゥ可能ではありません。コマンドの効果は単純にアンドゥメカニズムに
記録される訳ではありませんが、それらを実行した直後に限りアンドゥできます
(*note Undo::を参照してください)。

   これらのコマンドは、“カレント”のヘッダー行に作用します。ポイントがヘ
ッダー行にある場合、それがカレントのヘッダー行です。ポイントがボディー行
にある場合、カレントヘッダー行は一番近くの前にあるヘッダー行です。

‘C-c C-c’
     カレントヘッダー行のボディーを非表示にします(‘hide-entry’)。
‘C-c C-e’
     カレントヘッダー行のボディーを可視にします(‘show-entry’)。
‘C-c C-d’
     カレントヘッダー行の配下のすべて(ヘッダー行自身は含まれません)を非
     表示にします(‘hide-subtree’)。
‘C-c C-s’
     カレントヘッダー行の配下のすべて(ボディー、サブヘッダーおよびそのボ
     ディーを含む)を可視にします(‘show-subtree’)。
‘C-c C-l’
     カレントヘッダー行のボディーと、すべてのサブヘッダーを非表示にしま
     す(‘hide-leaves’)。
‘C-c C-k’
     カレントヘッダー行のサブヘッダーをすべてのレベルで可視にします
     (‘show-branches’)。
‘C-c C-i’
     カレントヘッダー行の一番近いサブヘッダー(1レベル下)を可視にします
     (‘show-children’)。
‘C-c C-t’
     バッファーのすべてのボディー行を非表示にします(‘hide-body’)。
‘C-c C-a’
     バッファーのすべての行を可視にします(‘show-all’)。
‘C-c C-q’
     上位Nレベルのヘッダー行を除き、すべてを非表示にします
     (‘hide-sublevels’)。
‘C-c C-o’
     ポイントのあるヘッダー行またはボディー行と、そこから最上位までのレ
     ベルにあるヘッダーを除き、すべてを非表示にします(‘hide-other’)。

   これらのコマンドのうち、カレントヘッダー行に直接続くボディー行を非表
示にする‘C-c C-c’ (‘hide-entry’)と、それらを可視にする‘C-c C-e’
(‘show-entry’)が一番簡単なコマンドです。サブヘッダーとそれらのボディーは
影響を受けません。

   コマンド‘C-c C-d’ (‘hide-subtree’)および‘C-c C-s’ (‘show-subtree’)は
、より強力です。これらはカレントヘッダー行の“サブツリー” — つまりカレン
トヘッダー行のボディーと、すべての直接または間接のサブヘッダーとそのボデ
ィー — に適用されます。

   コマンド‘C-c C-l’ (‘hide-leaves’)は、カレントヘッダー行のボディーと、
サブツリーのボディーをすべて非表示にします(サブヘッダー自身は表示されま
す)。コマンド‘C-c C-k’ (‘show-branches’)は、(たとえば‘C-c C-d’)などで)前
に非表示にされたサブヘッダーを可視にします。コマンド‘C-c C-i’
(‘show-children’)はこれの穏やかなバージョンで、直接的なサブヘッダー(たと
えば1レベル下のサブヘッダー)を可視にします。

   コマンド‘C-c C-o’ (‘hide-other’)は、ポイントのあるエントリーと、その
祖先(アウトライン構造上でそこから最上位レベルに至るまでのヘッダー)、およ
びトップレベルのヘッダーを除き、すべてを非表示にします。

   残りのコマンドは、バッファー全体に作用するコマンドです。‘C-c C-t’
(‘hide-body’)はすべてのボディー行を非表示にするので、アウトライン構造だ
けを見ることができます(特別な例外として、ファイルの最初にあるヘッダー行
より前の行は、技術的に言うとボディー行ですが、これらは非表示になりません
)。‘C-c C-a’ (‘show-all’)はすべての行を可視にします。‘C-c C-q’
(‘hide-sublevels’)は最上位のヘッダーを除き、すべてを非表示にします。数引
数Nを指定すると、上位Nレベルのヘッダー行を除き、すべてを非表示にします。

   インクリメンタル検索が、Outlineモードにより非表示にされたテキストを検
索したとき、検索された部分のバッファーは可視になります。その位置で検索を
抜けると、テキストは可視のまま残ります。アクティブなインクリメンタル検索
が、非表示のテキストにマッチするかを切り替えるには、‘M-s i’とタイプしま
す。将来の検索にたいしてデフォルトを変更するには、オプション
‘search-invisible’をカスタマイズします(このオプションは‘query-replace’、
および関連する機能が非表示のテキストを扱う方法に影響を与えます。*note
Query Replace::を参照してください)。バッファーローカルなマイナーモード
Revealモード(‘M-x reveal-mode’)を使用して、操作にしたがって自動的にテキ
ストを可視にもできます。


File: emacs-ja.info,  Node: Outline Views,  Next: Foldout,  Prev: Outline Visibility,  Up: Outline Mode

25.8.4 複数ビューによるアウトラインの閲覧
-----------------------------------------

1つのアウトラインを同時に2つのビューで、別のウィンドウで表示することがで
きます。これを行うには、‘M-x make-indirect-buffer’を使ってインダイレクト
バッファーを作らなければなりません。このコマンドの最初の引数は既存のアウ
トラインバッファーの名前で、2番目の引数は新しくインダイレクトバッファー
として使用する名前です。*note Indirect Buffers::を参照してください。

   1度インダイレクトバッファーが作成されると、‘C-x 4 b’や他のEmacsコマン
ドで、通常のやり方でウィンドウにそれを表示できます。テキストの一部を可視
にしたり非表示にするOutlineモードのコマンドは、それぞれのバッファーで独
立したエントリーを操作し、それぞれのバッファーは独自のビューをもつことが
できます。同じアウトラインにたいして2つ以上のビューが欲しいときは、追加
でインダイレクトバッファーを作成します。


File: emacs-ja.info,  Node: Foldout,  Prev: Outline Views,  Up: Outline Mode

25.8.5 折り畳み編集
-------------------

Foldoutパッケージは、OutlineモードおよびOutline minorモードを、“フォール
ディング(folding: 折り畳みの)”コマンドで拡張します。フォールディングのア
イデアは、アウトラインのネストされた部分にたいして、それに関連する部分と
、より高いレベルが非表示のときに、それにズームインするというものです。

   すべてのテキストと、レベル1より下のレベルが非表示になっている
Outlineモードのバッファーを考えてください。それらのヘッダーの下に何が隠
れているか見るには、‘C-c C-e’ (‘M-x show-entry’)でボディーを可視にするか
、‘C-c C-i’でその子ヘッダー(レベル2)を可視にすることができます。

   Foldoutでは、‘C-c C-z’ (‘M-x foldout-zoom-subtree’)を使います。これは
そのヘッダーのボディーと、その子サブヘッダーを可視にして、バッファーをナ
ローイングするので、レベル1にヘッダーとボディー、それにレベル2のヘッダー
だけが可視になります。そのうちの1つのレベル2ヘッダーの下を見るには、カー
ソル位置をそのヘッダーに移動して、もう一度‘C-c C-z’を使用します。これに
より、そのレベル2ヘッダーのボディーと、レベル3の子サブヘッダーが可視にな
り、バッファーが再びナローイングされます。連続して好きなだけサブヘッダー
をズームインすることができます。モードラインの文字列には、今どの深さにい
るのかが表示されます。

   ヘッダーにズームインしているときに、それらの子サブヘッダーを見るには
‘C-u C-c C-z’のように数引数を指定します。何レベル下の子かを指定すること
もできます(‘M-x show-children’に相当します)。たとえば‘M-2 C-c C-z’は2レ
ベルの子サブヘッダーを可視にします。ボディーを指定するには‘M-- C-c C-z’の
ように負の引数を指定します。‘C-c C-s’ (‘M-x show-subtree’)のようにサブツ
リー全体を展開するには、‘M-0 C-c C-z’のように引数に0を指定します。

   ズームインしている時でも、Outlineモードの表示および非表示の関数は、
Foldoutに干渉せずに使用できます。バッファーがナローイングされているので
、“グローバル”な編集操作は、ズームインされたヘッダーのテキストだけに影響
します、これは特定のチャプターやセクションに変更を限定するのに便利です。

   フォールドのズームを取り消す(抜ける)には、‘C-c C-x’ (‘M-x
foldout-exit-fold’)を使用します。これは最上位レベルのヘッダーの配下のす
べてのテキストと、サブヘッダーを非表示にして、バッファーの以前のビューに
戻ります。数引数はフォールドを何レベル抜けるかを指定します。0を指定する
とすべてのフォールドを抜けます。

   テキストとサブヘッダーを非表示にせずに、フォールドのナローイングを取
り消すには、負の引数を指定します。たとえば、‘M--2 C-c C-x’は2つのフォー
ルドを抜け出し、テキストとサブヘッダーは表示されたままにします。

   Foldoutモードはフォールドへの出入りと、非表示のテキストを表示するため
のマウスコマンドも提供します:

‘C-M-Mouse-1’でヘッダーをクリックするとズームインします。
          シングルクリック: ボディーを可視にします。
          ダブルクリック: サブヘッダーを可視にします。
          トリプルクリック: ボディーとサブヘッダーを可視にします。
          4連クリック: サブツリー全体を可視にします。
‘C-M-Mouse-2’でヘッダーをクリックしたときは可視になります
          シングルクリック: ボディーを可視にします。
          ダブルクリック: サブヘッダーを可視にします。
          トリプルクリック: ボディーとサブヘッダーを可視にします。
          4連クリック: サブツリー全体を可視にします。
‘C-M-Mouse-3’でヘッダーをクリックすると、ヘッダーの配下のテキストを非表示にするか、フォールドを抜けます
          シングルクリック: サブツリーを非表示にします。
          ダブルクリック: フォールドを抜けてテキストを非表示にします。
          トリプルクリック: テキストを非表示にせずにフォールドを抜けます
          4連クリック: すべてのフォールドを抜けてテキストを非表示にしま
          す。

   ‘foldout-mouse-modifiers’をセットすることにより、(‘<Ctrl>-<META>-’の
かわりに)他の修飾キーを指定できます。すでに‘foldout.el’ライブラリーがロ
ードされている場合、これが効果をもつために再ロードしなければなりません。

   Foldoutパッケージを使用するには、‘M-x load-library <RET> foldout
<RET>’とタイプするか、initファイルに以下の行を記述して自動的にこれを行う
ことができます。

     (eval-after-load "outline" '(require 'foldout))


File: emacs-ja.info,  Node: Org Mode,  Next: TeX Mode,  Prev: Outline Mode,  Up: Text

25.9 Orgモード
==============

Orgモードは、Emacsをオーガナイザーおよび／またはオーサリングツールとして
使用するための、Outlineモードの変種です。名前が拡張子‘.org’で終わるファ
イルは、Orgモードで開かれます(*note Choosing Modes::を参照してください
)。明示的にOrgモードに切り替えるには、‘M-x org-mode’とタイプしてください
。

   Orgモードでは、Outlineモードのように、各エントリーは1つ以上の‘*’文字
で始まるヘッダー行をもちます。*note Outline Format::を参照してください。
それに加えて、‘#’文字で始まる行は、コメントとして扱われます。

   Orgモードは、簡単にアウトライン構造を眺めたり操作するためのコマンドを
提供します。それらのコマンドのうち、一番簡単なのは<TAB> (‘org-cycle’)で
す。ヘッダー行でこのコマンドを呼び出すと、サブツリーを — (i)ヘッダー行だ
けを表示 (ii)ヘッダー行と、(あれば)直接の子ヘッダー行だけを表示 (iii)サ
ブツリー全体を表示 — の3つの異なる視点で巡回します。ボディー行にたいして
呼び出された場合、<TAB>にグローバルにバインドされたコマンドが実行されま
す。

   Orgモードのバッファーの任意の場所で、‘S-<TAB>’ (‘org-shifttab’)とタイ
プすることにより、アウトライン構造全体を — (i) 最上位ㇾベルのヘッダー行
だけを表示 (ii)ボディー行を除いたすべてのヘッダー行を表示 (iii) すべてを
表示 — の3つの異なる視点で巡回します。

   ヘッダー行で‘M-<up>’ (‘org-metaup’)または‘M-<down>’ (‘org-metadown’)と
タイプすることにより、ボディー行と(あれば)サブツリーを含むバッファー内の
エントリー全体を、上または下に移動できます。同様に‘M-<left>’
(‘org-metaleft’)および‘M-<right>’ (‘org-metaright’)で、ヘッダー行を昇格
または降格できます。ボディー行で呼び出された場合は、それらのキーにグロー
バルにバインドされたコマンドが実行されます。

   以下のサブセクションでは、オーガナイザーやオーサリングシステムとして
Orgモードを使用するための基本的な操作方法を解説します。詳細については、
*note The Org Mode Manual: (org)Top.を参照してください。

* Menu:

* Org Organizer::            TODOリストとアジェンダの管理。
* Org Authoring::            Orgバッファーをさまざまなフォーマットでエクスポートする。


File: emacs-ja.info,  Node: Org Organizer,  Next: Org Authoring,  Up: Org Mode

25.9.1 オーガナイザーとしてのOrg
--------------------------------

エントリー内のどこかで‘C-c C-t’ (‘org-todo’)とタイプすることにより、その
Orgエントリーを“TODO”アイテムとして、タグ付けすることができます。これは
ヘッダー行にキーワード‘TODO’を追加します。もう一度‘C-c C-t’をタイプする
とキーワードは‘DONE’に切り替わり、さらに‘C-c C-t’とタイプするとキーワー
ド全体を除去します。‘C-c C-t’で使用されるキーワードは、変数
‘org-todo-keywords’を通じてカスタマイズすることができます。

   エントリーをTODOとして作成する他に、エントリー内で‘C-c C-s’
(‘org-schedule’)とタイプすることにより、日付を割り当てることができます。
これはEmacs Calender(*note Calendar/Diary::を参照してください)をポップア
ップして日付の入力を求め、選択された日付と一緒に、ヘッダー行の下にタグ
‘SCHEDULED’を追加します。コマンド‘C-c C-d’ (‘org-deadline’)も、タグ
‘DEADLINE’を使う以外は同じ効果をもちます。

   1度Orgファイルに計画されたTODOアイテムをもつと、‘C-c [’
(‘org-agenda-file-to-front’)とタイプすることにより、“アジェンダファイル
(agenda files)”のリストにそのファイルを追加できます。Orgモードは、たとえ
ばあなたの生活のさまざまな側面をオーガナイズするために、複数のアジェンダ
ファイルを簡単に保守できるようにデザインされています。アジェンダファイル
のリストは、変数‘org-agenda-files’に格納されています。

   アジェンダファイルのアイテムを閲覧するには、‘M-x org-agenda’とタイプ
します。このコマンドは何を見たいのか、入力を求めます(今週に行なうすべて
の事項のリストか、特定のキーワードにマッチするTODOアイテムのリストか、な
ど)。 詳細は、*note (org)Agenda Views::を参照してください。


File: emacs-ja.info,  Node: Org Authoring,  Prev: Org Organizer,  Up: Org Mode

25.9.2 オーサリングシステムとしてのOrg
--------------------------------------

Orgノートを見映えよくフォーマットしたり、エクスポートして公表したいと思
うかもしれません。カレントバッファーをエクスポートするには、Orgバッファ
ーのどこかで‘C-c C-e’ (‘org-export’)とタイプします。このコマンドはエクス
ポートするフォーマットの入力を求めます。現在サポートされているフォーマッ
トは、HTML、LaTeX、OpenDocument(‘.odt’)、PDFです。PDFのようないくつかの
フォーマットは、システムに特定のツールがインストールされている必要があり
ます。

   1度に複数のファイルを特定のディレクトリー(ローカルまたはネットワーク
越し)にエクスポートするには、変数‘org-publish-project-alist’にプロジェク
トのリストを定義しなければなりません。詳細はOrgのドキュメントを参照して
ください。

   Orgはエクスポートされたドキュメントのテキストのフォーマットに適用する
、シンプルなマークアップの仕組みをサポートします:

     - This text is /emphasized/
     - This text is *in bold*
     - This text is _underlined_
     - This text uses =a teletype font=

     #+begin_quote
     ``This is a quote.''
     #+end_quote

     #+begin_example
     This is an example.
     #+end_example

   詳細は、*note (org)Exporting::、および*note (org)Publishing::を参照し
てください。


File: emacs-ja.info,  Node: TeX Mode,  Next: HTML Mode,  Prev: Org Mode,  Up: Text

25.10 TeXモード
===============

Emacsは、TeXおよびそれに関連するフォーマットで記述されたファイルを編集す
るための、特別なメジャーモードを提供します。TeXはDonald Knuthにより記述
された強力なテキストフォーマッターで、GNU Emacsと同様、フリーなソフトウ
ェアーです。LaTeXはTeXのための簡略化された入力フォーマットで、TeXマクロ
を使って実装されています。DocTeXはLaTeXソースが記述された特別なファイル
フォーマットで、ソースとドキュメントが合成されています。SliTeXは、時代遅
れの特別なLaTeX形式です。(1)

   TeXには4つの変種があります。それはPlain TeXモード、LaTeXモード、
DocTeXモード、SliTeXモードです。これら4つのメジャーモード間の違いはわず
かで、4つの異なるフォーマットを編集するためにデザインされています。
Emacsはバッファーの内容を調べて適切なモードを選択します(通常これはTeX風
なファイルをvisitしたときに自動的に呼び出される‘tex-mode’コマンドにより
行われます。*note Choosing Modes::を参照してください)。ファイル内容がこ
れを決定するのに不十分な場合、Emacsは‘tex-default-mode’に指定されたモー
ドを選択します。デフォルト値は‘latex-mode’です。Emacsが間違った選択をし
たときは、コマンド‘M-x plain-tex-mode’、‘M-x latex-mode’、‘M-x
slitex-mode’、‘doctex-mode’を使用して、正しいTeXモードの変種を選択できま
す。

   以下のセクションでは、TeXモードとその変種の機能について記述しています
。TeXに関連したモードは他にもいくつかありますが、このマニュアルには記述
されていません。

   • BibTeXモードはBibTeXファイルのためのメジャーモードで、これは一般的
     にはLaTeX文書の図書目録リファレンスを維持するのに使用されます。詳細
     については、コマンド‘bibtex-mode’のドキュメント文字列を参照してくだ
     さい。

   • RefTeXパッケージは、図書目録リファレンスを管理するLaTeXモードとして
     使用されるマイナーモードを提供します。 *note The RefTeX Manual:
     (reftex)Top.を参照してください。

   • AUCTeXパッケージは、TeXおよびそれに関連するフォーマットを編集するた
     めの。より先進的な機能を提供します。これにはEmacsバッファーでTeXを
     プレビューする機能も含まれます。BibTeXモードやRefTeXパッケージとは
     異なり、AUCTeXはデフォルトではEmacsとともには配布されません。これは
     Packageメニュー(*note Packages::を参照してください)を通じてダウンロ
     ードできます。インストールされた後に、 *note The AUCTeX Manual:
     (auctex)Top.を参照してください。

* Menu:

* TeX Editing::              TeXモードで編集するための特別なコマンド。
* LaTeX Editing::            LaTeX入力ファイルのための追加のコマンド。
* TeX Print::                ファイルの一部をTeXで印刷するコマンド。
* TeX Misc::                 TeXモードのカスタマイズと関連する機能。

   ---------- Footnotes ----------

   (1) これはLaTeX由来の‘slides’ドキュメントクラスにより置き換えられまし
た。


File: emacs-ja.info,  Node: TeX Editing,  Next: LaTeX Editing,  Up: TeX Mode

25.10.1 TeX編集コマンド
-----------------------

‘"’
     コンテキストに応じて‘``’、‘"’、‘''’のどれかを挿入します
     (‘tex-insert-quote’)。
‘C-j’
     パラグラフの区切り(2つの改行)を挿入して、前のパラグラフのバランスの
     取れていない大カッコ(braces)やドル記号をチェックします
     (‘tex-terminate-paragraph’)。
‘M-x tex-validate-region’
     リージョン内のパラグラフの、バランスのとれていない大カッコやドル記
     号をチェックします。
‘C-c {’
     ‘{}’を挿入して、ポイントをその間に配します(‘tex-insert-braces’)。
‘C-c }’
     対応が取れていない、次の閉じ大カッコの後ろに、前方に移動します
     (‘up-list’)。

   TeXでは文字‘"’は通常使用されません。かわりに‘``’で始まり‘''’で終わる
引用が使用されます。したがってTeXモードは‘"’キーを‘tex-insert-quote’コマ
ンドにバインドしています。これは空白文字または開き大カッコの後ろに‘``’、
バックスラッシュの後に‘"’、それ以外の文字の場合は‘''’を挿入します。

   特別な例外として、ポイントの前のテキストが‘``’か‘''’のときに‘"’をタイ
プすると、Emacsは前のテキストを1つの‘"’で置き換えます。したがって、必要
がある時は‘""’とタイプして‘"’を挿入できます(‘C-q "’を使用してこの文字を
挿入することもできます)。

   TeXモードでは、‘$’は特別な構文コードを持っていて、それはTeXの数式モー
ドの区切りを理解しようと試みます。数式モードを抜けるために‘$’を入力した
場合、数式モードに入るための対応する‘$’の位置が1秒間表示されます。これは
閉じ大カッコが挿入されたとき、それに対応する開き大カッコが表示されるのと
同じき機能です。しかし‘$’が数式モードに入るためなのか、それとも抜けるた
めなのかを指示する方法はありません。したがって、もし対応するものがある場
合、実際にはそれが関係なくても、前の‘$’の位置が表示されます。

   TeXは大カッコを、対応が取れていなければならない区切りとして使用します
。これを1つずつ挿入するより、つねに大カッコの対応が取られている方を好む
ユーザーもいます。‘C-c {’ (‘tex-insert-braces’)を使うと、対になった大カ
ッコを挿入します。これはポイントを2つの大カッコの間に配すので、中のテキ
ストを挿入することができます。その後でコマンド‘C-c }’ (‘up-list’)を使用
すると、前方の閉じ大カッコの先に移動します。

   対応の取れていない大カッコをチェックするコマンドが2つあります。‘C-j’
(‘tex-terminate-paragraph’)は、ポイントの前のパラグラフをチェックして、
新しいパラグラフを開始するための2つの改行を挿入します。対応が取れていな
いものが見つかった場合、エコーエリアにメッセージを出力します。‘M-x
tex-validate-region’はリージョンを、パラグラフごとにチェックします。エラ
ーは‘*Occur*’バッファーにリストされます。そのバッファーでは、特定のミス
マッチをvisitする‘C-c C-c’などの、通常のOccurモードのコマンドを使用でき
ます(*note Other Repeating Search::を参照してください)。

   TeXのEmacsコマンドは大カッコだけではなく、角カッコ(square brackets)や
カッコ(parentheses)などもカウントすることに注意してください。これはTeX構
文をチェックする目的としては、厳密に正しいとは言えません。しかしカッコと
角カッコはテキストの中で、同じような対応の取れた区切りとして使用され、さ
まざまな移動コマンドや、対応する区切りの表示が、それらにたいして機能する
のは便利なのです。


File: emacs-ja.info,  Node: LaTeX Editing,  Next: TeX Print,  Prev: TeX Editing,  Up: TeX Mode

25.10.2 LaTeX編集コマンド
-------------------------

LaTeXモードは、plain TeXには適用できない特別な機能をいくつか提供します:

‘C-c C-o’
     LaTeXブロックのための‘\begin’と‘\end’を挿入して、ポイントをそれらの
     間の行に配します(‘tex-latex-block’)。
‘C-c C-e’
     まだ閉じていない一番内側のLaTeXブロックを閉じます
     (‘tex-close-latex-block’)。

   LaTeX入力では、テキストをブロック化するのに‘\begin’と‘\end’のタグが使
用されます。ブロックを挿入するには‘C-c C-o’ (‘tex-latex-block’)とタイプ
します。これはブロックタイプの入力を求め、適切な対応する‘\begin’と
‘\end’を挿入し、その2行の間に空行を残してポイントをそこに移動します。

   ‘C-c C-o’にたいしてブロックタイプを入力するとき、通常の補完コマンドを
使用できます(*note Completion::を参照してください)。デフォルトの補完リス
トには、標準的なLaTeXのブロックタイプが含まれています。補完にブロックタ
イプを追加したい場合は、リスト変数‘latex-block-names’をカスタマイズして
ください。

   LaTeX入力では、‘\begin’と‘\end’のタグは対応が取れていなければなりませ
ん。‘C-c C-e’ (‘tex-close-latex-block’)により、対応が取れていない最後の
‘\begin’に対応する‘\end’を挿入することができます。これは対応する
‘\begin’に調和するように‘\end’をインデントし、ポイントが行の先頭にあると
きは‘\end’タグの後ろに改行を挿入します。マイナーモード
‘latex-electric-env-pair-mode’は、‘\end’か‘\begin’の一方をタイプしたとき
、自動的に対応する‘\end’または‘\begin’を挿入します。


File: emacs-ja.info,  Node: TeX Print,  Next: TeX Misc,  Prev: LaTeX Editing,  Up: TeX Mode

25.10.3 TeX印刷コマンド
-----------------------

バッファーの全内容、または一部(たとえば大きなドキュメントの1つのチャプタ
ー)にたいして、TeXをEmacsのサブプロセスとして呼び出すことができます。

‘C-c C-b’
     カレントバッファー全体にたいしてTeXを呼び出します(‘tex-buffer’)。
‘C-c C-r’
     バッファーのヘッダーとともに、カレントリージョンにたいしてTeXを呼び
     出します(‘tex-region’)。
‘C-c C-f’
     カレントファイルにたいしてTeXを呼び出します(‘tex-file’)。

‘C-c C-v’
     最後の‘C-c C-r’、‘C-c C-b’、‘C-c C-f’コマンドの出力をプレビューしま
     す(‘tex-view’)。

‘C-c C-p’
     最後の‘C-c C-b’、‘C-c C-r’、‘C-c C-f’コマンドの出力を印刷します
     (‘tex-print’)。

‘C-c <TAB>’
     カレントファイルにたいしてBibTeXを呼び出します(‘tex-bibtex-file’)。
‘C-c C-l’
     TeX出力を表示するウィンドウを再センタリングして、最後の行が見えるよ
     うにします(‘tex-recenter-output-buffer’)。
‘C-c C-k’
     TeXサブプロセスをkillします(‘tex-kill-job’)。
‘C-c C-c’
     カレントバッファー全体にたいして、他のコンパイルコマンドを呼び出し
     ます(‘tex-compile’)。

   カレントバッファーをTeXに渡すには、‘C-c C-b’ (‘tex-buffer’)とタイプし
ます。フォーマットされた出力は、通常‘.dvi’という一時ファイルに出力されま
す。その後で‘C-c C-v’ (‘tex-view’)とタイプして、‘xdvi’のような外部プログ
ラムを起動して、出力ファイルを閲覧することができます。‘C-c C-p’
(‘tex-print’)とタイプして出力ファイルのハードコピーを印刷することもでき
ます。

   デフォルトでは‘C-c C-b’は、カレントディレクトリーでTeXを実行します。
TeXの出力もこのディレクトリーに出力されます。TeXを違うディレクトリーで実
行するには、変数‘tex-directory’を望むディレクトリー名に変更します。環境
変数‘TEXINPUTS’に相対ディレクトリーが含まれていたり、ファイルに含まれる
‘\input’コマンドが相対ファイル名の場合、‘tex-directory’を‘"."’に_しない
と_、望ましくない結果となるでしょう。そうでない場合は、‘"/tmp"’などの他
のディレクトリーを指定しても安全です。

   そのバッファーにたいするTeXの変種は、‘C-c C-b’で実際に実行されるシェ
ルコマンドを決定します。Plain TeXモードでは、これは変数
‘tex-run-command’で指定され、デフォルトは‘"tex"’です。LaTeXモードでは、
これは‘latex-run-command’で指定され、デフォルトは‘"latex"’です。‘.dvi’を
閲覧するために‘C-c C-v’で実行されるシェルコマンドは、TeXの種類に関係なく
、変数‘tex-dvi-view-command’で決定されます。出力を印刷するために‘C-c
C-p’で実行されるシェルコマンドは、変数‘tex-dvi-print-command’で決定され
ます。

   Emacsは出力ファイル名に通常、前のパラグラフで説明したシェルコマンド文
字列を自動的に追加します。たとえば‘tex-dvi-view-command’が‘"xdvi"’のとき
、‘C-c C-v’は‘xdvi OUTPUT-FILE-NAME’を実行します。しかし、ファイル名がコ
マンドに埋め込まれている必要があるケース、たとえばあるコマンドの引数にフ
ァイル名を与えて、そのコマンドの出力をパイプで他のコマンドに渡さなければ
いけない場合があります。コマンド文字列の‘*’で、ファイル名をどこに置くか
指定することができます。以下は例です

     (setq tex-dvi-print-command "dvips -f * | lpr")

   エラーメッセージを含むTeXからの端末出力は、‘*tex-shell*’という名前の
バッファーに表示されます。TeXでエラーが発生した場合、このバッファーに切
り替えて、適切な入力を与えることができます(これはShellモードで機能します
。*note Interactive Shell::を参照してください)。このバッファーに切り替え
なくても、これをスクロールできるので、‘C-c C-l’とタイプして最後の行を表
示することができます。

   これ以上の出力が有用でないと判断した時は、‘C-c C-k’ (‘tex-kill-job’)と
タイプしてTeXプロセスをkillします。‘C-c C-b’および‘C-c C-r’の使用すると
きも、TeXがまだ実行中の時はkillします。

   ‘C-c C-r’ (‘tex-region’)とタイプして、任意のリージョンをTeXに渡すこと
ができます。しかし、これはトリッキーです。なぜならほとんどのTeX入力ファ
イルは、先頭にパラメーターをセットしたりマクロを定義するコマンドを含んで
いるからです。この問題を解決するために、‘C-c C-r’では、必須のマクロを含
むファイル部分を指定することができます。指定したリージョンの前にそれを含
めて、TeXの入力の一部とします。ファイルの必須と指定された部分を“ヘッダー
”と呼びます。

   Plain TeXモードでヘッダーの境界を示すには、ファイルに2つの特別な文字
列を挿入します。これはヘッダーの前に‘%**start of header’、ヘッダーの後ろ
に‘%**end of header’を記述します。これらの文字列は1行に全体を記述しなけ
ればなりませんが、文字列の前または後ろに他のテキストがあっても構いません
。この2つの文字列を含む行はヘッダーの中に含まれます。‘%**start of
header’がバッファーの先頭100行にない場合、‘C-c C-r’はヘッダーがないとみ
なします。

   LaTeXモードでは、ヘッダーは‘\documentclass’または‘\documentstyle’で始
まり、‘\begin{document}’で終わります。いかなる場合でもLaTeXがこれらを要
求するので、ヘッダーを識別するのに特別なことをする必要はありません。

   コマンド(‘tex-buffer’)および(‘tex-region’)は、すべてを一時ディレクト
リーで処理します。そしてTeXでクロスリファレンスのために必要となる補助的
なファイルは利用不可です。一般的にこれらのコマンドは、すべてのクロスリフ
ァレンスが正しい必要がある最終コピーのために実行するのには適していません
。

   クロスリファレンスのための補助的なファイルを使いたいときは、‘C-c C-f’
(‘tex-file’)を使用します。これはカレントバッファーのファイルにたいして、
そのファイルのディレクトリーでTeXを実行します。TeXを実行する前に、変更さ
れたバッファーを保存するか確認が求められます。一般的には、クロスリファレ
ンスを正しく取得するために、2回(‘tex-file’)を使用する必要があります。

   変数‘tex-start-options’の値は、TeXを実行するためのオプションを指定し
ます。

   変数‘tex-start-commands’の値は、TeXを開始するTeXコマンドを指定します
。デフォルト値はTeXをノンストップモードで実行します。対話的にTeXを実行す
るときは、変数に‘""’をセットします。

   大きなサイズのTeXドキュメントは複数のファイル — 1つはメインファイルで
、他はサブファイル — に分割されているときがあります。サブファイルにたい
してTeXを実行しても通常は動作しません。メインファイルにたいして実行する
必要があるのです。サブファイルを編集するのに‘tex-file’を使えるようにする
には、変数‘tex-main-file’にメインファイルの名前をセットします。その後は
‘tex-file’はそのファイルにたいしてTeXを実行します。

   ‘tex-main-file’を使用する一番簡単な方法は、各サブファイルのローカル変
数リストにそれを指定する方法です。*note File Variables::を参照してくださ
い。

   LaTeXファイルにたいしては、BibTeXを使用してカレントバッファーのファイ
ルのための補助的なファイルを処理できます。BibTeXはデータベースの図書目録
の引用(bibliographic citations)を探して、図書目録のセクション
(bibliography section)のための引用文献(cited references)を準備します。コ
マンド‘C-c <TAB>’ (‘tex-bibtex-file’)は、カレントバッファーのファイルに
たいする‘.bbl’ファイルを生成するためにシェルコマンド
(‘tex-bibtex-command’)を実行します。一般的に、‘.aux’ファイルを生成するた
めに一度‘C-c C-f’ (‘tex-file’)を行う必要があります。その後‘C-c <TAB>’
(‘tex-bibtex-file’)を行ってから、さらなるクロスリファレンスを正しく取得
するために‘C-c C-f’ (‘tex-file’)を2回行います。

   カレントのTeXバッファーで、他のコンパイルプログラムを呼び出すには、
‘C-c C-c’ (‘tex-compile’)をタイプします。このコマンドは‘pdflatex’、
‘yap’、‘xdvi’、‘dvips’を含む、多くの一般的なプログラムに渡す引数を知って
います。標準の補完キーを使用して望ましいコンパイルプログラムを選択できま
す(*note Completion::を参照してください)。


File: emacs-ja.info,  Node: TeX Misc,  Prev: TeX Print,  Up: TeX Mode

25.10.4 TeXモード、その他
-------------------------

TeXモードの変種に入ると、フック‘text-mode-hook’および‘tex-mode-hook’を実
行します。その後、‘plain-tex-mode-hook’、‘latex-mode-hook’、
‘slitex-mode-hook’のうち、適切なものを実行します。TeXシェルを開始すると
、フック‘tex-shell-hook’を実行します。*note Hooks::を参照してください。

   コマンド‘M-x iso-iso2tex’、‘M-x iso-tex2iso’、‘M-x iso-iso2gtex’、
‘M-x iso-gtex2iso’はLatin-1でエンコードされたファイルと、TeXでエンコード
された等価なファイルの変換に使用できます。


File: emacs-ja.info,  Node: HTML Mode,  Next: Nroff Mode,  Prev: TeX Mode,  Up: Text

25.11 SGMLモードとHTMLモード
============================

SGMLおよびHTMLのためのメジャーモードは、インデントのサポートとタグを操作
するコマンドを提供します。HTMLモードはSGMLモード少しカスタマイズした変種
です。

‘C-c C-n’
     対話的に特殊文字を指定して、その文字に対応するSGMLの‘&’コマンドを挿
     入します(‘sgml-name-char’)。

‘C-c C-t’
     対話的にタグとタグの属性を指定します(‘sgml-tag’)。このコマンドはタ
     グ名と属性値を尋ね、開始タグと終了タグの両方を挿入し、ポイントをそ
     の間に置きます。

     プレフィクス引数Nを指定すると、このコマンドはバッファーのポイントの
     後ろにあるN個の単語の周囲にタグを配します。リージョンがアクティブな
     ときは、タグをリージョンの周辺に配します(Transient Markモードがオフ
     のときは、引数に−1を与えることにより、これを行います)。

‘C-c C-a’
     対話的にカレントタグの属性値を挿入します(‘sgml-attributes’)。

‘C-c C-f’
     対応の取れたタグのグループ(開始タグと対応する終了タグまでの範囲)を
     スキップします(‘sgml-skip-tag-forward’)。数引数は繰り返し回数として
     振る舞います。

‘C-c C-b’
     対応の取れたタグのグループ(開始タグと対応する終了タグまでの範囲)を
     後方にスキップします(‘sgml-skip-tag-backward’)。数引数は繰り返し回
     数として振る舞います。

‘C-c C-d’
     ポイント位置またはポイントの後ろのタグを削除し、それに対応するタグ
     も削除します(‘sgml-delete-tag’)。ポイントの後のタグが開始タグの場合
     は、終了タグも削除します。終了タグの場合は、開始タグも削除します。

‘C-c ? TAG <RET>’
     タグTAGの意味の説明を表示します(‘sgml-tag-help’)。引数TAGが空のとき
     は、ポイント位置のタグを説明します。

‘C-c /’
     一番内側の終了されていないタグの終了タグを挿入します
     (‘sgml-close-tag’)。タグまたはコメントの中で呼び出されたときは、終
     了タグを挿入するかわりにそれを終了させます。

‘C-c 8’
     挿入したLatin-1文字を、その文字自身ではなく、その文字を表すSGMLコマ
     ンドを挿入するマイナーモードを切り替えます(‘sgml-name-8bit-mode’)。

‘C-c C-v’
     カレントバッファーをSGMLとして評価するシェルコマンド(指定しなければ
     ならない)を実行します(‘sgml-validate’)。

‘C-c <TAB>’
     バッファーの既存のタグの可視・不可視を切り替えます。これは簡単なプ
     レビューとして使用できます(‘sgml-tags-invisible’)。

   XMLドキュメントを編集するためのメジャーモードはnXMLモードと呼ばれます
。このモードは多くの既存のXMLスキーマを認識することができ、‘M-<TAB>’を通
じてXMLエレメントの補完、同様にエラーをハイライトする“オンザフライ”な
XMLの妥当性検証を提供します。既存のバッファーでnXMLモードを有効にするに
は、‘M-x nxml-mode’とタイプするか、‘M-x xml-mode’とタイプしても同じです
。Emacsは‘.xml’という拡張子をもつファイルにたいしてnXMLモードを使用しま
す。‘.xhtml’という拡張子をもつXHTMLファイルにたいしては、デフォルトで
EmacsはHTMLモードを使用します。変数‘auto-mode-alist’をカスタマイズするこ
とによりnXMLモードを使用させることができます(*note Choosing Modes::を参
照してください)。 nXMLモードについては、それ自身のマニュアルで説明されて
います: *note nXML Mode: (nxml-mode)Top.を参照してください。

   XMLはSGMLの厳格なサブセットなので、XMLを編集するのに、それほど強力で
はないSGMLモードの使用を選択することもできます。既存のバッファーでSGMLモ
ードを有効にするには、‘M-x sgml-mode’とタイプします。SGMLを有効にすると
き、EmacsはバッファーがXMLかどうかを検証します。もしXMLの場合、変数
‘sgml-xml-mode’に非‘nil’値をセットします。これにより上述したSGMLモードの
タグ挿入コマンドは、常に明示的に終了タグを挿入するようになります。


File: emacs-ja.info,  Node: Nroff Mode,  Next: Enriched Text,  Prev: HTML Mode,  Up: Text

25.12 Nroffモード
=================

NroffモードはTextモードから派生した、nroffファイル(たとえばUnixのman)の
編集に特化したメジャーモードです。‘M-x nroff-mode’とタイプすることにより
このモードにはいります。Nroffモードに入ることにより、フック
‘text-mode-hook’、その後で‘nroff-mode-hook’が実行されます(*note Hooks::を
参照してください)。

   Nroffモードでは、nroffコマンド行はパラグラフの区切りとして扱われ、ペ
ージは‘.bp’で区切られ、コメントはバックスラッシュとダブルクォートで始ま
ります。これは以下のコマンドも定義します:

‘M-n’
     nroffコマンドではない次の行の先頭に移動します
     (‘forward-text-line’)。引数は繰り返し回数です。
‘M-p’
     ‘M-n’と同様ですが上に移動します(‘backward-text-line’)。
‘M-?’
     エコーエリアにリージョンの、(nroffコマンドではない)テキストの行数を
     表示します(‘count-text-lines’)。

   Electric Nroffモードはバッファーローカルなマイナーモードで、Nroffモー
ドとともに使うことができます。このマイナーモードを切り替えるには、‘M-x
electric-nroff-mode’とタイプします(*note Minor Modes::を参照してください
)。このモードがオンのとき、グループ化を行う種類のnroffコマンドを含む行を
<RET>をタイプして終端すると、グループ化を閉じるnroffコマンドが自動的に後
続の行に挿入されます。

   NroffモードとともにOutline minorモード(*note Outline Mode::を参照して
ください)を使用する場合、ヘッダー行は‘.H’の後に数字(ヘッダーレベル)が続
く形式の行です。


File: emacs-ja.info,  Node: Enriched Text,  Next: Text Based Tables,  Prev: Nroff Mode,  Up: Text

25.13 Enrichedテキスト
======================

Enriched(多くの刺激を含む、豊かにした)は、フォーマットされたテキストファ
イルをWYSIWYG(“what you see is what you get”)な方法で編集するためのマイ
ナーモードです。Enrichedモードが有効な場合、フォントやカラーなどのさまざ
まなフォーマットプロパティーを、バッファーのテキストに適用できます。バッ
ファーを保存するときは、それらのプロパティーはテキストとともに、MIME形式
‘text/enriched’のファイルフォーマットを使用して保存されます。

   Enrichedモードは通常、Textモードとともに使用されます(*note Text
Mode::を参照してください)。これは多くのメジャーモード(構文のハイライトの
ためにFont Lockモードを使用するほとんどのプログラミング言語関連のモード
を含む)で使用される、Font Lockモードとの互換性は_ありません_。Enrichedモ
ードとは異なり、Font Lockモードはカレントバッファーの内容にもとづいて、
テキストのプロパティーを自動的に割り当てます。これらのプロパティーはディ
スクには保存されません。

   Emacsの‘data-directory’のファイル‘enriched.txt’は、Enrichedモードの機
能例として役に立ちます。

* Menu:

* Enriched Mode::            Enrichedモードの開始と終了。
* Hard and Soft Newlines::   改行には2つの種類があります。
* Editing Format Info::      テキストプロパティーの編集方法。
* Enriched Faces::           太字、斜体、下線、など。
* Enriched Indentation::     左余白と右余白の変更。
* Enriched Justification::   テキストの中央揃え、左揃え、右揃え、など。
* Enriched Properties::      特別なテキストプロパティーサブメニュー。


File: emacs-ja.info,  Node: Enriched Mode,  Next: Hard and Soft Newlines,  Up: Enriched Text

25.13.1 Enrichedモード
----------------------

Enrichedモードは、バッファーローカルなマイナーモードです(*note Minor
Modes::を参照してください)。‘text/enriched’フォーマットで保存されたファ
イルをvisitすると、Emacsは自動的にEnrichedモードを有効にし、ファイル内の
フォーマット情報をバッファーのテキストに適用します。Enrichedモードが有効
なときにバッファーを保存すると、ファイルはフォーマット情報を含む
‘text/enriched’フォーマットで保存されます。

   フォーマットされたテキストで新しいファイルを作成するには、存在しない
ファイルをvisitして‘M-x enriched-mode’とタイプします。このコマンドは実際
にEnrichedモードを切り替えます。プレフィクス引数を指定した場合、引数が正
のときはEnrichedモードを有効にし、それ以外はEnrichedモードを無効にします
。Enrichedモードを無効にすると、Emacsは‘text/enriched’フォーマットでバッ
ファーを保存しなくなります。バッファーに追加されたフォーマットプロパティ
ーはバッファーに残りますが、ディスクには保存されません。

   Enrichedモードは、すべてのEmacsのテキストプロパティーを保存しません。
変数‘enriched-translations’に指定されたものだけを保存します。これにはフ
ォント、カラー、インデント、行端揃えのプロパティーが含まれます。

   ファイルをvisitしたとき、ファイルが‘text/enriched’フォーマットだと
Emacsが認識できなかった場合は、‘M-x format-decode-buffer’とタイプします
。このコマンドはファイルフォーマットの入力を求め、そのフォーマットでファ
イルを再読み込みします。‘text/enriched’フォーマットを指定することにより
、自動的にEnrichedモードが有効になります。

   ‘text/enriched’ファイルをraw形式(フォーマットされたテキストではなく、
マークアップタグを伴う通常テキスト)として閲覧するには、‘M-x
find-file-literally’を使用します(*note Visiting::を参照してください)。

   Emacsが‘text/enriched’のようなファイルフォーマットを認識・変換する方
法については、*note Format Conversion: (elisp)Format Conversion.を参照し
てください。テキストプロパティーについての詳細は、*note (elisp)Text
Properties::を参照してください。


File: emacs-ja.info,  Node: Hard and Soft Newlines,  Next: Editing Format Info,  Prev: Enriched Mode,  Up: Enriched Text

25.13.2 ハード改行とソフト改行
------------------------------

Enrichedモードでは、Emacsは2つの異なる改行、“ハード”改行と“ソフト”改行を
区別します。‘M-x use-hard-newlines’とタイプすることにより、他のバッファ
ーにたいしてこの機能を有効または無効にできます。

   ハード改行は、パラグラフを分割したりテキストがフィルされる方法に関ら
ず行区切りが必要な場所で使用され、ソフト改行はフィルで使用されます。
<RET> (‘newline’)および‘C-o’ (‘open-line’)コマンドはハード改行を挿入しま
す。Auto Fill(*note Auto Fill::を参照してください)を含むフィルコマンドは
、ソフト改行だけを挿入し、削除もソフト改行だけでハード改行は削除せずに残
します。

   したがってEnrichedモードで編集するときは、フィルされたパラグラフの途
中で行を分けるのに<RET>や‘C-o’を使うべきではありません。かわりにAuto
Fillモード、または明示的なフィルコマンド(*note Fill Commands::を参照して
ください)を使用します。テーブルやリストのように、行区切りを常に残したい
場所で<RET>や‘C-o’を使用します。そのような行では、行端揃えスタイル
(justification style)も‘unfilled’にしたいと思うかもしれません(*note
Enriched Justification::を参照してください)。


File: emacs-ja.info,  Node: Editing Format Info,  Next: Enriched Faces,  Prev: Hard and Soft Newlines,  Up: Enriched Text

25.13.3 フォーマット情報の編集
------------------------------

プロパティーを変更する一番簡単な方法は、‘Text Properties’メニューです。
このメニューは、メニューバー(*note Menu Bar::を参照してください)の
‘Edit’メニュー、または‘C-Mouse-2’(*note Menu Mouse Clicks::を参照してく
ださい)で取得することができます。‘Text Properties’メニューのコマンドのい
くつかを、以下にリストします(‘M-x’)で呼び出すこともできます):

‘Remove Face Properties’
     リージョンからフェイスプロパティーを削除します
     (‘facemenu-remove-face-props’)。

‘Remove Text Properties’
     リージョンからフェイスプロパティーを含む、すべてのテキストプロパテ
     ィーを削除します(‘facemenu-remove-all’)。

‘Describe Properties’
     ポイントの後ろにある文字の、すべてのテキストプロパティーと他の情報
     をリストします(‘describe-text-properties’)。

‘Display Faces’
     定義されたフェイスのリストを表示します(‘list-faces-display’)。*note
     Faces::を参照してください。

‘Display Colors’
     定義されたカラーのリストを表示します(‘list-colors-display’)。*note
     Colors::を参照してください。

他のメニューエントリーについては、以下のセクションで説明します。


File: emacs-ja.info,  Node: Enriched Faces,  Next: Enriched Indentation,  Prev: Editing Format Info,  Up: Enriched Text

25.13.4 Enrichedテキストのフェイス
----------------------------------

以下のコマンドは、フェイスを追加または削除するのに使用することができます
(*note Faces::を参照してください)。マークがアクティブのときは、リージョ
ンのテキストに適用され、マークが非アクティブのときは、次の自己挿入文字に
適用されます。プレフィクス引数を指定すると、これらのコマンドはリージョン
がアクティブな場合でも、次の自己挿入文字に適用されます。

‘M-o d’
     すべての‘face’プロパティーを削除します(‘facemenu-set-default’)。

‘M-o b’
     ‘bold’(太字)フェイスを適用します(‘facemenu-set-bold’)。

‘M-o i’
     ‘italic’(斜体)フェイスを適用します(‘facemenu-set-italic’)。

‘M-o l’
     ‘bold-italic’(太字斜体)フェイスを適用します
     (‘facemenu-set-bold-italic’)。

‘M-o u’
     ‘underline’(下線)フェイスを適用します(‘facemenu-set-underline’)。

‘M-o o FACE <RET>’
     フェイスFACEを適用します(‘facemenu-set-face’)。

‘M-x facemenu-set-foreground’
     カラーの入力を求め(*note Colors::)、それをフォアグラウドカラーに適
     用します。

‘M-x facemenu-set-background’
     カラーの入力を求め、それをバックグラウンドカラーに適用します。

これらのコマンドは、Text Propertiesメニューからも利用可能です。

   自己挿入文字は通常、フェイスプロパティー(および他のほとんどのテキスト
プロパティー)を、そのバッファーの前の文字から継承します。次の自己挿入文
字にたいして上記のコマンドを指定した場合、その文字は前の文字からフェイス
プロパティーは継承しませんが、他のテキストプロパティーは継承します。

   Enrichedモードは、他の追加のフェイス‘excerpt’および‘fixed’を定義しま
す。これらはtext/enrichedファイルフォーマットで使われるコードに対応しま
す。‘excerpt’フェイスは引用のために使用されることを意図されており、デフ
ォルトでは‘italic’と同じように表示されます。‘fixed’フェイスは固定幅テキ
ストを指定し、デフォルトでは‘bold’と同じように表示されます。


File: emacs-ja.info,  Node: Enriched Indentation,  Next: Enriched Justification,  Prev: Enriched Faces,  Up: Enriched Text

25.13.5 Enrichedテキストのインデント
------------------------------------

Enrichedモードでは、パラグラフまたはパラグラフの一部の、右余白または左余
白に異なる量のインデントを指定できます。これらの余白は‘M-q’ (*note
Filling::を参照してください)のようなフィルコマンドにも影響します。

   IndentationサブメニューのTextプロパティーは、インデントを指定するコマ
ンドを提供します:

‘Indent More’
     リージョンを4列ずつインデントします(‘increase-left-margin’)。
     Enrichedモードでは、このコマンドは‘C-x <TAB>’でも利用可能です。数引
     数を指定した場合、何列を余白に追加するかを指定します(負の引数は余白
     を何列縮めるかを指定します)。

‘Indent Less’
     リージョンから4列のインデントを削除します。

‘Indent Right More’
     右端から4列インデントすることにより、テキストを狭くします。

‘Indent Right Less’
     右端からのインデントを4列削除します。

   変数‘standard-indent’は、これらのコマンドがインデントを追加または減少
させる列数を指定します。デフォルトは4です。Enrichedにたいするデフォルト
の右余白は、通常のように‘fill-column’により制御されます。

   ‘C-c [’ (‘set-left-margin’)または‘C-c ]’ (‘set-right-margin’)とタイプ
しても、左余白または右余白をセットできます。数引数で余白の幅を指定できま
す。指定しない場合、これらのコマンドはミニバッファーを通じて値の入力を求
めます。

   それに加えてフィルプレフィクスがある場合は、指定されたパラグラフのイ
ンデントに使用されます。‘C-x .’は、フィルプレフィクスにたいして指定され
た、新しい値の中の空白文字は含めません。フィルコマンドは各行のインデント
の後ろにフィルプレフィクスを探します。*note Fill Prefix::を参照してくだ
さい。


File: emacs-ja.info,  Node: Enriched Justification,  Next: Enriched Properties,  Prev: Enriched Indentation,  Up: Enriched Text

25.13.6 Enrichedテキストの位置調整
----------------------------------

Enrichedモードでは、以下のコマンドを使って、フィルのためにさまざまな“行
端揃えスタイル(justification styles)”を指定できます。これらのコマンドは
。ポイントを含むパラグラフ、またはリージョンがアクティブの場合は、リージ
ョンと重なるすべてのパラグラフに適用されます。

‘M-j l’
     行を左余白に揃えます(‘set-justification-left’)。

‘M-j r’
     行を右余白に揃えます(‘set-justification-right’)。

‘M-j b’
     行の途中にスペースを挿入することにより、行を両端の余白に揃えます
     (‘set-justification-full’)。

‘M-j c’
‘M-S’
     両端の余白の間で行を中央に揃えます(‘set-justification-center’)。

‘M-j u’
     フィルを完全にオフに切り替えます(‘set-justification-none’)。このセ
     ッティングにより、フィルコマンドはテキストに何も行わなくなります。
     それでも左余白はインデントすることができます。

   Text PropertiesメニューのJustificationサブメニューを使用して、行端揃
えスタイルを指定することもできます。デフォルトの行端揃えスタイルはバッフ
ァーごとの変数‘default-justification’により指定されます。この変数の値は
シンボル‘left’、‘right’、‘full’、‘center’、または‘none’のうちの1つです。
シンボルの意味は上述したコマンドに対応します。


File: emacs-ja.info,  Node: Enriched Properties,  Prev: Enriched Justification,  Up: Enriched Text

25.13.7 その他のテキストプロパティーのセッティング
--------------------------------------------------

Text PropertiesメニューのSpecial Propertiesサブメニューには、3つのテキス
トプロパティー — ‘read-only’(テキストの変更を不可にします)、
‘invisible’(テキストを非表示にします)、‘intangible’(テキスト内でのポイン
トの移動を不可にします) — を、追加または削除するエントリーがあります。
‘Remove Special’メニューアイテムは、リージョン内のテキストにたいする、こ
れらの特別なプロパティーを削除します。

   プロパティー‘invisible’および‘intangible’は保存されません。


File: emacs-ja.info,  Node: Text Based Tables,  Next: Two-Column,  Prev: Enriched Text,  Up: Text

25.14 テキストベーステーブルの編集
==================================

‘table’パッケージは、テキストベースのテーブルを簡単に編集するコマンドを
提供します。以下は、そのようなテーブルがどのように見えるかの例です:

     +-----------------+--------------------------------+-----------------+
     |     Command     |          Description           |   Key Binding   |
     +-----------------+--------------------------------+-----------------+
     |  forward-char   |Move point right N characters   |       C-f       |
     |                 |(left if N is negative).        |                 |
     |                 |                                |                 |
     +-----------------+--------------------------------+-----------------+
     |  backward-char  |Move point left N characters    |       C-b       |
     |                 |(right if N is negative).       |                 |
     |                 |                                |                 |
     +-----------------+--------------------------------+-----------------+

   このようなテキストがテーブルだとEmacsが認識した場合(*note Table
Recognition::を参照してください)、テーブルのセル内容を編集すると、内容が
大きくなってセルに収まらなくなったときは、テーブルのセルを自動的にサイズ
変更します。以下のセクションで説明されている、テーブルのレイアウトを操作
したり編集するコマンドを使用することができます。

   ‘M-x table-fixed-width-mode’とタイプすることにより、自動的なテーブル
のサイズ変更を切り替えることができます。

* Menu:

* Table Definition::         テキストベースのテーブルとは何か。
* Table Creation::           テーブルを作成する方法。
* Table Recognition::        テーブルをアクティブまたは非アクティブにする方法。
* Cell Commands::            テーブルのセル指向のコマンド。
* Cell Justification::       セル内容の位置調整。
* Table Rows and Columns::   行と列の追加と削除。
* Table Conversion::         プレーンテキストとテーブルの変換。
* Table Misc::               テーブル、その他。


File: emacs-ja.info,  Node: Table Definition,  Next: Table Creation,  Up: Text Based Tables

25.14.1 テキストベーステーブルとは
----------------------------------

“テーブル(table)”は矩形のテキスト領域からなり、それらは“セル(cells)”に分
割されます。セルは少なくとも1文字分の幅と高さをもち、それにボーダーライ
ンは含まれません。セルは複数のセルに分割できますが、それらは重なることは
できません。

   セルのボーダーラインは、以下の変数で指定された3つの特別な文字で描画さ
れます:

‘table-cell-vertical-char’
     垂直ラインに使用される文字です。デフォルトは‘|’です。

‘table-cell-horizontal-chars’
     水平ラインに使用される文字です。デフォルトは‘"-="’です。

‘table-cell-intersection-char’
     水平ラインと垂直ラインの交点に使用される文字です。デフォルトは‘+’で
     す。

以下は_無効_なテーブルの例です:

        +-----+       +--+    +-++--+
        |     |       |  |    | ||  |
        |     |       |  |    | ||  |
        +--+  |    +--+--+    +-++--+
        |  |  |    |  |  |    +-++--+
        |  |  |    |  |  |    | ||  |
        +--+--+    +--+--+    +-++--+
           a          b          c

左から順に説明します:

  a. 重なったセル、または非矩形のセルは許されません。
  b. ボーダーは矩形でなければなりません。
  c. セルは最小でも1文字分の幅と高さがなければなりません。


File: emacs-ja.info,  Node: Table Creation,  Next: Table Recognition,  Prev: Table Definition,  Up: Text Based Tables

25.14.2 テーブルの作成
----------------------

テキストベースのテーブルをスクラッチから作成するには、‘M-x
table-insert’とタイプします。このコマンドはテーブルの列数、テーブルの行
数、セルの幅と高さの入力を求めます。セルの幅とセルの高さに、セルのボーダ
ーは含まれません。これらは1つの整数で指定するか(これは各セルの幅と高さが
同じになることを意味します)、スペースまたはカンマで区切られた整数のシー
ケンス(これはテーブルの左から右の列、上から下の行の個別のセルにたいして
幅と高さを指定します)です。その後、指定されたテーブルはポイント位置に挿
入されます。

   ‘M-x table-insert’で挿入されたテーブルは、Emacsにそれをテキストベース
のテーブルとして特別に扱うように指示する、特別なテキストプロパティーを含
みます。そのバッファーをファイルに保存して、後で再びvisitすると、それら
のプロパティーは失われ、Emacsにとってテーブルは普通のテキストとして判断
されます。これをテーブルに変換する方法については、次のセクションを参照し
てください。


File: emacs-ja.info,  Node: Table Recognition,  Next: Cell Commands,  Prev: Table Creation,  Up: Text Based Tables

25.14.3 テーブルの認識
----------------------

バッファーに既存のテーブルがあり、そのテーブルから‘M-x table-insert’で適
用された特別なテキストプロパティーが失われているとき、それはテーブルとし
て特別に扱われなくなります。これにテキストプロパティーを適用するには、
‘M-x table-recognize’とタイプします。このコマンドはカレントバッファーを
スキャンして、有効なテーブルセルを“認識”して、適切なテキストプロパティー
を適用します。反対に、‘M-x table-unrecognize’とタイプすることにより、特
別なテキストプロパティーを削除して、テーブルをプレーンテキストに変換して
、カレントバッファーのすべてのテーブルを認識しなくなります。

   以下のコマンドを使って、選択的にテーブルを認識したり認識させなくする
こともできます:

‘M-x table-recognize-region’
     カレントリージョンのテーブルを認識します。

‘M-x table-unrecognize-region’
     カレントリージョンのテーブルを認識しなくします。

‘M-x table-recognize-table’
     ポイント位置のテーブルを認識してアクティブにします。

‘M-x table-unrecognize-table’
     ポイント位置のテーブルを非アクティブにします。

‘M-x table-recognize-cell’
     ポイント位置のセルを認識してアクティブにします。

‘M-x table-unrecognize-cell’
     ポイント位置のセルを非アクティブにします。

   テーブルを認識する他の方法については、*note Table Conversion::を参照
してください。


File: emacs-ja.info,  Node: Cell Commands,  Next: Cell Justification,  Prev: Table Recognition,  Up: Text Based Tables

25.14.4 テーブルセルにたいするコマンド
--------------------------------------

コマンド‘M-x table-forward-cell’および‘M-x table-backward-cell’は、ポイ
ントをカレントセルから隣接するセルに移動します。その順番は巡回的です。ポ
イントがテーブルの最後のセルにあるとき、‘M-x table-forward-cell’はポイン
トを最初のセルに移動します。同様に、ポイントが最初のセルにあるとき、‘M-x
table-backward-cell’はポイントを最後のセルに移動します。

   ‘M-x table-span-cell’は方向 — 右、左、上、下 — の入力を求め、カレント
セルをその方向の隣接するセルにマージします。マージした結果が不正なセルの
レイアウトになる場合、このコマンドはエラーをシグナルします。

   ‘M-x table-split-cell’は、ミニバッファーを使って分割する方向の入力を
求め、カレントセルを垂直(vertically)または水平(horizontally)に分割します
。特定の方向に分割するには、‘M-x table-split-cell-vertically’と‘M-x
table-split-cell-horizontally’を使います。垂直に分割する場合、古いセルの
内容は自動的に2つの新しいセルに分割されます。水平に分割する場合、セルが
空でない場合は、セル内容をどのように分割するか入力を求めます。オプション
は‘split’(内容をポイント位置で分割)、‘left’(すべての内容を左のセルへ)、
‘right’(すべての内容を右のセルへ)です。

   以下のコマンドは、セルを拡大または縮小します。デフォルトでは、1行また
は1列ずつサイズ変更します。数引数が与えられた場合、それはサイズ変更を何
行または何列単位で行うかを指定します。

‘M-x table-heighten-cell’
     カレントセルを垂直方向に拡大します。

‘M-x table-shorten-cell’
     カレントセルを垂直方向に縮小します。

‘M-x table-widen-cell’
     カレントセルを水平方向に拡大します。

‘M-x table-narrow-cell’
     カレントセルを水平方向に縮小します。


File: emacs-ja.info,  Node: Cell Justification,  Next: Table Rows and Columns,  Prev: Cell Commands,  Up: Text Based Tables

25.14.5 セルの位置調整
----------------------

コマンド‘M-x table-justify’は、テキストベーステーブルの1つ以上のセルにた
いして、“位置調整(justification)”を行います。位置調整は、セルのテキスト
がセルの外枠にたいして、どのように位置合わせされるかを決定します。テーブ
ルの各セルは個別に位置調整できます。

   ‘M-x table-justify’は、最初に何の位置調整をするかの入力を求めます。オ
プションは‘cell’(カレントセルのみ)、‘column’(テーブルのカレント列のすべ
てのセル)、‘row’ (テーブルのカレント行のすべてのセル)です。その後、コマ
ンドは位置調整のスタイルの入力を求めます。オプションは‘left’、‘center’、
‘right’、‘top’、‘middle’、‘bottom’、または‘none’(垂直方向の位置調整を行
わないことを意味します)です。

   水平および垂直方向の位置調整スタイルは独立して指定され、2つのタイプは
同時に適用できます。たとえば‘M-x table-justify’を2回呼び出して、1回目は
位置調整に‘right’を指定して、2回目は位置調整に‘bottom’を指定することによ
り、セルの内容を右下に位置調整することができます。

   位置調整スタイルは、テキストプロパティーとしてバッファーに格納され、
バッファーをkillするかEmacsを終了すると失われます。‘M-x
table-recognize’(*note Table Recognition::を参照してください)のようなテ
ーブルの認識コマンドは、セルの内容を確認して各セルの位置調整スタイルの決
定と再適用を試みます。この機能を無効にするには、変数
‘table-detect-cell-alignment’を‘nil’に変更してください。


File: emacs-ja.info,  Node: Table Rows and Columns,  Next: Table Conversion,  Prev: Cell Justification,  Up: Text Based Tables

25.14.6 テーブルの行と列
------------------------

‘M-x table-insert-row’は、テーブルのカレント行の前にセル行を挿入します。
カレント行とポイントは、新しい行の下になります。テーブル最下にある最後の
行の後ろに行を挿入するには、ポイントをテーブルの最下線の直下にポイントを
移動して、このコマンドを呼び出します。数引数を指定することにより2つ以上
の行を挿入できます。

   同様に、‘M-x table-insert-column’は、テーブルのカレント列の左にセル列
を挿入します。右端の最右列の右に列を挿入するには、ポイントを最右線の右
(テーブルの外)に移動して、このコマンドを呼び出します。数引数は挿入する列
の数を指定します。

   ‘M-x table-delete-column’は、ポイントがあるセルの列を削除します。同様
に、‘M-x table-delete-row’は、ポイントがあるセルの行を削除します。どちら
のコマンドも数引数により削除する列または行の数を指定します。


File: emacs-ja.info,  Node: Table Conversion,  Next: Table Misc,  Prev: Table Rows and Columns,  Up: Text Based Tables

25.14.7 プレーンテキストとテーブルの変換
----------------------------------------

コマンド‘M-x table-capture’は、プレーンテキストをリージョンにキャプチャ
ーして、それをテーブルに変換します。‘M-x table-recognize’(*note Table
Recognition::を参照してください)とは異なり、元のテキストはテーブルの体裁
をとる必要はありません。テーブル的な論理構造もつことだけが必要です。

   たとえば以下の数字があったとして、これらは3つの行と、カンマで水平方向
に分割されます:

     1, 2, 3, 4
     5, 6, 7, 8
     , 9, 10

このテキストにたいして‘M-x table-capture’を呼び出すと、以下のテーブルが
生成されます:

     +-----+-----+-----+-----+
     |1    |2    |3    |4    |
     +-----+-----+-----+-----+
     |5    |6    |7    |8    |
     +-----+-----+-----+-----+
     |     |9    |10   |     |
     +-----+-----+-----+-----+

   ‘M-x table-release’は逆のことを行います。これはテーブルを元のプレーン
テキストに戻し、セルのボーダーを削除します。

   この2つのコマンドの1つの用途としては、テキストをレイアウトで編集する
ことです。以下の3つのパラグラフを見てください(後者の2つはヘッダー行にイ
ンデントされています):

     table-capture is a powerful command.
     Here are some things it can do:

     Parse Cell Items   Using row and column delimiter regexps,
                        it parses the specified text area and
                        extracts cell items into a table.

上記のテキストを含むリージョンに‘table-capture’を適用して、列と行を区切
るregexpsに空文字列を指定すると、以下のような1つのセルからなるテーブルが
作成されます。

     +----------------------------------------------------------+
     |table-capture is a powerful command.                      |
     |Here are some things it can do:                           |
     |                                                          |
     |Parse Cell Items   Using row and column delimiter regexps,|
     |                   it parses the specified text area and  |
     |                   extracts cell items into a table.      |
     +----------------------------------------------------------+

その後でセル分割コマンド(*note Cell Commands::を参照してください)を使っ
て、各パラグラフが1つのセルを占めるようにテーブルを分割できます。

     +----------------------------------------------------------+
     |table-capture is a powerful command.                      |
     |Here are some things it can do:                           |
     +-----------------+----------------------------------------+
     |Parse Cell Items | Using row and column delimiter regexps,|
     |                 | it parses the specified text area and  |
     |                 | extracts cell items into a table.      |
     +-----------------+----------------------------------------+

これで各セルは他のセルのレイアウトに影響を与えることなく、独立して編集す
ることができるようになりました。終了したら‘M-x table-release’を呼び出し
て、テーブルをプレーンテキストに戻します。


File: emacs-ja.info,  Node: Table Misc,  Prev: Table Conversion,  Up: Text Based Tables

25.14.8 テーブル、その他
------------------------

コマンド‘table-query-dimension’は、テーブルのレイアウトとポイント位置の
テーブルセルをレポートします。以下は出力の例です:

     Cell: (21w, 6h), Table: (67w, 16h), Dim: (2c, 3r), Total Cells: 5

これはカレントセルの幅が21文字、高さが6行で、テーブルの幅が67文字、高さ
が16行で、2列3行で5つのセルがあることを示します。

   ‘M-x table-insert-sequence’は文字列を各セルに挿入します。各文字列はシ
ーケンス — たとえば一連の増加する数字 — の一部です。

   ‘M-x table-generate-source’は、特定のマークアップ言語にフォーマットさ
れたテーブルを生成します。このコマンドは言語(これは‘html’、‘latex’、
‘cals’のどれか1つでなければなりません)と、結果を出力するバッファー、テー
ブルの表題を尋ね、生成されたテーブルを指定したバッファーに出力します。デ
フォルトの出力バッファーは‘table.LANG’で、LANGは指定された言語です。


File: emacs-ja.info,  Node: Two-Column,  Prev: Text Based Tables,  Up: Text

25.15 2列編集
=============

2C-two-column(2列)モードは、横に並んだテキストの列を、簡単に編集できるよ
うにします。これは横に並んだ2つのウィンドウを使って、それぞれのウィンド
ウは自身のバッファーを表示します。2Cモードに入るには3つの方法があります
。

‘<F2> 2’または‘C-x 6 2’
     カレントバッファーを左に、カレントバッファーの名前にもとづいた名前
     のバッファーを右にして、2Cモードに入ります。右側のバッファーがまだ
     存在しない場合、そのバッファーは空で開始されます。カレントバッファ
     ーの内容は変更されません。

     このコマンドは、カレントバッファーが空か1列だけしか含まなくて、それ
     に別の列を追加したいときに適しています。

‘<F2> s’または‘C-x 6 s’
     2列のテキストを含むカレントバッファーを2つのバッファーに分割して、
     それを横に並べて表示します(‘2C-split’)。カレントバッファーは左側の
     バッファーになりますが、右側の列のテキストは、右側のバッファーに移
     動します。カレント列は分割ポイントを指定します。分割はカレント行か
     らバッファーの最後まで続きます。

     このコマンドはすでに2列になったテキストを含むバッファーがあり、一時
     的にそれを列に分割したいときに適しています。

‘<F2> b BUFFER <RET>’
‘C-x 6 b BUFFER <RET>’
     カレントバッファーを左側のバッファー、バッファーBUFFERを右側のバッ
     ファーにして2Cモードに入ります(‘2C-associate-buffer’)。

   ‘<F2> s’または‘C-x 6 s’は、列の区切りを探します。区切りは各行に出現す
る2列の間にある文字列です。区切りの幅は、‘<F2> s’への数引数で指定するこ
とができます。これはポイントの前の指定した文字数文を区切り文字とします。
デフォルトでは幅が1なので、ポイントの前の文字が列区切りになります。

   行が適切な位置で分割された場合、‘<F2> s’は区切りの後ろのテキストを右
側のバッファーに移動して、区切りを削除します。適切な位置に列区切りをもた
ない行は、分割されずに残ります。分割されない行は左側のバッファーに残り、
右側のバッファーの対応する行は空になります(これは“2Cモードで2列にまたが
る”行を書くときの方法で、そのような行は左側のバッファーに記述して、右側
のバッファーは空の行にします)。

   コマンド‘C-x 6 <RET>’ または‘<F2> <RET>’ (‘2C-newline’)は、2つのバッ
ファーの対応する位置にそれぞれ改行を挿入します。これは2列のテキストを分
割されたバッファーで編集するときに、新しい行を追加する一番簡単な方法です
。

   望みどおりに両方のバッファーを編集し終えたら、‘<F2> 1’または‘C-x 6 1’
(‘2C-merge’)で、それらをマージします。これは右側のバッファーからテキスト
を、もう一方のバッファーの2列目にコピーします。2列編集に戻るには、‘<F2>
s’を使用します。

   ‘<F2> d’または‘C-x 6 d’は、バッファーをそのままにして、2つのバッファ
ーを分割します。‘<F2> d’とタイプしたとき、カレントではないバッファーが空
の場合、‘<F2> d’によりそのバッファーはkillされます。


File: emacs-ja.info,  Node: Programs,  Next: Building,  Prev: Text,  Up: Top

26 プログラムの編集
*******************

このチャプターでは、プログラムの編集を容易にするEmacsの機能を説明します
。これらの機能で行えるいくつかは、以下のようなものです:

   • トップレベルの定義の検索や移動(*note Defuns::を参照してください)。
   • 言語の通常のインデント規則の適用(*note Program Indent::を参照してく
     ださい)。
   • カッコの対応をとります(*note Parentheses::を参照してください)。
   • コメントの挿入、kill、位置揃え(*note Comments::を参照してください
     )。
   • プログラム構文のハイライト(*note Font Lock::を参照してください)。

* Menu:

* Program Modes::            プログラムを編集するためのメジャーモード。
* Defuns::                   プログラムの主要なトップレベル要素を操作するためのコマンド。
* Program Indent::           ネスティングを示すためのインデントの調整。
* Parentheses::              カッコを操作するコマンド。
* Comments::                 コメントの挿入、kill、位置揃え。
* Documentation::            関数ドキュメントの取得。
* Hideshow::                 ブロックの選択的な表示。
* Symbol Completion::        プログラムまたは言語でのシンボルの補完。
* MixedCase Words::          identifiersLikeThisのような識別子の処理。
* Semantic::                 ソースコードのパースにもとづいた編集ツール。
* Misc for Programs::        その他、プログラムを編集するための便利なEmacs機能。
* C Modes::                  C、C++、Objective-C、Java、IDL、Pike、AWKモードの特別なコマンド。
* Asm Mode::                 Asmモードと特別な機能。
* Fortran:: Fortranモードと特別な機能。


File: emacs-ja.info,  Node: Program Modes,  Next: Defuns,  Up: Programs

26.1 プログラミング言語のためのメジャーモード
=============================================

Emacsには、プログラミング言語のために特化した、多くのメジャーモード
(*note Major Modes::を参照してください)があります。プログラミング言語に
関連したモードは通常、式の構文、インデントの慣習的ルール、言語の構文をハ
イライトする方法、関数定義の開始と終了を検索する方法を指定します。プログ
ラムをコンパイルしたり、デバッグするための機能をもつ場合もあります。各言
語にたいするメジャーモード名は、言語名により名づけられます。たとえばCプ
ログラミング言語にたいするメジャーモードは、‘c-mode’です。

   EmacsにはLisp、Scheme、SchemeベースのDSSSL expression言語、Ada、ASM、
AWK、C、C++、Fortran、Icon、IDL(CORBA)、IDLWAVE、Java、Javascript、
Metafont(フォント作成のためのTeXの仲間)、Modula2、Object Pascal、
Objective-C、Octave、Pascal、Perl、Pike、PostScript、Prolog、Python、
Ruby、Simula、Tcl、VHDLなどのプログラミング言語のためのモードがあります
。Perlのための代替モードはCPerlモードと呼ばれます。一般的なGNUおよび
Unixシェルのスクリプティング言語、VMS DCL、MS-DOS/MS-Windowsの‘BAT’ファ
イル、makefiles、DNS masterファイル、一連のさまざまな設定ファイルのため
のモードも利用可能です。

   理想的には、Emacsは編集したいと望むすべてのプログラミング言語のための
メジャーモードをもつべきです。しかし、もしあなたのお気に入りの言語のため
のモードがない場合、それはEmacsとともに配布されないパッケージで実装され
ているかもしれません(*note Packages::を参照してください)。または、あたた
が貢献することもできます。

   ほとんどのプログラミング言語では、インデントはプログラム構造を示すた
めに行ごとに異なります。したがって、ほとんどのプログラミング言語のモード
では、<TAB>とタイプすることにより、カレント行のインデントが更新されます
(*note Program Indent::を参照してください)。さらに<DEL>は通常、タブをあ
たかも等価な数のスペースであるかのように扱って、後方に削除する
‘backward-delete-char-untabify’にバインドされているので、空白文字がスペ
ースなのかタブなのか気にせずに、インデントを1列ずつ削除できます。

   プログラミング言語のモードに入ることにより、フック変数
‘prog-mode-hook’に指定されたカスタムLisp関数と、その後でモード自身のモー
ドフックが実行されます(*note Major Modes::を参照してください)。たとえば
Cモードに入ることにより、‘prog-mode-hook’と‘c-mode-hook’が実行されます。
フックについての情報は、*note Hooks::を参照してください。

   Adaモード(*note Ada Mode: (ada-mode)Top.を参照してください)、
C/C++/Objective C/Java/Corba IDL/Pike/AWKモード(*note CC Mode:
(ccmode)Top.を参照してください)、IDLWAVEモード(*note IDLWAVE:
(idlwave)Top.を参照してください)のマニュアルが利用可能です。


File: emacs-ja.info,  Node: Defuns,  Next: Program Indent,  Prev: Program Modes,  Up: Programs

26.2 トップレベルの定義、またはdefun
====================================

Emacsでは関数などの、バッファーのトップレベルの主要な定義は、“defun”と呼
ばれます。この名前はLispが由来ですが、Emacsではすべての言語に使用します
。

* Menu:

* Left Margin Paren::        開きカッコまたは同様の開始を意味する区切りは、それが左端にある場合はdefunの開始です。
* Moving by Defuns::         主要な定義を移動したりマークするコマンド。
* Imenu::                    バッファーのインデックスをメニューにする。
* Which Function::           Which
                               Functionモードはどの関数にいるか表示します。


File: emacs-ja.info,  Node: Left Margin Paren,  Next: Moving by Defuns,  Up: Defuns

26.2.1 左端の慣習
-----------------

プログラミング言語のモードの多くは、デフォルトでは左端で見つかった開始区
切りは、トップレベル定義、またはdefunの開始とみなします。したがって、*そ
のような意味をもたない場合、開始区切りを左端に配してはいけません*。たと
えば、それがトップレベルのリストの開始でない場合は、Lispファイルの左端に
開きカッコを記述しないでください。

   この慣習に従わない場合、コードの構文を解析するために、バッファーの先
頭から再スキャンが必要ですが、慣習に従うことにより、多くのEmacs操作をス
ピードアップできます。

   この慣習にしたがわない場合、defunにより動作するコマンドを明示的に使用
する場合にトラブルが起こるだけではありません。これを使用する他の機能もト
ラブルを起こすでしょう。これにはインデントコマンド(*note Program
Indent::を参照してください)と、Font Lockモード(*note Font Lock::を参照し
てください)が含まれます。

   同様な問題ケースのほとんどは、文字列リテラルで開始区切りを行の先頭に
記述したい場合です。このトラブルを避けるには、開始区切りの前にエスケープ
文字(CおよびEmacs Lispでは‘\’、その他のLisp方言のいくつかは‘/’)を配しま
す。これは文字列の内容には影響を与えませんが、その開始区切りがdefunの開
始となるのを防ぎます。以下は例です:

       (insert "Foo:
     \(bar)
     ")

   この慣習を破ったことに気づくには、Font Lockモードが助けになります。
Font Lockモードは混乱して、(クォートする必要がある)開始区切りを赤の太字
でハイライトするからです。

   この慣習をオーバーライドする必要がある場合、変数
‘open-paren-in-column-0-is-defun-start’をセッティングすることにより、こ
れを行うことができます。このユーザーオプションが‘t’(デフォルト)にセット
されている場合、列0の開きカッコまたは大カッコ(braces)は常にdefunの開始と
なります。‘nil’の場合、defunは最外レベルのカッコまたは大カッコを検索する
ことにより発見されます。

   通常は、このオプションをデフォルト値の‘t’にしておくべきです。バッファ
ーの列0にdefunの開始でないカッコまたは大カッコが含まれていて、これらのカ
ッコまたは大カッコを削除するのが何らかの理由で現実的でない場合、このオプ
ションを‘nil’にするのが役に立つかもしれません。しかしこれは大きなバッフ
ァーのスクロールや、表示の速度を著しく低下させるかもしれないことを知って
おいてください。さらに、正しく機能させるために、バッファー全体を通じてカ
ッコまたは大カッコが、正しく対応が取れていなければなりません。


File: emacs-ja.info,  Node: Moving by Defuns,  Next: Imenu,  Prev: Left Margin Paren,  Up: Defuns

26.2.2 defunの移動
------------------

これらのコマンドはトップレベルの主要な定義、または“defuns”にもとづいてポ
イントを移動したり、リージョンをセットアップします。

‘C-M-a’
     カレントまたは直前のdefunの先頭に移動します(‘beginning-of-defun’)。
‘C-M-e’
     カレントまたは直後のdefunの最後に移動します(‘end-of-defun’)。
‘C-M-h’
     カレントまたは後続のdefun全体の周囲にリージョンを設定します
     (‘mark-defun’)。

   カレントのdefunの先頭または最後に移動するコマンドは、‘C-M-a’
(‘beginning-of-defun’)と‘C-M-e’ (‘end-of-defun’)です。これらのコマンドの
1つを繰り返すか、正の数引数を使用すると、繰り返しごとに動作方向の次の
defunに移動します。

   ‘C-M-a’で負の引数−Nを指定すると、次のdefunの開始へとN回移動します。こ
れは‘C-M-e’に引数Nを与えたときに移動する位置と、正確に同じではありません
。defunの終わりは通常、後続のdefunの開始と同じ位置ではないからです(空白
文字、コメント、もしかしたら宣言がこれらのdefunを分割するからです)。同様
に‘C-M-e’に負の引数を与えると、defunの最後に後方に移動しますが、これは
‘C-M-a’に正の引数を与えた場合とは完全に異なる位置になります。

   カレントのdefunを操作するには、‘C-M-h’ (‘mark-defun’)を使用します。こ
れはカレントのdefunの最後にマークをセットし、先頭にポイントを配します。
*note Marking Objects::を参照してください。これは、そのdefunをkillしてフ
ァイルの他の場所に移動するための、一番簡単な準備方法です。ポイントが
defunの間にある場合、後続のdefunを使用します。マークがすでにアクティブの
ときにこのコマンドを使用すると、マークはセットしますがポイントは移動しま
せん。さらに、連続して‘C-M-h’を使用するとリージョンの最後が、複数の
defunを含むように拡張されます。

   Cモードでは、‘mark-defun’とほとんど同じな‘c-mark-function’を実行しま
す。違いは、それが引数定義、関数名、リターンデータ型を含むことで、これに
よりC関数全体にリージョンが設定されます。これは標準のキーバインディング
をメジャーモードが調整する方法の例です。これにより特定の言語によりふさわ
しい方法で標準的な作業を行うのです。この目的のために、他のメジャーモード
は、これらのキーバインディングすべてを置き換えているかもしれません。


File: emacs-ja.info,  Node: Imenu,  Next: Which Function,  Prev: Moving by Defuns,  Up: Defuns

26.2.3 Imenuとは
----------------

Imenu機能は、ファイル内の主要な定義を、名前で検索する方法を提供します。
これはチャプター、セクションなどを扱う、テキストフォーマッターのためのメ
ジャーモードでも有用です(複数ファイルを扱う、より強力な機能については、
*note Tags::を参照してください)。

   ‘M-x imenu’とタイプすると、これはミニバッファーを使用して定義の名前を
読み取り、ポイントをその定義に移動します。名前の指定に補完を使用できます
。このコマンドは常に有効な名前の全体のリストを表示します。

   かわりに、コマンド‘imenu’をマウスクリックにバインドできます。そうする
と定義名を選択するために、マウスメニューが表示されます。
‘imenu-add-menubar-index’を呼び出して、バッファーのインデックスをメニュ
ーバーに追加することもできます。特定のメジャーモードのすべてのバッファー
にたいして、このメニューバーアイテムを有効にしたい場合、モードフックに
‘imenu-add-menubar-index’を追加して、これを行うことができます。しかし、
それを行うことにより、そのモードでファイルをvisitするたびに、Emacsがその
バッファーのすべての定義を検索する間、待つ必要があります。

   バッファーの内容を変更する際、定義の追加や削除をした場合は、メニュー
の‘*Rescan*’アイテムを呼び出すことにより、新しい内容にもとづいてバッファ
ーのインデックスを更新することができます。‘imenu-auto-rescan’を非‘nil’値
にセットした場合、再スキャンは自動的に発生します。テキストを少量変更した
だけの場合、再スキャンは必要ありません。

   変数‘imenu-sort-function’をセットして、メニューがソートされる方法をカ
スタマイズすることができます。デフォルトでは、名前はバッファーで出現する
順にソートされています。アルファベット順にソートしたいときは、値にシンボ
ル‘imenu--sort-by-name’を使用します。Lispコードを記述することにより、独
自の比較関数を定義することもできます。

   ImenuはWhich Functionモードに情報を提供します (*note Which
Function::を参照してください)。 Speedbarもこれを使用します(*note
Speedbar::を参照してください)。


File: emacs-ja.info,  Node: Which Function,  Prev: Imenu,  Up: Defuns

26.2.4 Which Functionモード
---------------------------

Which Function(どの関数)モードは、グローバルなマイナーモード(*note Minor
Modes::を参照してください)で、これはカレントの関数名をモードラインに表示
して、バッファーの移動にしたがってそれを更新します。

   Which Functionモードを有効または無効にするには、コマンド‘M-x
which-function-mode’を使用します。Which Functionモードは、グローバルなマ
イナーモードです。デフォルトでは、それをサポートする方法を知っている、す
べてのメジャーモード(たとえばImenuをサポートするすべてのメジャーモード
)に影響を与えます。変数‘which-func-modes’の値を‘t’(これは利用可能なすべ
てのメジャーモードをサポートすることを意味します)から、特定のメジャーモ
ードのリストに変更することにより、これを制限することができます。


File: emacs-ja.info,  Node: Program Indent,  Next: Parentheses,  Prev: Defuns,  Up: Programs

26.3 プログラムのインデント
===========================

プログラムを正しくインデントされた状態に保つには、何か変更したらEmacsを
使って再インデントするのが一番よい方法です。Emacsには1行、指定した数の行
、1つのカッコでグループ化されたすべての行をインデントするコマンドがあり
ます。

   インデントに間する全般的な情報は、*note Indentation::を参照してくださ
い。このセクションでは、プログラミング言語のモードに特有のインデント機能
について説明します。

* Menu:

* Basic Indent::             1行のインデント。
* Multi-line Indent::        複数行を1度に再インデントするコマンド。
* Lisp Indent::              Lisp関数がどのようにインデントされるべきか指定する。
* C Indent::                 Cおよび関連するモードのインデントのための追加機能。
* Custom C Indent::          Cおよび関連するモードのインデントスタイルの制御。

   Emacsは‘pp’パッケージで、Lispのプリティープリンター(pretty-printer)も
提供します。これはLispオブジェクトを、見栄えのよいインデントで再フォーマ
ットします。


File: emacs-ja.info,  Node: Basic Indent,  Next: Multi-line Indent,  Up: Program Indent

26.3.1 プログラムの基本的なインデントコマンド
---------------------------------------------

‘<TAB>’
     カレント行のインデントを調整します(‘indent-for-tab-command’)。
‘<RET>’
     改行を挿入して、次の行のインデントを調整します(‘newline’)。

   基本的なインデントコマンドは<TAB> (‘indent-for-tab-command’)で、これ
は*note Indentation::で説明されています。プログラミング言語のモードでは
、<TAB>は前の行のインデントと構文的な内容にもとづき、カレント行をインデ
ントします。リージョンがアクティブのとき、<TAB>はカレント行だけでなく、
リージョン内の各行をインデントします。

   *note Inserting Text::で説明されているコマンド<RET> (‘newline’)は、
‘C-j’の後に<TAB>を続けるのと同じです。これは改行を挿入してから、その行の
インデントを調整します。

   カッコによるグループ化により開始される行でインデントする場合、通常
Emacsはグループ内の前の行の開始、または、カッコの後ろのテキストの下に、
行の開始を合わせます。(たとえば美的観点により)これらの行に手動で非標準的
なインデントを与えた場合は、その下の行もそれにしたがいます。

   プログラミング言語のモードのほとんどは、左端の開きカッコ、開き大カッ
コ(open-brace)、その他の開始区切りを関数の開始とみなします。編集している
コードがこの前提に違反する場合は — それらの区切りが文字列やコメントの中
にある場合でも — インデントが正しく機能するために、
‘open-paren-in-column-0-is-defun-start’に‘nil’をセットしなければなりませ
ん。*note Left Margin Paren::を参照してください


File: emacs-ja.info,  Node: Multi-line Indent,  Next: Lisp Indent,  Prev: Basic Indent,  Up: Program Indent

26.3.2 複数行のインデント
-------------------------

複数行のコードを、1度に再インデントしたいときがあるかもしれません。これ
を行う1つの方法は、マークを使う方法です。マークがアクティブでリージョン
が空でないとき、<TAB>はリージョン内の各行をインデントします。一方、コマ
ンド‘C-M-\’ (‘indent-region’)は、マークがアクティブか否かにかかわらず、
リージョン内の各行をインデントします(*note Indentation Commands::を参照
してください)。

   それらに加えて、Emacsはコードの大きな断片をインデントするために、以下
のコマンドを提供します:

‘C-M-q’
     カッコでグループ化された、すべての行を再インデントします。
‘C-u <TAB>’
     カッコでグループ化されたすべてを横にシフトして、最初の行が正しくイ
     ンデントされるようにします。
‘M-x indent-code-rigidly’
     リージョン内のすべての行を横にシフトしますが、コメントや文字列内で
     開始される行は変更しません。

   1つのカッコでグループ化されたものを再インデントするには、ポイントをグ
ループ化の前に配して、‘C-M-q’とタイプします。これはグループ化されたもの
の全体的なインデント(たとえばグループ化が開始される行のインデント)は変更
せずに、相対的なインデントを変更します。‘C-M-q’で実行される関数は、
Lispモードでは‘indent-pp-sexp’、Cモードでは‘c-indent-exp’、のようにメジ
ャーモードに依存します。全体的なインデントも同様に訂正したい場合は、最初
に<TAB>をタイプします。

   グループ内の相対的なインデントは好ましいが、それの最初の行のインデン
トが好ましくない場合は、その最初の行にポイントを移動して‘C-u <TAB>’とタ
イプします。Lisp、C、他のいくつかのメジャーモードでは、数引数を指定した
<TAB>は通常どおりカレント行をインデントしてから、カレント行で始まる、カ
ッコでグループ化されたすべての行を同じ量で再インデントします。このコマン
ドは巧妙なので、文字列内で開始される行は変更しません。CモードのときはCプ
リプロセッサー行は変更しませんが、それらにアタッチされた継続行は再インデ
ントします。

   コマンド‘M-x indent-code-rigidly’は、‘indent-rigidly’が行うように
(*note Indentation Commands::を参照してください)、リージョン内のすべての
行を厳格(rigidly)にシフトします。このコマンドはリージョンが文字列内で開
始される場合を除き、文字列内で開始される行のインデントは変更しません。プ
レフィクス引数は、インデントする列数です。


File: emacs-ja.info,  Node: Lisp Indent,  Next: C Indent,  Prev: Multi-line Indent,  Up: Program Indent

26.3.3 Lispのインデントのカスタマイズ
-------------------------------------

Lisp式のインデントパターンは、式により呼ばれる関数によって決定することが
できます。それぞれのLisp関数のために、事前定義された複数のインデントパタ
ーンの中から選択するか、Lispプログラムで独自のものを定義できます。

   標準的なインデントのパターンは以下のとおりです。最初の引数が式の開始
行にある場合、式の2行目は最初の引数の下にインデントされます。そうでない
場合、2行目は関数名の下にインデントされ、後続の行はネストの深さが同じな
ら前の行の下にインデントされます。

   変数‘lisp-indent-offset’が非‘nil’の場合、これは式の2行目の通常のイン
デントパターンをオーバーライドするので、常にこれを含むリストより
‘lisp-indent-offset’列余計にインデントされます。

   特定の関数は、標準のパターンをオーバーライドします。名前が‘def’で始ま
る関数は、式の開始の開きカッコより‘lisp-body-indent’列多く2行目をインデ
ントすることにより、2行目を“body”の開始として扱います。

   関数名の‘lisp-indent-function’プロパティーにより、個々の関数の標準パ
ターンを、さまざまな方法でオーバーライドできます。これは通常‘declare’構
成を使用することにより、マクロ定義のために行われます。*note
(elisp)Defining Macros::を参照してください。


File: emacs-ja.info,  Node: C Indent,  Next: Custom C Indent,  Prev: Lisp Indent,  Up: Program Indent

26.3.4 Cのインデントのためのコマンド
------------------------------------

Cおよび関連するモードのインデントのために、特別な機能があります。

‘C-c C-q’
     カレントのトップレベル関数を再インデント、または型定義を統合します
     (‘c-indent-defun’)。

‘C-M-q’
     ポイントの後ろの、対応が取れた式の中の各行を再インデントします
     (‘c-indent-exp’)。プレフィクス引数は、無効な構文についての警告メッ
     セージを抑制します。

‘<TAB>’
     カレント行の再インデントおよび／またはタブ文字を挿入する場合もあり
     ます(‘c-indent-command’)。

     ‘c-tab-always-indent’が‘t’の場合、このコマンドは常にカレント行をイ
     ンデントし、他には何もしません。これがデフォルトです。

     この変数が‘nil’の場合、このコマンドはポイントが左端か、その行のイン
     デント位置にある場合だけ、カレント行を再インデントします。そうでな
     い場合、このコマンドはタブ(‘indent-tabs-mode’が‘nil’の場合は等価な
     数のスペース)を挿入します。

     (‘nil’でも‘t’でもない)他の値の場合、常にその行をインデントし、コメ
     ントか文字列の中の場合は、タブも挿入します。

   カレントバッファー全体を再インデントするには、‘C-x h C-M-\’とタイプし
ます。これは最初にバッファー全体をリージョンとして選択し、それからリージ
ョンを再インデントします。

   カレントブロックを再インデントするには、‘C-M-u C-M-q’を使用します。こ
れはブロックの前に移動してから、ブロックのすべてを再インデントします。


File: emacs-ja.info,  Node: Custom C Indent,  Prev: C Indent,  Up: Program Indent

26.3.5 Cのインデントのカスタマイズ
----------------------------------

Cモードおよび関連するモードは、インデントをカスタマイズするために柔軟な
メカニズムを使用します。Cモードはソース行を2ステップでインデントします。
最初のステップは、行の内容とコンテキストに応じて行の構文を分類します。次
のステップで、構文コンストラクトで選択された“スタイル”により、関連付けら
れたインデントのオフセットを決定して、これを“アンカーとなる命令文(anchor
statement)”のインデントに加えます。

‘C-c . STYLE <RET>’
     事前に定義されたスタイルSTYLEを選択します(‘c-set-style’)。

   “スタイル”とは、Cモードおよび関連するモードで使用できるカスタマイズ用
の名前つきコレクションです。完全な説明は、*note (ccmode)Styles::を参照し
てください。Emacsには、‘gnu’、‘k&r’、‘bsd’、‘stroustrup’、‘linux’、
‘python’、‘java’、‘whitesmith’、‘ellemtel’、‘awk’を含む、事前に定義され
たスタイルがいくつか付属します。これらのスタイルのうちいくつかは、主に
1つの言語を意図したものですが、他のスタイルはこれらのモードをサポートす
る任意の言語で使用できます。スタイルがどのように見えるかは、何らかのコー
ドにたいしてスタイルを選択して、(たとえば関数定義の最初で‘C-M-q’とタイプ
して)再インデントしてみることです。

   カレントバッファーのスタイルを選択するには、コマンド‘C-c .’を使用しま
す。引数として、スタイル名を指定します(大文字小文字に意味はありません)。
このコマンドはカレントバッファーだけに影響し、将来のインデントコマンドの
呼び出しだけに影響します。そのバッファーにすでにあるコードの再インデント
はしません。バッファー全体を新しいスタイルで再インデントするには、‘C-x h
C-M-\’とタイプしてください。

   変数‘c-default-style’をセットして、さまざまなメジャーモードにたいして
デフォルトのスタイルを指定できます。この値は、スタイル名(文字列)、または
各要素が1つのメジャーモードと、それに使用するインデントスタイルを指定す
るalistです。たとえば、

     (setq c-default-style
           '((java-mode . "java")
             (awk-mode . "awk")
             (other . "gnu")))

これはJavaモード、AWKモードにたいして明示的に選択して、その他のC-likeな
モードにたいしては、デフォルトの‘gnu’スタイルを指定します。この変数は
C-likeなメジャーモードを選択したときに効果を表します。したがってJavaモー
ドにたいして新しいデフォルトスタイルを指定するには、既存のJavaモードのバ
ッファーで、‘M-x java-mode’とタイプすることにより効果が表れます。

   ‘gnu’スタイルは、CにたいするGNUプロジェクトで推奨されるフォーマットを
指定します。これがデフォルトで、私たちが使用を推奨するスタイルです。

   既存のスタイルのオーバーライドや、独自のスタイルを定義する方法など、
Cおよび関連するモードにたいするインデントのカスタマイズに間する情報は、
*note (ccmode)Indentation Engine Basics::、および*note
(ccmode)Customizing Indentation::を参照してください。

   スタイルを指定するかわりに、サンプルコードのバッファーで‘M-x
c-guess’とタイプすることにより、Emacsにスタイルを推測させることができま
す。その後、‘M-x c-guess-install’として、推測されたスタイルを他のバッフ
ァーに適用できます。詳細については、*note (ccmode)Guessing the Style::を
参照してください。


File: emacs-ja.info,  Node: Parentheses,  Next: Comments,  Prev: Program Indent,  Up: Programs

26.4 カッコに付随する編集のためのコマンド
=========================================

このセクションでは、プログラム内のカッコ構造を活用したり、それらを対応が
取れた状態に保つためのコマンドと機能について説明します。

   これらの機能を語るとき、用語“カッコ(parenthesis)”には、大カッコ
(braces)、角カッコ(brackets)、またはマッチするペアとして定義される区切り
も含まれます。メジャーモードはどの区切りに意味があるかを、構文テーブル
(syntax table)を通じて制御します(*note Syntax Tables: (elisp)Syntax
Tables.を参照してください)。Lispでは丸カッコ(parentheses)だけが考慮され
、Cではこれらのコマンドは大カッコや角カッコにも適用されます。

   ‘M-x check-parens’を使用して、バッファー内の対応の取れていないカッコ
と、対応が取れていない文字列のクォートを検索することができます。

* Menu:

* Expressions::              対応が取れたカッコの式。
* Moving by Parens::         カッコ構造を上、下、横断して移動するコマンド。
* Matching::                 終了区切りの挿入による、マッチする開始区切りのフラッシュ表示。


File: emacs-ja.info,  Node: Expressions,  Next: Moving by Parens,  Up: Parentheses

26.4.1 対応が取れたカッコの式
-----------------------------

プログラミング言語のモードはそれぞれ、“対応が取れた式(balanced
expression)”にたいする、独自の定義をもちます。対応が取れた式は通常、個別
のシンボル、数字、文字列定数、同様にマッチする区切りで囲まれたコードの断
片を含みます。以下のコマンドは対応が取れた式にたいするものです(Emacsでは
、内部的にそのような式は“sexp”として参照されます(1))。

‘C-M-f’
     対応が取れた式を、前方に飛び越して移動します(‘forward-sexp’)。
‘C-M-b’
     対応が取れた式を、後方に飛び越して移動します(‘backward-sexp’)。
‘C-M-k’
     対応が取れた式を、前方にkillします(‘kill-sexp’)。
‘C-M-t’
     式を入れ替えます(‘transpose-sexps’)。
‘C-M-@’
‘C-M-<SPC>’
     後続の式の後ろに、マークを配します(‘mark-sexp’)。

   対応が取れた式を前方に飛び越して移動するには、‘C-M-f’
(‘forward-sexp’)を使用します。ポイントの後ろの最初の文字が開始区切り(た
とえばCでは‘(’、‘[’、‘{’)の場合、このコマンドはそれにマッチする終了区切
りまで移動します。文字がシンボル、文字列、数字で始まる場合、このコマンド
はそれらを飛び越して移動します。

   コマンド‘C-M-b’ (‘backward-sexp’)は対応が取れた式を後方 — ‘C-M-f’と同
様ですが逆向き — に飛び越して移動します。式の前にプレフィクス文字がある
場合(Lispではシングルクォート、バッククォート、カンマ)、このコマンドはそ
れらも同様に飛び越して後方に移動します。

   ‘C-M-f’および‘C-M-b’に数引数を与えると、指定した回数繰り返し操作をし
ます。負の引数を与えると、反対の方向に移動します。ほとんどのモードでは、
これらの2つのコマンドはコメントをあたかも空白文字のように通過します。こ
れら‘C-M-f’および‘C-M-b’のキーは、文字単位で移動する‘C-f’および
‘C-b’(*note Moving Point::を参照してください)、単語単位に移動する‘M-f’お
よび‘M-b’(*note Words::を参照してください)に類似していることに注意してく
ださい。

   対応が取れた式全体をkillするには、‘C-M-k’ (‘kill-sexp’)とタイプします
。これは‘C-M-f’が飛び越すテキストをkillします。

   ‘C-M-t’ (‘transpose-sexps’)は、前にある対応の取れた式と、次の対応の取
れた式の位置をスイッチします。このコマンドは、文字を入れ替える‘C-t’コマ
ンド(*note Transpose::を参照してください)と類似しています。‘C-M-t’への引
数は繰り返し回数を意味し、前の式を、何個か先の式に移動します。負の引数は
前にある対応が取れた式を後方に、それらの式の前に移動します。引数0は何も
しないのではなく、ポイントの位置で終わる対応が取れた式、またはポイントの
後ろの式と、マークの後ろの式を入れ替えます。

   リージョンにたいして動作するコマンドで対応が取れた式を操作するには、
‘C-M-<SPC>’ (‘mark-sexp’)とタイプします。これは‘C-M-f’が移動する位置にマ
ークをセットします。マークがアクティブの間、このコマンドを連続で呼び出す
とマークが1つの式ごとにシフトしてリージョンが拡張します。正または負の引
数はマークを前方または後方に指定した数の式分のマークを移動します。エイリ
アス‘C-M-@’は、‘C-M-<SPC>’と等価です。これに関連したコマンドは、*note
Marking Objects::を参照してください。

   Cのように挿入オペレーター(infix operators)を使用する言語では、与えら
れた位置で複数の可能な解釈があるので、すべての対応が取れた式を認識するの
は不可能です。たとえば‘foo + bar’は1つのCの式ですが、Cモードはこれを1つ
の式とは扱いません。かわりに‘foo’を1つの式、‘bar’をもう1つの式、そしてそ
れらの間にある‘+’を句読点として認識します。しかしカッコがあればCモードは
‘(foo + bar)’を1つの式として認識します。

   ---------- Footnotes ----------

   (1) 単語“sexp”はLispで式を参照するのに使用されます。


File: emacs-ja.info,  Node: Moving by Parens,  Next: Matching,  Prev: Expressions,  Up: Parentheses

26.4.2 カッコ構造の移動
-----------------------

以下のコマンドはカッコ(または、あなたが使用している言語で、そのような区
切りとして使用される文字)で区切られてグループ化されたものを移動するコマ
ンドです。これらのコマンドは、カッコを含んでいたとしても文字列とコメント
を無視し、エスケープ文字で“クォート”されたカッコも無視します。これらのコ
マンドは主にプログラムの編集を意図していますが、カッコを含む任意のテキス
トの編集にも有用です。これらは内部的には“リスト”コマンドとして参照されま
す。なぜならLispではこれらのグループはリストだからです。

   これらのコマンドは、開始ポイントが文字列やコメントの中でないと仮定し
ます。これらのコマンドを文字列やコメントの中から呼び出したとき、結果は信
頼できません。

‘C-M-n’
     カッコでグループ化されたグループを飛び越えて、前方に移動します
     (‘forward-list’)。
‘C-M-p’
     カッコでグループ化されたグループを飛び越えて、後方に移動します
     (‘backward-list’)。
‘C-M-u’
     カッコによる構造を上に移動します(‘backward-up-list’)。
‘C-M-d’
     カッコによる構造を下に移動します(‘down-list’)。

   “リスト(list)”コマンドの‘C-M-n’ (‘forward-list’)と‘C-M-p’
(‘backward-list’)は、グループ化されたカッコを前方または後方に、1つ(また
はN個)飛び越えて移動します。

   ‘C-M-n’と‘C-M-p’は、カッコによる構造において同じレベルに留まろうと試
みます。1レベル(またはNレベル)_上_に移動するには、‘C-M-u’
(‘backward-up-list’)を使用します。‘C-M-u’は対応が取れていない、前にある
開始区切りへ、後方に移動します。正の引数は繰り返し回数を意味します。負の
引数は移動の方向を逆転するので、このコマンドは1レベル以上を上に、前方に
移動します。

   カッコによる構造を_下_に移動するには、‘C-M-d’ (‘down-list’)を使用しま
す。Lispモードでは‘(’は開始区切りなので、これは‘(’を検索するのとほとんど
同じです。引数は何レベルしたに移動するかを指定します。


File: emacs-ja.info,  Node: Matching,  Prev: Moving by Parens,  Up: Parentheses

26.4.3 マッチするカッコ
-----------------------

Emacsには“カッコのマッチング(parenthesis matching)”機能がいくつかありま
す。これにより、どのカッコ(または他の区切り)がどのようにマッチするか簡単
に見ることができます。

   終了文字となる自己挿入文字をタイプすると、Emacsはそれがスクリーン上に
あれば、マッチする開始区切りの位置を簡単に示します。スクリーン上にない場
合、Emacsは開始区切りの近くにあるテキストをエコーエリアに表示します。ど
ちらの方法でも、どのグループを終了したのか見分けることができます。開始区
切りと終了区切りがマッチしない — ‘[x)’のような場合、エコーエリアに警告メ
ッセージが表示されます。

   3つの変数が、マッチするカッコの表示を制御します:

   • ‘blink-matching-paren’は、この機能をオンまたはオフに切り替えます。
     ‘nil’は無効にしますが、デフォルトの‘t’は有効にします。‘jump’にセッ
     トすると、マッチする開始区切りに数瞬カーソルを移動して指示します。

   • ‘blink-matching-delay’は、マッチする開始区切りを何秒表示するかを指
     定します。これには整数または浮動小数点数を指定します。デフォルトは
     1です。

   • ‘blink-matching-paren-distance’には、マッチする開始区切りを後方に何
     文字検索するかを指定します。この文字数内にマッチが見つからない場合
     、Emacsは検索を中止して、何も表示しません。デフォルトは102400です。

   グローバルなマイナーモードのShow Parenモードは、より強力な自動的なマ
ッチングの類を提供します。これは開始区切りの前、または終了区切りの後ろに
ポイントを移動すると、その区切りと、それに対応する反対側の区切りをハイラ
イトします。Show Parenモードに切り替えるには、‘M-x show-paren-mode’とタ
イプしてください。

   グローバルなマイナーモードのElectric Pairモードは、マッチする区切りを
簡単に挿入する方法を提供します。開始区切りを挿入すると、マッチする終了区
切りが自動的に挿入され、2つの区切りの間にポイントが配されます。反対に終
了区切りを既存の区切りの先に挿入した場合、何の挿入もされず、その位置は単
にスキップされます。以下の変数はElectric Pairモードの追加機能を制御しま
す:

   • ‘electric-pair-preserve-balance’ — 非‘nil’の場合、デフォルトのペア
     リングロジックは、開始区切りと終了区切りの数のバランスになります。

   • ‘electric-pair-delete-adjacent-pairs’ — 非‘nil’の場合、隣接する区切
     りの間でのバックスペースにより、終了区切りも自動的に削除します。

   • ‘electric-pair-open-newline-between-pairs’ — 非‘nil’の場合、2つの隣
     接するペアの間での改行の挿入は、ポイントの後ろに自動的に自動的に追
     加の改行をオープンします。

   • ‘electric-pair-skip-whitespace’ — 非‘nil’の場合、終了区切りのスキッ
     プを決定する前に、マイナーモードが空白文字を前方にスキップするよう
     にします。

   Electric Pairモードに切り替えるには、‘M-x electric-pair-mode’とタイプ
してください。


File: emacs-ja.info,  Node: Comments,  Next: Documentation,  Prev: Parentheses,  Up: Programs

26.5 コメントの操作
===================

コメントは、プログラミングにおいて重要なパートなので、Emacsはコメントの
編集や挿入を行う特別なコマンドを提供します。Flyspell Progモードによる、
コメントのスペルチェックも行うことができます(*note Spelling::を参照して
ください)。

   異なる種類のコメントのインデントにたいして、特別なルールをもつメジャ
ーモードがいくつかあります。たとえばLispコードでは、2つのセミコロンで始
まるコメントは、それらの行がコードであるかのようにインデントされ、3つの
セミコロンで始まるコメントは左端に揃えてインデントされ、しばしば区分けの
目的で使用されます。Emacsはこれらの慣習を理解します。たとえば、コメント
行で<TAB>をタイプすると、そのコメントを適切な位置にインデントします。

     ;; This function is just an example.
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;;  And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

* Menu:

* Comment Commands::         コメントの挿入、kill、位置揃え。
* Multi-Line Comments::      複数行のコメントを追加・編集するコマンド。
* Options for Comments::コメント機能のカスタマイズ。


File: emacs-ja.info,  Node: Comment Commands,  Next: Multi-Line Comments,  Up: Comments

26.5.1 コメントコマンド
-----------------------

以下のコマンドは、コメントにたいして処理を行います:

‘M-;’
     カレント行にコメントを挿入、または位置揃えします。リージョンがアク
     ティブのときは、かわりにリージョンをコメント化、または非コメント化
     します(‘comment-dwim’)。
‘C-u M-;’
     カレント行のコメントをkillします(‘comment-kill’)。
‘C-x ;’
     コメント列をセットします(‘comment-set-column’)。
‘C-M-j’
‘M-j’
     <RET>の後にコメントを挿入して位置揃えします
     (‘comment-indent-new-line’)。*note Multi-Line Comments::を参照して
     ください。
‘M-x comment-region’
‘C-c C-c’ (C-likeなモードの場合)
     リージョンのすべての行にたいして、コメント区切りを追加します。

   コメントを挿入または位置揃えするコマンドは、‘M-;’ (‘comment-dwim’)で
す。単語“dwim”は、“Do What I Mean(私が言ったとおりにしてください)”の頭文
字をとったものです。このコマンドは、コメントに関係する多くの異なる作業に
使用できます。それは、このコマンドをどこで使うかという、状況に依存するこ
とを示します。

   リージョンがアクティブ(*note Mark::を参照してください)の場合、‘M-;’は
リージョンのコメント区切りの追加と削除のどちらかを行います。リージョンの
各行がすでにコメントの場合、それらのコメント区切りを削除することにより、
それらの行を“非コメント化”します。そうでない場合は、リージョンのテキスト
にコメント区切りを追加します。

   リージョンがアクティブのときに‘M-;’に数引数を与えると、それは追加また
は削除するコメント区切りの数を指定します。正の引数NはN個の区切りを追加し
、負の引数-NはN個の区切りを削除します。

   リージョンが非アクティブで、カレント行にコメントがない場合、‘M-;’はカ
レント行に新しいコメントを追加します。ブランク行(たとえば空または空白文
字しか含まない)の場合、<TAB>をタイプしたときにインデントされるのと同じ位
置に、コメントがインデントされます(*note Basic Indent::を参照してくださ
い)。非ブランク行の場合、コメントはその行の最後の非空白文字の後ろに配さ
れます。通常Emacsは変数‘comment-column’ (*note Options for Comments::を
参照してください)で指定された列にコメントを配そうと試みますが、行が既に
その列を越えている場合、コマンドはコメントを適切な位置 — 通常、非コメン
トのテキストと1つのスペースを空けてコメントを配します。どちらの場合も、
Emacsはコメントの開始区切りの後ろにポイントを配すので、すぐにコメントの
タイプを開始できます。

   既存のコメントの位置揃えにも‘M-;’を使用できます。行がすでにコメント開
始文字列を含む場合、‘M-;’は慣習的な位置にそれを位置揃えして、ポイントを
コメント開始区切りの後ろに移動します。例外として、列0で始まるコメントは
移動されません。既存のコメントがすでに正しく位置揃えされているときでも、
‘M-;’はコメントテキストの開始に直接移動するので有用です。

   ‘C-u M-;’ (‘comment-dwim’にプレフィクス引数を指定)は、カレント行の任
意のコメントを、それの前の空白文字と一緒にkillします。コメントはkillリン
グに保存されるので、他の行の行末に移動して‘C-y’で挿入して、‘M-;’でコメン
トの位置揃えをすることができます。‘M-x comment-kill’とタイプしても‘C-u
M-;’と同じ効果を得ることができます(‘comment-dwim’はプレフィクス引数を与
えられたとき、実際にサブルーチンとして‘comment-kill’を呼び出します)。

   コマンド‘M-x comment-region’は、アクティブなリージョンにたいして
‘M-;’を呼び出すのと等価ですが、このコマンドはマークが非アクティブのとき
でも、常にリージョンにたいして動作します。Cモードおよび関連するモードで
は、このコマンドは‘C-c C-c’にバインドされています。コマンド‘M-x
uncomment-region’は、リージョンの各行を非コメント化します。数引数は、削
除するコメント区切りの数を指定します(負の引数は、追加するコメント区切り
の数を指定します)。

   C-likeなモードにたいしては、変数‘c-indent-comment-alist’および
‘c-indent-comments-syntactically-p’をセットすることにより、‘M-;’の正確な
効果を設定できます。たとえば閉じ大カッコで終わる行では、‘M-;’は
‘comment-column’ではなく、大カッコの後ろにスペースを1つ空けてコメントを
配します。完全な詳細は、*note (ccmode)Comment Commands::を参照してくださ
い。


File: emacs-ja.info,  Node: Multi-Line Comments,  Next: Options for Comments,  Prev: Comment Commands,  Up: Comments

26.5.2 複数行のコメント
-----------------------

コメントをタイプするとき、それを次の行に継続したくなったときは、‘M-j’ま
たは‘C-M-j’ (‘comment-indent-new-line’)とタイプします。これはカレント行
を行ブレークして、コメントを継続するために必要なコメント区切りとインデン
トを挿入します。

   コメントの終了区切りをもつ言語(たとえばCの‘*/’)では、‘M-j’の正確な振
る舞いは、変数‘comment-multi-line’の値に依存します。変数の値が‘nil’の場
合、このコマンドは古い行のコメントを終了させて、新しい行で新しいコメント
を開始します。そうでない場合、カレントのコメント区切りの中で新しい行を開
きます。

   Auto Fillモードがオンの場合、コメントをタイプしているときにフィル列に
達すると、明示的に‘M-j’を呼び出したときと同じ方法で、コメントが継続され
ます。

   既存の行をコメントにするには、リージョンがアクティブのときは‘M-;’、ま
たは‘M-x comment-region’を使用します。 (*note Comment Commands::).

   複数行ブロックのコメントの行の開始で‘/’をタイプすると、コメントを終了
するようにCモードを設定できます。これを行なうには、クリーンアップ
(clean-up)で、‘comment-close-slash’を有効にします。*note
(ccmode)Clean-ups::を参照してください。


File: emacs-ja.info,  Node: Options for Comments,  Prev: Multi-Line Comments,  Up: Comments

26.5.3 コメントを制御するオプション
-----------------------------------

*note Comment Commands::で示したように、‘M-j’コマンドが行にコメントを追
加するとき、バッファーローカルな変数‘comment-column’で指定された位置にコ
メントを配しようと試みます。このバッファーローカルな変数のデフォルト値、
またはローカルな値は、通常の方法(*note Locals::を参照してください)でセッ
トできます。かわりに‘C-x ;’ (‘comment-set-column’)とタイプすることにより
、カレントバッファーの‘comment-column’の値を、現在コメントがある列にセッ
トすることができます。‘C-u C-x ;’は、コメント列をそのバッファーのポイン
トの前にある最後のコメントにセットします。その後で‘M-;’を行うことにより
、カレント行のコメントを前のコメントに揃えることができます。

   コメントコマンドは、変数‘comment-start-skip’の値である正規表現にもと
づいて、コメントを認識します。この正規表現がヌル文字列にマッチしないよう
に気をつけてください。単語という言葉の厳格な意味から考えると、これはコメ
ント開始区切りより長い文字列にマッチするかもしれません。たとえばCモード
での変数の値は‘"\\(//+\\|/\\*+\\)\\s *"’で、これは‘/*’自身と、その後ろの
余分なアスタリスクやスペースにマッチし、C++スタイルのコメントも許容しま
す(文字列に‘\’を含む場合、Lisp構文では‘\\’と記述する必要があることに注意
してください。これは最初のアスタリスクにたいして、正規表現においてアスタ
リスクがもつ特別な意味を打ち消すために必要です)。

   コメントコマンドが新しいコメントを作るとき、これは‘comment-start’の値
をコメント開始区切りとして挿入します。これはポイントの後ろに、コメント終
了区切りとして‘comment-end’の値も挿入します。たとえばLispモードでは
‘comment-start’が‘";"’で、‘comment-end’が‘""’(空文字列)です。Cモードでは
‘comment-start’が‘"/* "’で、‘comment-end’が‘" */"’です。

   変数‘comment-padding’は、コメントコマンドが、コメント区切りとコメント
テキストの間を区切る文字列を指定します。デフォルトでは‘" "’、つまり1つの
スペースが指定されます。かわりに数字を指定すると、これは指定した数のスペ
ースになり、‘nil’の場合、スペースは挿入されません。

   変数‘comment-multi-line’は、‘M-j’とAuto Fillモードがコメントをどのよ
うに複数行に継続するかを制御します。*note Multi-Line Comments::を参照し
てください。

   変数‘comment-indent-function’は、新しく挿入されたコメント、または既存
のコメントの位置揃え位置を計算するために呼び出される関数を指定します。こ
れはメジャーモードごとに異なります。関数は引数なしで呼び出されますが、新
しいコメントが挿入されるときはコメント開始位置のポイント、または行末のポ
イントで呼び出されます。この関数はコメントが開始されるべき列を返す必要が
あります。たとえばLispモードでは、インデントフック関数の決定は、既存のコ
メントがいくつのセミコロンで始まるかと、前の行のコードにもとづきます。


File: emacs-ja.info,  Node: Documentation,  Next: Hideshow,  Prev: Comments,  Up: Programs

26.6 ドキュメントの照会
=======================

Emacsは、関数やプログラムで使おうと計画している変数およびコマンドを、ド
キュメントから探すのに使用できる機能をいくつか提供します。

* Menu:

* Info Lookup::              Infoファイルからライブラリー関数やコマンドを探す。
* Man Page::                 manからライブラリー関数やコマンドを探す。
* Lisp Doc::                 Emacs関数を探す、その他。


File: emacs-ja.info,  Node: Info Lookup,  Next: Man Page,  Up: Documentation

26.6.1 Infoドキュメントの照会
-----------------------------

Infoドキュメントをもつ言語に適用されるメジャーモードでは、プログラムで使
用されるシンボルにたいして‘C-h S’ (‘info-lookup-symbol’)を使用することに
より、Infoドキュメントを閲覧できます。シンボルはミニバッファーで指定しま
す。デフォルトはバッファーのポイント位置にあるシンボルです。たとえばCモ
ードでは、シンボルをC Library Manualから探します。このコマンドは適切な
Infoファイルのマニュアルがインストールされているときだけ機能します。

   メジャーモードは、どのドキュメントのどこからシンボルを探すか — つまり
、どのInfoファイルを探すのか、そしてどのインデックスを検索するかを決定し
ます。‘M-x info-lookup-file’を使用して、ドキュメントのファイル名を指定す
ることもできます。

   ‘C-h S’をサポートしないメジャーモードでこれを使用すると、これは
“symbol help mode”を指定するよう求めます。ここでは‘c-mode’コマンドのよう
に、‘C-h S’をサポートするメジャーモードを選択します。


File: emacs-ja.info,  Node: Man Page,  Next: Lisp Doc,  Prev: Info Lookup,  Up: Documentation

26.6.2 man-pageの照会
---------------------

Unixでは、オンラインドキュメントのメインフォームは“manual page”または
“man page”です。GNUオペレーティングシステムではmanを、Infoでブラウズでき
る、より組織化されたマニュアルで置き換えることを目指しています。このプロ
セスは終了していないので、manを読むことはまだ有用です。

   オペレーティングシステムのコマンド、ライブラリー関数、システムコール
にたいするman pageを、‘M-x man’コマンドで読むことができます。このコマン
ドは補完つき(*note Completion::を参照してください)でトピック(topic)の入
力を求め、対応するman pageをフォーマットするために、‘man’コマンドを実行
します。そのシステムが許すなら、このコマンドは‘man’を非同期で実行するの
で、ページがフォーマットされる間、編集を続けることができます。フォーマッ
トされた結果は‘*Man TOPIC*’という名前のバッファーに表示されます。このバ
ッファーは、Manモードという特別なメジャーモードを使用します。これはスク
ロールや他のman pageにジャンプする機能をもちます。詳細についてはManモー
ドのバッファーで、‘C-h m’をタイプしてください。

   それぞれのman pageは、1つ以上の“セクション(sections)”に属します。セク
ションの名前は数字または数字と文字です。同じ名前のman pageが、複数のセク
ションに存在することもあります。特定のセクションのman pageを読むには、
‘M-x manual-entry’がトピックの入力を求める際、‘TOPIC(SECTION)’または
‘SECTION TOPIC’とタイプします。たとえばCのライブラリー関数‘chmod’はセク
ション2ですが、同じ名前のシェルコマンドのman pageはセクション1です。前者
を閲覧するには、‘M-x manual-entry <RET> chmod(2) <RET>’とタイプしてくだ
さい。

   セクションを指定しないと、‘M-x man’は通常、最初に見つかったman pageだ
けを表示します。‘man’に、コマンドラインオプション‘-a’を指定できるシステ
ムもいくつかあります。これは指定したトピックにたいするすべてのman pageを
表示するよう指定します。これを使用するには、変数‘Man-switches’の値を
‘"-a"’に変更します。そうするとManモードのバッファーで、‘M-n’と‘M-p’で異
なるセクションのman pagfeを切り替えることができます。モードラインには、
利用可能なman pageの数が表示されます。

   man pageを読む他の方法として、‘M-x woman’コマンドがあります。‘M-x
man’とは異なり、これはman pageをフォーマットするために外部のプログラムを
実行しないので、MS-Windowsのような、‘man’プログラムが利用できないかもし
れないシステムでも機能します。このコマンドは、表示するman pageの入力を求
め、それを‘*WoMan SECTION TOPIC’という名前のバッファーに表示します。

   ‘M-x woman’は、コマンドを最初に呼び出したとき、man pageの補完リストを
計算します。数引数を指定すると、このリストを再計算します。これはman
pageを追加・削除したとき有用です。

   man pageの名前を入力して、‘M-x woman’が複数のセクションで同じ名前の
man pageを見つけた場合、これはウィンドウをポップアップして利用可能な候補
を示し、それらから1つを選択するよう求めます。

   ‘M-x woman’のセットアップと使用についての情報は、 *note WoMan:
(woman)Top.を参照してください。


File: emacs-ja.info,  Node: Lisp Doc,  Prev: Man Page,  Up: Documentation

26.6.3 Emacs Lispドキュメントの照会
-----------------------------------

Emacs Lispコードを編集するとき、コマンド‘C-h f’ (‘describe-function’)お
よび‘C-h v’ (‘describe-variable’)で、使用したい関数または変数のビルトイ
ンドキュメントを閲覧できます。*note Name Help::を参照してください。

   Eldocモードは、Lispドキュメントを検索するのに助けとなる、バッファーロ
ーカルなマイナーモードです。これが有効な場合、ポイントがLisp関数または変
数にあるときは、有用な情報がエコーエリアに表示されます。関数の場合は引数
リスト、変数の場合は変数のドキュメントストリングの最初の行が表示されます
。Eldocモードに切り替えるには、‘M-x eldoc-mode’とタイプします。Eldocモー
ドは、メジャーモードのEmacs LispモードおよびLisp Interactionモードととも
に使用できます。


File: emacs-ja.info,  Node: Hideshow,  Next: Symbol Completion,  Prev: Documentation,  Up: Programs

26.7 Hideshowマイナーモード
===========================

Hideshowモードは、バッファーローカルなマイナーモードで、“ブロック”と呼ば
れるプログラムの一部を、選択的に表示させることができます。このマイナーモ
ードに切り替えるには、‘M-x hs-minor-mode’とタイプします(*note Minor
Modes::を参照してください)。

   ブロックを非表示にするためにHideshowモードを使用したとき、そのブロッ
クはスクリーンに表示されなくなり、かわりに省略記号(3つのピリオド)に置き
換えられます。何をブロックと定めるかは、メジャーモードに依存します。Cモ
ード、および関連するモードでは、ブロックは大カッコ(braces)で区切られ、
Lispモードでは丸カッコ(parentheses)で区切られます。複数行のコメントもブ
ロックとみなされます。

   Hideshowモードは以下のコマンドを提供します:

‘C-c @ C-h’
     カレントブロックを隠します(‘hs-hide-block’)。
‘C-c @ C-s’
     カレントブロックを表示します(‘hs-show-block’)。
‘C-c @ C-c’
     カレントブロックを表示、または非表示にします(‘hs-toggle-hiding’)。
‘S-Mouse-2’
     クリックしたブロックの表示・非表示を切り替えます
     (‘hs-mouse-toggle-hiding’)。
‘C-c @ C-M-h’
     トップレベルのすべてのブロックを隠します(‘hs-hide-all’)。
‘C-c @ C-M-s’
     バッファーのすべてのブロックを表示します(‘hs-show-all’)。
‘C-c @ C-l’
     現在のブロックの、Nレベル下のすべてのブロックを隠します
     (‘hs-hide-level’)。

   以下の変数はHideshowモードをカスタマイズするのに使用されます:

‘hs-hide-comments-when-hiding-all’
     非‘nil’の場合、‘C-c @ C-M-h’ (‘hs-hide-all’)はコメントも隠します。

‘hs-isearch-open’
     この変数は、インクリメンタル検索でマッチするテキストが隠されたブロ
     ックにあるとき、それを表示すべき条件を指定します。変数の値は、
     ‘code’(コードブロックだけを表示)、‘comment’(コメントだけを表示)、
     ‘t’(コードブロックとコメントの両方を表示)、‘nil’(どちらも表示しない
     )のいずれかです。デフォルト値は‘code’です。


File: emacs-ja.info,  Node: Symbol Completion,  Next: MixedCase Words,  Prev: Hideshow,  Up: Programs

26.8 シンボル名の補完
=====================

補完は通常ミニバッファーで行われますが(*note Completion::を参照してくだ
さい)、シンボル名の補完を、普通のEmacsバッファーで行うこともできます。

   プログラミング言語のモードでは、‘C-M-i’または‘M-<TAB>’とタイプするこ
とにより、ポイントの前のシンボル名の一部にたいして補完を行うことができま
す。グラフィカルなディスプレーでは、‘M-<TAB>’キーは通常、グラフィカルな
ウィンドウの切り替え用にウィンドウマネージャーに予約されているので、かわ
りに‘C-M-i’または‘<ESC> <TAB>’とタイプする必要があります。

   ほとんどのプログラミング言語のモードでは、‘C-M-i’ (または‘M-<TAB>’)は
、コマンド‘completion-at-point’を呼び出します。これは柔軟な方法で補完リ
ストを生成します。Semanticモードが有効な場合は、補完にSemanticパーサーの
データを使用することを試みます(*note Semantic::を参照してください)。
Semanticモードが無効、または補完の処理に失敗した場合、選択されたtagsテー
ブル(*note Tags::を参照してください)を使用して補完を試みます。Emacs
Lispモードの場合、カレントのEmacsセッションで定義された関数、変数、プロ
パティー名を使用して補完を行います。

   他の点では、バッファーでのシンボル補完はミニバッファーでの補完と同様
に振る舞います。たとえば、Emacsが一意なシンボルを補完できない場合、他の
ウィンドウに補完候補のリストを表示します。*note Completion::を参照してく
ださい。

   Textモード、および関連するモードでは、‘M-<TAB>’はスペルチェッカーの辞
書にもとづいて単語を補完します。*note Spelling::を参照してください。


File: emacs-ja.info,  Node: MixedCase Words,  Next: Semantic,  Prev: Symbol Completion,  Up: Programs

26.9 大文字小文字の混ざった単語
===============================

いくつかのプログラミングスタイルでは、‘unReadableSymbol’のような大文字小
文字が混ざった(“CamelCase”の)シンボルを使います(GNUプロジェクトでは、識
別子の単語の区切りに、大文字小文字の違いではなく、アンダースコアを使用す
ることを推奨しています)。Emacsには、そのようなシンボルに簡単に対処するた
めの、さまざまな機能があります。

   バッファーローカルなマイナーモードのGlassesモードは、そのようなシンボ
ルが表示される方法を変更することにより、それらを読みやすくします。デフォ
ルトでは、小文字とそれに続く大文字の間に余分なアンダースコアを表示します
。これはバッファーのテキストを変更するわけではなく、表示の仕方だけを変更
します。

   Glassesモードに切り替えるには、‘M-x glasses-mode’とタイプします(*note
Minor Modes::を参照してください)。Glassesモードが有効な場合、モードライ
ンのマイナーモードインジケーターには‘o^o’が表示されます。Glassesモードに
間する情報を得るには、‘C-h P glasses <RET>’とタイプしてください。

   Subwordモードは、バッファーローカルなマイナーモードです。Subwordモー
ドでは、Emacsの単語コマンドは、‘StudlyCapsIdentifiers’のような、単語の中
の大文字を単語境界と認識します。Subwordモードが有効なときは、モードライ
ンのマイナーモードインジケーターに‘,’が表示されます。同様なモード
‘superword-mode’も参照してください(*note Misc for Programs::を参照してく
ださい)。


File: emacs-ja.info,  Node: Semantic,  Next: Misc for Programs,  Prev: MixedCase Words,  Up: Programs

26.10 Semanticとは
==================

Semanticは、‘ソースコードパーサー(source code parsers)’にもとづく、言語
認識(language-aware)による編集のためのコマンドを提供します。このセクショ
ンは、Semanticについての簡単な説明を提供します。完全な詳細については、
*note Semantic: (semantic)Top.を参照してください。

   Font Lockモード(*note Font Lock::を参照してください)のような、Emacsの
“言語認識機能(language aware features)”のほとんどは、“rules of
thumb”(1)にもとづいています。これは大抵の場合においてよい結果を得られま
すが、完全に正しい結果は決して得られない、ということを意味します。対照的
に、Semanticで使用されるパーサーは、プログラミング言語の構文を正確に理解
します。これによりSemanticは、より強力で正確な検索、操作、補完コマンドが
提供できるのです。

   Semanticの使用を開始するには、‘M-x semantic-mode’をタイプするか、
‘Tools’メニューの、‘Source Code Parsers (Semantic)’という名前のメニュー
をクリックします。これはグローバルなマイナーモードのSemanticモードを有効
にします。

   Semanticモードが有効な場合、Emacsはファイルをvisitするたびに自動的に
パースを試みます。現在のところ、SemanticはC、C++、Scheme、Javascript、
Java、HTML、Makeを理解します。パースされたバッファーでは以下のコマンドが
利用可能です:

‘C-c , j’
     カレントファイルで定義された関数名の入力を求め、ポイントをそこに移
     動します(‘semantic-complete-jump-local’)。

‘C-c , J’
     Emacsがパースした任意のファイルで定義された関数名の入力を求め、ポイ
     ントをそこに移動します(‘semantic-complete-jump’)。

‘C-c , <SPC>’
     ポイント位置のシンボルにたいして可能な補完候補のリストを表示します
     (‘semantic-complete-analyze-inline’)。これは補完候補を選択するため
     の特別なキーバインドのセットをアクティブにします。<RET>はカレントの
     補完候補を選択し、‘M-n’と‘M-p’は可能な補完候補を巡回、<TAB>は可能な
     ところまで補完を行ってから巡回、そして、‘C-g’または他のキーは補完を
     中止します。

‘C-c , l’
     ポイント位置のシンボルにたいして可能な補完候補のリストを、他のウィ
     ンドウに表示します(‘semantic-analyze-possible-completions’)。

上記のコマンドに加えて、Semanticパッケージは、パーサー情報を使用する他の
さまざまな方法を提供します。たとえば、Emacsがアイドルのとき、補完候補の
リストを表示するために、それを使用することができます。 詳細は、*note
Semantic: (semantic)Top.を参照してください。

   ---------- Footnotes ----------

   (1) 正規表現と構文テーブル。


File: emacs-ja.info,  Node: Misc for Programs,  Next: C Modes,  Prev: Semantic,  Up: Programs

26.11 プログラムを編集するための他の便利な機能
==============================================

プログラムを編集するためにデザインされているわけではありませんが、有用な
Emacsコマンドもいくつかあります

   単語、センテンス、パラグラフを操作するEmacsコマンドは、コードを編集す
るのに有用です。ほとんどのシンボル名は単語(*note Words::を参照してくださ
い)を含んでおり、文字列やコメントの中でセンテンス(*note Sentences::を参
照してください)を見つけることができます。パラグラフについては、ほとんど
のプログラミング言語のモードは空行をパラグラフの開始および終了に定義して
います。したがって空行を注意深く使用してプログラムをクリアーにすることに
より、パラグラフコマンドが機能できる、有意なテキストの集合を提供すること
ができます。プログラミング言語のモードでAuto Fillモードが有効な場合、新
しい行の作成でインデントされるようになります。

   Superwordはバッファーローカルなマイナーモードで、編集および移動コマン
ドがシンボル(たとえば‘this_is_a_symbol’)を単語として扱うようになります。
Superwordモードが有効な場合、モードラインのマイナーモードインジケーター
に、 ‘²’ が表示されます。同様なモード‘subword-mode’も参照してください
(*note MixedCase Words::を参照してください)。

   Electric Layoutモード(‘M-x electric-layout-mode’)はグローバルなマイナ
ーモードで、特定の文字をタイプしたときに自動的に改行を挿入します。たとえ
ばJavascriptモードでは‘{’、‘}’、‘;’などです。

   Hideshowモード(*note Hideshow::を参照してください)は別として、プログ
ラムの一部を選択的に表示するには、選択的な表示機能(*note Selective
Display::を参照してください)を使う方法があります。プログラミングのモード
には、Foldoutパッケージ(*note Foldout::を参照してください)とともに使用で
きる、Outline minorマイナーモード(*note Outline Mode::を参照してください
)をサポートするものもあります。

   プログラムを記述するためには“automatic typing”機能が有用でしょう。
*note Autotyping: (autotype)Top.を参照してください。

   Prettify Symbolsモードはバッファーローカルなマイナーモードで、特定の
文字の表示をより“アトラクティブ(attractive: 見栄えのする)”なバージョンに
置き換えます。たとえばEmacs Lispモードでは、文字列“lambda”を、ギリシャ文
字のラムダに置き換えます。このモードを、プログラミングとは関係のないモー
ドで使いたいと思うかもしれません。‘prettify-symbols-alist’にエントリーを
追加することにより、このモードをカスタマイズできます。グローバルなバージ
ョン‘global-prettify-symbols-mode’は、サポートするすべてのモードでこれを
有効にします。


File: emacs-ja.info,  Node: C Modes,  Next: Asm Mode,  Prev: Misc for Programs,  Up: Programs

26.12 Cおよび関連するモード
===========================

このセクションではC、C++、Objective-C、Java、CORBA IDL、Pike、AWKのため
のモード(これらは“Cモードおよび関連するモード”と呼ばれます)で利用できる
、特別な機能を簡単に説明します。 詳細は、*note CC Mode: (ccmode)Top.を参
照してください。

* Menu:

* Motion in C::              Cステートメント単位での移動、その他。
* Electric C::               コロンおよび他の文字による、自動的な再インデント。
* Hungry Delete::            より強力なDELコマンド。
* Other C Commands::         コメントのフィル、マクロ展開の閲覧、その他のクールな機能。


File: emacs-ja.info,  Node: Motion in C,  Next: Electric C,  Up: C Modes

26.12.1 Cモードの移動コマンド
-----------------------------

このセクションでは、Cモードおよび関連するモードで、ポイントを移動するコ
マンドを説明します。

‘C-M-a’
‘C-M-e’
     カレント関数またはトップレベルの定義の、先頭または最後にポイントを
     移動します。スコープによる囲い(C++のclassなど)をもつ言語では、“カレ
     ント関数(current function)”はスコープ内の隣接する関数です。そうでな
     い場合、それは大カッコ(braces)で囲まれることにより定義されます。
     *note Moving by Defuns::を参照してください。

‘C-c C-u’
     マークを置いたまま、ポイントを含むプリプロセッサー条件を後方に移動
     します。プレフィクス引数は、繰り返し回数として振る舞います。負の引
     数を指定すると、ポイントを含むプリプロセッサー条件の最後に、前方へ
     ポイントを移動します。

     ‘#elif’は、‘#else’の後に‘#if’を続けたのと同じなので、この関数は後方
     に移動するときは‘#elif’で止まりますが、前方に移動するときは止まりま
     せん。

‘C-c C-p’
     マークを置いたまま、プリプロセッサー条件を越えてポイントを後方に移
     動します。プレフィクス引数は、繰り返し回数として振る舞います。負の
     引数の場合は前方に移動します。

‘C-c C-n’
     マークを置いたまま、プリプロセッサー条件を越えて、ポイントを前方に
     移動します。プレフィクス引数は、繰り返し回数として振る舞います。負
     の引数の場合は後方に移動します。

‘M-a’
     一番内側のCステートメントの先頭に、ポイントを移動します
     (‘c-beginning-of-statement’)。すでにポイントがステートメントの先頭
     にある場合は、その前のステートメントの先頭に移動します。プレフィク
     ス引数Nを指定した場合、N − 1個前のステートメントに、後方へ移動しま
     す。

     2行以上のコメントまたは文字列の場合、このコマンドはステートメントで
     はなくセンテンス単位で移動します。

‘M-e’
     Cステートメントまたはセンテンスの最後に、ポイントを移動します。
     ‘M-a’と同様ですが、これは逆の方向に移動します
     (‘c-end-of-statement’)。


File: emacs-ja.info,  Node: Electric C,  Next: Hungry Delete,  Prev: Motion in C,  Up: C Modes

26.12.2 エレクトリックC文字
---------------------------

Cモードおよび関連するモードでは、特定の文字は“エレクトリック(electric)”
— つまり自分自身を挿入するのに加えて、カレント行を再インデントしたり、オ
プションで改行を挿入します。“エレクトリック”な文字は、‘{’、‘}’、‘:’、
‘#’、‘;’、‘,’、‘<’、‘>’、‘/’、‘*’、‘(’、‘)’です。

   混乱したインデントのコードを編集している場合には、エレクトリックなイ
ンデントを不便だと感じるかもしれません。CCモードになれていない場合、それ
はあなたを当惑させるかもしれません。エレクトリックな動作は、コマンド‘C-c
C-l’で切り替えることができます。有効な場合には、モードラインのモード名の
後ろに‘/l’が表示されます。

‘C-c C-l’
     エレクトリックな動作を切り替えます(‘c-toggle-electric-state’)。正の
     プレフィクス引数を指定した場合、、このコマンドはエレクトリックな動
     作を有効にし、負の引数の場合は無効にします。

   エレクトリックな文字は、エレクトリックな状態に加えて、“自動改行
(auto-newline)”の機能が有効な場合(モードラインのモード名の後ろに‘/la’が
表示されている状態のとき)だけ、改行を挿入します。この機能は‘C-c C-a’で、
オンまたはオフに切り替えることができます。

‘C-c C-a’
     自動改行機能を切り替えます(‘c-toggle-auto-newline’)。このコマンドに
     プレフィクス引数を指定した場合、引数が正のときは自動改行機能をオン
     、負のときはオフに切り替えます。

   CCモードのスタイルは通常、Emacsが自動改行する正確な状況を設定します。
これを直接設定することもできます。*note (ccmode)Custom Auto-newlines::を
参照してください。


File: emacs-ja.info,  Node: Hungry Delete,  Next: Other C Commands,  Prev: Electric C,  Up: C Modes

26.12.3 Cの欲張りな削除機能
---------------------------

ポイント位置の空白文字のブロック全体を削除したい場合は、“hungry
deletion(欲張りな削除)”を使うことができます。これはポイントの前後の、一
連の空白文字を1回の操作で削除します。“空白文字(whitespace)”にはタブと改
行が含まれますが、コメントとプリプロセッサーコマンドは含まれません。

‘C-c C-<DEL>’
‘C-c <DEL>’
     ポイントの前の空白文字のブロック全体を削除します
     (‘c-hungry-delete-backwards’)。

‘C-c C-d’
‘C-c C-<Delete>’
‘C-c <Delete>’
     ポイントの後の空白文字のブロック全体を削除します
     (‘c-hungry-delete-forward’)。

   上記のコマンドのかわりに、“hungry deleteモード”を有効にすることができ
ます。この機能が有効な場合(モードラインのモード名の後ろに‘/h’が示されま
す)、1回の<DEL>で1つのスペースではなくポイントの前に続くすべての空白文字
を削除し、‘C-d’(<Delete>では_ありません_)でポイントの後に続くすべての空
白文字を削除します。

‘M-x c-toggle-hungry-state’
     hungry-delete機能を切り替えます(‘c-toggle-hungry-state’)。このコマ
     ンドにプレフィクス引数を指定した場合、正の場合はhungry-delete機能を
     オン、負の場合はオフにします。

   変数‘c-hungry-delete-key’は、hungry-delete機能を有効にするかを制御し
ます。


File: emacs-ja.info,  Node: Other C Commands,  Prev: Hungry Delete,  Up: C Modes

26.12.4 Cモードのその他のコマンド
---------------------------------

‘M-x c-context-line-break’
     このコマンドは、コンテキストに応じたマナーで、行ブレークの挿入と新
     しい行のインデントを行います。通常のコードの中では、<RET>
     (‘newline’)の働きをしますが、Cプリプロセッサー行の中では、行ブレー
     クに追加で‘\’を挿入し、コメントの中では‘M-j’
     (‘c-indent-new-comment-line’)のように動作します。

     デフォルトでは、‘c-context-line-break’はキーにバインドされていませ
     んが、便利に使うためには、キーにバインドする必要があります。以下の
     コードは、このコマンドを<RET>にバインドします。この例ではキーマップ
     を変更する前に、それがロードされていることを確実にするために
     ‘c-initialization-hook’を使用しています。

          (defun my-bind-clb ()
            (define-key c-mode-base-map "\C-m"
                        'c-context-line-break))
          (add-hook 'c-initialization-hook 'my-bind-clb)

‘C-M-h’
     マークを関数定義の最後に配し、ポイントを先頭に配します
     (‘c-mark-function’)。

‘M-q’
     CおよびC++のコメントに対応した、パラグラフのフィルを行います
     (‘c-fill-paragraph’)。カレント行がコメントを含む、またはカレント行
     がコメントの場合、このコマンドはコメントのインデントとコメント区切
     りを保ちながら、コメントまたはポイントがあるパラグラフをフィルしま
     す。

‘C-c C-e’
     リージョンのテキストにたいして、Cプリプロセッサーを実行して、すべて
     のマクロ呼び出しの展開を含めて、結果を表示します。リージョンの前に
     あるバッファーのテキストも、マクロ定義がそこにあるためにプリプロセ
     スされますが、この部分は出力には表示されません。

     マクロを使用するCコードをデバッグするとき、マクロがどのように展開さ
     れるか正確に解明するのが難しいときがあります。このコマンドにより、
     展開結果を見ることができるので、わざわざ解明する必要がなくなります
     。

‘C-c C-\’
     リージョン内の各行末に、‘\’文字を挿入、または位置揃えします
     (‘c-backslash-region’)。これはCマクロ定義を、記述または編集した後に
     便利です。

     行がすでに(‘c-backslash-region’)で終了されている場合、このコマンド
     はそれの前の空白文字の数を調整します。そうでない場合は、新規に‘\’を
     挿入します。しかしリージョンの最後の行は特別に扱われます。この行に
     は‘\’は挿入されず、もし‘\’がある場合は削除します。

‘M-x cpp-highlight-buffer’
     プリプロセッサー条件に対応するテキスト部分を、ハイライトします。こ
     のコマンドは‘*CPP Edit*’という名前の別のバッファーを表示します。こ
     れは特定の条件とその内容をどのように表示するかを選択するための、グ
     ラフィックメニューを供します。さまざまなセッティングを変更した後に
     、‘[A]pply these settings’をクリック(またはそのバッファーで‘a’をタ
     イプ)すると、それに応じてCモードのバッファーが再ハイライトされます
     。

‘C-c C-s’
     カレントソース行の構文的な情報を表示します
     (‘c-show-syntactic-information’)。この情報は、その行がどのようにイ
     ンデントされるべきか決定するために使用されます。

‘M-x cwarn-mode’
‘M-x global-cwarn-mode’
     CWarnマイナーモードは、ある種の疑わしいCおよびC++の構文をハイライト
     します。

        • 式の中での値の割り当て。
        • ‘if’、‘for’、‘while’(‘do ... while’命令は除く)の直後のセミコロ
          ン。
        • 参照パラメーターをともなうC++関数。

     このモードを1つのバッファーにたいして有効にするにはコマンド‘M-x
     cwarn-mode’、すべての適合するバッファーにたいして有効にするにはコマ
     ンド‘M-x global-cwarn-mode’、または変数‘global-cwarn-mode’をカスタ
     マイズします。これが機能するためには、Font Lockモードも有効にしなけ
     ればなりません。

‘M-x hide-ifdef-mode’
     Hide-ifdefマイナーモードは、プリプロセッサーブロック‘#if’および
     ‘#ifdef’の中の選択されたコードを隠します。変数‘hide-ifdef-shadow’を
     ‘t’に変更した場合、Hide-ifdefマイナーモードははプリプロセッサーブロ
     ックを隠すかわりに、より目立たないフェイスでそれらのブロックを
     “shadows”します。詳細は、‘hide-ifdef-mode’のドキュメント文字列を参
     照してください。

‘M-x ff-find-related-file’
     カレントバッファーでvisitされたファイルに“関連する”ファイルを、特別
     な方法で検索します。通常これはC/C++ソースファイルにたいするヘッダー
     ファイル、またはその逆です。変数‘ff-related-file-alist’は、関連する
     ファイル名をどのように計算するかを指定します。


File: emacs-ja.info,  Node: Asm Mode,  Next: Fortran,  Prev: C Modes,  Up: Programs

26.13 Asmモード
===============

Asmモードは、アセンブラーコードのファイルを編集するためのメジャーモード
です。このモードは、以下の3つのコマンドを定義します:

‘<TAB>’
     ‘tab-to-tab-stop’.
‘C-j’
     改行を挿入してから、‘tab-to-tab-stop’を使ってインデントします。
‘:’
     コロンを挿入してから、コロンの前のラベルからインデントを削除します
     。その後、‘tab-to-tab-stop’を実行します。
‘;’
     コメントの挿入または位置揃えをします。

   変数‘asm-comment-char’はアセンブラー構文でコメントを開始する文字を指
定します。


File: emacs-ja.info,  Node: Fortran,  Prev: Asm Mode,  Up: Programs

26.14 Fortranモード
===================

Fortranモードは、“固定形式(fixed form)”(または“タブ形式(tab format)”)の
ソースコードを編集するためのモードです(通常はFortran 77)。よりモダンな
“自由形式(free form)”のソースコードを編集するためには、F90モード
(‘f90-mode’)を使用します。Emacsは通常、拡張子が‘.f’、‘.F’、‘.for’のファ
イルにたいしてはFortranモードを使用し、拡張子が‘.f90’、‘.f95’、‘.f03’、
‘.f08’のファイルにたいしてはF90モードを使用します。‘auto-mode-alist’をカ
スタマイズして、拡張子を追加することができます。GNU Fortranは、これら自
由形式と固定形式の両方をサポートします。このマニュアルでは主にFortranモ
ードを記述しますが、対応するF90モードの機能については、その都度言及しま
す。

   Fortranモードは、Fortran命令文およびサブプログラムにたいする特別な移
動コマンドと、Fortranのネスト規則、行番号、行継続された命令文を理解する
、インデントコマンドを提供します。Fortranモードは、長い行を適正な
Fortranの継続行にブレークする、Auto Fillモードをサポートします。
FortranモードはHideshowマイナーモード (*note Hideshow::を参照してくださ
い)、 、およびImenu (*note Imenu::を参照してください)もサポートします。

   Fortranのコメントは他の言語とは異なるので、コメントのための特別なコマ
ンドも提供されています。ビルトインのabbrev(省略形)は、Fortranキーワード
をタイプする手間を削減します。

   ‘M-x fortran-mode’を使用して、このメジャーモードに切り替えます。この
コマンドはフック‘fortran-mode-hook’を実行します。 *note Hooks::を参照し
てください。

* Menu:

* Motion: Fortran Motion.    命令文またはサブプログラムごとにポイントを移動する。
* Indent: Fortran Indent.    Fortranのためのインデントコマンド。
* Comments: Fortran Comments.  コメントの挿入と位置揃え。
* Autofill: Fortran Autofill.  FortranをサポートするAuto Fill。
* Columns: Fortran Columns.  有効なFortranのための列の計算。
* Abbrev: Fortran Abbrev.    Fortranキーワードのためのビルトインのabbrev。


File: emacs-ja.info,  Node: Fortran Motion,  Next: Fortran Indent,  Up: Fortran

26.14.1 移動コマンド
--------------------

“defun”(Fortranのサブプログラム — 関数、サブルーチン、同様にF90モードの
モジュールには、コマンド‘fortran-end-of-subprogram’および
‘fortran-beginning-of-subprogram’を使用します)を単位に移動、操作する通常
コマンドに加えて、Fortranモードは命令文や他のプログラム単位に移動する、
特別なコマンドを提供します。

‘C-c C-n’
     次の命令文の先頭に移動します
     (‘fortran-next-statement’/‘f90-next-statement’)。

‘C-c C-p’
     前の命令文の先頭に移動します
     (‘fortran-previous-statement’/‘f90-previous-statement’)。前の命令文
     が存在しない場合(たとえばバッファーの最初の命令文で呼び出された場合
     )、バッファーの先頭に移動します。

‘C-c C-e’
     次のコードブロックの先頭、またはカレントのコードブロックの最後に移
     動します(‘f90-next-block’)。コードブロックとは、サブルーチン、
     ‘if’–‘endif’命令文などです。これはF90モードだけのコマンドで、
     Fortranモードにはありません。数引数を指定すると、複数ブロックを前方
     に移動します。

‘C-c C-a’
     前のブロックに、後方にポイントを移動します(‘f90-previous-block’)。
     これは‘f90-next-block’と似ていますが、後方に移動します。

‘C-M-n’
     カレントのコードブロックの最後にポイントを移動します
     (‘fortran-end-of-block’/‘f90-end-of-block’)。数引数を指定した場合、
     指定した数のブロックを前方に移動します。ポイントを移動する前にマー
     クがセットされます。このコマンドのF90モードのバージョンでは、ブロッ
     クタイプと、(もしあれば)ラベルの整合性をチェックしますが、最外のブ
     ロックは不完全かもしれないのでチェックしません。

‘C-M-p’
     カレントコードブロックの先頭にポイントを移動します
     (‘fortran-beginning-of-block’/‘f90-beginning-of-block’)。これは
     ‘fortran-end-of-block’と似ていますが、後方に移動します。

   コマンド‘fortran-beginning-of-subprogram’および
‘fortran-end-of-subprogram’は、カレントサブプログラムの先頭または後方に
移動します。コマンド‘fortran-mark-do’および‘fortran-mark-if’は、カレント
の‘do’ブロック、または‘if’ブロックの最後にマークをセットして、ポイントを
ブロックの先頭に移動します。


File: emacs-ja.info,  Node: Fortran Indent,  Next: Fortran Comments,  Prev: Fortran Motion,  Up: Fortran

26.14.2 Fortranのインデント
---------------------------

固定形式(またはタブ形式)のFortranコードにたいしては、さまざまな構文エン
トリー(行番号、行インジケーター、継続行フラグ)が、要求される列に表示され
るようにするために、特別なコマンドと機能が必要です。

* Menu:

* Commands: ForIndent Commands.  Fortranをインデントおよびフィルするコマンド。
* Contline: ForIndent Cont.  継続行がインデントされる方法。
* Numbers: ForIndent Num.    行番号が自動インデントされる方法。
* Conv: ForIndent Conv.      トラブル防止のために、したがわなければならない慣習。
* Vars: ForIndent Vars.      Fortranのインデントスタイルを制御する変数。


File: emacs-ja.info,  Node: ForIndent Commands,  Next: ForIndent Cont,  Up: Fortran Indent

26.14.2.1 Fortranのインデントおよびフィルコマンド
.................................................

‘C-M-j’
     ポイント位置でカレント行をブレークして、継続行をセットアップします
     (‘fortran-split-line’)。
‘M-^’
     その行を前の行と結合します(‘fortran-join-line’)。
‘C-M-q’
     ポイントのあるサブプログラムの、すべての行をインデントします
     (‘fortran-indent-subprogram’)。
‘M-q’
     コメントブロックまたは命令文をフィルします
     (‘fortran-fill-paragraph’または‘fortran-fill-statement’を使用します
     )。

   キー‘C-M-q’は、‘fortran-indent-subprogram’を実行します、これはポイン
トを含むFortranサブプログラム(関数またはサブルーチン)の、すべての行を再
インデントします。

   キー‘C-M-j’は、‘fortran-split-line’を実行します、これはFortranの流儀
にあった方法で行を分割します。非コメント行では、後半は継続行になり、それ
にしたがったインデントになります。コメント行の場合、両方とも別のコメント
行になります。

   ‘M-^’または‘C-c C-d’は、コマンド‘fortran-join-line’を実行します。これ
は継続行を前の行に結合します。大雑把にいうと、‘fortran-split-line’の逆で
す。このコマンドを呼び出すとき、ポイントは継続行になければなりません。

   Fortranモードでの‘M-q’は、ポイントのあるコメントブロックまたは命令文
ブロックをフィルします。これは余分な命令文の継続を削除します。


File: emacs-ja.info,  Node: ForIndent Cont,  Next: ForIndent Num,  Prev: ForIndent Commands,  Up: Fortran Indent

26.14.2.2 継続行
................

ほとんどのFortran77コンパイラーは、2つの方法で継続行を記述します。ある行
の最初の非スペース文字が列5の場合、その行は前の行の継続行です。これを“固
定形式(fixed form)”と呼びます。(GNU Emacsでは常に列は0から数えますが、
Fortran標準では列1から数えることに注意してください)。変数
‘fortran-continuation-string’は、列5に配す文字を指定します。タブ文字で開
始され、その後‘0’以外の任意の数字が記述された行も継続行です。この継続ス
タイルを“タブ形式(tab format)”と呼びます(Fortran 90では、“自由形式(free
form)”という、他の継続行スタイルが導入されました)。

   Fortranモードは、どちらの継続行スタイルも使用できます。Fortranモード
に入ったとき、バッファー内容から、自動的に適切な継続行スタイルを推論しよ
うと試みます。これはバッファーの開始から、‘fortran-analyze-depth’行(デフ
ォルトは100)をスキャンすることにより行われます。最初の行の開始がタブ文字
か、6個のスペースかで選択が決定されます。スキャンが失敗した場合(たとえば
、新しいバッファーで中身が空の場合)、‘fortran-tab-mode-default’の値
(‘nil’の場合は固定形式で、非‘nil’の場合はタブ形式)が使用されます。モード
ラインに‘/t’ (‘fortran-tab-mode-string’)が表示されている場合、タブ形式が
選択されていることを示します。それに応じてFortranモードは
‘indent-tabs-mode’の値をセットします。

   行のテキストがFortranの継続マーカー‘$’で始まるか、列5の非空白文字で始
まる場合、Fortranモードはそれを継続行として扱います。継続行を<TAB>でイン
デントした場合、その行をカレントの継続スタイルに変換します。Fortran命令
文を‘C-M-j’で分割した場合、継続スタイルに応じた継続マーカーがある新しい
行が作成されます。

   継続スタイルのセッティングは、Fortranモードでの編集の他の側面に影響し
ます。固定形式の場合、命令文の最小列は6になります。Fortranブロック内でそ
れより大きい列にインデントされる行には、空白文字としてスペース文字だけを
使用しなければなりません。タブ形式では、命令文の最小列は8で、列8より前の
空白文字は1つのタブ文字でなければなりません。

